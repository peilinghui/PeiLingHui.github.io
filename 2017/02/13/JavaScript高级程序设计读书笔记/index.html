<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript高级程序设计读书笔记 | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript高级程序设计读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript高级程序设计读书笔记">
<meta property="og:url" content="http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="JavaScript高级程序设计读书笔记">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png">
<meta property="og:updated_time" content="2017-02-15T12:59:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript高级程序设计读书笔记">
<meta name="twitter:description" content="JavaScript高级程序设计读书笔记">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/RAC-学习笔记/" style="font-size: 10px;">RAC,学习笔记</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS面试/" style="font-size: 13.33px;">iOS面试</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习笔记/" style="font-size: 13.33px;">学习笔记</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/面试/" style="font-size: 16.67px;">面试</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-JavaScript高级程序设计读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/13/JavaScript高级程序设计读书笔记/" class="article-date">
      <time datetime="2017-02-13T07:37:24.000Z" itemprop="datePublished">2017-02-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript高级程序设计读书笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><strong>JavaScript高级程序设计读书笔记</strong><br><a id="more"></a></p>
<h1 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h1><p>JavaScript有下列三个不同的部分组成：</p>
<pre><code>核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
</code></pre><p>ECMA-262规定的语言组成部分：</p>
<pre><code>语法
类型
语句
关键字
保留字
操作符
对象
</code></pre><p>DOM：<br>DOM把真个页面映射为一个多层结点结构。<br>DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。<br>DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。<br>DOM3级：以统一方式加载和保存文档的方法。验证文档的方法<br>BOM：<br>处理浏览器窗口和框架。</p>
<h1 id="第二章-在HTML中使用JavaScript"><a href="#第二章-在HTML中使用JavaScript" class="headerlink" title="第二章 在HTML中使用JavaScript"></a>第二章 在HTML中使用JavaScript</h1><pre><code>把JavaScript插入到HTML页面中要使用&lt;script&gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&lt;script&gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&lt;script&gt;元素中的代码之后，才会开始解析后面的&lt;script&gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&lt;script&gt;元素中的代码，然后再解析后面的内容，所以一般应该把&lt;script&gt;元素放在页面最后，即主要内容后面，&lt;/body&gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
</code></pre><h1 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h1><pre><code>ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
</code></pre><p>ECMAScript中的函数与其他语言中的函数有诸多不同之处。</p>
<pre><code>无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
</code></pre><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：</p>
<pre><code>第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。</p>
<p><strong>Undefined类型</strong><br>Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。</p>
<p><strong>Null类型</strong><br>Null类型是第二个只有一个值的数据类型，这个特殊值时null。</p>
<p><strong>Boolean类型</strong><br>该类型只有两个字面值：true和false。<br>虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> message</span> = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> messageAsBoolean</span> = <span class="typename">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<p>给出各数据类型及其转换的规则：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png" alt=""></p>
<p><strong>Number类型</strong></p>
<pre><code>这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
</code></pre><p><strong>NaN</strong></p>
<pre><code>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
</code></pre><p>alert(isNaN(NaN));              //true<br>alert(isNaN(10));               //false（10是一个数值）<br>alert(isNaN(“10”));             //false（可以被转换成数值10）<br>alert(isNaN(“blue”));           //false（不能被转换成数值）<br>alert(isNaN(true));             //false（可以被转换成数值1）</p>
<p>有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。</p>
<p><strong>String类型</strong></p>
<pre><code>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
</code></pre><p><strong>Object类型</strong></p>
<pre><code>ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&quot;name&quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
</code></pre><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>一元操作符<br>递增操作符     ++<br>递减操作符     –<br>一元加操作符     +<br>一元减操作符     -<br>位操作符<br>按位非     NOT(~)<br>按位与     AND(&amp;)<br>按位或     OR(|)     var result=25 | 3;alert(result);//27<br>按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26<br>左移     &lt;&lt;     var oldValue=2;var newValue=oldValue &lt;&lt; 5;//64<br>有符号的右移     &gt;&gt;     var oldValue=64;var newValue=oldValue &gt;&gt; 5;//2<br>无符号的右移     &gt;&gt;&gt;     var oldValue=-64;var newValue=oldValue &gt;&gt;&gt; 5;//134217726<br>布尔操作符<br>逻辑非     !     alert(!false);//true<br>逻辑与     &amp;&amp;     var result=true &amp;&amp; false;//false<br>逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true<br>乘性操作符（略）<br>加性操作符（略）<br>关系操作符（略）<br>条件操作符（略）<br>赋值操作符（略）<br>逗号操作符（略）         </p>
<p>相等操作符</p>
<pre><code>ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
</code></pre><p>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h1 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h1><p>JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：</p>
<pre><code>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
</code></pre><p>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：</p>
<pre><code>执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
</code></pre><p>JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：</p>
<pre><code>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
</code></pre><p>需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。</p>
<h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。<br>第一种是使用new操作符后跟Object构造函数，如</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()；</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种是使用对象字面量表示法，如</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    <span class="string">name :</span> <span class="string">"Nicholas"</span>,</span><br><span class="line">    <span class="string">age :</span> <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]);              <span class="regexp">//</span><span class="string">"Nicholas"</span></span><br><span class="line">alert(person.name);                 <span class="regexp">//</span><span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  </p>
<p><strong>表示方法</strong><br>创建数组的基本方式有两种。<br>第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);<span class="comment">//创建一个包含3项的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);<span class="comment">//创建一个包含三个字符串值的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">Array</span>(<span class="string">"Greg"</span>);<span class="comment">//创建一个包含一个字符串值的数组</span></span><br></pre></td></tr></table></figure>
<p>第二种是使用数组字面量表示法。如</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]<span class="comment">;//创建一个包含3个字符串的数组</span></span><br><span class="line">var names = []<span class="comment">;//创建一个空数组</span></span><br><span class="line">var values = [<span class="number">1</span>,<span class="number">2</span>,]<span class="comment">;//禁忌，会创建一个包含2或3项的数组</span></span><br><span class="line">var options = [, , , , ,]<span class="comment">;//禁忌，会创建一个包含5或6项的数组</span></span><br></pre></td></tr></table></figure>
<p><strong>length属性</strong><br>数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。</p>
<p><strong>检测数组</strong><br>自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。<br>对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.<span class="built_in">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>转换方法</strong></p>
<p>toLocaleString() :<br>toString() :<br>valueOf() : </p>
<p><strong>栈方法和队列方法</strong></p>
<p>ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。</p>
<p>实现栈的方式（LIFO）后进先出</p>
<pre><code>push()： 栈中项插入
pop()：栈中项移除
</code></pre><p>实现队列的方法（FIFO）先进先出</p>
<pre><code>push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
</code></pre><p><strong>重排序方法</strong></p>
<p>数组中已经存在两个可以直接用来重排序的方法：<br>reverse()和sort()方法。</p>
<p>reverse()方法会反转数组项的顺序。</p>
<p>默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。<br>另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)    &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需将其作为参数传递给sort()方法即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values);  <span class="comment">//0, 1, 5, 10, 15</span></span><br></pre></td></tr></table></figure>
<p>另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span><span class="number">2</span> - <span class="keyword">value</span><span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>ECMAScript为操作已经包含在数组中的项提供了很多内置方法。</p>
<p>concat()：<br>该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors2</span> = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>];</span><br><span class="line"></span><br><span class="line">alert(colors);  <span class="comment">//red, green, blue</span></span><br><span class="line">alert(colors2);     <span class="comment">//red, green, blue, yellow, black, brown</span></span><br></pre></td></tr></table></figure>
<p>slice()：  </p>
<p>该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors2</span> = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors3</span> = colors.slice(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">alert(colors2);     <span class="comment">//green, blue, yellow, purple</span></span><br><span class="line">alert(colors3);     <span class="comment">//green, blue, yellow</span></span><br></pre></td></tr></table></figure>
<p>splice()：<br>该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：</p>
<pre><code>删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &quot;red&quot;, &quot;green&quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &quot;red&quot;, &quot;green&quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
</code></pre><p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">var removed = colors.splice(<span class="number">0</span>, <span class="number">1</span>);      <span class="comment">//删除第一项</span></span><br><span class="line">alert(colors);      <span class="comment">//green, blue</span></span><br><span class="line">alert(removed); <span class="comment">//red, 返回的数组中只包含一项</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>);      <span class="comment">//从位置1开始插入两项</span></span><br><span class="line">alert(colors);      <span class="comment">//green, yellow, orange, blue</span></span><br><span class="line">alert(removed); <span class="comment">//返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>);     <span class="comment">//插入两项，删除一项</span></span><br><span class="line">alert(colors);      <span class="comment">//green, red, purple, orange, blue</span></span><br><span class="line">alert(removed); <span class="comment">//yellow, 返回的数组中只包含一项</span></span><br></pre></td></tr></table></figure>
<p><strong>位置方法</strong></p>
<p>ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。</p>
<p>var person = {  name: “Nicholas” };<br>var people = [{ name: “Nicholas” }];</p>
<p>var morePeople = [person];</p>
<p>alert(people.indexOf(person));          //-1<br>alert(morePeople.indexOf(person));  //0</p>
<p><strong>迭代方法</strong></p>
<p>ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。</p>
<pre><code>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
</code></pre><p>以上方法都不会修改数组中的包含的值。</p>
<p>其中，every()和filter()方法最相似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">var everyResult = numbers.every(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(everyResult);     <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">var someResult = numbers.some(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(someResult);      <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">var filterResult = numbers.filter(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(filterResult);            <span class="comment">//[3, 4, 5, 4, 3]</span></span><br></pre></td></tr></table></figure>
<p>map()可以用来创建包含的项与另一个数组一一对应的项。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">var mapResult = numbers.filter(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(mapResult);           <span class="comment">//[2, 4, 6, 8, 10, 8, 6, 4, 2]</span></span><br></pre></td></tr></table></figure>
<p>forEach()本质上和使用for循环迭代数组一样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">numbers.forEach(function(item, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>归并方法</strong></p>
<p>ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。<br>使用reduce()方法可以执行数组中所有值求和操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">var sum = values.reduce(function(prev, cur, index, <span class="built_in">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum);     <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>创建日期对象，使用new操作符和Date构造函数即可。</p>
<p>var now = new Date()</p>
<p>根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。<br>Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式<br>var someDate = new Date(Date.parse(“May 25, 2004”));</p>
<p>Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。</p>
<p>//GMT时间2000年1月1日午夜零时<br>var y2k = new Date(Date.UTC(2000, 0));</p>
<p>//GMT时间2005年5月5日下午5:55:55<br>var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));</p>
<p>Date类型还有一些专门用于将日期格式化为字符串的方法，如下：</p>
<pre><code>toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
</code></pre><p>其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.</p>
<h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><p>ECMAScript通过RegExp类型来支持正则表达式。</p>
<p>var expression = / pattern / flags ;</p>
<p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。</p>
<pre><code>g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
</code></pre><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。<br>关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。<br>另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。</p>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>函数声明与函数表达式</p>
<p>解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用函数声明</span></span><br><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用函数表达式</span></span><br><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">var <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>没有重载！</strong><br>由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。</p>
<p><strong>作为返回值的函数</strong><br>由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。<br>函数作为返回值是极有用的技术，是“闭包”技术的基础之一。<br>比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComparisonFunction (propertyName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="keyword">object</span><span class="number">1</span>, <span class="keyword">object</span><span class="number">2</span>) &#123;</span><br><span class="line">        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];</span><br><span class="line">        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var data = [&#123;name: <span class="string">"Zachary"</span>, age: <span class="number">28</span>&#125;, &#123;name: <span class="string">"Nicholas"</span>, age: <span class="number">29</span>&#125;];</span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));<span class="comment">//根据name来排序</span></span><br><span class="line">alert(data[<span class="number">0</span>].name);        <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));<span class="comment">//根据age来排序</span></span><br><span class="line">alert(data[<span class="number">0</span>].name);        <span class="comment">//Zachary</span></span><br></pre></td></tr></table></figure>
<p><strong>函数内部属性（重点）</strong><br>在函数内部，有两个特殊的对象：arguments和this。</p>
<p>arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与函数名紧紧耦合</span></span><br><span class="line">function factorial (<span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">num</span> * factorial (<span class="built_in">num</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用arguments.callee替代函数名，消除耦合</span></span><br><span class="line">function factorial (<span class="built_in">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">num</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">num</span> * arguments.callee (<span class="built_in">num</span> - <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line"></span><br><span class="line">factorial = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">alert(trueFactiorial(<span class="number">5</span>));           <span class="comment">//120</span></span><br><span class="line">alert(factorial(<span class="number">5</span>));                    <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();             <span class="comment">//"red"</span></span><br><span class="line"></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();           <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<p>sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。</p>
<p>ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)</p>
<p><strong>函数属性和方法（重点）</strong><br>ECMAScript中函数是对象，因此也有属性和方法。</p>
<p>每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。<br>诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br>apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);          <span class="comment">//传入arguments对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]);       <span class="comment">//传入数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum1(<span class="number">10</span>, <span class="number">10</span>));        <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>, <span class="number">10</span>));        <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span><span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>));     <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor();                     <span class="comment">//red</span></span><br><span class="line"></span><br><span class="line">sayColor.call(<span class="keyword">this</span>);            <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);          <span class="comment">//red</span></span><br><span class="line">sayColor.call(o);               <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; color: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();           <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> s1</span> = <span class="string">"some text"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> s2</span> = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在访问s1时，访问过程处于读取模式，后台自动完成下列处理：</p>
<pre><code>创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
</code></pre><p>以上三个步骤可以想象成下列代码</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。<br>引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。</p>
<p><strong>Boolean类型</strong></p>
<p>Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。</p>
<p><strong>Number类型</strong></p>
<p>除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。</p>
<ul>
<li>toFixed()：按指定小数位返回数值的字符串表示。</li>
<li>toExponential()：返回以指数表示法表示的数值的字符串形式。</li>
<li>toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。</li>
</ul>
<p><strong>String类型</strong></p>
<p>String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。</p>
<p><strong>字符方法</strong><br>两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。</p>
<p><strong>字符串操作方法</strong><br>concat()：<br>用于将一或多个字符串拼接起来，接受任意多个参数。</p>
<p>slice()、substr()和substring()：<br>这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。</p>
<p>当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.</p>
<p><strong>字符串位置方法</strong><br>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。<br>两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。<br>在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。</p>
<p><strong>trim()方法</strong><br>该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。</p>
<p><strong>字符串大小写转换方法</strong><br>ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</p>
<p><strong>字符串的模式匹配方法</strong></p>
<p>match()：<br>在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。</p>
<p>search()：<br>参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。</p>
<p>replace()：<br>接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。</p>
<p>split()：<br>该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>
<p>localeCompare()方法;<br>该方法比较两个字符串，并返回下列值中的一个：</p>
<pre><code>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
</code></pre><p>fromCharCode()方法：</p>
<p>String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。</p>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()<br>isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  </p>
<p><strong>URI编码方法</strong><br>Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。</p>
<p><strong>eval()方法</strong><br>eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。<br>当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：</p>
<p>var msg = “hello world”;<br>eval(“alert(msg)”);     //“hello world”</p>
<p>变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.</p>
<p><strong>Global对象的属性</strong><br>Global对象的所有属性：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png" alt="">  </p>
<p><strong>window对象</strong><br>ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</p>
<h3 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math()对象"></a>Math()对象</h3><p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。</p>
<p><strong>Math对象的属性</strong><br><strong>Math对象的方法</strong><br>min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.<br>Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。<br>Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。</p>
<p><strong>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）</strong></p>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择一个介于2到10之间的值</span></span><br><span class="line">var num = Math.<span class="built_in">floor</span>(Math.random() * <span class="number">9</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>以下函数可以直接指定随机范围（整数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> choices = upperValue - lowerValue +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * choices + lowerValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">alert(num);     <span class="comment">//介于2和10之间（包括2和10）的一个数值</span></span><br></pre></td></tr></table></figure>
<p><strong>其他方法</strong></p>
<p>Math.abs(num)     返回num的绝对值<br>Math.asin(x)     返回x的反正弦值<br>Math.exp(num)     返回Math.E的num次幂<br>     Math.atan(x)     返回x的反正切值<br>Math.log(num)     返回num的自然对数<br>Math.atan2(y,x)     返回y/x的反正切值<br>Math.pow(num, power)     返回num的power次幂<br>Math.cos(x)     返回x的余弦值<br>Math.sqrt(num)     返回num的平方根<br>Math.sin(x)     返回x的正弦值<br>Math.acos(x)     返回x的反余弦值<br>Math.tan(x)     返回x的正切值</p>
<pre><code>小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
</code></pre><h1 id="第六章-面向对象的程序设计"><a href="#第六章-面向对象的程序设计" class="headerlink" title="第六章 面向对象的程序设计"></a>第六章 面向对象的程序设计</h1><h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript中有两种属性：数据属性和访问器属性。<br><strong>数据属性</strong>  </p>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p>
<pre><code>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
</code></pre><p>直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。<br>要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：<br>注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">Object.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">value</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//抛出错误</span></span><br><span class="line">Object.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    configurable: <span class="keyword">true</span>,</span><br><span class="line">    <span class="keyword">value</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。</p>
<p><strong>访问器属性</strong></p>
<p>访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p>
<pre><code>[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
</code></pre><p>直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。<br>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);        <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>设置一个属性的值会导致其他属性发生变化。<br>注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。</p>
<p><strong>定义多个属性</strong></p>
<p>ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<p><strong>读取属性的特性</strong></p>
<p>ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。</p>
<p>注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：</p>
<pre><code>没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
</code></pre><p>此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。<br>要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：</p>
<pre><code>(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
</code></pre><p>在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。<br>创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。</p>
<p><strong>将构造函数当做函数</strong><br>任何函数，只要通过new操作符来调用，那它就可以作为构造函数；</p>
<p><strong>构造函数的问题</strong><br>构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.</p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。<br>如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。</p>
<p>isPrototypeOf()：确定对象原型方法。<br><code>alert(Person.prototype.isPrototypeOf(person1)); //true</code></p>
<p> Object.getPrototypeOf()：ECMAScript 5新增方法。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="list">(<span class="keyword">Object</span>.getPrototypeOf<span class="list">(<span class="keyword">person1</span>)</span> == Person.prototype)</span><span class="comment">;  //true</span></span><br><span class="line">alert<span class="list">(<span class="keyword">Object</span>.getPrototypeOf<span class="list">(<span class="keyword">person1</span>)</span>.name)</span><span class="comment">; //"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p><strong>原型与in操作符</strong><br>有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。</p>
<p>而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function hasPrototypeProperty(<span class="class"><span class="keyword">object</span>, <span class="title">name</span>) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> !<span class="class"><span class="keyword">object</span>.<span class="title">hasOwnProperty</span>(</span>name) &amp;&amp; (name in <span class="class"><span class="keyword">object</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。</p>
<p>Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<p>如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</p>
<p><strong>更简单的原型语法</strong></p>
<p>为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.</p>
<p><strong>原型的动态性</strong></p>
<p>由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。</p>
<p><strong>原生对象的原型</strong></p>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。</p>
<p><strong>原型链的问题</strong>  </p>
<p>原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。<br>原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。</p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);    <span class="comment">//"red, blue, green, black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);    <span class="comment">//"red, blue, green"</span></span><br></pre></td></tr></table></figure>
<p>第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。</p>
<p><strong>传递参数</strong><br>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<p><strong>借用构造函数的问题</strong><br>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SupType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);    <span class="comment">//"red, blue, green, black"</span></span><br><span class="line">instance1.sayName();        <span class="comment">//"Nicolas"</span></span><br><span class="line">instance1.sayAge();         <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);    <span class="comment">//"red, blue, green"</span></span><br><span class="line">instance2.sayName();        <span class="comment">//"Greg"</span></span><br><span class="line">instance2.sayAge();         <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p>SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。<br>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> person</span> = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> anotherPerson</span> = <span class="keyword">object</span>(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anttherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> yetAnotherPerosn</span> = <span class="keyword">object</span>(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);  <span class="comment">//"Shelby, Court, Van, Rob, Barbie"</span></span><br></pre></td></tr></table></figure>
<p>克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。<br>ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。<br>object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">clone</span> = object(original);    <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;       <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">clone</span>;                    <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi();  <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。<br>注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);             <span class="comment">//第二次调用SuperType()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();        <span class="comment">//第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。<br>而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype);    <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType;                <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype;                  <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：<br>1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。<br>2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。<br>3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。<br>JavaScript主要使用原型链实现继承。<strong>原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的</strong>。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。<br>使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br>此外，还存在下列可供选择的继承模式：<br>1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。<br>2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。<br>3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</p>
<h1 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h1><p>定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span><span class="params">(arg0, arg1, arg2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span><span class="params">(arg0, arg1, arg2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">factorial</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * arguments.callee(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var factorial = (<span class="function">function <span class="title">f</span><span class="params">(num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">num * <span class="title">f</span><span class="params">(num-<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>不少开发人员总是搞不清匿名函数和闭包这两个概念。<br><strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong><br><strong>而匿名函数是指没有函数名称的函数。</strong><br>创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComparisonFunction(propertyName) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> createComparisonFunction(<span class="keyword">object</span><span class="number">1</span>, <span class="keyword">object</span><span class="number">2</span>) &#123;</span><br><span class="line">        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];</span><br><span class="line">        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span>&lt;<span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span>&lt;<span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。<br>在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span>&lt;<span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span>&gt;<span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result = compare(<span class="number">5</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 </p>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png" alt=""></p>
<p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 </p>
<p>无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。<br>在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compare = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = compare(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建函数</span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">//调用函数</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = compareNames(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</span><br><span class="line"></span><br><span class="line">//解除对匿名函数的引用（以便释放内存）</span><br><span class="line">compareNames = null;</span><br></pre></td></tr></table></figure>
<p>首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png" alt=""></p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="literal">result</span>[i] = function() &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数会返回一个函数数组，而其中的每个函数都返回10。<br>我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions() &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        //匿名函数直接赋值</span><br><span class="line">        <span class="literal">result</span>[i] = function(num) &#123;</span><br><span class="line">            <span class="keyword">return</span> function() &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h3><p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line"></span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure>
<p>getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line"></span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(object.getNameFunc()());  <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure>
<p>在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。</p>
<p>每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止内存泄露</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;</span><br><span class="line"></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。</p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。<br>用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即调用函数表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span>) <span class="comment">&#123;</span><br><span class="line">    //这里是块级作用域</span><br><span class="line">&#125;</span>)<span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<p>以上代码定义并立即调用了一个匿名函数。<br>函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。</p>
<p>无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span><span class="params">(count)</span> </span>&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    alert(i);    <span class="comment">//导致一个错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。<br>如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。<br>我们把有权访问私有变量和私有函数的公有方法成为<strong>特权方法</strong>（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。<br>利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nihcholas"</span>);</span><br><span class="line">alert(person.getName());    <span class="comment">//"Nicholas"</span></span><br><span class="line">person.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person.getName());    <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<p>以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。<br>构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。</p>
<h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><p>通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。<br>这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Person.prototye.getName = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line">alert(person1.getName());   <span class="comment">//"Nicholas"</span></span><br><span class="line">person1.setName(<span class="string">"Greg"</span>);</span><br><span class="line">alert(person1.getName());   <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Michael"</span>);</span><br><span class="line">alert(person1.getName());   <span class="comment">//"Michael"</span></span><br><span class="line">alert(person2.getName());   <span class="comment">//"Michael"</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。<br>以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。</p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name : value,</span><br><span class="line">    <span class="keyword">method</span> : function() &#123;</span><br><span class="line">        //这里是方法的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        publicProperty: <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有变量和函数</span></span><br><span class="line">    <span class="keyword">var</span> components = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    components.push(<span class="keyword">new</span> BaseComponent());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公共</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getComponentCount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> components.length;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        registerComponent : <span class="function"><span class="keyword">function</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> component == <span class="string">"object"</span>) &#123;</span><br><span class="line">                components.push(component);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。<br>简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。</p>
<h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。</p>
<pre><code>函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
</code></pre><p>当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。</p>
<pre><code>在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
</code></pre><p>使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：</p>
<pre><code>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
</code></pre><p>闭包还可以用于在对象中创建私有变量，相关概念和要点如下：</p>
<pre><code>及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
</code></pre><p>JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p>
<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><p>window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。</p>
<p>定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。<br>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，</p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。<br>每个window对象都有一个name属性，其中包含框架的名称。<br>top对象始终指向最高（最外）层的框架，也就是浏览器窗口。<br>与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。</p>
<h3 id="窗口的位置"><a href="#窗口的位置" class="headerlink" title="窗口的位置"></a>窗口的位置</h3><p>使用如下代码可以取得窗口左边和上边的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">"number"</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure>
<p>moveTo():接收新位置的x,y坐标值</p>
<p>moveBy():接收在水平和垂直方向上移动的像素数</p>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.</p>
<p>resizeTo():接收浏览器窗口的新宽度和新高度</p>
<p>resizeBy():接收新窗口与原窗口的宽度和高度之差</p>
<p>innerWidth和innerHeight表示该容器中页面视图区的大小</p>
<h3 id="导航和打开新窗口"><a href="#导航和打开新窗口" class="headerlink" title="导航和打开新窗口"></a>导航和打开新窗口</h3><p>使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。</p>
<h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p>javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。<br>超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。</p>
<p>间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。</p>
<h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。</p>
<pre><code>调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
</code></pre><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。</p>
<h3 id="查询字符串参数"><a href="#查询字符串参数" class="headerlink" title="查询字符串参数"></a>查询字符串参数</h3><p>location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  </p>
<h3 id="位置操作"><a href="#位置操作" class="headerlink" title="位置操作"></a>位置操作</h3><p>用location对象改变浏览器位置的多种方式：  </p>
<pre><code>location.assign(&quot;http://www.wrox.com&quot;);  
window.location=&quot;htttp://www.wrox.com&quot;;  
location.href=&quot;htttp://www.wrox.com&quot;;  
</code></pre><p> 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。</p>
<p>  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。</p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。</p>
<h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><p>navigator.plugins[]表示浏览器所用的插件的集合。<br>name: 插件的名字</p>
<p>description:插件的描述</p>
<p>filename:插件的文件名</p>
<p>length:插件所处理的MIME类型数量</p>
<h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。</p>
<p>registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。</p>
<p>navigator.registerContentHandler(‘application/rss+xml’, ‘<a href="http://www.sohu.com?feed=%s’" target="_blank" rel="external">http://www.sohu.com?feed=%s’</a>, ‘some Reader’);</p>
<p>FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。</p>
<h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p>screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>history.go(-1) | history.back(); //后退一页</p>
<p>history.go(1) | history.forward();//前进一页</p>
<p>history.go(n);//前进n页</p>
<p>history.go(‘sohu.com’);//跳转到最后的sohu页面</p>
<p>history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。</p>
<h1 id="第9章，客户端检测"><a href="#第9章，客户端检测" class="headerlink" title="第9章，客户端检测"></a>第9章，客户端检测</h1><p>尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案</p>
<h2 id="能力检测"><a href="#能力检测" class="headerlink" title="能力检测"></a>能力检测</h2><p>检测浏览器是否具备某一能力。</p>
<p>尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险</p>
<p>并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。</p>
<h2 id="怪癖检测"><a href="#怪癖检测" class="headerlink" title="怪癖检测"></a>怪癖检测</h2><p>检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。</p>
<h2 id="用户代理检测"><a href="#用户代理检测" class="headerlink" title="用户代理检测"></a>用户代理检测</h2><p>通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。<br>识别呈现引擎</p>
<p>注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera</p>
<p>注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别<br>识别浏览器<br>识别平台<br>识别windows操作系统<br>识别移动设备<br>识别游戏系统<br>完整的用户代理检测代码</p>
<h1 id="第10章-DOM"><a href="#第10章-DOM" class="headerlink" title="第10章 DOM"></a>第10章 DOM</h1>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2017年02月13日 - 15时37分</p>
        <p><span>最后更新:</span>2017年02月15日 - 20时59分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/02/13/JavaScript高级程序设计读书笔记/" title="JavaScript高级程序设计读书笔记">http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2017/02/16/自动化测试/">
                    自动化测试
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2017/02/03/研究框架YYModel/">
                    研究框架YYModel
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-JavaScript简介"><span class="toc-number">1.</span> <span class="toc-text">第一章 JavaScript简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-在HTML中使用JavaScript"><span class="toc-number">2.</span> <span class="toc-text">第二章 在HTML中使用JavaScript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-基本概念"><span class="toc-number">3.</span> <span class="toc-text">第三章 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语法"><span class="toc-number">3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">3.3.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作符"><span class="toc-number">3.4.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语句"><span class="toc-number">3.5.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">3.6.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-变量、作用域和内存问题"><span class="toc-number">4.</span> <span class="toc-text">第四章 变量、作用域和内存问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-引用类型"><span class="toc-number">5.</span> <span class="toc-text">第五章 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object类型"><span class="toc-number">5.1.</span> <span class="toc-text">Object类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array类型"><span class="toc-number">5.2.</span> <span class="toc-text">Array类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作方法"><span class="toc-number">5.2.1.</span> <span class="toc-text">操作方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date类型"><span class="toc-number">5.3.</span> <span class="toc-text">Date类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegExp对象"><span class="toc-number">5.4.</span> <span class="toc-text">RegExp对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function类型"><span class="toc-number">5.5.</span> <span class="toc-text">Function类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本包装类型"><span class="toc-number">5.6.</span> <span class="toc-text">基本包装类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单体内置对象"><span class="toc-number">5.7.</span> <span class="toc-text">单体内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Global对象"><span class="toc-number">5.7.1.</span> <span class="toc-text">Global对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math-对象"><span class="toc-number">5.7.2.</span> <span class="toc-text">Math()对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-面向对象的程序设计"><span class="toc-number">6.</span> <span class="toc-text">第六章 面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解对象"><span class="toc-number">6.1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性类型"><span class="toc-number">6.1.1.</span> <span class="toc-text">属性类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">6.2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂模式"><span class="toc-number">6.2.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数模式"><span class="toc-number">6.2.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">6.2.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合使用构造函数模式和原型模式"><span class="toc-number">6.2.4.</span> <span class="toc-text">组合使用构造函数模式和原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态原型模式"><span class="toc-number">6.2.5.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生构造函数模式"><span class="toc-number">6.2.6.</span> <span class="toc-text">寄生构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#稳妥构造函数模式"><span class="toc-number">6.2.7.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">6.3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#借用构造函数"><span class="toc-number">6.3.1.</span> <span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合继承"><span class="toc-number">6.3.2.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型式继承"><span class="toc-number">6.3.3.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生式继承"><span class="toc-number">6.3.4.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生组合式继承"><span class="toc-number">6.3.5.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-函数表达式"><span class="toc-number">7.</span> <span class="toc-text">第七章 函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-number">7.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">7.2.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包与变量"><span class="toc-number">7.2.1.</span> <span class="toc-text">闭包与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于this对象"><span class="toc-number">7.2.2.</span> <span class="toc-text">关于this对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存泄漏"><span class="toc-number">7.2.3.</span> <span class="toc-text">内存泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模仿块级作用域"><span class="toc-number">7.3.</span> <span class="toc-text">模仿块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#私有变量"><span class="toc-number">7.4.</span> <span class="toc-text">私有变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#静态私有变量"><span class="toc-number">7.4.1.</span> <span class="toc-text">静态私有变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块模式"><span class="toc-number">7.4.2.</span> <span class="toc-text">模块模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强的模块模式"><span class="toc-number">7.4.3.</span> <span class="toc-text">增强的模块模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结："><span class="toc-number">7.5.</span> <span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BOM"><span class="toc-number">8.</span> <span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Window对象"><span class="toc-number">8.1.</span> <span class="toc-text">Window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局作用域"><span class="toc-number">8.1.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#窗口关系及框架"><span class="toc-number">8.1.2.</span> <span class="toc-text">窗口关系及框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#窗口的位置"><span class="toc-number">8.1.3.</span> <span class="toc-text">窗口的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#窗口大小"><span class="toc-number">8.1.4.</span> <span class="toc-text">窗口大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导航和打开新窗口"><span class="toc-number">8.1.5.</span> <span class="toc-text">导航和打开新窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间歇调用和超时调用"><span class="toc-number">8.1.6.</span> <span class="toc-text">间歇调用和超时调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统对话框"><span class="toc-number">8.1.7.</span> <span class="toc-text">系统对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location对象"><span class="toc-number">8.2.</span> <span class="toc-text">location对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#查询字符串参数"><span class="toc-number">8.2.1.</span> <span class="toc-text">查询字符串参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位置操作"><span class="toc-number">8.2.2.</span> <span class="toc-text">位置操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigator对象"><span class="toc-number">8.3.</span> <span class="toc-text">navigator对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检测插件"><span class="toc-number">8.3.1.</span> <span class="toc-text">检测插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注册处理程序"><span class="toc-number">8.3.2.</span> <span class="toc-text">注册处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#screen对象"><span class="toc-number">8.4.</span> <span class="toc-text">screen对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history对象"><span class="toc-number">8.5.</span> <span class="toc-text">history对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第9章，客户端检测"><span class="toc-number">9.</span> <span class="toc-text">第9章，客户端检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#能力检测"><span class="toc-number">9.1.</span> <span class="toc-text">能力检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#怪癖检测"><span class="toc-number">9.2.</span> <span class="toc-text">怪癖检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户代理检测"><span class="toc-number">9.3.</span> <span class="toc-text">用户代理检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第10章-DOM"><span class="toc-number">10.</span> <span class="toc-text">第10章 DOM</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2017/02/13/JavaScript高级程序设计读书笔记/" data-title="JavaScript高级程序设计读书笔记" data-url="http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/02/16/自动化测试/" title="上一篇: 自动化测试">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2017/02/03/研究框架YYModel/" title="下一篇: 研究框架YYModel">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/05/2017年总结/">2017年总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/ReactNative中使用Redux/">ReactNative中使用Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/开发一个React-Native的APP/">开发一个React-Native的APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/ReactNative的常用组件/">ReactNative的常用组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/iOS应用APP架构/">iOS应用APP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/iOS网络层的封装/">iOS网络层的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/项目重构遇到的问题/">项目重构遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/iOS中的图表Charts/">iOS中的图表Charts</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/移动应用的设计模式/">移动应用的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Jenkins搭建来实现自动化打包/">Jenkins搭建来实现自动化打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/做一个搜索框的Demo/">做一个搜索框的Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/如何使用Mac本地服务器/">如何使用Mac本地服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/iOS打包和发布流程/">iOS打包和发布流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/学习iOS中JS与OC相互调用的方式/">学习iOS中JS与OC相互调用的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/深入学习NSURLProtocol/">深入学习NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/UIView的Frame和bounds区别/">UIView的Frame和bounds区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/21/学习React-Native的与原生的交互/">学习React-Native的与原生的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/学习React-Native的API和组件/">学习React-Native的API和组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/学习React-Native入门/">学习React Native入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/学习React知识/">学习React知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/自动化测试/">自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/研究框架YYModel/">研究框架YYModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/深入学习GCD/">深入学习GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/深入学习KVC和KVO/">深入学习KVC和KVO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/深入学习RunLoop/">深入学习RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/消息处理之performSelector/">消息处理之performSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习Runtime/">深入学习Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转 </a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/深入学习内存管理/">深入学习内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/关于NSString的引用计数问题/">关于NSString的引用计数问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/深入学习Block/">深入学习Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/设计模式解析/">设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的第三方框架/">iOS中的第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/关于深拷贝和浅拷贝/">关于深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机网络基础知识与安全/">计算机网络基础知识与安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/经典排序算法总结与实现/">经典排序算法总结与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2018 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>