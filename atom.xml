<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <icon>https://www.gravatar.com/avatar/f1a75c66faf43f3b1652aef0eb09037e</icon>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2019-10-22T12:04:55.864Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter学习</title>
    <link href="http://peilinghui.com/2019/10/22/Flutter%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2019/10/22/Flutter学习/</id>
    <published>2019-10-22T11:48:43.000Z</published>
    <updated>2019-10-22T12:04:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>简单学习一下flutter。</p><a id="more"></a><h1 id="Dart语言基础"><a href="#Dart语言基础" class="headerlink" title="Dart语言基础"></a>Dart语言基础</h1><p>Dart不单独安装，随框架安装，可通过DartPad在线编写和运行代码。</p><p>基础概念：</p><ul><li>一切变量都是对象，包括数字、函数和null</li><li>对象是类的实例，所有类都继承于object</li><li>强类型但支持类型推断</li><li>如果不想指定具体类型可以使用dynamic</li><li>支持泛型，比如List<int>或List<dynamic></dynamic></int></li><li>支持顶层函数、类方法、实例变量和嵌套函数</li><li>支持顶层变量、类变量、实例变量和局部变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单学习一下flutter。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="http://peilinghui.com/2019/10/15/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2019/10/15/webpack学习/</id>
    <published>2019-10-15T01:45:13.000Z</published>
    <updated>2019-10-16T07:54:35.565Z</updated>
    
    <content type="html"><![CDATA[<p>webpack是现代前端开发中最火的模块打包工具。<br>官网：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h3 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h3><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p><h2 id="webpack源码"><a href="#webpack源码" class="headerlink" title="webpack源码"></a>webpack源码</h2><ol><li>把所有模块的代码放入到函数中，用一个数组保存起来</li><li>根据require时传入的数组索引，能知道需要哪一段代码</li><li>从数组中，根据索引取出包含我们代码的函数</li><li>执行该函数，传入一个对象Module.exports</li><li>我们的代码，按照约定，正好是用module.exports=’xxx’进行赋值</li><li>调用函数结束后，module.exports从原来的空对象，就有值了</li><li>最终return module.exports作为require函数的返回值</li></ol><h2 id="webpack-config-js文件配置："><a href="#webpack-config-js文件配置：" class="headerlink" title="webpack.config.js文件配置："></a>webpack.config.js文件配置：</h2><ol><li>Entry：指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库</li><li>Output：告诉webpack如何命名输出的文件以及输出的目录</li><li><p>Module模块（对象）（loaders:[]）存在一些loader{test:正则，loader：’style-loader!css-loader’}<br>webpack中，loader的配置主要在module.rules中进行，这是一个数组，每一个rule做了两件事</p><p> 识别文件类型，来确定具体处理该数据的loader(Rule.test属性)<br> 使用相关的loader对文件进行相关的操作转换(Rule.use属性）   </p><blockquote><p>常用的loader：</p></blockquote><pre><code>　　转换编译：script-loader, babel-loader,ts-loader,coffee-loader　　处理样式：style-loader,css-loader,less-loader,sass-loader,postcss-loader　　处理文件：raw--loader,url-loader,file-loader　　处理数据：csv-loader,xml-loader　　处理模板语言：html-loader,pug-loader,jade-loader,markdown-loader　　清理和测试：mocha-loader,eslint-loader　　此外还有许多loader，可以到loader文档里查询处理CSS：require(./xxx.css)</code></pre></li></ol><p>处理less:loader：’style-loader!css-loader!less-loader’</p><p>Loaders：由于webpack只能处理javascript，所以我们需要对一些非js文件处理成webpack能够处理的模块，比如sass文件</p><p>处理ES6：babel-loader+babel-preset-env(se2015/2016/2017)</p><p>处理文件+base64：<br>url-loader可以将文件生成为base64编码。到build.js中<br>文件在base64加密后会比原来大三分之一<br>应用场景是比较小的图片 4kb以内的图片</p><p>Plugins： Loaders将各类型的文件处理成webpack能够处理的模块， plugins有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。比如对js文件进行压缩优化的 UglifyJsPlugin插件。一种插件就是一种函数，通过传入不同的参数，可以实现不同的功能，webpack让人觉得难学的地方之一是哟啊自己封装plugins，对于我们大多数人来说，需要掌握的plugins并不是那么多，用的时候再查就可以</p><p>Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用 CommonsChunkPlugin将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中 CommonsChunkPlugin被废弃，使用 SplitChunksPlugin</p><p>5、一些辅助开发的相关属性</p><p>　　devtool:打包后的代码和原始代码存在较大的差异，此选项控制是否生成以及如何生成sourcemap</p><p>　　devserver：通过配置devserver选项，可以开启一个本地服务器</p><p>　　watch：启用watch模式后，webpack将持续监听热河已经解析文件的更改，开发是开启会很方便</p><p>　　watchoption：用来定制watch模式的选项</p><p>　　performance：打包后命令行如何展示性能提示，如果超过某个大小是警告还是报错　　</p><h3 id="字符串内使用的内置变量"><a href="#字符串内使用的内置变量" class="headerlink" title="字符串内使用的内置变量"></a>字符串内使用的内置变量</h3><p>name:[name].[ext]<br>name是获取原文件名，ext是获取原文件名的后缀<br>output:{path:’绝对路径’//设置产出的资源目录 filename:’build.js’}</p><h3 id="使用webpack构建本地服务器webpack-dev-server"><a href="#使用webpack构建本地服务器webpack-dev-server" class="headerlink" title="使用webpack构建本地服务器webpack-dev-server"></a>使用webpack构建本地服务器webpack-dev-server</h3><p>让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p><ol><li><p>安装webpack-dev-server</p><p>   npm i webpack-dev-server</p></li><li><p>安装cross-env</p><p> npm i cross-env </p></li><li><p>安装HTML支持文件</p><p> npm i html-webpack-plugin<br> 下载，引入，在plugin里面配置，给其Options设置template(参照物)</p></li><li><p>配置pack.json文件</p><p> “scripts”: {</p><pre><code>    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</code></pre><p>   },</p></li></ol><p>命令：</p><ul><li>open 自动打开浏览器</li><li>hot 热替换，不再刷新的情况下替换</li><li>inline 自动刷新</li><li>port 9999 指定端口</li><li>process 显示编译进度</li></ul><h4 id="包的分类管理和分类恢复"><a href="#包的分类管理和分类恢复" class="headerlink" title="包的分类管理和分类恢复"></a>包的分类管理和分类恢复</h4><ol><li><p>安装包的时候，做一个分类的管理</p><pre><code>- 开发依赖devDependencies（打包相关webpack） npm i 包名 -D   - 生产依赖dependencies（不包含webpack打包依赖） npm i 包名 -S </code></pre></li><li><p>恢复依赖</p><ul><li>开发恢复依赖： npm i</li><li>生产恢复： npm i –production</li></ul></li></ol><p>webpack.config.js<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        output:&#123;</span><br><span class="line">            filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">            path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">module</span>:&#123;</span><br><span class="line">            rules:[<span class="comment">// 配置模块loaders，解析规则</span></span><br><span class="line">                &#123;</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    use:[</span><br><span class="line">                        <span class="string">'style-loader'</span>,</span><br><span class="line">                        <span class="string">'css-loader'</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test:<span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                    use:[</span><br><span class="line">                        <span class="string">'file-loader'</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool:<span class="string">"source-map"</span>,<span class="comment">// enum</span></span><br><span class="line"><span class="comment">// 为浏览器开发者工具添加元数据增强调试</span></span><br><span class="line">plugins:[</span><br><span class="line"> <span class="comment">// 附加插件列表 ,插件的执行顺序与元素的索引有关</span></span><br><span class="line">],</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p><pre><code>让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</code></pre><h3 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><pre><code>// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</code></pre><h4 id="Babel的配置"><a href="#Babel的配置" class="headerlink" title="Babel的配置"></a>Babel的配置</h4><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack是现代前端开发中最火的模块打包工具。&lt;br&gt;官网：&lt;a href=&quot;https://www.webpackjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.webpackjs.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React面试题</title>
    <link href="http://peilinghui.com/2019/09/24/React%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2019/09/24/React面试题/</id>
    <published>2019-09-24T06:36:32.000Z</published>
    <updated>2019-10-23T02:06:41.713Z</updated>
    
    <content type="html"><![CDATA[<p>React高频面试题</p><a id="more"></a><ol><li><p>React生命周期有哪些，16版本生命周期发生了哪些变化？</p><p> <strong>15版本的生命周期：</strong></p><blockquote><p>初始化阶段</p></blockquote><pre><code> constructor 构造函数getDefaultProps props默认值getInitialState state默认值</code></pre><blockquote><p>挂载阶段  </p></blockquote><pre><code>componentWillMount 组件初始化渲染前调用render 组件渲染componentDidMount组件挂载到 DOM后调用</code></pre><blockquote><p>更新阶段</p></blockquote><pre><code>componentWillReceiveProps 组件将要接收新 props前调用shouldComponentUpdate 组件是否需要更新componentWillUpdate 组件更新前调用render 组件渲染componentDidUpdate 组件更新后调用</code></pre><blockquote><p>卸载阶段</p></blockquote><pre><code>componentWillUnmount 组件卸载前调用</code></pre><p> <strong>16生命周期</strong></p><blockquote><p>初始化阶段</p></blockquote><pre><code>constructor 构造函数getDefaultProps props默认值getInitialState state默认值</code></pre><blockquote><p>挂载阶段</p></blockquote><pre><code>static getDerivedStateFromProps(props,state)rendercomponentDidMount</code></pre><p> 补充：getDerivedStateFromProps：组件每次被 rerender的时候，包括在组件构建之后(虚拟 dom之后，实际 dom挂载之前)，每次获取新的 props或 state之后；每次接收新的props之后都会返回一个对象作为新的 state，返回null则说明不需要更新 state；配合 componentDidUpdate，可以覆盖 componentWillReceiveProps的所有用法</p><blockquote><p>更新阶段</p></blockquote><pre><code>static getDerivedStateFromProps(props,state)shouldComponentUpdaterendergetSnapshotBeforeUpdate(prevProps,prevState)componentDidUpdate</code></pre><p> 补充：getSnapshotBeforeUpdate：触发时间: update发生的时候，在 render之后，在组件 dom渲染之前；返回一个值，作为 componentDidUpdate的第三个参数；配合 componentDidUpdate, 可以覆盖 componentWillUpdate的所有用法</p><blockquote><p>卸载阶段</p></blockquote><pre><code>componentWillUnmount</code></pre><blockquote><p>错误处理</p></blockquote><pre><code>componentDidCatch</code></pre></li></ol><p>React16新的生命周期弃用了 componentWillMount、componentWillReceivePorps，componentWillUpdate新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数。</p><p>React16并没有删除这三个钩子函数，但是不能和新增的钩子函数混用， React17将会删除这三个钩子函数，新增了对错误的处理（ componentDidCatch）</p><ol start="2"><li>setState是同步的还是异步的？</li></ol><blockquote><p>生命周期和合成事件中</p></blockquote><p>在 React的生命周期和合成事件中， React仍然处于他的更新机制中，这时无论调用多少次 setState，都会不会立即执行更新，而是将要更新的·存入 _pendingStateQueue，将要更新的组件存入 dirtyComponent。</p><p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 didmount后会将批处理标志设置为 false。这时将取出 dirtyComponent中的组件以及 _pendingStateQueue中的 state进行更新。这样就可以确保组件不会被重新渲染多次</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是0</p><p>所以，如上面的代码，当我们在执行 setState后立即去获取 state，这时是获取不到更新后的 state的，因为处于 React的批处理机制中， state被暂存起来，待批处理机制完成之后，统一进行更新。</p><p>所以。setState本身并不是异步的，而是 React的批处理机制给人一种异步的假象。</p><blockquote><p>异步代码和原生事件中</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> <span class="built_in">set</span>Timeout(() =&gt; &#123;</span><br><span class="line">      console.<span class="keyword">log</span>(<span class="string">"调用setState"</span>);</span><br><span class="line">      this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;);</span><br><span class="line">      console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是1</p><p>根据 JavaScript的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，这时 React的批处理机制已经走完，处理标志设被设置为 false，这时再调用 setState即可立即执行更新，拿到更新后的结果。</p><p>在原生事件中调用 setState并不会出发 React的批处理机制，所以立即能拿到最新结果。</p><blockquote><p>最佳实践</p></blockquote><p>setState的第二个参数接收一个函数，该函数会在 React的批处理机制完成之后调用，所以你想在调用 setState后立即获取更新后的值，请在该回调函数中获取。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是1</p><ol start="3"><li>为什么有时连续多次 setState只有一次生效？</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;);</span><br><span class="line">   this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次打印出的结果是相同的,都为1。</p><p>原因就是 React会批处理机制中存储的多个 setState进行合并，来看下 React源码中的 _assign函数，类似于 Object的 assign：</p><p>React会对多次连续的 setState进行合并，如果你想立即使用上次 setState后的结果进行下一次 setState，可以让 setState 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。</p><ol start="4"><li>React如何实现自己的事件机制？</li></ol><p>React事件并没有绑定在真实的 Dom节点上，而是通过事件代理，在最外层的 document上对事件进行统一分发。</p><ol start="5"><li>为何 React事件要自己绑定 this？<br>React在 document上进行统一的事件分发， dispatchEvent通过循环调用所有层级的事件来模拟事件冒泡和捕获。</li></ol><p>在 React源码中，当具体到某一事件处理函数将要调用时，将调用 invokeGuardedCallback方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function invokeGuardedCallback(name,<span class="function"><span class="keyword">func</span>,<span class="title">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(caughtError === null)&#123;</span><br><span class="line">caughtError = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this是不准确的，所以我们需要手动将当前组件绑定到 this上。</p><ol start="6"><li><p>原生事件和 React事件的区别？</p><ul><li>React 事件使用驼峰命名，而不是全部小写。<ul><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li><li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。</li></ul></li></ul></li></ol><p>由上面执行机制我们可以得出： React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。</p><ol start="7"><li><p>React事件和原生事件的执行顺序</p><pre><code>react的所有事件都挂载在 document中当真实dom触发后冒泡到 document后才会对 react事件进行处理所以原生的事件会先执行然后执行 react合成事件最后执行真正在 document上挂载的事件</code></pre></li></ol><ol start="8"><li>React的合成事件是什么？<br>React 根据 W3C 规范定义了每个事件处理函数的参数，即合成事件。</li></ol><p>事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。它具有与浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()，在所有浏览器中他们工作方式都相同。</p><p>React合成的 SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</p><p>另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。</p><ol start="9"><li>React和原生事件的执行顺序是什么？可以混用吗？</li></ol><p>React的所有事件都通过 document进行统一分发。当真实 Dom触发事件后冒泡到 document后才会对 React事件进行处理。</p><p>所以原生的事件会先执行，然后执行 React合成事件，最后执行真正在 document上挂载的事件</p><p>React事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation方法，则会导致其他 React事件失效。因为所有元素的事件将无法冒泡到 document上，导致所有的 React事件都将无法被触发。。</p><ol start="10"><li>虚拟Dom是什么？</li></ol><p>在原生的 JavaScript程序中，我们直接对 DOM进行创建和更改，而 DOM元素通过我们监听的事件和我们的应用程序进行通讯。</p><p>而 React会先将你的代码转换成一个 JavaScript对象，然后这个 JavaScript对象再转换成真实 DOM。这个 JavaScript对象就是所谓的虚拟 DOM。</p><p>当我们需要创建或更新元素时， React首先会让这个 VitrualDom对象进行创建和更改，然后再将 VitrualDom对象渲染成真实DOM。</p><p>当我们需要对 DOM进行事件监听时，首先对 VitrualDom进行事件监听， VitrualDom会代理原生的 DOM事件从而做出响应。</p><ol start="11"><li>虚拟Dom比 普通Dom更快吗？</li></ol><p>很多文章说 VitrualDom可以提升性能，这一说法实际上是很片面的。</p><p>直接操作 DOM是非常耗费性能的，这一点毋庸置疑。但是 React使用 VitrualDom也是无法避免操作 DOM的。<br>如果是首次渲染， VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。</p><p>VitrualDom的优势在于 React的 Diff算法和批处理策略， React在页面更新之前，提前计算好了如何进行更新和渲染 DOM。实际上，这个计算过程我们在直接操作 DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如 React好的。所以，在这个过程中 React帮助我们”提升了性能”。</p><p>所以，我更倾向于说， VitrualDom帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比 DOM操作更快。</p><ol start="12"><li><p>虚拟Dom中的 $$typeof属性的作用是什么？</p></li><li><p>React组件的渲染流程是什么？</p></li><li><p>为什么代码中一定要引入 React？<br>JSX只是为 React.createElement(component,props,…children)方法提供的语法糖。<br>所有的 JSX代码最后都会转换成 React.createElement(…)， Babel帮助我们完成了这个转换的过程。<br>所以使用了 JSX的代码都必须引入 React。</p></li><li><p>为什么 React组件首字母必须大写？<br>babel在编译时会判断 JSX中组件的首字母，当首字母为小写时，其被认定为原生 DOM标签， createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement的第一个变量被编译为对象；</p></li><li><p>React在渲染 真实Dom时做了哪些性能优化？<br>在 IE（8-11）和 Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。</p></li></ol><p>React通过 lazyTree，在 IE（8-11）和 Edge中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的 DOM结构构建好，然后再整体插入容器。</p><p>并且，在单独渲染节点时， React还考虑了 fragment等特殊节点，这些节点则不会一个一个插入渲染。</p><ol start="17"><li>什么是高阶组件？如何实现？<br>高阶组件可以看作 React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</li></ol><blockquote><p>高阶组件（ HOC）是 React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是 ReactAPI。它只是一种模式，这种模式是由 React自身的组合性质必然产生的。</p></blockquote><p>我们可以通过以下两种方式实现高阶组件：</p><ol><li><strong>属性代理</strong></li></ol><p>函数返回一个我们自己定义的组件，然后在 render中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数 visible就是一个 HOC属性代理的实现方式。<br>对比原生组件增强的项：</p><pre><code>可操作所有传入的 props可操作组件的生命周期可操作组件的 static方法获取 ref</code></pre><ol start="2"><li><strong>反向继承</strong></li></ol><p>返回一个组件，继承原组件，在 render中调用原组件的 render。由于继承了原组件，能通过this访问到原组件的 生命周期、props、state、render等，相比属性代理它能操作更多的属性。</p><p>对比原生组件增强的项：</p><pre><code>可操作所有传入的 props可操作组件的生命周期可操作组件的 static方法获取 refs可操作 state可以渲染劫持</code></pre><ol start="18"><li><p>HOC在业务场景中有哪些实际应用场景？<br>HOC可以实现的功能：</p><pre><code>组合渲染条件渲染操作 props获取 refs状态管理操作 state渲染劫持</code></pre></li></ol><p>HOC在业务中的实际应用场景：</p><pre><code>日志打点权限控制双向绑定表单校验</code></pre><ol start="19"><li><p>高阶组件( HOC)和 Mixin的异同点是什么？<br>Mixin和 HOC都可以用来解决 React的代码复用问题。</p><ul><li>Mixin 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的 Mixin中的方法可能会相互冲突</li><li>Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ul><p>而 HOC的出现可以解决这些问题：</p><ul><li>高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</li><li>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为</li><li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</li></ul></li><li><p>Hook有哪些优势？</p><ul><li>减少状态逻辑复用的风险</li></ul><p>Hook和 Mixin在用法上有一定的相似之处，但是 Mixin引入的逻辑和状态是可以相互覆盖的，而多个 Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用 HOC也有可能带来一定冲突，比如 props覆盖等等，使用 Hook则可以避免这些问题。</p><ul><li>避免地狱式嵌套</li></ul><p>大量使用 HOC的情况下让我们的代码变得嵌套层级非常深，使用 HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。</p><ul><li>让组件更容易理解</li></ul><p>在使用 class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用 Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。</p><ul><li>使用函数代替class</li></ul><p>相比函数，编写一个 class可能需要掌握更多的知识，需要注意的点也越多，比如 this指向、绑定事件等等。另外，计算机理解一个 class比理解一个函数更快。Hooks让你可以在 classes之外使用更多 React的新特性。</p></li><li><p>ReactDiff算法的策略是什么？</p></li><li><p>React中 key的作用是什么？</p></li><li><p>ReactFiber是什么？为什么要引入？</p></li><li><p>为什么推荐在 componentDidMount中发起网络请求？</p></li><li><p>React代码优化？</p></li><li><p>React组件设计要掌握哪些原则？</p></li><li><p>Redux的核心原理是什么？</p></li><li><p>什么是 Redux中间件？</p></li><li><p>Reduxconnect函数的实现策略？</p></li><li><p>Mox的核心原理是什么？</p></li><li><p>Redux和 Mobx的异同点，如何选择？</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React高频面试题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios源码分析</title>
    <link href="http://peilinghui.com/2019/09/20/Axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://peilinghui.com/2019/09/20/Axios源码分析/</id>
    <published>2019-09-20T06:50:58.000Z</published>
    <updated>2019-10-10T09:59:57.111Z</updated>
    
    <content type="html"><![CDATA[<p>Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><a id="more"></a><p>Axios 的主要特性包括：</p><pre><code>基于 Promise支持浏览器和 node.js可添加拦截器和转换请求和响应数据请求可以取消自动转换 JSON 数据客户端支持防范 XSRF支持各主流浏览器及 IE8+</code></pre><p>Axios的使用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/get?name=xmz'</span>)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response'</span>, response)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error'</span>, error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当业务请求代码发起时，具体执行的是lib/core/Axios.js中的request方法。</p><pre><code>├── /dist/                     # 项目输出目录├── /lib/                      # 项目源码目录│ ├── /cancel/                 # 定义取消功能│ ├── /core/                   # 一些核心功能│ │ ├── Axios.js               # axios的核心主类---------------------------这是其最核心部分│ │ ├── dispatchRequest.js     # 用来调用http请求适配器方法发送请求         |│ │ ├── InterceptorManager.js  # 拦截器构造函数                            |│ │ └── settle.js              # 根据http响应状态，改变Promise的状态--------│ ├── /helpers/                # 一些辅助方法│ ├── /adapters/               # 定义请求的适配器 xhr、http----这个文件夹封装了ajax的请求│ │ ├── http.js                # 实现http适配器│ │ └── xhr.js                 # 实现xhr适配器│ ├── axios.js                 # 对外暴露接口│ ├── defaults.js              # 默认配置 │ └── utils.js                 # 公用工具├── package.json               # 项目信息├── index.d.ts                 # 配置TypeScript的声明文件└── index.js                   # 入口文件</code></pre><h2 id="工厂函数createInstance"><a href="#工厂函数createInstance" class="headerlink" title="工厂函数createInstance"></a>工厂函数createInstance</h2><p>在找到axios/lib/axios.js里面有这个对象，<code>var axios = createInstance(defaults);</code>创建axios这样一个实例函数</p><p>axios/lib/defaults.js是默认配置，默认导出一个对象</p><p>配置：</p><ul><li>全局配置：提供配置参考，实例化的时候可以使用。</li><li>实例配置：一个应用可能需要实例化多个不同的对象（针对不同的接口）所以每个实例化对象都会有自己的配置，可以通过全局配置进行初始化，或合并一个新的配置项</li><li>请求配置：请求的时候需要传入配置与实例配置进行合并。不要影响(赋值引用)</li></ul><p>深度克隆-deepcopy函数，深度克隆对象</p><p>配置合并-configMerge函数，有的是覆盖，有的是合并</p><h2 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h2><p>在 Axios 中，大概是这样添加拦截器：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Add a request interceptor</span><br><span class="line">axios.interceptors.request.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(config) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">config</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">// Add a response interceptor</span><br><span class="line">axios.interceptors.response.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(response) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">response</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>interceptors.request -&gt; request -&gt; interceptors.response -&gt; response<br>而 Axios 内部，很巧妙地实现了上面所说的管道式流程，首先看 lib/core/Axios.js。interceptors.request可以注册函数，在发送请求之前执行，interceptors.response在发送请求并得到数据后执行，then之前执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatchRequest = <span class="built_in">require</span>(<span class="string">'./dispatchRequest'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 省略部分代码...</span></span><br></pre></td></tr></table></figure><p>先看到 Axios 类的定义里面有 interceptors，并且带有 request 和 response 属性，而这 2 个属性都是指向 InterceptorManager 类的实例。这个等下再说，先看 request 方法里 interceptors 的实现。</p><p>我们留意 chain 这个变量，经过 2 次 forEach 操作后，最后的值会变成：(这个 forEach 方法在 InterceptorManager 中定义)</p><ul><li>单请求配置Options:axios.post(url,data,options)</li><li>全局配置Defaults:this.$axios.defaults</li><li>config：请求拦截器中的参数</li><li>response.config:响应拦截器中的参数</li><li><p>Options:</p><pre><code>-  baseURL 基础URL路径-  params 查询字符串对象-  transformRequest 转换请求体数据-  transformResponse 转换响应体数据-  headers:头信息-  data：请求体数据-  timeout：请求超时。 </code></pre><h3 id="InterceptorManager管理拦截器"><a href="#InterceptorManager管理拦截器" class="headerlink" title="InterceptorManager管理拦截器"></a>InterceptorManager管理拦截器</h3></li></ul><p>use()方法接收到两个参数，一个是fulfilled，一个是rejected</p><h2 id="适配器adapters"><a href="#适配器adapters" class="headerlink" title="适配器adapters"></a>适配器adapters</h2><p>通过适配器，把不同的接口进行适配。在adapter的处理逻辑中，axios没有把http和xhr两个模块（一个用于Node.js发送请求，另一个则用于浏览器端发送请求）当成自身的模块直接在dispatchRequest中直接饮用，而是通过配置的方法在default.js文件中进行默认引入。这样既保证了两个模块间的低耦合性，同时又能够为今后用户需要自定义请求发送模块保留了余地。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/axios/axios&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="http://peilinghui.com/2019/09/17/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2019/09/17/JavaScript面试题/</id>
    <published>2019-09-17T06:53:56.000Z</published>
    <updated>2019-10-09T06:33:29.123Z</updated>
    
    <content type="html"><![CDATA[<p>相关面试题</p><a id="more"></a><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。<br>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p><p>原型链：JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：666666</p><p>改变：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; (<span class="function"><span class="keyword">function</span><span class="params">(j)</span> &#123;</span></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123; <span class="title">console</span>.<span class="title">log</span><span class="params">( j )</span>;</span></span><br><span class="line">             &#125;, <span class="built_in">j</span>*<span class="number">1000</span> );</span><br><span class="line">         &#125;)( <span class="built_in">i</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：123456</p><p>块作用域和闭包联手便可天下无敌。把var改成let<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ol><li>数组常用遍历的方法</li></ol><p>forEach、map、filter、find、every、some、reduce，它们有个共同点：不会改变原始数组。</p><ul><li>forEach：遍历数组</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [1,2,3,4,5];</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">sum</span> = 0;</span><br><span class="line">numbers.<span class="keyword">forEach</span>(number=&gt;<span class="keyword">sum</span>+=number)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">sum</span>)<span class="comment">//15</span></span><br></pre></td></tr></table></figure><ul><li>map：将数组映射成另一个数组(map通过指定函数处理数组的每个元素，并返回处理后新的数组，map 不会改变原始数组。forEach和map的区别在于，forEach没有返回值。)</li></ul><p>map需要返回值，如果不给return，默认返回undefined</p><ul><li>filter：从数组中找出所有符合指定条件的元素</li><li>find：返回通过测试（函数内判断）的数组的第一个元素的值</li><li><p>every&amp;some<br>every：数组中是否每个元素都满足指定的条件<br>some:数组中是否有元素满足指定的条件<br>Some: 一真即真；Every: 一假即假</p></li><li><p>reduce：将数组合成一个值(reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。)</p></li></ul><ol start="2"><li>浅拷贝与深拷贝</li></ol><p>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。<br>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>浅拷贝的实现方式：</p><ul><li>Object.assign()拷贝的是对象的属性的引用，而不是对象本身。当object只有一层的时候，是深拷贝</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li></ul><p>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p><p>深拷贝的实现方式</p><ul><li>JSON.parse(JSON.stringify())这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</li><li>函数库lodash提供_.cloneDeep用来做 Deep Copy</li><li>手写递归方法<br>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相关面试题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React新特性Hooks</title>
    <link href="http://peilinghui.com/2019/09/16/React%E6%96%B0%E7%89%B9%E6%80%A7Hooks/"/>
    <id>http://peilinghui.com/2019/09/16/React新特性Hooks/</id>
    <published>2019-09-16T07:25:56.000Z</published>
    <updated>2019-09-18T05:39:59.765Z</updated>
    
    <content type="html"><![CDATA[<p>React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-reference.html</a><br>中文：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-intro.html</a><br><a id="more"></a><br>React 的核心是组件,组件的标准写法是类（class), 组件的最佳写法应该是函数，而不是类。但是函数组件必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p><p>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。就是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来</p><p>总结一下要解决的痛点问题就是：</p><ol><li>在组件之间复用状态逻辑很难</li></ol><ul><li>之前的解决方案是：render props 和高阶组件</li><li>缺点是难理解、存在过多的嵌套形成“嵌套地狱”  </li></ul><ol start="2"><li>复杂组件变得难以理解</li></ol><ul><li>生命周期函数中充斥着各种状态逻辑和副作用</li><li>这些副作用难以复用，且很零散</li></ul><ol start="3"><li>难以理解的Class</li></ol><ul><li>this指针问题</li><li>组件预编译技术（组件折叠）会在class中遇到优化失效的case</li><li>class不能很好的压缩</li><li>class在热重载时会出现不稳定的情况</li></ul><p>React 默认提供的基础Hook。</p><pre><code>useState()useEffect()useContext()</code></pre><p>额外的 Hook</p><pre><code>useReducer()useReduceruseCallbackuseMemouseRefuseImperativeHandleuseLayoutEffectuseDebugValue</code></pre><h2 id="useState-：状态钩子"><a href="#useState-：状态钩子" class="headerlink" title="useState()：状态钩子"></a>useState()：状态钩子</h2><p><code>const [state, setState] = useState(initialState);</code></p><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><p> class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setState(prevState =&gt; &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;.<span class="built_in">..prevState</span>, .<span class="built_in">..updatedValues</span>&#125;<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h2><p><code>const value = useContext(MyContext);</code></p><h2 id="useReducer-：action-钩子"><a href="#useReducer-：action-钩子" class="headerlink" title="useReducer()：action 钩子"></a>useReducer()：action 钩子</h2><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。</p><p>useReducers()钩子用来引入 Reducer 功能。</p><pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre><p>上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。</p><p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p><h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。</p><p>useEffect()的用法如下。</p><pre><code>useEffect(()  =&gt;  {  // Async Action}, [dependencies])</code></pre><p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：&lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://reactjs.org/docs/hooks-reference.html&lt;/a&gt;&lt;br&gt;中文：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-hans.reactjs.org/docs/hooks-intro.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RN第三方组件</title>
    <link href="http://peilinghui.com/2019/09/09/RN%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2019/09/09/RN第三方组件/</id>
    <published>2019-09-09T06:56:21.000Z</published>
    <updated>2019-09-19T09:59:00.156Z</updated>
    
    <content type="html"><![CDATA[<p>用过的一些组件。  </p><a id="more"></a><h1 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h1><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p>react-native-simple-router</p><p>react-native-scrollable-tab-view</p><p>react-native-router-flux</p><p>react-native-router-redux</p><p>react-native-tabbar-navigator(IOS only)</p><p>react-native-navigation</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p><a href="https://github.com/tradle/react-native-crypto" target="_blank" rel="noopener">react-native-crypto</a>此类库支持在 React Native 中使用 node 的 crypto 模块</p><p><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="noopener">https://www.npmjs.com/package/crypto-js</a></p><h1 id="整体框架布局–轮播"><a href="#整体框架布局–轮播" class="headerlink" title="整体框架布局–轮播"></a>整体框架布局–轮播</h1><p>react-native-side-menu 侧栏</p><p>react-native-scrollable-tab-view 可滑动的底部或上部导航栏框架</p><h1 id="轮播视图"><a href="#轮播视图" class="headerlink" title="轮播视图"></a>轮播视图</h1><p><a href="https://github.com/race604/react-native-viewpager" target="_blank" rel="noopener">react-native-viewpager</a> 分页浏览 </p><p><a href="https://github.com/FuYaoDe/react-native-app-intro" target="_blank" rel="noopener">https://github.com/FuYaoDe/react-native-app-intro</a> </p><p><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">https://github.com/appintheair/react-native-looped-carousel react-native-swiper</a> 轮播</p><p><a href="https://github.com/root-two/react-native-drawer" target="_blank" rel="noopener">react-native-drawer</a> 抽屉效果 </p><p><a href="https://github.com/react-native-fellowship/react-native-side-menu" target="_blank" rel="noopener">react-native-side-menu</a></p><p><a href="https://github.com/react-navigation/material-bottom-tabs" target="_blank" rel="noopener">react-navigation-material-bottom-tabs</a>底部tab</p><p>react-native-swiper</p><p>react-native-carousel</p><p>react-native-looped-carousel</p><p>react-native-carousel-control</p><p>react-native-spring-carousel</p><p>react-native-image-carousell</p><h1 id="键盘遮挡"><a href="#键盘遮挡" class="headerlink" title="键盘遮挡"></a>键盘遮挡</h1><p><a href="https://github.com/wix/react-native-keyboard-aware-scrollview" target="_blank" rel="noopener">react-native-keyboard-aware-scrollview</a><br><a href="https://github.com/reactnativecn/react-native-inputscrollview" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-inputscrollview</a> </p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>react-native-icons 图标 </p><p><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener">react-native-vector-icons</a>头像库 矢量</p><h2 id="初始化应用时启动轮播图"><a href="#初始化应用时启动轮播图" class="headerlink" title="初始化应用时启动轮播图"></a>初始化应用时启动轮播图</h2><p><a href="https://github.com/phil-r/react-native-looped-carousel" target="_blank" rel="noopener">react-native-looped-carousel</a></p><p><a href="https://www.npmjs.com/package/react-native-auto-height-image" target="_blank" rel="noopener">react-native-auto-height-image</a>自动调节图片高度</p><p>react-native-image-picker 图片选择器</p><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><p><a href="https://github.com/DylanVann/react-native-fast-image" target="_blank" rel="noopener">react-native-fast-image</a>图片缓存以及预加载</p><p>react-native-rn-cacheimage缓存</p><p><a href>react-native-cache-image</a></p><p><a href>react-native-image-zoom-viewer</a>图片轮播、放大、手势捏合</p><p>react-native-image-pan-zoom</p><p>react-native-image-resizer图片压缩</p><h2 id="图片放大查看"><a href="#图片放大查看" class="headerlink" title="图片放大查看"></a>图片放大查看</h2><p><a href="https://github.com/oblador/react-native-lightbox" target="_blank" rel="noopener">react-native-lightbox</a></p><p><a href="https://github.com/ldn0x7dc/react-native-transformable-image" target="_blank" rel="noopener">react-native-transformable-image</a></p><h2 id="照片选择"><a href="#照片选择" class="headerlink" title="照片选择"></a>照片选择</h2><p><a href="https://github.com/marcshilling/react-native-image-picker" target="_blank" rel="noopener">react-native-image-picker</a></p><p><a href>react-native-camera-roll-picker</a></p><p><a href="https://github.com/ivpusic/react-native-image-crop-picker" target="_blank" rel="noopener">react-native-image-crop-picker</a>图像选择器，可支持摄像头，可配置压缩，可多选图像和可对图像进行裁剪的。</p><p>图片加载进度条 <a href="https://github.com/oblador/react-native-image-progress" target="_blank" rel="noopener">https://github.com/oblador/react-native-image-progress</a></p><h1 id="通知栏"><a href="#通知栏" class="headerlink" title="通知栏"></a>通知栏</h1><p>Noticebar与Snackbar的区别：<a href="http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html" target="_blank" rel="noopener">http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html</a></p><h2 id="noticebar"><a href="#noticebar" class="headerlink" title="noticebar"></a>noticebar</h2><p><a href="https://github.com/seymoe/react-native-noticebar" target="_blank" rel="noopener">react-native-noticebar</a>上下滚动的通知栏</p><p><a href="https://rn.mobile.ant.design/components/notice-bar-cn/#components-notice-bar-demo-basic" target="_blank" rel="noopener">Ant Design Mobile NoticeBar 通告栏</a>滚动播放的noticebar</p><p><a href="https://github.com/peilinghui/BokeDemo/tree/master/React-Native%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%AD%97%E4%BD%93%E8%B7%91%E9%A9%AC%E7%81%AFmarquee" target="_blank" rel="noopener">纯JS跑马灯的text</a></p><p><a href="https://github.com/remobile/react-native-marquee-label" target="_blank" rel="noopener">链接原生Text跑马灯效果</a></p><h2 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h2><p><a href>rn-snackbar</a></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="https://github.com/itinance/react-native-fs" target="_blank" rel="noopener">react-native-fs</a>文件下载、文本存储</p><p>先下载<a href="https://github.com/wkh237/react-native-fetch-blob" target="_blank" rel="noopener">https://github.com/wkh237/react-native-fetch-blob</a><br>或者rn-fetch-blob</p><p>react-native-fileupload 文件上传</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p>react-native-video 视频播放</p><h1 id="滚动列表"><a href="#滚动列表" class="headerlink" title="滚动列表"></a>滚动列表</h1><p><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="noopener">react-native-refreshable-listview</a> 可刷新列表</p><p>react-native-sortable-listview 分类ListView</p><p>单选多选ListView <a href="https://github.com/hinet/react-native-checkboxlist" target="_blank" rel="noopener">https://github.com/hinet/react-native-checkboxlist</a></p><p><a href>react-native-invertible-scroll-view</a> 翻转listview</p><p>recyclerlistview”: “^2.0.0-beta.4”,</p><p>recyclerlistview-gridlayoutprovider”: “^1.0.1”,</p><p><a href="https://github.com/jaysoo/react-native-parallax-scroll-view" target="_blank" rel="noopener">react-native-parallax-scroll-view</a>拉伸最上方图片刷新，类似微信朋友圈刷新</p><p>react-native-lazyload</p><p><a href="https://github.com/sghiassy/react-native-sglistview" target="_blank" rel="noopener">react-native-sglistview</a>ListView的优化 </p><p>react-native-refreshable-listview</p><h1 id="WebView网页"><a href="#WebView网页" class="headerlink" title="WebView网页"></a>WebView网页</h1><p>react-native-htmlview 将 HTML 目录作为本地视图的控件，其风格可以定制 </p><p>react-native-webview-invoke React Native和WebView中的函数可以互相调用</p><p>react-native-easy-toast 一款简单易用的 Toast 组件，支持 Android&amp;iOS.</p><p>WebView相关 <a href="https://github.com/alinz/react-native-webview-bridge" target="_blank" rel="noopener">https://github.com/alinz/react-native-webview-bridge</a></p><p>选项卡 <a href="https://github.com/exponentjs/react-native-tab-navigator" target="_blank" rel="noopener">https://github.com/exponentjs/react-native-tab-navigator</a></p><p>material组件库（各种漂亮的小组件）<a href="https://github.com/xinthink/react-native-material-kit" target="_blank" rel="noopener">https://github.com/xinthink/react-native-material-kit</a></p><p>base组件库（各种封装不错的小组件）<a href="http://nativebase.io/docs/v0.4.6/components#anatomy" target="_blank" rel="noopener">http://nativebase.io/docs/v0.4.6/components#anatomy</a> <a href="https://github.com/GeekyAnts/NativeBase" target="_blank" rel="noopener">https://github.com/GeekyAnts/NativeBase</a></p><p>不错的按钮 <a href="https://github.com/mastermoo/react-native-action-button" target="_blank" rel="noopener">https://github.com/mastermoo/react-native-action-button</a> <a href="https://github.com/ide/react-native-button" target="_blank" rel="noopener">https://github.com/ide/react-native-button</a></p><p>输入框表单验证 <a href="https://github.com/gcanti/tcomb-form-native" target="_blank" rel="noopener">https://github.com/gcanti/tcomb-form-native</a> <a href="https://github.com/FaridSafi/react-native-gifted-form" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-form</a> <a href="https://github.com/bartonhammond/snowflake" target="_blank" rel="noopener">https://github.com/bartonhammond/snowflake</a></p><p>炫酷效果的 TextInput <a href="https://github.com/halilb/react-native-textinput-effects" target="_blank" rel="noopener">https://github.com/halilb/react-native-textinput-effects</a> <a href="https://github.com/zbtang/React-Native-TextInputLayout" target="_blank" rel="noopener">https://github.com/zbtang/React-Native-TextInputLayout</a></p><p>聊天 <a href="https://github.com/FaridSafi/react-native-gifted-chat" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-chat</a></p><p>地图 <a href="https://github.com/lelandrichardson/react-native-maps" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-maps</a></p><p>侧滑按钮 <a href="https://github.com/dancormier/react-native-swipeout" target="_blank" rel="noopener">https://github.com/dancormier/react-native-swipeout</a> <a href="https://github.com/jemise111/react-native-swipe-list-view" target="_blank" rel="noopener">https://github.com/jemise111/react-native-swipe-list-view</a></p><p>图表 <a href="https://github.com/tomauty/react-native-chart" target="_blank" rel="noopener">https://github.com/tomauty/react-native-chart</a></p><p>下拉放大 <a href="https://github.com/lelandrichardson/react-native-parallax-view" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-parallax-view</a></p><p>日历组件 <a href="https://github.com/cqm1994617/react-native-myCalendar" target="_blank" rel="noopener">https://github.com/cqm1994617/react-native-myCalendar</a> <a href="https://github.com/vczero/react-native-calendar" target="_blank" rel="noopener">https://github.com/vczero/react-native-calendar</a></p><p>语言转化和一些常用格式转换 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a><br>选择按钮 <a href="https://github.com/sconxu/react-native-checkbox" target="_blank" rel="noopener">https://github.com/sconxu/react-native-checkbox</a></p><p>制作本地库 <a href="https://github.com/frostney/react-native-create-library" target="_blank" rel="noopener">https://github.com/frostney/react-native-create-library</a></p><p>影音相关 <a href="https://github.com/MisterAlex95/react-native-record-sound" target="_blank" rel="noopener">https://github.com/MisterAlex95/react-native-record-sound</a></p><p>安卓录音 <a href="https://github.com/bosung90/react-native-audio-android" target="_blank" rel="noopener">https://github.com/bosung90/react-native-audio-android</a></p><p>提示消息的Bar <a href="https://github.com/KBLNY/react-native-message-bar" target="_blank" rel="noopener">https://github.com/KBLNY/react-native-message-bar</a></p><p>iOS原生TableView <a href="https://github.com/aksonov/react-native-tableview" target="_blank" rel="noopener">https://github.com/aksonov/react-native-tableview</a></p><p>点击弹出视图 <a href="https://github.com/jeanregisser/react-native-popover" target="_blank" rel="noopener">https://github.com/jeanregisser/react-native-popover</a> <a href="https://github.com/instea/react-native-popup-menu" target="_blank" rel="noopener">https://github.com/instea/react-native-popup-menu</a></p><p>3D Touch <a href="https://github.com/madriska/react-native-quick-actions" target="_blank" rel="noopener">https://github.com/madriska/react-native-quick-actions</a></p><p>照片墙 <a href="https://github.com/ldn0x7dc/react-native-gallery" target="_blank" rel="noopener">https://github.com/ldn0x7dc/react-native-gallery</a></p><p>本地存储 <a href="https://github.com/sunnylqm/react-native-storage" target="_blank" rel="noopener">https://github.com/sunnylqm/react-native-storage</a></p><p>星星 <a href="https://github.com/djchie/react-native-star-rating" target="_blank" rel="noopener">https://github.com/djchie/react-native-star-rating</a></p><p>国际化 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a></p><p>通讯录 <a href="https://github.com/rt2zz/react-native-contacts" target="_blank" rel="noopener">https://github.com/rt2zz/react-native-contacts</a></p><p>缓存管理 <a href="https://github.com/reactnativecn/react-native-http-cache" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-http-cache</a></p><p>图片和base64互转 <a href="https://github.com/xfumihiro/react-native-image-to-base64" target="_blank" rel="noopener">https://github.com/xfumihiro/react-native-image-to-base64</a></p><p>安卓 iOS 白屏解决 <a href="https://github.com/mehcode/rn-splash-screen" target="_blank" rel="noopener">https://github.com/mehcode/rn-splash-screen</a></p><p>清除按钮的输入框 <a href="https://github.com/beefe/react-native-textinput" target="_blank" rel="noopener">https://github.com/beefe/react-native-textinput</a></p><p>PDF <a href="https://github.com/cnjon/react-native-pdf-view" target="_blank" rel="noopener">https://github.com/cnjon/react-native-pdf-view</a></p><h1 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h1><p><a href="https://github.com/rebeccahughes/react-native-device-info" target="_blank" rel="noopener">react-native-device-info</a></p><p>下拉-上拉-刷新 <a href="https://github.com/FaridSafi/react-native-gifted-listview" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-listview</a> </p><p><a href="https://github.com/greatbsky/react-native-pull/wiki" target="_blank" rel="noopener">https://github.com/greatbsky/react-native-pull/wiki</a></p><p>下拉选择 <a href="https://github.com/alinz/react-native-dropdown" target="_blank" rel="noopener">https://github.com/alinz/react-native-dropdown</a></p><h1 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h1><p><a href>react-native-alphabetlistview</a>类似iPhone通讯录样式</p><h1 id="toast提示"><a href="#toast提示" class="headerlink" title="toast提示"></a>toast提示</h1><p><a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">react-native-root-toast</a>浮动提示</p><h1 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h1><p><a href="https://github.com/react-native-fellowship/react-native-blur" target="_blank" rel="noopener">react-native-blur</a></p><p>滑动选项卡 <a href="https://github.com/skv-headless/react-native-scrollable-tab-view" target="_blank" rel="noopener">https://github.com/skv-headless/react-native-scrollable-tab-view</a></p><h1 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h1><p><a href>react-native-progress</a></p><h1 id="第三方授权登录"><a href="#第三方授权登录" class="headerlink" title="第三方授权登录"></a>第三方授权登录</h1><p><a href="https://github.com/yoaicom/react-native-social-kit" target="_blank" rel="noopener">https://github.com/yoaicom/react-native-social-kit</a> <a href="https://github.com/mozillo/react-native-open-share" target="_blank" rel="noopener">https://github.com/mozillo/react-native-open-share</a> <a href="https://github.com/zuoyoulian/React-Native-iOS-OpenShare" target="_blank" rel="noopener">https://github.com/zuoyoulian/React-Native-iOS-OpenShare</a></p><p>react-native-dialog-input弹框的输入框</p><p>react-native-countdown 倒计时</p><p>react-native-device-info 设备信息</p><p><a href="https://github.com/beefe/react-native-actionsheet" target="_blank" rel="noopener">react-native-actionsheet</a>双平台兼容的ActionSheet弹框</p><h1 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h1><p><a href>react-native-camera</a></p><p><a href="https://github.com/wix/react-native-camera-kit" target="_blank" rel="noopener">react-native-camera-kit</a>相机组件</p><p>react-native-keychain iOS KeyChain管理</p><p>react-native-picker滚轮选择器</p><p>react-native-picker-Android Android 滚轮选择器</p><h1 id="表情选择"><a href="#表情选择" class="headerlink" title="表情选择"></a>表情选择</h1><p><a href="https://github.com/arronhunt/react-native-emoji-selector" target="_blank" rel="noopener">react-native-emoji-selector</a></p><p><a href="https://github.com/yonahforst/react-native-emoji-picker" target="_blank" rel="noopener">react-native-emoji-picker</a></p><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p><a href="https://github.com/master-atul/react-native-exception-handler" target="_blank" rel="noopener">react-native-exception-handler</a></p><h1 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h1><p><a href="https://github.com/Sunhat/react-native-extra-dimensions-android" target="_blank" rel="noopener">react-native-extra-dimensions-android</a></p><p>React Native目前存在一个错误，Dimensions.get(‘window’).height有时会返回错误的值。</p><h1 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h1><p><a href>react-native-gesture-handler</a><br><a href>react-native-gesture-password</a>手势解锁</p><p>手势放大缩小移动 <a href="https://github.com/kiddkai/react-native-gestures" target="_blank" rel="noopener">https://github.com/kiddkai/react-native-gestures</a> </p><p><a href="https://github.com/johanneslumpe/react-native-gesture-recognizers" target="_blank" rel="noopener">https://github.com/johanneslumpe/react-native-gesture-recognizers</a></p><p>react-native-linear-gradient渐变</p><h1 id="Model模态视图"><a href="#Model模态视图" class="headerlink" title="Model模态视图"></a>Model模态视图</h1><p><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="noopener">react-native-modal</a><br><a href="https://github.com/maxs15/react-native-modalbox" target="_blank" rel="noopener">react-native-modalbox</a><br><a href="https://github.com/bodyflex/react-native-simple-modal" target="_blank" rel="noopener">react-native-simple-modal</a></p><h1 id="横竖屏"><a href="#横竖屏" class="headerlink" title="横竖屏"></a>横竖屏</h1><p><a href="https://github.com/yamill/react-native-orientation" target="_blank" rel="noopener">react-native-orientation</a>判断横竖屏 </p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>react-native-qrcode-svg</p><p><a href="https://github.com/lazaronixon/react-native-qrcode-reader" target="_blank" rel="noopener">react-native-qrcode-reader</a>扫描二维码 </p><p><a href="https://github.com/ideacreation/react-native-barcodescanner" target="_blank" rel="noopener">react-native-barcodescanner</a></p><h1 id="网页链接"><a href="#网页链接" class="headerlink" title="网页链接"></a>网页链接</h1><p><a href="https://github.com/obipawan/react-native-hyperlink" target="_blank" rel="noopener">react-native-hyperlink</a>超链接变可点击的</p><p>react-native-tab-navigator 底部或上部导航框架(不可滑动)</p><p>react-native-check-box CheckBox</p><p>react-native-splash-screen 启动白屏问题</p><p>react-native-simple-router 简易路由跳转框架</p><p>react-native-storage 持久化存储<br>    “react-native-global-props”: “^1.1.5”,<br>    “react-native-iphone-x-helper”: “^1.2.0”,<br>    “react-native-paper”: “^2.15.2”,<br>    “react-native-plugin-zhugeio”: “^1.1.1”,<br>    “react-native-randombytes”: “^3.5.3”,<br>    “react-native-shadow”: “^1.2.2”,<br>    “react-native-svg”: “^9.4.0”,<br>    “react-native-tab-view”: “^1.3.2”,<br>    “react-native-text-size”: “^3.0.0”,<br>    “react-native-update-app”: “^1.1.11”,<br>    “react-native-view-shot”: “^2.5.0”,   </p><h1 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h1><p>react-native-wechat “git+<a href="https://github.com/AegoYu/react-native-wechat.git&quot;" target="_blank" rel="noopener">https://github.com/AegoYu/react-native-wechat.git&quot;</a> </p><p>react-navigation</p><p>react-navigation-redux-helpers<br>react-navigation-transitions<br>react-redux<br>redux-immutable<br>redux-persist</p><p>socket.io-client<br>teaset<br>react-native-menu<br>react-timer-mixin<br>redux<br>redux-actions<br>redux-form<br>redux-thunk<br>remote-redux-devtools<br>rmc-date-picker<br>rmc-tabs<br>semver<br>react-native-networkplugin</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><a href="https://github.com/oblador/react-native-collapsible" target="_blank" rel="noopener">react-native-collapsible</a>制作动画可折叠组件—手风琴</p><p>React-native-animatable 动画</p><p>动画 <a href="https://github.com/oblador/react-native-animatable" target="_blank" rel="noopener">https://github.com/oblador/react-native-animatable</a></p><p>加载动画 <a href="https://github.com/maxs15/react-native-spinkit" target="_blank" rel="noopener">https://github.com/maxs15/react-native-spinkit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过的一些组件。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux中间件与异步</title>
    <link href="http://peilinghui.com/2019/08/21/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://peilinghui.com/2019/08/21/Redux中间件与异步/</id>
    <published>2019-08-21T02:40:48.000Z</published>
    <updated>2019-08-21T02:40:48.761Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://peilinghui.com/2019/07/19/TypeScript/"/>
    <id>http://peilinghui.com/2019/07/19/TypeScript/</id>
    <published>2019-07-19T07:21:29.000Z</published>
    <updated>2019-08-23T09:07:26.168Z</updated>
    
    <content type="html"><![CDATA[<p>学习TS。是JS的超集。TS类Class。接口Interface。<br><a id="more"></a></p><p>安装：npm install -g typescript</p><p>官网：<a href="https://typescript.bootcss.com/" target="_blank" rel="noopener">https://typescript.bootcss.com/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>TS强于JS：可以声明数据类型。<br>Boolean<br>Number<br>String<br>Array<br>Enum<br>Any<br>Void</p><p>访问修饰符：public和private</p><p>封装的实现：方法里面写get和set方法<br>类：<br>认识类Class：有构造方法的话必须传参数<br>类的继承：在子类的constructor构造函数中调用super<br>static和使用：</p><p>函数类型：命名函数和匿名函数<br>重载：</p><p>Lambads和this关键字的使用：</p><p>TypeScript的接口：Class类型</p><p>interface CLockInterface{<br>} </p><p>class Clock implements CLockInterface{</p><p>}</p><p>了解接口：规范传入参数的类型<br>可选属性：自定义接口属性<br>函数类型：<br>数组类型：<br>Class类型：<br>继承接口与混合类型：</p><p>混合类型</p><p>泛型：<br>class HelloNumber<t>{<br> Ten:T<br> add:(x:T,y:T)=&gt;T;<br>}<br>var myHelloNumber = new </t></p><p>Module模式：<br>1.模块化、可重用<br>2.封装变量和函数</p><p>//闭包<br>(function(){<br>    //内部代码<br>}());</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习TS。是JS的超集。TS类Class。接口Interface。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js</title>
    <link href="http://peilinghui.com/2019/07/18/%E5%AD%A6%E4%B9%A0Node.js/"/>
    <id>http://peilinghui.com/2019/07/18/学习Node.js/</id>
    <published>2019-07-18T10:14:32.000Z</published>
    <updated>2019-09-17T01:54:42.712Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下Node.js。</p><a id="more"></a><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p><p><strong>Nodejs的特点是：</strong></p><ul><li>JavaScript运行环境，相当于js在服务端的一个宿主环境</li><li>依赖于Chrome V8引擎进行代码解释，V8引擎执行Javascript的速度非常快，性能非常好。</li><li>事件驱动</li><li>非阻塞I/O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li><li>Node提供核心功能模块，使得JavaScript语言可以实现文件的读写、进程管理以及网络通信等功能，在这个意义上，Node又是JavaScript的工具库</li></ul><p><strong>Node.js的应用领域</strong></p><ul><li>项目管理：npm,grunt, gulp,bower, yeoman</li><li>桌面应用: node-webkit</li><li>Web开发：express,ejs,hexo, socket.io, restify, cleaver, stylus, browserify,cheerio</li><li>工具包 underscore,moment,connet,later,log4js,passport,passport(oAuth),domain,require,reap,commander,retry,PDFkit</li><li>数据库：mysql,mongoose,redis,memcached</li><li>异步：async,wind,eventProxy,bluebird</li><li>部署：forever,pm2,nodemon</li><li>测试：jasmine,karma,protractor</li><li>跨平台：rio,tty</li><li>内核：cluster,http,request</li><li>模板: jade</li><li>博客: ghost,hexo</li><li>微信: weui</li><li>硬件控制: NoduinoWeb</li><li>操作系统: NodeOS</li></ul><p><strong>Node.js的优点缺点</strong><br><strong>优点：</strong></p><ul><li>解决并发连接的问题</li></ul><blockquote><p>更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。</p></blockquote><ul><li>解决I/O阻塞的问题<br>业务场景：需要从多个数据源拉取数据，然后进行处理，处理的方式有：</li></ul><ol><li>串行获取数据，这是我们一般的解决方案</li><li>NodeJS非阻塞I/O，是通过发射/监听事件来控制执行过程<br>NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行，事件代理接收到线程后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。</li></ol><p><strong>缺点：</strong><br>匿名函数，使得抛出的异常不易阅读。try/catch使得异常捕获较为复杂。单线程的可靠性。不适合CPU密集型的场景。</p><p><strong>总结：</strong>  </p><ul><li>Nodejs具有处理高并发的能力（最重要的优点）</li><li>Nodejs适合I/O密集型应用</li><li>Nodejs不适合CPU密集型应用；<br>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；<br>解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；或者使用第三方模块，让Node也可以创建多进程。</li></ul><p>Node.js的特点：<br>1.部署简单方便<br>2.事件驱动：根据当前出现的事件，调用资源进行相关的处理。<br>3.异步编程：回调函数，事件监听，发布/订阅模式，<br>4.高效与性能：<br>5.单线程与多线程<br>6.可以解析JS代码，提供系统级别的API：文件的读写，线程的管理，网络通信</p><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><ul><li>express的安装：npm install express –save<br>expressjs的基础<br>expressjs的初始化配置<br>expressjs的路由<br>expressjs的返回响应</li><li>从Request—中间件—URL—-response<br>中间件MiddleWare：app.use  app.get  app.post<br>request:req.params  req.query  req.body<br>response: res.send() next()</li></ul><ol><li><p>使用express返回HTML内容</p><ul><li>Content-Type：text/html</li><li>fs.createReadStream(‘xxx.html’).pipe(res)</li><li>res.render()</li></ul></li><li><p>模板引擎：–复用HTML组件，简化开发流程</p><ul><li>app.set(‘view’, ‘ejs’)</li><li>res.render(‘home.ejs’, {title: ‘ejs template’}) </li></ul></li><li><p>使用app.set来设置express实例所使用的模板引擎</p></li><li>前后端共用模板</li></ol><h2 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h2><ol><li>简介<br><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">https://github.com/koajs/koa</a><br>Express的扩展。更小，更健壮的Web框架。组合不同的generator可以免除重复繁琐的回调函数的嵌套。提供了轻量优雅的函数库。<br>教程：<a href="https://chenshenhai.github.io/koa2-note/note/start/async.html" target="_blank" rel="noopener">https://chenshenhai.github.io/koa2-note/note/start/async.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960</a></li><li>应用</li></ol><ol start="3"><li>Request和Response</li><li>Content上下文</li></ol><h2 id="Mac下升级Node-js"><a href="#Mac下升级Node-js" class="headerlink" title="Mac下升级Node.js"></a>Mac下升级Node.js</h2><p>node有一个专门管理node.js版本的包叫作：n(没错，就是一个字母n)，mac下升级步骤如下：</p><ul><li>查看当前 node版本：</li></ul><p><code>$ node -v</code></p><ul><li>清除node缓存：</li></ul><p><code>$ sudo npm cache clean -f</code></p><ul><li>安装n工具包：</li></ul><p><code>$ sudo npm i -g n</code></p><ul><li>安装最新版node.js</li></ul><p><code>$ sudo n stable</code></p><ul><li>也可以到安装指定版本：(例如升级到10.8.0)</li></ul><p><code>$ sudo n v10.8.0</code></p><ul><li>再次查看本机node版本</li></ul><p><code>$ node -v</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下Node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://peilinghui.com/categories/NodeJS/"/>
    
    
  </entry>
  
  <entry>
    <title>RN性能优化总结</title>
    <link href="http://peilinghui.com/2019/05/22/RN%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2019/05/22/RN性能优化总结/</id>
    <published>2019-05-22T13:53:04.000Z</published>
    <updated>2019-05-22T14:02:23.724Z</updated>
    
    <content type="html"><![CDATA[<p>RN的性能优化<br><a id="more"></a></p><h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p>更新阶段的生命周期</p><pre><code>componentWillReceiveProps(object nextProps)：当挂载的组件接收到新的props时被调用。此方法应该被用于比较this.props 和 nextProps以用于使用this.setState()执行状态转换。（组件内部数据有变化，使用state，但是在更新阶段又要在props改变的时候改变state，则在这个生命周期里面）shouldComponentUpdate(object nextProps, object nextState)： -boolean 当组件决定任何改变是否要更新到DOM时被调用。作为一个优化实现比较this.props 和 nextProps 、this.state 和 nextState ，如果React应该跳过更新，返回false。componentWillUpdate(object nextProps, object nextState)：在更新发生前被立即调用。你不能在此调用this.setState()。componentDidUpdate(object prevProps, object prevState)： 在更新发生后被立即调用。（可以在DOM更新完之后，做一些收尾的工作）</code></pre><blockquote><p>  Tips: React的优化是基于shouldComponentUpdate的，该生命周期默认返回true，所以一旦prop或state有任何变化，都会引起重新render。</p></blockquote><h2 id="React官方的解决方案"><a href="#React官方的解决方案" class="headerlink" title="React官方的解决方案"></a>React官方的解决方案</h2><p>PureRenderMixin(es5)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Shallow Compare (es6)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCompare = require(<span class="symbol">'react</span>-addons-shallow-compare');</span><br><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;foo&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es7装饰器的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pureRender <span class="keyword">from</span> <span class="string">"pure-render-decorator"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@pureRender</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我re-render了"</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123;name,age&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;span&gt;姓名:<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">          &lt;span&gt;&#123;name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span&gt; age:&lt;/</span>span&gt;</span><br><span class="line">          &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>immutable.js</p><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>【在react中使用immutable】改变shouldComponentUpdate的重新渲染规则（1）防止每次setState或传递props，即使state和props的值没有发生改变也重新渲染组件，带来无谓的性能消耗（2）防止浅比较带来的比较误差问题，以及深比较带来的性能消耗问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RN的性能优化&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习Dva</title>
    <link href="http://peilinghui.com/2019/04/11/%E5%AD%A6%E4%B9%A0Dva/"/>
    <id>http://peilinghui.com/2019/04/11/学习Dva/</id>
    <published>2019-04-11T02:11:03.000Z</published>
    <updated>2019-04-11T02:53:52.840Z</updated>
    
    <content type="html"><![CDATA[<p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。</p><a id="more"></a><h1 id="Dva-概念"><a href="#Dva-概念" class="headerlink" title="Dva 概念"></a>Dva 概念</h1><p>dva = React-Router + Redux + Redux-saga</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line">const App = <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Hello dva&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 创建应用</span><br><span class="line">const app = dva();</span><br><span class="line"><span class="regexp">//</span> 注册视图</span><br><span class="line">app.router(<span class="function"><span class="params">()</span> =&gt;</span> &lt;App /&gt;);</span><br><span class="line"><span class="regexp">//</span> 启动应用</span><br><span class="line">app.start(<span class="string">'#root'</span>);</span><br></pre></td></tr></table></figure><ul><li>State：一个对象，保存整个应用状态</li><li>View：React 组件构成的视图层</li><li>Action：一个对象，描述事件</li><li>connect 方法：一个函数，绑定 State 到 View</li><li>dispatch 方法：一个函数，发送 Action 到 State</li></ul><p>改变数据的时候可以通过 dispatch 发起一个 action,<br>同步行为:直接通过 Reducers 改变 State ，异步行为:会先触发 Effects 然后流向 Reducers 最终改变 State.</p><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><h3 id="State-是储存数据的地方，收到-Action-以后，会更新数据。"><a href="#State-是储存数据的地方，收到-Action-以后，会更新数据。" class="headerlink" title="State : 是储存数据的地方，收到 Action 以后，会更新数据。"></a>State : 是储存数据的地方，收到 Action 以后，会更新数据。</h3><p><code>type State = any</code><br>表示 Model 的状态数据</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>type AsyncAction = any</code></p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'add'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="connect-绑定-State-到-View"><a href="#connect-绑定-State-到-View" class="headerlink" title="connect:绑定 State 到 View"></a>connect:绑定 State 到 View</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; <span class="keyword">from</span> 'dva';</span><br><span class="line"></span><br><span class="line">function mapStateToProps(<span class="keyword">state</span>) &#123;</span><br><span class="line">  return &#123; todos: <span class="keyword">state</span>.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line">connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure><p>mapStateToProps 函数会返回一个对象，用于建立 State 到 Props 的映射关系。</p><h3 id="dispatch-函数：用来将-Action-发送给-State。"><a href="#dispatch-函数：用来将-Action-发送给-State。" class="headerlink" title="dispatch 函数：用来将 Action 发送给 State。"></a>dispatch 函数：用来将 Action 发送给 State。</h3><p><code>type dispatch = (a: Action) =&gt; Action</code></p><p>dispatching function 是一个用于触发 action 的函数，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'user/add'</span>, <span class="comment">// 如果在 model 外调用，需要添加 namespace</span></span><br><span class="line">  <span class="attribute">payload</span>: &#123;&#125;, <span class="comment">// 需要传递的信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S</p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。计算以外的操作都属于 Effect，典型的就是 I/O 操作、数据库读写。Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。<br>dva 提供多个 effect 函数内部的处理函数，比较常用的是 call 和 put。</p><ul><li>call：执行异步函数</li><li>put：发出一个 Action，类似于 dispatch</li></ul><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><h1 id="通信：组件之间如何通信？"><a href="#通信：组件之间如何通信？" class="headerlink" title="通信：组件之间如何通信？"></a>通信：组件之间如何通信？</h1><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><h1 id="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"><a href="#数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等" class="headerlink" title="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"></a>数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等</h1><p>目前流行的数据流方案有：</p><ul><li>Flux，单向数据流方案，以 Redux 为代表</li><li>Reactive，响应式数据流方案，以 Mobx 为代表</li><li>其他，比如 rxjs 等</li><li>最流行的社区 React 应用架构方案如下。</li></ul><p>路由： React-Router<br>架构： Redux<br>异步操作： Redux-saga</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于RN的热更新</title>
    <link href="http://peilinghui.com/2019/03/07/%E5%85%B3%E4%BA%8ERN%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://peilinghui.com/2019/03/07/关于RN的热更新/</id>
    <published>2019-03-07T09:46:13.000Z</published>
    <updated>2019-08-21T03:09:33.408Z</updated>
    
    <content type="html"><![CDATA[<p>写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题</p><a id="more"></a><p>在APPDelegate中加载RN，一般的加载方式是：<br><code>RCTRootView *rootView= [[RCTRootView alloc] initWithBundleURL:jsCodeLocation                                                   moduleName:@&quot;authen_native&quot;                                            initialProperties:nil                                               launchOptions:nil];</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(instancetype)</span>initWithBundleURL:<span class="params">(NSURL *)</span>bundleURL</span><br><span class="line">                       moduleName:<span class="params">(NSString *)</span>moduleName</span><br><span class="line">                initialProperties:<span class="params">(NSDictionary *)</span>initialProperties</span><br><span class="line">                    launchOptions:<span class="params">(NSDictionary *)</span>launchOptions;</span><br></pre></td></tr></table></figure><p>但在调试中发现两个现象：<br>1.重复进入react-native页面、退出react-native页面的操作，RCTBridge对象会被重复创建、销毁。有时候RCTBridge对象未能及时创建还会crash<br>2.在原生页面和react-native页面相互跳转是RCTBridge也会被重复创建，造成很大的内存开销</p><p>阅读RCTRootView.h发现一些细节:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Convenience initializer -</span></span><br><span class="line"><span class="comment"> * A bridge will be created internally.</span></span><br><span class="line"><span class="comment"> * This initializer is intended to be used when the app has a single RCTRootView,</span></span><br><span class="line"><span class="comment"> * otherwise create an `RCTBridge` and pass it in via `initWithBridge:moduleName:`</span></span><br><span class="line"><span class="comment"> * to all the instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBundleURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">bundleURL</span></span><br><span class="line">                       <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">                <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span></span><br><span class="line">                    <span class="selector-tag">launchOptions</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">launchOptions</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Designated initializer -</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBridge</span><span class="selector-pseudo">:(RCTBridge</span> *)<span class="selector-tag">bridge</span></span><br><span class="line">                    <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">             <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span> <span class="selector-tag">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><h2 id="initWithBundleURL与initWithBridge的区别"><a href="#initWithBundleURL与initWithBridge的区别" class="headerlink" title="initWithBundleURL与initWithBridge的区别"></a>initWithBundleURL与initWithBridge的区别</h2><p>对于项目中只有一个RCTRootView的时候建议initWithBundleURL的方法，这个方法内部创建了一个RCTBridge.</p><p>而有多个RCTRootView的情况，建议initWithBridge的方法.开发者直接创建RCTBridge，多个RCTRootView可共用一个RCTBridge。</p><h1 id="RN版本升级更新"><a href="#RN版本升级更新" class="headerlink" title="RN版本升级更新"></a>RN版本升级更新</h1><p>项目中使用多个RCTRootView，推荐使用以下方法initWithBridge初始化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">_bridge</span> <span class="string">=</span> <span class="string">[[RCTBridge</span> <span class="string">alloc]</span> <span class="attr">initWithBundleURL:[SDRrectFileOption</span> <span class="attr">SetFileWithOption:self.luanchOption]</span></span><br><span class="line"><span class="attr">                                  moduleProvider:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                                   launchOptions:</span><span class="string">self.luanchOption];</span></span><br><span class="line"><span class="string">RCTRootView</span> <span class="meta">*rootView</span> <span class="string">=</span> <span class="string">[[RCTRootView</span> <span class="string">alloc]</span> <span class="attr">initWithBridge:_bridge</span></span><br><span class="line"><span class="attr">                                                   moduleName:</span><span class="string">@"authen_native"</span></span><br><span class="line"><span class="attr">                                            initialProperties:</span><span class="string">nil];</span></span><br></pre></td></tr></table></figure><p>在SDRrectFileOption中返回的是jsbundle的地址。在这个文件中可以使用NSFileManager来把jsbundle缓存到本地。但是如果是新版本的RN比如0.57要替换老版本的比如0.54的APP覆盖更新的话，记得要对比版本号，然后把缓存里面的jsbundle清除掉再返回新的jsbundle地址。不然会导致crash。</p><h1 id="RN的热更新"><a href="#RN的热更新" class="headerlink" title="RN的热更新"></a>RN的热更新</h1><p>在APPdelegate的didFinishLaunchingWithOptions方法中来判断是否需要Update。在Update方法中如果需要强制更新的话就就把RCTBridge调用reload方法进行热更新—和初始化使用的是同一个bridge。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>checkUpdate &#123;</span><br><span class="line">  <span class="keyword">patch</span>Class *<span class="keyword">patch</span> = [<span class="keyword">patch</span>Class sharedInstance];</span><br><span class="line">  [<span class="keyword">patch</span> checkUpdate];</span><br><span class="line">  <span class="keyword">patch</span>.IS_COERCIVE = ^<span class="params">(NSURL *newPath)</span> &#123;</span><br><span class="line">    <span class="string">//</span>是强制更新的话，就把RCTBridge调用<span class="keyword">reload</span>方法进行热更新</span><br><span class="line">    [_bridge <span class="keyword">reload</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在patchClass中使用的是单例，在这个里面通过接口判断是否需要热更还是强制更新，是只更新jsbundle还是整包更新，下载文件，把下载的压缩文件解压缩，如果缓存里面有文件先删除旧的jsbundle再保存，</p><h1 id="解决白屏问题"><a href="#解决白屏问题" class="headerlink" title="解决白屏问题"></a>解决白屏问题</h1><p>使用单例初始化一个bridge对象解决上述问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeManager</span>: <span class="title">RCTBridge</span></span></span><br><span class="line"></span><br><span class="line">+ (BridgeManager*)shareInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeHandle</span> : <span class="title">NSObject</span>&lt;<span class="title">RCTBridgeDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line">implementation MallBridgeHandle</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)sourceURLForBridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"index.ios"</span> withExtension:<span class="string">@"jsbundle"</span>];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BridgeManager</span></span></span><br><span class="line"><span class="keyword">static</span> BridgeManager * manager = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">+ (BridgeManager*)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        manager = [BridgeManager alloc] initWithDelegate:[[BridgeHandle alloc] init] launchOptions:<span class="literal">nil</span>]; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>单例在程序启动时初始化。<br>测试验证可以发现：内存得到优化，白屏问题得到解决。</p><h1 id="桥接原生模块"><a href="#桥接原生模块" class="headerlink" title="桥接原生模块"></a>桥接原生模块</h1><p>首先我们需要创建一个类，然后导入头文件 #import &lt;RCTBridgeModule.h&gt; ,这个类需要实现 RCTBridgeModule 协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RNTestManager</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>模块名字</strong></p><p>在类的实现部分，需要包含 RCT_EXPORT_MODULE() 宏，这个宏也可以添加一个参数用来指定在 JS 中访问这个模块的名字。如果你不指定，默认就会使用这个 OC 类的名字。</p><p><strong><em>导出方法</em></strong></p><p>RCT_EXPORT_METHOD()，导出到 JS 的方法名是 OC 的方法名的第一个部分，桥接到 JS 的方法返回值类型必须是 void。<strong>RN 的桥接操作是异步的</strong>，所以如果要返回结果给 JS，你必须通过回调或者触发事件来进行。传入的参数类型有以下几种：</p><p>string (NSString)<br>number (NSInteger, float, double, CGFloat, NSNumber)<br>boolean (BOOL, NSNumber)<br>array (NSArray) 包含本列表中任意类型<br>object (NSDictionary) 包含string类型的键和本列表中任意类型的值<br>function (RCTResponseSenderBlock)</p><p><strong>回调函数</strong><br>RCT_EXPORT_METHOD(RNInvokeOCPromise:(NSDictionary *)dictionary resolver:(RCTPromiseResolveBlock)resolve<br>                  rejecter:(RCTPromiseRejectBlock)reject){<br>}<br>桥接原生方法的最后两个参数是RCTPromiseResolveBlock 和RCTPromiseRejectBlock的话，则对应的JS方法就会返回一个Promise对象。</p><p><strong>设置原生模块执行操作的线程</strong><br>如果你在原生模块中需要更改 UI 或者必须在主线程的话，可以实现 </p><p><code>- (dispatch_queue_t)methodQueue 方法</code></p><p><code>- (dispatch_queue_t)methodQueue {    return dispatch_get_main_queue();}</code></p><h2 id="RN使用原生的View"><a href="#RN使用原生的View" class="headerlink" title="RN使用原生的View"></a>RN使用原生的View</h2><p>import入UIView+React.h文件，，原生视图都需要被一个RCTViewManager的子类来创建和管理。这些管理器在功能上有些类似“视图控制器”，但它们本质上都是单例 —— React Native只会为每个管理器创建一个实例。步骤：</p><ol><li>创建一个子类</li><li>添加 RCT_EXPORT_MODULE()标记宏</li><li>实现 -(UIView *)view 方法</li></ol><h3 id="创建一个子类"><a href="#创建一个子类" class="headerlink" title="创建一个子类"></a>创建一个子类</h3><p>该组件有回调需要处理，这里即必须用到 RCTDirectEventBlock 或者 RCTBubblingEventBlock，而且命名的时候要特别注意，需要已 on 开头，熟悉 JS 的朋友应该会反应过来，这很像 JS 的事件命名规范。</p><p><code>@property (nonatomic, copy) RCTBubblingEventBlock onValueChange;</code><br><code>@property (nonatomic, copy) RCTBubblingEventBlock onSlidingComplete;</code></p><h3 id="在自定义ViewManager中"><a href="#在自定义ViewManager中" class="headerlink" title="在自定义ViewManager中"></a>在自定义ViewManager中</h3><ol><li>初始化子View</li><li>添加 RCT_EXPORT_MODULE()标记宏<br>添加TYRCBarChartViewManager 来管理TYRCBarChartView。这个TYRCBarChartViewManager : 继承自RCTViewManager。 RCTViewManager 实现 RCTBridgeModule 协议。</li><li>自定义属性RCT_CUSTOM_VIEW_PROPERTY</li><li>自定义方法RCT_EXPORT_METHOD(refresh){<br> [_barView refreshData];<br>}<br>RCT_CUSTOM_VIEW_PROPERTY(name, type, viewClass)，完整的属性定义为</li></ol><h3 id="给JS发送事件使用-eventDispatcher"><a href="#给JS发送事件使用-eventDispatcher" class="headerlink" title="给JS发送事件使用 eventDispatcher"></a>给JS发送事件使用 eventDispatcher</h3><p>   [self.rootView.bridge.eventDispatcher sendAppEventWithName:@”deviceLocalStateChange”<br>                                                          body:@{@”state”:state}];</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ios2.1大礼包被拒经验分享<a href="https://zhuanlan.zhihu.com/p/54042709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54042709</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题&lt;/p&gt;
    
    </summary>
    
      <category term="RN" scheme="http://peilinghui.com/categories/RN/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac获取ipa方法</title>
    <link href="http://peilinghui.com/2019/02/02/Mac%E8%8E%B7%E5%8F%96ipa%E6%96%B9%E6%B3%95/"/>
    <id>http://peilinghui.com/2019/02/02/Mac获取ipa方法/</id>
    <published>2019-02-02T05:46:05.000Z</published>
    <updated>2019-02-02T05:53:34.025Z</updated>
    
    <content type="html"><![CDATA[<p>从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。<br>新的方法。</p><a id="more"></a><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p> Apple Configurator 2   Mac appstore下载即可<br>登录appleId</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><ol><li>在Appstore下载相关App（以XX为例）到iPhone或iPad上;</li><li>打开 Apple Configurator 2</li><li>选中连接Mac的移动设备后，点击 Apple Configurator 2 工具菜单 ”添加“ –&gt; 应用；</li><li>搜索app-xx，选中，点击右下角添加，等待添加完成(如下图)；</li><li>不要操作  Apple Configurator 2,切换到桌面;</li><li>快捷键：command + shift + G 或者在Finder 中前往文件夹…</li><li>输入路径：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</li><li>拷贝出 上述路径中的ipa文件，之后在 Apple Configurator 2 工具的弹框中点击停止，即可；<br>zhifubao<br>done</li></ol></blockquote><h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><ol><li>修改上述获取的ipa文件，修改后缀名 ipa –&gt;zip;</li><li>解压zip文件，在完成的文件夹中打开Payload 文件夹，即可看到应用xx宝应用程序；</li><li>选中该应用程序，右键显示包内容即可查看图片资源等；</li></ol><h3 id="获取图片资源"><a href="#获取图片资源" class="headerlink" title="获取图片资源"></a>获取图片资源</h3><ol><li>找到包内容中的 Assets.car 文件；</li><li>打开 “Assets提取工具”，导入 Assets.car 文件，添加到处文件夹，点击提取即可获取；</li></ol><p>参考资料:</p><ol><li>Mac获取ipa和相关资源</li><li>Assets提取工具<a href="https://github.com/pcjbird/AssetsExtractor" target="_blank" rel="noopener">https://github.com/pcjbird/AssetsExtractor</a></li></ol><p>微信分享二维码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。&lt;br&gt;新的方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS逆向</title>
    <link href="http://peilinghui.com/2019/02/01/%E5%AD%A6%E4%B9%A0iOS%E9%80%86%E5%90%91/"/>
    <id>http://peilinghui.com/2019/02/01/学习iOS逆向/</id>
    <published>2019-02-01T02:26:24.000Z</published>
    <updated>2019-07-19T03:48:10.635Z</updated>
    
    <content type="html"><![CDATA[<p>从现有APP实现细节的过程.</p><a id="more"></a><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>壳是应用程序加密保护的一种方式，在APP Store上的应用程序都是有加密保护的。<br>查看是否加壳：<br><code>otool -l 可执行文件 | grep cryptid</code><br>例如：<code>localhost:ivwen.app peilinghui$ otool -l ivwen | grep cryptid        cryptid 1</code><br>    如果是1表示是加密的.0表示脱壳的。<br>查看架构：<br><code>lipo -info WeChat</code><br><code>Non-fat file: WeChat is architecture: arm64</code></p><h3 id="1-砸壳工具"><a href="#1-砸壳工具" class="headerlink" title="1. 砸壳工具"></a>1. 砸壳工具</h3><h4 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a>dumpdecrypted</h4><p><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted</a><br>去 Github 下载 dumpdecrypted 源码, 源码就一个 C 源文件.下载 zip 包之后, 解压.在当前目录, 执行 make 即可完成编译,编译成功后生成 dumpdecrypted.dylib 文件.<br>iOS 逆向: dumpdecrypted 砸壳记<a href="http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/" target="_blank" rel="noopener">http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/</a></p><h4 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a>Clutch</h4><p><a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch/releases</a></p><h3 id="2-监控工具"><a href="#2-监控工具" class="headerlink" title="2.监控工具"></a>2.监控工具</h3><p>通过监控，可以获取界面的变化，文件的读取，网络的传输。</p><h4 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h4><p>对于去壳的应用可以得到所有类的头文件<br><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">https://github.com/nygard/class-dump</a></p><h4 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h4><p><a href="https://revealapp.com/" target="_blank" rel="noopener">https://revealapp.com/</a><br>得到界面UI，得到响应事件。</p><h4 id="Snoop-it"><a href="#Snoop-it" class="headerlink" title="Snoop-it"></a>Snoop-it</h4><p><a href="https://code.google.com/archive/p/snoop-it/" target="_blank" rel="noopener">https://code.google.com/archive/p/snoop-it/</a></p><h4 id="introspy"><a href="#introspy" class="headerlink" title="introspy"></a>introspy</h4><p><a href="https://github.com/iSECPartners/Introspy-iOS" target="_blank" rel="noopener">https://github.com/iSECPartners/Introspy-iOS</a></p><h3 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h3><p>通过分析二进制文件，生成汇编代码，进而转换成高级语言。</p><h4 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h4><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><h3 id="调试跟踪工具"><a href="#调试跟踪工具" class="headerlink" title="调试跟踪工具"></a>调试跟踪工具</h3><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><h4 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h4><h2 id="程序功能具体实现"><a href="#程序功能具体实现" class="headerlink" title="程序功能具体实现"></a>程序功能具体实现</h2><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="应用代码框架构成"><a href="#应用代码框架构成" class="headerlink" title="应用代码框架构成"></a>应用代码框架构成</h2><h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><h2 id="执行流程参数传递"><a href="#执行流程参数传递" class="headerlink" title="执行流程参数传递"></a>执行流程参数传递</h2><p><code>class-dump -s -S -H WeChat.decrypted -o /Users/lecoding/Desktop/test/WeChatDemo/Headers</code></p><blockquote><p>WeChat.decrypted ： 砸壳后的Mach-o文件路径<br>/Users/lecoding/Desktop/test/WeChatDemo/Headers： 存储头文件目录<br>-s             sort classes and categories by name<br>-S             sort methods by name<br>-H            generate header files in current directory, or directory specified with -o<br>-o            output directory used for -H</p></blockquote><h1 id="iOS系统安全机制"><a href="#iOS系统安全机制" class="headerlink" title="iOS系统安全机制"></a>iOS系统安全机制</h1><p><code>image list -o -f</code>打印出iOS中二进制文件，库文件，动态链接文件，栈和堆内存地址的位置全部都是随机的。</p><h1 id="iOS越狱"><a href="#iOS越狱" class="headerlink" title="iOS越狱"></a>iOS越狱</h1><p>通过一系列iOS系统的漏洞，对系统安全权限进行破解，获取系统Root的权限。<br>引导式越狱，不完美越狱，完美越狱。</p><h2 id="越狱环境的配置"><a href="#越狱环境的配置" class="headerlink" title="越狱环境的配置"></a>越狱环境的配置</h2><h1 id="iOS底层的知识储备"><a href="#iOS底层的知识储备" class="headerlink" title="iOS底层的知识储备"></a>iOS底层的知识储备</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h2 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h2><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h2 id="UI控件的背后代码执行"><a href="#UI控件的背后代码执行" class="headerlink" title="UI控件的背后代码执行"></a>UI控件的背后代码执行</h2><h2 id="整个APP的结构以及构建的过程"><a href="#整个APP的结构以及构建的过程" class="headerlink" title="整个APP的结构以及构建的过程"></a>整个APP的结构以及构建的过程</h2><h3 id="手动打包APP模拟Xcode自动打包的过程"><a href="#手动打包APP模拟Xcode自动打包的过程" class="headerlink" title="手动打包APP模拟Xcode自动打包的过程"></a>手动打包APP模拟Xcode自动打包的过程</h3><h1 id="Hook的原理"><a href="#Hook的原理" class="headerlink" title="Hook的原理"></a>Hook的原理</h1><h2 id="Hook的几种方式"><a href="#Hook的几种方式" class="headerlink" title="Hook的几种方式"></a>Hook的几种方式</h2><h3 id="1-Method-Swizzle—OC"><a href="#1-Method-Swizzle—OC" class="headerlink" title="1.Method Swizzle—OC"></a>1.Method Swizzle—OC</h3><p>通过OC的Runtime机制，改变函数的地址来交换方法实现</p><h3 id="2-fishHook—–C"><a href="#2-fishHook—–C" class="headerlink" title="2.fishHook—–C"></a>2.fishHook—–C</h3><p>通过修改懒加载和非懒加载的表，通过修改表的指针来达到Hook的效果，作用于C函数</p><h3 id="3-Cydia-Substrate（框架）"><a href="#3-Cydia-Substrate（框架）" class="headerlink" title="3.Cydia Substrate（框架）"></a>3.Cydia Substrate（框架）</h3><p>针对OC，C函数，或者是函数地址来做Hook操作</p><h1 id="Theos"><a href="#Theos" class="headerlink" title="Theos"></a>Theos</h1><p><a href="http://codershmily.github.io/2017/04/03/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8BTheos/" target="_blank" rel="noopener">iOS逆向之Theos基础到实战</a></p><h1 id="iOSOpenDev"><a href="#iOSOpenDev" class="headerlink" title="iOSOpenDev"></a>iOSOpenDev</h1><p>基于Xcode创建模板和编译打包<br><a href="http://iosopendev.com/download/" target="_blank" rel="noopener">http://iosopendev.com/download/</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一条命令完成砸壳<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/" target="_blank" rel="noopener">http://www.alonemonkey.com/2018/01/30/frida-ios-dump/</a><br>书籍：&lt;iOS逆向&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从现有APP实现细节的过程.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode10遇到的问题</title>
    <link href="http://peilinghui.com/2018/11/03/%E5%8D%87%E7%BA%A7Xcode10%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2018/11/03/升级Xcode10遇到的问题/</id>
    <published>2018-11-03T07:59:27.000Z</published>
    <updated>2019-08-21T03:46:11.287Z</updated>
    
    <content type="html"><![CDATA[<p>升级Xcode10遇到的问题以及最近解决的问题。</p><a id="more"></a><p>项目升级到Xcode10 以后报错：</p><h3 id="React-Native-‘config-h’-file-not-found"><a href="#React-Native-‘config-h’-file-not-found" class="headerlink" title="React-Native ‘config.h’ file not found"></a>React-Native ‘config.h’ file not found</h3><p>解决方法：</p><p>cd node_modules/react-native/third-party/glog-0.3.4<br>../../scripts/ios-configure-glog.sh</p><h3 id="Xcode-10-libfishhook-a-cannot-be-found"><a href="#Xcode-10-libfishhook-a-cannot-be-found" class="headerlink" title="Xcode 10 libfishhook.a cannot be found"></a>Xcode 10 libfishhook.a cannot be found</h3><p>解决方法：</p><p>在LIbrary下面的RCTWebSocket中的Target中的Build Phases中的Link Binary With Libraries 中的libfishhook.a文件删了重新导入就好了。</p><h3 id="Multiple-commands-produce"><a href="#Multiple-commands-produce" class="headerlink" title="Multiple commands produce"></a>Multiple commands produce</h3><p>Showing Recent Messages</p><p>2) Target ‘YAORecordProject’ (project ‘YAORecordProject’) has process command with output ‘/Users/peilinghui/Library/Developer/Xcode/DerivedData/YAORecordProject-frlkqcmjttdqtdandttwzrmfhjnt/Build/Products/Debug-iphonesimulator/YAORecordProject.app/Info.plist’</p><p>解决方法：</p><p>This issue might occur just because of multiple Plist/other files within App-<br>Solution -&gt; Open target -&gt; Build phases &gt; Copy Bundle Resources and remove info.plist from there.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级Xcode10遇到的问题以及最近解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://peilinghui.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>RN与iOS的混合开发</title>
    <link href="http://peilinghui.com/2018/10/29/RN%E4%B8%8EiOS%E7%9A%84%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://peilinghui.com/2018/10/29/RN与iOS的混合开发/</id>
    <published>2018-10-29T09:16:37.000Z</published>
    <updated>2018-10-29T10:00:52.152Z</updated>
    
    <content type="html"><![CDATA[<p>以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。</p><a id="more"></a><h2 id="纯RN的APP"><a href="#纯RN的APP" class="headerlink" title="纯RN的APP"></a>纯RN的APP</h2><p>就是通过React-Native init一个项目以后，代码写好以后把代码打包成bundle文件，然后导入到Xcode里面然后打包成ipa来发布，其中在APPdelegate里面是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSURL</span> *jsCodeLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index.ios" fallbackResource:nil];</span></span><br><span class="line">  jsCodeLocation = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"main"</span> withExtension:<span class="string">@"jsbundle"</span>];</span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                      moduleName:<span class="string">@"CompassRN"</span></span><br><span class="line">                                               initialProperties:<span class="literal">nil</span></span><br><span class="line">                                                   launchOptions:launchOptions];</span><br><span class="line">  rootView.backgroundColor = [[<span class="built_in">UIColor</span> alloc] initWithRed:<span class="number">1.0</span>f green:<span class="number">1.0</span>f blue:<span class="number">1.0</span>f alpha:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最重要的连接就是RCTRootView，的方法加载bundle文件，参数initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。</p><p>具体解析请看：<a href="https://www.jianshu.com/p/9d7dbf17daa5" target="_blank" rel="noopener">https://www.jianshu.com/p/9d7dbf17daa5</a><br>RCTBridge桥接，moduleName是CompassRN，同样在RN中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CompassRN <span class="keyword">from</span> <span class="string">'./component/Appmain'</span>;</span><br><span class="line">AppRegistry.registerComponent(<span class="string">'CompassRN'</span>, <span class="function"><span class="params">()</span> =&gt;</span> CompassRN);</span><br></pre></td></tr></table></figure><p>在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。</p><h2 id="RN和iOS混合开发"><a href="#RN和iOS混合开发" class="headerlink" title="RN和iOS混合开发"></a>RN和iOS混合开发</h2><p>需要在iOS工程中：</p><p>iOS是如何下载bundle文件，并且保证bundle文件的安全？</p><ol><li><p>TYRCTPanelViewController 的viewDidLoad中加载面板 loadDevicePanel,<br>通过TYPanelService来下载面板，<br>如果是debug模式的话，加载路径是：</p><pre><code>panelPath = [NSString stringWithFormat:@&quot;http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true&amp;gwId=%@&quot;,ip, self.devId];其中IP是本机电脑的IP，</code></pre></li></ol><p>否则release模式的话：  [self loadWebView:panelPath]通过panelPath的网络请求路径来加载面板</p><p>_rootView = [[RCTRootView alloc] initWithBundleURL:[NSURL URLWithString:panelPath] moduleName:@”TYRCTApp” initialProperties:@{@”devInfo”:devInfo} launchOptions:nil];<br>_rootView.frame = self.view.bounds;<br>如果设备变更，数据，网络，蓝牙等变化的话，通过<br>[self.rootView.bridge.eventDispatcher sendAppEventWithName:@”networkStateChange”<br>                        body:@{@”state”:[NSNumber numberWithBool:state]}];<br>来通知rootView</p><ol start="2"><li><p>列表中用 TYPanelViewControllerFactory来处理具体进入到哪个面板。 isEnableDebug模式下进入 TYCommonPanelViewController,</p></li><li><p>TYPanelService.拉取面板主要是 TYPanelService 这个方法， 使用NSURLSessionDownload来下载面板，<br>如果沙盒 TPSandBox里面通过 NSFileManager来管理，如果里面存在有面板，直接加载，<br>不存在的话就去下载main.jsbundle（通过 RunLoop里面的这个方法cancelPreviousPerformRequestsWithTarget可以取消先前的请求任务）<br>下载以后的面板通过JSON解析以后放到 TYUIPanel（Model）中，删除先前的tar.gz压缩包，取消先前的任务，</p></li></ol><p>3.对于每一个panel文件，Model对象里面有 uiId， version， content， fileMd5，<br>其中 fileMd5来保证包的安全性，包解析用的工具是 TPEncryptUtils，先把 tarPath的文件转化成NSData，然后通过 DCTar来解压文件，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在APP中IM使用融云</title>
    <link href="http://peilinghui.com/2018/09/21/%E5%9C%A8APP%E4%B8%ADIM%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91/"/>
    <id>http://peilinghui.com/2018/09/21/在APP中IM使用融云/</id>
    <published>2018-09-21T04:43:28.000Z</published>
    <updated>2018-09-29T09:21:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。<br><a id="more"></a></p><p>首先可以参照官网：<a href="https://www.rongcloud.cn/docs/ios.html#prepare" target="_blank" rel="noopener">https://www.rongcloud.cn/docs/ios.html#prepare</a>来进行基本的融云包的导入和集成到工程中。<br>通过在控制台中API的调用<a href="https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=" target="_blank" rel="noopener">https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=</a>来模拟接口调用的过程。<br>集成融云，就是能用好他所提供的API，就能完成大部分的工作，用好IMKit和IMLib。IMKit主要就是页面，可以在它的基础上进行我们自己页面的自定义，IMLib就是通讯的API，通过使用它暴露的方法来实现及时通讯，单聊，群聊，以及自定义消息的发送。</p><h1 id="导入融云，连接融云"><a href="#导入融云，连接融云" class="headerlink" title="导入融云，连接融云"></a>导入融云，连接融云</h1><p>在APPDelegate中注册自定义的消息类型和做消息推送相关的内容。<br>最好是在登录APP的时候，让服务端返回userId和rongcloudToken，获取到Token以后，登录融云的服务器。可以写一个单例的工具类，来处理融云的登录，断开连接，和&lt;RCIMUserInfoDataSource, RCIMReceiveMessageDelegate,RCIMConnectionStatusDelegate&gt;用户数据源的一些方法的实现。</p><h1 id="用户信息和群组信息的数据源"><a href="#用户信息和群组信息的数据源" class="headerlink" title="用户信息和群组信息的数据源"></a>用户信息和群组信息的数据源</h1><p>因为融云已经做好了基本的聊天通讯的功能，我们要做的就是处理用户昵称，头像和群组的一些信息的处理，设置</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置用户信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.userInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群组信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群成员数据源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupMemberDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息需要通过实现RCIMUserInfoDataSource的方法"><a href="#用户信息需要通过实现RCIMUserInfoDataSource的方法" class="headerlink" title="用户信息需要通过实现RCIMUserInfoDataSource的方法"></a>用户信息需要通过实现RCIMUserInfoDataSource的方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getUserInfoWithUserId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">userId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCUserInfo *userInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>我们需要在这个方法里面调用自己的接口来获取用户的相关信息，就是头像和昵称，然后把获取到的数据放到RCUserInfo对象的userId，name，和portraitUri中，也把这个数据存到FMDB数据库中。这样在聊天列表展示聊天cell的时候，可以通过<br><code>RCUserInfo *user = [[RCIM sharedRCIM] getUserInfoCache:model.targetId];</code>这个方法，如果User存在的话，直接赋值，如果不存在的话，再次调用getUserInfoWithUserId这个来获取用户的信息，获取到以后刷新用户信息，并存到数据库中。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">RCIM</span> sharedRCIM] refreshUserInfoCache:user withUserId:user.userId]<span class="comment">; </span></span><br><span class="line">[[<span class="name">JRDataBaseManager</span>  shareInstance]insertUserToDB:userInfo]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="群组信息实现RCIMGroupInfoDataSource方法"><a href="#群组信息实现RCIMGroupInfoDataSource方法" class="headerlink" title="群组信息实现RCIMGroupInfoDataSource方法"></a>群组信息实现RCIMGroupInfoDataSource方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getGroupInfoWithGroupId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">groupId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCGroup *groupInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>融云自带的群组的信息类是RCGroup，只包含groupId，groupName和portraitUri，我们如果需要更多的信息存储，只需要继承自RCGroup,<br>如果我们需要在群组名称中携带很多信息的话，只需要把相关的信息放到一个字典中然后后转化成json字符串赋值给groupName</p><h3 id="群组成员实现"><a href="#群组成员实现" class="headerlink" title="群组成员实现"></a>群组成员实现</h3><p>我们可以写个单例来实现这三个方法。在方法实现中通过调用自己的接口获取到相关的数据，然后调用融云的接口refreshGroupInfoCache存储起来。</p><h1 id="消息列表"><a href="#消息列表" class="headerlink" title="消息列表"></a>消息列表</h1><p>消息列表需要继承自RCConversationListViewController，只要继承了这个，然后通过其暴露的属性和方法来设置基本列表的样式，当有消息的时候就能展示出来融云自带的聊天cell。如果我们要自定义的消息列表的cell。主要实现的方法：</p><h3 id="重写方法：插入自定义会话model"><a href="#重写方法：插入自定义会话model" class="headerlink" title="重写方法：插入自定义会话model"></a>重写方法：插入自定义会话model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSMutableArray</span> *)willReloadTableData:(<span class="built_in">NSMutableArray</span> *)dataSource&#123;</span><br><span class="line"> [dataSource enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        RCConversationModel *model = (RCConversationModel *)obj;</span><br><span class="line">        <span class="comment">//筛选请求添加好友的系统消息，用于生成自定义会话类型的cell</span></span><br><span class="line">       <span class="keyword">if</span> (model.conversationType == ConversationType_GROUP) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (model.conversationType == ConversationType_PRIVATE) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">     <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在该方法内筛选数据源dataSource中具体的会话类型及消息的model，将model 类型必须修改为 model.conversationModelType=RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION</p><p>如果需要插入类似微博消息列表中的点赞、评论，关注和系统消息的自定义cell，需要在这个方法中自定义Model，并且拼接到DataSource中。</p><p>代码如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_isShowServiceSystem == <span class="keyword">NO</span>) &#123;</span><br><span class="line">        RCConversationModel *<span class="keyword">model</span> = [[RCConversationModel alloc] init];</span><br><span class="line">        <span class="keyword">model</span>.targetId = JR_Service_System_ID;</span><br><span class="line">        <span class="keyword">model</span>.conversationType = ConversationType_SYSTEM;</span><br><span class="line">        <span class="keyword">model</span>.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        [dataSource addObject:<span class="keyword">model</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重写返回-cell-高度的方法"><a href="#重写返回-cell-高度的方法" class="headerlink" title="重写返回 cell 高度的方法"></a>重写返回 cell 高度的方法</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGFloat)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView heightForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath;</span><br></pre></td></tr></table></figure><p>如果需要显示不同高度测自定义的cell，只需要在这个方法中，根据判断的类型返回高度值。</p><h3 id="自定义会话Cell显示时的回调"><a href="#自定义会话Cell显示时的回调" class="headerlink" title="自定义会话Cell显示时的回调"></a>自定义会话Cell显示时的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(RCConversationBaseCell *)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView cellForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>或者是即将显示cell的时候把用户信息和群组信息放到cell里面</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>willDisplayConversationTableCell:<span class="params">(RCConversationBaseCell *)</span>cell atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>如果使用的都是自定义的cell的话，要设置在model.conversationModelType == RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION)先区分数据模型是自定义的，再区分是单聊还是群聊conversationType。对于每一种会话类型，自定义我们需要的cell的样式，然后通过取出对应index的Model。<br>  <code>RCConversationModel *model = self.conversationListDataSource[indexPath.row];</code><br>来把Model中的头像、昵称、最近消息、时间、未读数、一些信息放到cell对应的位置。</p><h3 id="点击事件-–点击cell的回调"><a href="#点击事件-–点击cell的回调" class="headerlink" title="点击事件 –点击cell的回调"></a>点击事件 –点击cell的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>onSelectedTableRow:<span class="params">(RCConversationModelType)</span>conversationModelType</span><br><span class="line">         conversationModel:<span class="params">(RCConversationModel *)</span>model</span><br><span class="line">               atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>在点击事件中，根据你自定义cell类型的不同，跳转到不同的页面，如果是单聊，群聊跳转到聊天会话页面，如果是系统消息：评论回复、点赞、关注、系统消息，跳转到自己写的页面，融云提供了这种系统消息的通知的接口，我们可以通过它的接口就可以实现通知的推送，不需要接入第三方极光等来进行推送。只需要把这些通知调用发送接口，作为消息发送给用户。</p><p>例如：评论和回复页面：继承自RCConversationViewController，隐藏下面的输入栏<code>self.chatSessionInputBarControl.hidden = YES;</code><br>注册自定义的消息和数据模型：<code>[self registerClass:[JRServiceCommentCell class] forMessageClass:[JRServiceCommentModel class]];</code><br>通过接收到通知以后，在会话页面插入一条消息并展示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在会话页面中插入一条消息并展示</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(updateForSharedMessageInsertSuccess:)</span><br><span class="line">                                                 name:<span class="string">@"RCDSharedMessageInsertSuccess"</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">                                               </span><br><span class="line">-(<span class="keyword">void</span>)updateForSharedMessageInsertSuccess:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    RCMessage *message = notification.object;</span><br><span class="line">    <span class="keyword">if</span> (message.conversationType == <span class="keyword">self</span>.conversationType &amp;&amp; [message.targetId isEqualToString:<span class="keyword">self</span>.targetId]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> appendAndDisplayMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论和回复的cell继承自RCMessageBaseCell。可以自己写这个cell的样式。再说一下这个cell的数据源，也是自己自定义的CommentModel继承自RCMessageContent，就和自定义消息类型一样的，需要把消息内容编码成JSON，然后将JSON解码成消息内容，定义消息的类型名（与融云消息不要名字一样），类似我们平时用网络请求后的JSON数据解析，把NSData的data消息解码成字典，<code>NSDictionary *dictionary = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error];</code>然后把字典中的dictionary[@”content”]取出来，判断是字典还是字符串类型，如果是字典的话就用YYModel解析到一个Model中来使用。如果是字符串的话就用方法把JSON字符串转化为字典，</p><h1 id="消息会话"><a href="#消息会话" class="headerlink" title="消息会话"></a>消息会话</h1><h1 id="消息会话展示"><a href="#消息会话展示" class="headerlink" title="消息会话展示"></a>消息会话展示</h1><ol><li>单聊不显示对方名称：RCMessageModel的model.isDisplayNickname来设置<br>2.群聊显示身份的名称：获取到群成员数组以后，遍历数组，把身份和成员的昵称存到RCUserInfo的name中，并保存到SDK中，再把  [self.conversationMessageCollectionView reloadData];</li></ol><p>重要的方法:<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sendMessage:<span class="params">(RCMessageContent *)</span>messageContent pushContent:<span class="params">(NSString *)</span>pushContent;</span><br></pre></td></tr></table></figure></p><p>在发送自定义消息和通知的时候使用，当我在发送一个邀请好友进入聊天室的自定义cell的时候，使用</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JRInviteMessage *inviteMsg = [JRInviteMessage messageWithGroupId:<span class="literal">self</span>.<span class="keyword">group</span>Id</span><br><span class="line">                                                             WithGroupHeader:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img).length==<span class="number">0</span>?  <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>ImgAll :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img</span><br><span class="line">                                                               WithGroupName:[<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name containsString:@<span class="string">"、"</span>] ? <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>NameAll : <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name</span><br><span class="line">                                                            WithGroupProflie:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct).length==<span class="number">0</span>?  @<span class="string">"暂无简介"</span> :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct];</span><br><span class="line">           </span><br><span class="line">[[RCIM sharedRCIM]sendMessage:ConversationType_PRIVATE</span><br><span class="line">                                 targetId:selectArray[j]</span><br><span class="line">                                  content:inviteMsg</span><br><span class="line">                              pushContent:nil</span><br><span class="line">                                 pushData:nil</span><br><span class="line">                                  success:^(long messageId) &#123;&#125;</span><br><span class="line">                                    error:^(RCErrorCode nErrorCode, long messageId)&#123;&#125;]</span><br></pre></td></tr></table></figure><p>对于文字，图片和自定义的消息的cell都可以重写，文字继承自RCTextMessageCell，语音继承自RCVoiceMessageCell，图片继承自RCImageMessageCell，其他自定义邀请好友进入群聊的cell继承自RCMessageCell或者是它的父类RCMessageBaseCell，在方法中实现<br><code>- (void)setDataModel:(RCMessageModel *)model</code>来设置自己想要的属性的样式.</p><h3 id="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"><a href="#进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库" class="headerlink" title="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"></a>进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库</h3><p>这样做的目的就是：用户换了头像或者是昵称以后，在会话页面可以更新用户的数据，</p><h3 id="自定义Cell的点击"><a href="#自定义Cell的点击" class="headerlink" title="自定义Cell的点击"></a>自定义Cell的点击</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>didTapMessageCell:<span class="params">(RCMessageModel *)</span>model</span><br></pre></td></tr></table></figure><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><p>就像上面的会话列表里面的评论和回复一样，只要在这个的地方，调用自己服务端在融云基础上开发的接口，就能把Model传过去，把需要发送的数据放在一个字典里面，然后jsonStringWithObject把字典转换成JSON字符串</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>1.修改聊天气泡以及一些图标<br>直接把要替换的图片替换RongCloud.bundle文件中的图片即可。</p><p>2.当融云SDK和BlocksKit被引入到同一工程，通过融云的聊天UI界面去选择照片、拍摄照片并发送时，无法正常选择和发送。<br>问题的本质：</p><p>UIImagePickerController代理中的方法冲突了，导致融云SDK中选择并发送照片的功能失效。</p><p>解决方法：</p><p>BlocksKit是开源方法，直接编辑UIImagePickerController+BlocksKit.m文件，注释红框部分，问题便可解决。<img src="http://rongcloud-web.qiniudn.com/39ef2374b74fb20691d28a5b6b9824d1" alt></p><p>3.//点击消息发送失败红点的回调<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">didTapmessageFailedStatusViewForResend:(RCMessageModel </span>*)model&#123;</span><br><span class="line">     RCMessageContent *resendContent = (RCMessageContent *)model.content<span class="comment">;</span></span><br><span class="line">    AlertShowMoreButtons(@[@<span class="string">"重新发送"</span>], ^(NSString *title, NSInteger moreButtonIndex) &#123;</span><br><span class="line">        if (<span class="keyword">BoolEqualToString(title, </span>@<span class="string">"重新发送"</span>)) &#123;</span><br><span class="line">            [self resendMessage:resendContent]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>独立开发一个APP</title>
    <link href="http://peilinghui.com/2018/08/04/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAPP/"/>
    <id>http://peilinghui.com/2018/08/04/独立开发一个APP/</id>
    <published>2018-08-04T07:22:24.000Z</published>
    <updated>2018-10-11T04:02:17.141Z</updated>
    
    <content type="html"><![CDATA[<p>独立开发一个社群APP，类似微博，知识星球，简书这一类的。</p><a id="more"></a><p>首先是整个项目的框架的搭建。</p><h1 id="中间层的路由跳转方案"><a href="#中间层的路由跳转方案" class="headerlink" title="中间层的路由跳转方案"></a>中间层的路由跳转方案</h1><p>抽象出一个中间层来对纷乱的引用关系进行统一的跳转。模块只和中间层耦合，模块间解耦；中间层使用runtime的形式调用模块的业务组件，不依赖具体的模块代码.两种主流方案:</p><ol><li>以<a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="noopener">JLRoutes</a>为代表的URLRoute方案:以URL为key，以待执行的block为value，保存在一个全局map中，在内存中常驻;</li><li>Mediator中间人方案:把所有的调用都集合在一起，使用一个中间人管理。所有调用方都通过中间人调取另外一个模块;</li></ol><ul><li>创建Target-Action。Target对象暴露整个模块对外提供的所有服务，此外，因为Mediator和Target是通过Runtime交互的，Target暴露的方法中接收的参数是一个字典，但在方法实现中负责将传过来的字典还原成各个参数，并调用该模块具体的类和方法。</li><li>创建 CTMediator 的Category. 受限于runtime只能以字典形式传一系列参数，Mediator分类的职责就在于对外提供参数友好型的一系列方法，但在方法实现中包装成字典形式。这里涉及到key的定义必须和Target中还原时的key定义一致，因此划分给相同的开发维护。<br><a href="https://github.com/yehot/YT_TargetAction" target="_blank" rel="noopener">使用方法</a></li></ul><ol start="3"><li><a href="https://github.com/xuzhenhao/ZHMediator" target="_blank" rel="noopener">结合URLRoute和Mediator的跳转方案</a></li></ol><h1 id="整体导航条Navigation"><a href="#整体导航条Navigation" class="headerlink" title="整体导航条Navigation"></a>整体导航条Navigation</h1><p>写自定义的navigationController，主要用于处理问题：</p><ul><li>手势返回的支持和不支持。</li><li>导航栏的显示和隐藏。</li><li>底部tabBar的显示和隐藏。</li></ul><p>在一些页面对于statusBar的处理，设置statusBar的背景颜色和样式</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>在AFN上面封装，包装AFNManager，创建一个单例的HTTPClient继承自AFHTTPSessionManager，在单例中设置securityPolicy、requestSerializer、responseSerializer、和请求头，以及Content-type相关的参数，包装GET、post请求<br>没有判断网络的情况，是WIFI还是4G还是3G，还是无网络的状态</p><h1 id="tableView自适应"><a href="#tableView自适应" class="headerlink" title="tableView自适应"></a>tableView自适应</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>Sunny写的<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a><br>UITableView+FDTemplateLayoutCell</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><a href="https://github.com/peilinghui/SDAutoLayout" target="_blank" rel="noopener">SDAutoLayout</a><br>不仅可以实现tableview和cell高度自适应，还可以实现普通view的自动布局，比用masonry代码更少，</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>在每个元素的模型model中添加一个height属性，实现它的get方法，在get方法中计算需要多行显示文字的高度，然后再加上其他乱七八糟的高度并返回，然后在tableview的 </p><ul><li>(CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath中获取到每行对应的model，取出其中的model.height属性的值返回，还要在cell中确定cell中label的高度。。。总之就是很麻烦，而且还不一定总能算的很正确，甚是受此困扰。</li></ul><p>只要你懂一定的Autolayout知识的话，原来实现这种的cell高度自适应，其实是灰常灰常简单的：<br>首先，第一步，现在自定义的cell中将高度随着内容动态改变的label的布局使用autolayout布局完成，这里有个注意点就是label和cell边界的距离要确定好，不能固定死label的高度，然后设置label的numberOfLines=0，行数设置为0即意味着label可以有任意行。<br>其次，实现以下两个tableview的delegate中的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，只要实现这两个方法，然后运行你的项目，你会惊讶的发现，哇塞，高度完美自适应…<br>这里有几个关键点：<br>关键点1：必须重写estimatedHeightForRowAtIndexPath方法<br>这个方法是iOS7.0之后才出现的，如果不重写此方法，仅重写heightForRowAtIndexPath，那么大家会发现，cell并不会根据label的内容，自适应高度。因为系统是先获取cell的高度，再获取cell的view。也就是先调用heightForRowAtIndexPath，再调用cellForRowAtIndexPath。在cellForRowAtIndexPath被调用之前，你的label是没有被设置文本内容的，因此它获取到的高度，并不是你想要的。那么我们必须想办法让系统在获取了cell之后，再获取cell的高度。方法就是，重写estimatedHeightForRowAtIndexPath，顾名思义，它会返回一个估计高度，有了这个方法后，tableview会先调用它获取估计高度，然后获取cell，最后获取真实高度。estimatedHeightForRowAtIndexPath的返回值可以随意，返回多少都可以，只是给tableview一个安慰而已，让它延迟获取真实的高度。<br>关键点2：真实高度返回值为<br>UITableViewAutomaticDimension<br>关键点3：cell中的元素，必须相对于cell的顶部和底部布局，这样在元素中的内容动态变化的时候，才能撑开cell</p><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>ASDK：AsyncDisplayKit.相关连接：<br><a href="https://draveness.me/asdk-rendering" target="_blank" rel="noopener">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></p><p><a href="https://www.cnblogs.com/ludashi/p/5895725.html" target="_blank" rel="noopener">iOS开发之多种Cell高度自适应实现方案的UI流畅度分析</a></p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><p>YYKit的</p><h1 id="整体的方法"><a href="#整体的方法" class="headerlink" title="整体的方法"></a>整体的方法</h1><p>页面布局：masonry自动布局<br>页面的网络解析：YYModel<br>页面的网络请求：</p><p>各个模块需要注意的问题：</p><h1 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h1><p>第一次登录和再次登录</p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>图片压缩</p><h1 id="弹框处理"><a href="#弹框处理" class="headerlink" title="弹框处理"></a>弹框处理</h1><h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h1 id="下拉刷新和上拉加载更多"><a href="#下拉刷新和上拉加载更多" class="headerlink" title="下拉刷新和上拉加载更多"></a>下拉刷新和上拉加载更多</h1><h1 id="第三方登录和第三方分享"><a href="#第三方登录和第三方分享" class="headerlink" title="第三方登录和第三方分享"></a>第三方登录和第三方分享</h1><p>第三方分享：</p><ol><li>申请微信APPKey和申请友盟APPkey</li><li>cocospod:    pod ‘UMengUShare/Social/WeChat’</li><li>在APPdelegate中设置APPkey</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAppkey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//友盟</span></span><br><span class="line">    [WXApi <span class="string">registerApp:</span>WXAPPID];</span><br><span class="line">    <span class="comment">//设置友盟appkey</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setUmSocialAppkey:</span>UMKey];</span><br><span class="line">    <span class="comment">//分享到微信</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setPlaform:</span>UMSocialPlatformType_WechatSession <span class="string">appKey:</span>APPKEY <span class="string">appSecret:</span>APPSECRET <span class="string">redirectURL:</span>@<span class="string">"www.com"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)<span class="string">application:</span>(UIApplication *)application <span class="string">openURL:</span>(NSURL *)url <span class="string">sourceApplication:</span>(NSString *)sourceApplication <span class="string">annotation:</span>(id)annotation</span><br><span class="line">&#123;</span><br><span class="line">    BOOL result = [UMSocialSnsService <span class="string">handleOpenURL:</span>url];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置Plis跳转的URL。URL Schemes列为白名单</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>LSApplicationQueriesSchemes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>weixin<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>创建分享信息</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建分享消息对象</span></span><br><span class="line"> UMSocialMessageObject *messageObject = [UMSocialMessageObject messageObject];</span><br><span class="line"><span class="built_in">NSString</span> *title = <span class="keyword">self</span>.shareTitle;</span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="keyword">self</span>.originUrl;</span><br><span class="line"><span class="built_in">NSString</span> *text = <span class="keyword">self</span>.shareText;</span><br><span class="line"><span class="built_in">NSString</span> *imgUrl = <span class="keyword">self</span>.shareImage;</span><br><span class="line">UMShareWebpageObject *shareObject = [UMShareWebpageObject shareObjectWithTitle:title descr:text thumImage:imgUrl];</span><br><span class="line">[shareObject setWebpageUrl:url];</span><br><span class="line">messageObject.shareObject = shareObject;</span><br><span class="line">[[UMSocialManager defaultManager] shareToPlatform:UMSocialPlatformType_WechatSession</span><br><span class="line">           messageObject:messageObject</span><br><span class="line">currentViewController:<span class="literal">nil</span></span><br><span class="line">completion:^(<span class="keyword">id</span> data, <span class="built_in">NSError</span> *error) &#123;    </span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">UMSocialLogInfo(<span class="string">@"************Share fail with error %@*********"</span>,error);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;         </span><br><span class="line"><span class="keyword">if</span> ([data isKindOfClass:[UMSocialShareResponse <span class="keyword">class</span>]]) &#123;          </span><br><span class="line">  UMSocialShareResponse *resp = data; UMSocialLogInfo(<span class="string">@"response message is %@"</span>,resp.message);   UMSocialLogInfo(<span class="string">@"response originalResponse data is %@"</span>,resp.originalResponse);&#125;<span class="keyword">else</span>&#123; UMSocialLogInfo(<span class="string">@"response data is %@"</span>,data); &#125;&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="系统问题"><a href="#系统问题" class="headerlink" title="系统问题"></a>系统问题</h1><p>启动图</p><p>横屏</p><p>推送</p><p>3Dtouch</p><p>屏幕适配</p><h1 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h1><p>1。手动打包</p><p>2。自动化打包</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>tableView的流畅：没有网络请求结束的时候先加载占位图，然后<br><a href="https://www.jianshu.com/p/d1e6ae279dd2" target="_blank" rel="noopener">UITableView的优化策略</a><br><a href="https://didee.cn/2018/01/29/iOS-ASDK/" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a><br>UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定 contentSize及Cell的位置,然后才会调用tableView:cellForRowAtIndexPath:,从而来显示在 当前屏幕的Cell。</li></ol><p>UITableView的滚动优化主要在于以下两个方面：</p><p>减少cellForRowAtIndexPath代理中的计算量（cell的内容计算）<br>减少heightForRowAtIndexPath代理中的计算量（cell的高度计算）</p><h3 id="减少cellForRowAtIndexPath代理中的计算量"><a href="#减少cellForRowAtIndexPath代理中的计算量" class="headerlink" title="减少cellForRowAtIndexPath代理中的计算量"></a>减少cellForRowAtIndexPath代理中的计算量</h3><p>首先要提前计算每个cell中需要的一些基本数据，代理调用的时候直接取出；<br>图片要异步加载，加载完成后再根据cell内部UIImageView的引用设置图片；<br>图片数量多时，图片的尺寸要跟据需要提前经过transform矩阵变换压缩好（直接设置图片的contentMode让其自行压缩仍然会影响滚动效率），必要的时候要准备好预览图和高清图，需要时再加载高清图。<br>图片的‘懒加载’方法，即延迟加载，当滚动速度很快时避免频繁请求服务器数据。<br>尽量手动Drawing视图提升流畅性，而不是直接子类化UITableViewCell，然后覆盖drawRect方法，因为cell中不是只有一个contentview。绘制cell不建议使用UIView，建议使用CALayer。原因要参考UIView和CALayer的区别和联系。</p><h3 id="减少heightForRowAtIndexPath代理中的计算量"><a href="#减少heightForRowAtIndexPath代理中的计算量" class="headerlink" title="减少heightForRowAtIndexPath代理中的计算量"></a>减少heightForRowAtIndexPath代理中的计算量</h3><p>由于每次TableView进行update更新都会对每一个cell调用heightForRowAtIndexPath代理取得最新的height，会大大增加计算时间。如果表格的所有cell高度都是固定的，那么去掉heightForRowAtIndexPath代理，直接设置TableView的rowHeight属性为固定的高度；<br>如果高度不固定，应尽量将cell的高度数据计算好并储存起来，代理调用的时候直接取，即将height的计算时间复杂度降到O(1)。例如：在异步请求服务器数据时，提前将cell高度计算好并作为dataSource的一个数据存到数据库供随时取用。</p><h1 id="数据刷新"><a href="#数据刷新" class="headerlink" title="数据刷新"></a>数据刷新</h1><h2 id="tableView的数据刷新"><a href="#tableView的数据刷新" class="headerlink" title="tableView的数据刷新"></a>tableView的数据刷新</h2><p>那就在每个元素的model里面加上一个高度字段，显示的时候如果高度非0，直接拿过来使用，如果是0就自适应计算一下</p><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p><h1 id="把模块拆分成Pod"><a href="#把模块拆分成Pod" class="headerlink" title="把模块拆分成Pod"></a>把模块拆分成Pod</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="UIScrollView的左右滑动与侧滑返回并存"><a href="#UIScrollView的左右滑动与侧滑返回并存" class="headerlink" title="UIScrollView的左右滑动与侧滑返回并存"></a>UIScrollView的左右滑动与侧滑返回并存</h2><p>侧滑返回效果的触发需要满足：(1) 滑动位置在屏幕左边缘;（2）向右滑动;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 侧滑返回和控件手势冲突的解决方法</span></span><br><span class="line"><span class="comment">//是否支持多手势触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥.</span></span><br><span class="line"><span class="comment">//是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播</span></span><br><span class="line"><span class="comment">//一句话总结就是此方法返回YES时，手势事件会一直往下传递，不论当前层次是否对该事件进行响应。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//location_X可自己定义,其代表的是滑动返回距左边的有效长度</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)panBack:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是滑动返回距左边的有效长度</span></span><br><span class="line">    <span class="keyword">int</span> location_X =<span class="number">0.15</span>*IPHONE_W;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gestureRecognizer ==<span class="keyword">self</span>.panGestureRecognizer) &#123;</span><br><span class="line">        <span class="built_in">UIPanGestureRecognizer</span> *pan = (<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer;</span><br><span class="line">        <span class="built_in">CGPoint</span> point = [pan translationInView:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">UIGestureRecognizerState</span> state = gestureRecognizer.state;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIGestureRecognizerStateBegan</span> == state ||<span class="built_in">UIGestureRecognizerStatePossible</span> == state) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> location = [gestureRecognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这是允许每张图片都可实现滑动返回</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = location.x;</span><br><span class="line">            <span class="keyword">int</span> temp2 =IPHONE_W;</span><br><span class="line">            <span class="built_in">NSInteger</span> XX = temp1 % temp2;</span><br><span class="line">            <span class="keyword">if</span> (point.x &gt;<span class="number">0</span> &amp;&amp; XX &lt; location_X) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取系统的UIPanGestureRecognizer的<br>(3) 侧滑手势优先，侧滑手势失效时，才触发UISrcollView的滑动</p><p><a href="https://www.jianshu.com/p/8170fea174da" target="_blank" rel="noopener">https://www.jianshu.com/p/8170fea174da</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;独立开发一个社群APP，类似微博，知识星球，简书这一类的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS底层实现</title>
    <link href="http://peilinghui.com/2018/06/25/iOS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://peilinghui.com/2018/06/25/iOS底层实现/</id>
    <published>2018-06-25T07:07:36.000Z</published>
    <updated>2018-10-14T06:49:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>源于一个面试题。</p><a id="more"></a><p><img src="https://wx3.sinaimg.cn/mw690/51530583ly1fsatleo2zmj213u10caiu.jpg" alt><br>我们知道在Runtime中的swizzling:通过selector来找IMP，可以利用Runtime来实现交换原方法和目标方法的IMP，以完全代替原方法的实现，或为原实现前后相当于加一段额外的代码。</p><p>就是在分类的load方法中，通过class_getClassMethodclass_getInstanceMethod获取类方法和实例方法，然后method_exchangeImplementations(),交换方法实现，或者是其他class_addMethods、class_addIvar、class_addProtocol、class_addProperty来动态的添加方法或者成员变量。还有class_copyIvarList、class_copyMethodList获得某个类所有的成员变量和所有方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span>: <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodA;</span><br><span class="line">+ (<span class="keyword">void</span>)methodB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(methodA));</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(swizzled_methodA));</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_methodA &#123;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span> swizzled_methodA];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AOP的库Aspects 支持多次hook同一个方法，支持从hook返回的id<aspecttoken>对象删除对应的hook，IMP即函数指针。<br>Aspects 的大致原理：替换原方法的IMP为 消息转发函数指针 _objc_msgForward或_objc_msgForward_stret，把原方法IMP添加并对应到SEL aspects_originalSelector，将forwardInvocation:的IMP替换为参数对齐的C函数<strong>ASPECTS_ARE_BEING_CALLED</strong>(NSObject <em>self, SEL selector, NSInvocation </em>invocation)的指针。在<strong>ASPECTS_ARE_BEING_CALLED</strong>函数中，替换invocation的selector为aspects_originalSelector，相当于要发送调用原始方法实现的消息。对于插入位置在前面，替换，后面的多个block，构建新的blockInvocation，从invocation中提取参数，最后通过invokeWithTarget:block来完成依次调用。</aspecttoken></p><h1 id="libffi-简介"><a href="#libffi-简介" class="headerlink" title="libffi 简介"></a>libffi 简介</h1><p>    libffi 可以认为是实现了C语言上的runtime，简单来说，libffi 可根据 参数类型(ffi_type)，参数个数 生成一个 模板(ffi_cif)；可以输入 模板、函数指针 和 参数地址 来直接完成 函数调用(ffi_call)； 模板 也可以生成一个所谓的 闭包(ffi_closure)，并得到指针，当执行到这个地址时，会执行到自定义的void function(ffi_cif <em>cif, void </em>ret, void <strong>args, void <em>userdata)函数，在这里，我们可以获得所有参数的地址(包括返回值)，以及自定义数据userdata。当然，在这个函数里我们可以做一些额外的操作。<br>    <br>    <br>如何hook ObjC方法和实现AOP，思路：我们可以将ffi_closure关联的指针替换原方法的IMP，当对象收到该方法的消息时objc_msgSend(id self, SEL sel, …)，将最终执行自定义函数void ffi_function(ffi_cif </em>cif, void *ret, void </strong>args, void *userdata)。而实现这一切的主要工作是：设计可行的结构，存储类的多个hook信息；根据包含不同参数的方法和切面block，生成包含匹配ffi_type的cif；替换类某个方法的实现为ffi_closure关联的imp，记录hook；在ffi_function里，根据获得的参数，动态调用原始imp和block。</p><h2 id="动态调用C函数"><a href="#动态调用C函数" class="headerlink" title="动态调用C函数"></a>动态调用C函数</h2><p>使用libffi提供接口动态调用流程如下：</p><ol><li>准备好参数数据及其对应ffi_type数组、返回值内存指针、函数指针</li><li>创建与函数特征相匹配的函数原型：ffi_cif对象</li><li>使用“ffi_call”来完成函数调用<br>使用ffi，只要有函数原型cif对象，函数实现指针，返回值内存指针和函数参数数组，我们就可以实现在运行时动态调用任意C函数。</li></ol><p>所以如果想实现其他语言(譬如JS)，执行过程中动态调用C函数，只需在调用过程中加一层转换，将参数及返回值类型转换成libffi对应类型，并封装成函数原型cif对象，准备好参数数据，找到对应函数指针，然后调用即可。</p><h2 id="动态定义C函数"><a href="#动态定义C函数" class="headerlink" title="动态定义C函数"></a>动态定义C函数</h2><p>libffi还有一个特别强大的函数，通过它我们可以将任意参数和返回值类型的函数指针，绑定到一个函数实体上。那么这样我们就可以很方便的实现动态定义一个C函数了！同时这个函数在编写解释器或提供任意函数的包装器(通用block)时非常有用，此函数是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffi_status ffi_prep_closure_loc (ffi_closure *closure,  <span class="comment">//闭包，一个ffi_closure对象</span></span><br><span class="line">       ffi_cif *cif,  <span class="comment">//函数原型</span></span><br><span class="line">       <span class="keyword">void</span> (*fun) (ffi_cif *cif, <span class="keyword">void</span> *ret, <span class="keyword">void</span> **args, <span class="keyword">void</span>*user_data), <span class="comment">//函数实体</span></span><br><span class="line">       <span class="keyword">void</span> *user_data, <span class="comment">//函数上下文，函数实体实参</span></span><br><span class="line">       <span class="keyword">void</span> *codeloc)   <span class="comment">//函数指针，指向函数实体</span></span><br></pre></td></tr></table></figure><p>通过一个简单的例子，看下如何将一个函数指针绑定到一个函数实体上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acts like puts with the file given at time of enclosure. */</span></span><br><span class="line"><span class="comment">// 函数实体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts_binding</span><span class="params">(ffi_cif *cif, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ret, <span class="keyword">void</span>* args[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ret = <span class="built_in">fputs</span>(*(<span class="keyword">char</span> **)args[<span class="number">0</span>], stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ffi_cif cif;</span><br><span class="line">    ffi_type *args[<span class="number">1</span>];</span><br><span class="line">    ffi_closure *closure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*bound_puts)(<span class="keyword">char</span> *);  <span class="comment">//声明一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate closure and bound_puts */</span>  <span class="comment">//创建closure</span></span><br><span class="line">    closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), &amp;bound_puts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closure)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Initialize the argument info vectors */</span></span><br><span class="line">        args[<span class="number">0</span>] = &amp;ffi_type_pointer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Initialize the cif */</span>  <span class="comment">//生成函数原型</span></span><br><span class="line">        <span class="keyword">if</span> (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, <span class="number">1</span>,</span><br><span class="line">                         &amp;ffi_type_uint, args) == FFI_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Initialize the closure, setting stream to stdout */</span></span><br><span class="line">            <span class="comment">// 通过 ffi_closure 把 函数原型_cifPtr / 函数实体JPBlockInterpreter / 上下文对象self / 函数指针blockImp 关联起来</span></span><br><span class="line">            <span class="keyword">if</span> (ffi_prep_closure_loc(closure, &amp;cif, puts_binding,</span><br><span class="line">                                     <span class="built_in">stdout</span>, bound_puts) == FFI_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                rc = bound_puts(<span class="string">"Hello World!"</span>);</span><br><span class="line">                <span class="comment">/* rc now holds the result of the call to fputs */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deallocate both closure, and bound_puts */</span></span><br><span class="line">    ffi_closure_free(closure);   <span class="comment">//释放闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述步骤大致分为：</p><ol><li>准备一个函数实体</li><li>声明一个函数指针</li><li>根据函数参数个数/参数及返回值类型生成一个函数原型</li><li>创建一个ffi_closure对象，并用其将函数原型、函数实体、函数上下文、函数指针关联起来</li><li>释放closure</li></ol><p>通过以上这5步，我们就可以在执行过程中将一个函数指针，绑定到一个函数实体上，从而轻而易举的实现动态定义一个C函数。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.assuner.com/%E5%BC%80%E6%BA%90/2018/01/16/Stinger.html" target="_blank" rel="noopener">Hook方法的新姿势–(使用libffi实现AOP )</a></p><p><a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="noopener">如何动态调用 C 函数</a></p><p><a href="http://blog.cnbang.net/tech/3332/" target="_blank" rel="noopener">如何动态创建 block – JPBlock 扩展原理详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源于一个面试题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
