<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2016-03-05T15:00:01.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中的第三方框架</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的第三方框架/</id>
    <published>2016-03-05T06:08:53.000Z</published>
    <updated>2016-03-05T15:00:01.000Z</updated>
    
    <content type="html">&lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;FMDB&quot;&gt;&lt;a href=&quot;#FMDB&quot; class=&quot;headerlink&quot; title=&quot;FMDB&quot;&gt;&lt;/a&gt;FMDB&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是FMDB：&lt;br&gt;FMDB是iOS平台的SQLite数据库框架；&lt;br&gt;FMDB以OC的方式封装了SQLite的C语言API&lt;/li&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码&lt;/li&gt;
&lt;li&gt;对比苹果自带的Core Data框架，更加轻量级和灵活&lt;/li&gt;
&lt;li&gt;提供了多线程安全的数据库操作方法，有效地防止数据混乱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FMDB的github地址:  &lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ccgus/fmdb&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的数据存储</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的数据存储/</id>
    <published>2016-03-05T05:59:07.000Z</published>
    <updated>2016-03-05T15:01:37.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的数据存储方式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS中的数据存储方式&quot;&gt;&lt;a href=&quot;#iOS中的数据存储方式&quot; class=&quot;headerlink&quot; title=&quot;iOS中的数据存储方式&quot;&gt;&lt;/a&gt;iOS中的数据存储方式&lt;/h1&gt;&lt;h2 id=&quot;Plist（NSArray-NSDictionary）&quot;&gt;&lt;a href=&quot;#Plist（NSArray-NSDictionary）&quot; class=&quot;headerlink&quot; title=&quot;Plist（NSArray\NSDictionary）&quot;&gt;&lt;/a&gt;Plist（NSArray\NSDictionary）&lt;/h2&gt;&lt;p&gt;只能存储数组，字典，但是数组和字典里面不能有自定义对象&lt;/p&gt;
&lt;h2 id=&quot;Preference（偏好设置-NSUserDefaults）&quot;&gt;&lt;a href=&quot;#Preference（偏好设置-NSUserDefaults）&quot; class=&quot;headerlink&quot; title=&quot;Preference（偏好设置\NSUserDefaults）&quot;&gt;&lt;/a&gt;Preference（偏好设置\NSUserDefaults）&lt;/h2&gt;&lt;h2 id=&quot;NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot;&gt;&lt;a href=&quot;#NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot; class=&quot;headerlink&quot; title=&quot;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&quot;&gt;&lt;/a&gt;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&lt;/h2&gt;&lt;p&gt;存储自定义对象，局限：一次性做读取的存储的操作&lt;/p&gt;
&lt;h2 id=&quot;SQLite3&quot;&gt;&lt;a href=&quot;#SQLite3&quot; class=&quot;headerlink&quot; title=&quot;SQLite3&quot;&gt;&lt;/a&gt;SQLite3&lt;/h2&gt;&lt;p&gt;1.什么是SQLite&lt;br&gt;SQLite是一款轻型的嵌入式数据库;它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了;它的处理速度比Mysql、PostgreSQL这两款著名的数据库都还快&lt;/p&gt;
&lt;h2 id=&quot;Core-Data&quot;&gt;&lt;a href=&quot;#Core-Data&quot; class=&quot;headerlink&quot; title=&quot;Core Data&quot;&gt;&lt;/a&gt;Core Data&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是Core Data？&lt;br&gt;Core Data是iOS5以后才出现的一个框架，它提供了对象-关系映射（ORM）关系，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象，不用编写任何SQL语言（类似于Hibernate框架，没有那么强大）&lt;/li&gt;
&lt;li&gt;使用步骤&lt;ul&gt;
&lt;li&gt;创建模型文件，&lt;strong&gt;相当于数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加实体，&lt;strong&gt;相对于表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;创建实体类，&lt;strong&gt;相当于模型类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成&lt;strong&gt;上下文&lt;/strong&gt; 关联模型文件生成数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的数据存储方式&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的多线程网络</title>
    <link href="http://peilinghui.com/2016/03/04/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C/"/>
    <id>http://peilinghui.com/2016/03/04/iOS中的多线程网络/</id>
    <published>2016-03-04T13:31:31.000Z</published>
    <updated>2016-03-06T07:05:59.000Z</updated>
    
    <content type="html">&lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是多线程&lt;br&gt;进程：是指在系统中正在运行的一个应用程序。1个进程要想执行任务，必须得有线程。（一个进程至少要有一个线程）&lt;br&gt;线程：是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。&lt;br&gt;多线程：在一个进程中可以开启多个线程，每条线程可以并发（同时）执行不同的任务。&lt;/li&gt;
&lt;li&gt;iOS中如何实现多线程&lt;ul&gt;
&lt;li&gt;pthread（一套通用的多线程API，使用难度大 &lt;strong&gt;C语言（底层）&lt;/strong&gt;）程序员管理，几乎不用  &lt;code&gt;#include &amp;lt;pthread.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;NSThread（面向对象，简单易用，可直接操作多线程对象,&lt;strong&gt;OC&lt;/strong&gt;），偶尔使用&lt;/li&gt;
&lt;li&gt;GCD（旨在替代NSThread等线程技术，充分利用设备的多核，&lt;strong&gt;C语言&lt;/strong&gt;）自动管理，经常使用&lt;/li&gt;
&lt;li&gt;NSOperation（基于GCD，比GCD多了一些简单实用的功能，&lt;strong&gt;OC&lt;/strong&gt;）自动管理，经常使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间通讯的方法&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89NSOperation%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;利用字典（图片地址为key，下载操作为value）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程安全的几种解决办法及多线程安全怎么控制？&lt;br&gt;线程安全的概念: 就是在多个线程同时执行的时候，能够保证资源信息的准确性.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;苹果约定，&lt;strong&gt;所有程序的更新UI都在主线程进行&lt;/strong&gt;，也就不会出现多个线程同时改变一个资源。在主线程更新UI，有什么好处？只在主线程更新UI，就不会出现多个线程同时改变同一个UI控件;主线程的优先级最高。也就意味UI的更新优先级高。 会让用户感觉很流畅    .&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果要防止资源抢夺，得用synchronized进行加锁保护.&lt;br&gt;线程同步：多条线程按顺序的执行任务（互斥锁）互斥锁使用格式&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&amp;#38656;&amp;#35201;&amp;#38145;&amp;#23450;&amp;#30340;&amp;#20195;&amp;#30721;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果异步操作要保证线程安全等问题, 尽量使用GCD(有些函数默认就是安全的)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD内部怎么实现的&lt;br&gt;1&amp;gt; iOS和OS X的核心是XNU内核，GCD是基于XNU内核实现的&lt;br&gt;2&amp;gt; GCD的API全部在libdispatch库中&lt;br&gt;3&amp;gt; GCD的底层实现主要有Dispatch Queue和Dispatch Source&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dispatch Queue ：管理block(操作)&lt;/li&gt;
&lt;li&gt;Dispatch Source ：处理事件(比如线程间的通讯)&lt;br&gt;补充：GCD：Grand Central Dispatch “牛逼的中枢调度器”，自动利用更多CPU内核，自动管理线程的生命周期（创建线程，调度任务，销毁线程).使用2个步骤：  &lt;/li&gt;
&lt;li&gt;定制任务（执行什么操作）用block来封装任务  &lt;/li&gt;
&lt;li&gt;将任务添加到队列中（自动将队列中的任务取出，放到对应的线程中执行）（先进先出，后进后出）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD和NSoperation区别&lt;br&gt;1&amp;gt;GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装&lt;br&gt;2&amp;gt;GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序、设置最大并发数量&lt;br&gt;3&amp;gt;NSOperationQueue可以在轻松在Operation间设置依赖关系，而GCD需要写很多的代码才能实现&lt;br&gt;4&amp;gt;NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）&lt;br&gt;5&amp;gt;GCD的执行速度比NSOperationQueue快&lt;br&gt;任务之间不太互相依赖：GCD&lt;br&gt;任务之间有依赖(或者要监听任务的执行情况)：NSOperationQueue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Socket的实现原理以及Socket是如何实现通信的？&lt;br&gt;Socket：称之为套接字，是一种用于网络传输的“工具”。&lt;br&gt;socket的实现原理：是基于TCP/UDP的（TCP：传输控制协议，是一种面向连接的，安全的，基于IP传输层的协议，三次握手。例如：XMPP等网络聊天）（UDP：传输控制协议，是一种面向连接的，不安全的，基于IP传输层的协议，特点：快，只管发，不管收到没有。例如：游戏,QQ视频，红蜘蛛）&lt;/li&gt;
&lt;li&gt;http协议的实现&lt;br&gt;HTTP：是一种超文本协议，定义了网络传输的格式（短连接）&lt;br&gt;如果利用HTTP做聊天，每次都要重新创建连接，因为HTTP是短连接，一次回话后就断开了，如果利用HTTP做聊天，如果聊天特别频繁，会不断的创建连接，消耗资源，性能不好，服务端不会主动给客户端发送请求。      &lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="多线程" scheme="http://peilinghui.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocosPods</title>
    <link href="http://peilinghui.com/2016/03/04/CocosPods/"/>
    <id>http://peilinghui.com/2016/03/04/CocosPods/</id>
    <published>2016-03-04T08:54:28.000Z</published>
    <updated>2016-03-04T09:20:16.000Z</updated>
    
    <content type="html">&lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;CocoaPods是什么？&quot;&gt;&lt;a href=&quot;#CocoaPods是什么？&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods是什么？&quot;&gt;&lt;/a&gt;CocoaPods是什么？&lt;/h1&gt;&lt;p&gt;CocoaPods应该是iOS最常用最有名的类库管理工具.开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;a href=&quot;https://blog.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPod&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;Cocoapods原理&quot;&gt;&lt;a href=&quot;#Cocoapods原理&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods原理&quot;&gt;&lt;/a&gt;Cocoapods原理&lt;/h1&gt;&lt;p&gt;Pods项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。&lt;br&gt;对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh的 bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;br&gt;CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;
&lt;h1 id=&quot;安装CocoaPods&quot;&gt;&lt;a href=&quot;#安装CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;安装CocoaPods&quot;&gt;&lt;/a&gt;安装CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要先确保电脑本地是否有 Ruby环境，因为CocoaPods运行于 Ruby之上，默认情况下，Mac 是自带了 Ruby 环境的，可以通过命令行 ruby -v查看当前Ruby的版本。&lt;br&gt;执行命令：&lt;br&gt; &lt;code&gt;$ ruby -v&lt;/code&gt;&lt;br&gt;已经安装了Ruby开发环境，那么在终端（Terminal）中使用以下命令即可直接安装：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ pod setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装过程中可能遇到的问题&lt;br&gt;①执行完install命令半天没反应&lt;br&gt;这有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：&lt;br&gt; &lt;code&gt;$ gem sources --remove https://rubygems.org/&lt;/code&gt;&lt;br&gt;//等有反应之后再敲入以下命令&lt;br&gt; &lt;code&gt;$ gem sources -a http://ruby.taobao.org/&lt;/code&gt;&lt;br&gt;要想验证是否替换成功了，可以执行：&lt;br&gt; &lt;code&gt;$ gem sources -l&lt;/code&gt;&lt;br&gt;正常的输出是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%9B%BE1%EF%BC%88%E9%95%9C%E5%83%8F%EF%BC%89.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;②gem版本过老&lt;br&gt;gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：&lt;br&gt;    &lt;code&gt;$ sudo gem update --system&lt;/code&gt;&lt;br&gt;③安装完成后，执行pod setup命令时报错：&lt;br&gt;这就是路径设置的问题，可以通过执行：&lt;br&gt;    &lt;code&gt;$ rvm use ruby-1.9.3-p448&lt;/code&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级CocoaPods&lt;br&gt;升级很简单，再次执行安装命令即可：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看pod版本输入命令：&lt;br&gt; &lt;code&gt;$ pod --version&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;使用CocoaPods&quot;&gt;&lt;a href=&quot;#使用CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods&quot;&gt;&lt;/a&gt;使用CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建一个项目，比如swift或者oc项目，然后在终端下打开文件夹：&lt;br&gt;输入命令：&lt;br&gt; &lt;code&gt;$ touch Podfile&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ vi Podfile&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;可以输入命令&lt;br&gt; &lt;code&gt;$ pod search ...&lt;/code&gt;来找到所需要的版本  &lt;/li&gt;
&lt;li&gt;在Podfile中输入&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/podfile.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意：ios小写。一般设置为‘8.0’，这样就可以适配多个版本。&lt;/li&gt;
&lt;li&gt;然后仍旧是在项目根目录下执行如下命令&lt;br&gt; &lt;code&gt;$ pod install&lt;/code&gt;&lt;br&gt;现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。&lt;/li&gt;
&lt;li&gt;每次更改了 Podfile 文件，你需要重新执行一次pod update命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&lt;/a&gt;&lt;br&gt;深入理解CocoaPods:&lt;a href=&quot;http://objccn.io/issue-6-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://objccn.io/issue-6-4/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CocoaPods" scheme="http://peilinghui.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题总结</title>
    <link href="http://peilinghui.com/2016/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2016/03/01/iOS面试题总结/</id>
    <published>2016-03-01T08:57:25.000Z</published>
    <updated>2016-03-06T14:49:32.000Z</updated>
    
    <content type="html">&lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;单例设计模式-Singleton&quot;&gt;&lt;a href=&quot;#单例设计模式-Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式(Singleton)&quot;&gt;&lt;/a&gt;单例设计模式(Singleton)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;它可以保证某个类创建出来的对象永远只有1个&lt;/li&gt;
&lt;li&gt;作用：节省内存资源，一个应用就一个对象  例如：工具类(音频Sound)&lt;/li&gt;
&lt;li&gt;实现：MRC和ARC&lt;/li&gt;
&lt;li&gt;单例模式实现代码：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%20%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;创建单例设计模式的基本步骤：&lt;ul&gt;
&lt;li&gt;声明一个单件对象的静态实例,并初始化为nil。 &lt;/li&gt;
&lt;li&gt;创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类的实例&lt;/li&gt;
&lt;li&gt;实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和初始化对象时,不会产 生另一个对象。 &lt;/li&gt;
&lt;li&gt;覆盖release、autorelease、retain、retainCount方法, 以此确保单例的状态。 &lt;/li&gt;
&lt;li&gt;在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实例被正确的创建和初始化。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;a href=&quot;#内存管理（MRC和ARC）&quot; class=&quot;headerlink&quot; title=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;/a&gt;内存管理（MRC和ARC）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;讲解：&lt;a href=&quot;http://www.jianshu.com/p/3129ce12e020&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/3129ce12e020&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于类方法（静态方法）默认是autorelease的。所有类方法都会这样吗？&lt;br&gt;系统自带的绝大数类方法返回的对象,都是经过autorelease的&lt;/li&gt;
&lt;li&gt;block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？&lt;br&gt;注意：1&amp;gt;block的内存管理 (block的实现是基于指针和函数指针) &lt;ul&gt;
&lt;li&gt;如果没有copy操作，block代码默认放在栈内存（弱引用）。&lt;/li&gt;
&lt;li&gt;如果有copy操作，block升级放在堆内存（强引用）。&lt;br&gt;2&amp;gt;防止循环引用&lt;br&gt; 解决：非ARC（MRC）：&lt;strong&gt;__block&lt;/strong&gt;&lt;br&gt;ARC：&lt;strong&gt;__weak&lt;/strong&gt;或者&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动释放池底层怎么实现&lt;br&gt;自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.&lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;作用：间接通过字符串类型的key取出对应的属性值&lt;br&gt;字典中key必须和模型的属性名称一模一样&lt;br&gt; &lt;code&gt;self.answer = dic[@&amp;quot;answer&amp;quot;];&lt;/code&gt;等价于：&lt;br&gt; &lt;code&gt;[self setValue:dict[@&amp;quot;answer&amp;quot;] forKeyPath:@&amp;quot;answer&amp;quot;];&lt;/code&gt;&lt;br&gt;一句话：&lt;br&gt; &lt;code&gt;[self setValuesForKeysWithDictionary:dict];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;keyPath包含了key的功能&lt;br&gt;key：只能访问当前对象的属性&lt;br&gt;keyPath：能利用运算符一层一层往内部访问属性  &lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;键值编码（key-value coding）是一种间接更改对象状态的方式。通过传入的字符串（key）查找要更改的对象的状态。查找的规则是，先查找以字符串（key）命名的getter和setter方法。如果没有找到对应的方法，再查找key和_key的实例变量。KVC 是字典转模型，模型转字典的神器  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KVC中基本调用的两个方法：&lt;br&gt;valueForKey:&lt;br&gt; &lt;code&gt;NSString *name = [self.studentModel valueForKey:@&amp;quot;name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKey:&lt;br&gt; &lt;code&gt;[self.studentModel setValue:@&amp;quot;李四&amp;quot; forKey:@&amp;quot;name&amp;quot;];&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于标量值，会自动进行装箱和拆箱。&lt;br&gt;使用键路径：&lt;br&gt;valueForKeyPath:&lt;br&gt; &lt;code&gt;NSString *phone = [self.schoolModel valueForKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKeyPath:&lt;br&gt; &lt;code&gt;[self.schoolModel setValue:@&amp;quot;初三五班&amp;quot; forKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;p&gt;作用：属性监听&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVO.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;讲解&lt;/strong&gt;：&lt;a href=&quot;http://www.jianshu.com/p/0492b841b500&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/0492b841b500&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/8f83f592a354#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/8f83f592a354#&lt;/a&gt;&lt;br&gt;内部实现原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KVO是基于runtime机制实现的&lt;/li&gt;
&lt;li&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。&lt;br&gt;派生类在被重写的 setter 方法实现真正的通知机制（Person-&amp;gt;NSKVONotifying_Person）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Foundation&quot;&gt;&lt;a href=&quot;#Foundation&quot; class=&quot;headerlink&quot; title=&quot;Foundation&quot;&gt;&lt;/a&gt;Foundation&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否可以把比较耗时的操作放在NSNotificationCenter中&lt;br&gt;如果在异步线程发的通知，那么可以执行比较耗时的操作；&lt;br&gt;如果在主线程发的通知，那么就不可以执行比较耗时的操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Foundation对象与Core Foundation对象有什么区别  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Foundation对象是OC的，Core Foundation对象是C对象&lt;/li&gt;
&lt;li&gt;数据类型之间的转换&lt;br&gt;ARC:&lt;strong&gt;__bridge_retained&lt;/strong&gt;,&lt;strong&gt;__bridge_transfer&lt;/strong&gt;&lt;br&gt;非ARC:&lt;strong&gt;__bridge&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否使用Core Text或者Core Image等？如果使用过，请谈谈你使用Core Text或者Core Image的体验。&lt;br&gt;CoreText：随意修改文本的样式，图文混排(纯C语言)国外:Niumb&lt;br&gt;Core Image(滤镜处理)： 能调节图片的各种属性(对比度, 色温, 色差等)&lt;/li&gt;
&lt;li&gt;controllers间怎么进行通信。&lt;br&gt;在IOS应用不断的出现三种模式来实现这种通信：&lt;ul&gt;
&lt;li&gt;委托delegation；（一个controller定义了一个协议（即一系列的方法定义））&lt;/li&gt;
&lt;li&gt;通知中心Notification Center；(通知比较灵活(1个通知能被多个对象接收, 1个对象能接收多个通知)&lt;/li&gt;
&lt;li&gt;键值观察key value observing，KVO(KVO性能不好(底层会动态产生新的类)，只能监听某个对象属性的改变, 不推荐使用(1个对象的属性能被多个对象监听,  1个对象能监听多个对象的其他属性)&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/dqjyong/article/details/7685933&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/dqjyong/article/details/7685933&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是runtime？&lt;br&gt;1&amp;gt; runtime是一套比较底层的纯C语言API, 属于1个C语言库（包含很多强大实用的C语言数据类型、C语言函数）&lt;br&gt;2&amp;gt; 平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者&lt;br&gt;3&amp;gt; 举例:&lt;br&gt;OC：&lt;code&gt;[[Person alloc] init]&lt;/code&gt;&lt;br&gt;runtime: &lt;code&gt;objc_msgSend(objc_msgSend(&amp;quot;Person&amp;quot; , &amp;quot;alloc&amp;quot;), &amp;quot;init&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有什么用？&lt;br&gt;runtime是属于OC的底层, 可以进行一些非常底层的操作。&lt;br&gt;1&amp;gt; 能动态产生一个类、一个成员变量、一个方法&lt;br&gt;2&amp;gt; 能动态修改一个类、一个成员变量、一个方法&lt;br&gt;3&amp;gt; 能动态删除一个类、一个成员变量、一个方法  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的函数、头文件&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt; : 成员变量、类、方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;Ivar * class_copyIvarList : 获得某个类内部的所有成员变量&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method * class_copyMethodList : 获得某个类内部的所有方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getInstanceMethod: 获得某个实例方法（对象方法，减号-开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getClassMethod : 获得某个类方法（加号+开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;method_exchangeImplementations : 交换2个方法的具体实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;#import &amp;lt;objc/message.h&amp;gt;: 消息机制&lt;/code&gt;&lt;br&gt; &lt;code&gt;objc_msgSend(....)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;UI&quot;&gt;&lt;a href=&quot;#UI&quot; class=&quot;headerlink&quot; title=&quot;UI&quot;&gt;&lt;/a&gt;UI&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;介绍一下isa指针,怎么用？&lt;br&gt;每一个对象内部都有一个ISA指针，对象的ISA指针就指向它的真实类型它所属的类。&lt;/li&gt;
&lt;li&gt;控制器的生命周期&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%89%AF%E6%9C%AC.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;IOS7之前,后台执行内容有几种形式,都是什么？&lt;br&gt;一般的应用在进入后台的时候可以获取一定时间来运行相关任务，也就是说可以在后台运行一小段时间(10S左右)。&lt;ul&gt;
&lt;li&gt;后台播放音乐&lt;/li&gt;
&lt;li&gt;后台GPS跟踪&lt;/li&gt;
&lt;li&gt;后台voip支持（网络电话）&lt;/li&gt;
&lt;li&gt;7以后查看，在Support Interface orientations中添加Requried background modes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;APP的启动过程,从main文件开始说起&lt;br&gt;程序启动分为两类:&lt;br&gt;1&amp;gt;有storyboard&lt;ul&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain(创建UIApplication对象,创建UIApplication的delegate对象)&lt;/li&gt;
&lt;li&gt;根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(创建UIWindow,创建和设置UIWindow的rootViewController,显示窗口)&lt;br&gt;2&amp;gt;没有storyboard情况下:&lt;/li&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain（创建UIApplication对象，创建UIApplication的delegate对象）&lt;/li&gt;
&lt;li&gt;delegate对象开始处理(监听)系统事件(没有storyboard)&lt;br&gt;程序启动完毕的时候, 就会调用代理的&lt;br&gt;&lt;code&gt;application:didFinishLaunchingWithOptions:方法&lt;/code&gt;&lt;br&gt;&lt;code&gt;在application:didFinishLaunchingWithOptions:中创建UIWindow&lt;/code&gt;&lt;br&gt;创建和设置UIWindow的rootViewController&lt;br&gt;显示窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把程序自己关掉和程序进入后台,远程推送的区别&lt;br&gt;1&amp;gt;关掉后不执行任何代码, 不能处理事件&lt;br&gt;2&amp;gt;应用程序进入&lt;strong&gt;后台状态&lt;/strong&gt;不久后转入&lt;strong&gt;挂起状态&lt;/strong&gt;。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。只有当用户再次运行此应用，应用才会从挂起状态唤醒，代码得以继续执行&lt;br&gt;3&amp;gt;或者进入后台时开启多任务状态，保留在内存中，这样就可以&lt;br&gt;执行系统允许的动作&lt;br&gt;4&amp;gt;远程推送是由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序,当应用程序收到推送的消息会自动调用特定的方法执行事先写好的代码&lt;/li&gt;
&lt;li&gt;本地通知和远程推送通知对基本概念和用法？&lt;br&gt;本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.&lt;br&gt;本地通知由本应用负责调用,只能从当前设备上的iOS发出&lt;br&gt;远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OC" scheme="http://peilinghui.com/tags/OC/"/>
    
      <category term="iOS面试" scheme="http://peilinghui.com/tags/iOS%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS中的autolayout</title>
    <link href="http://peilinghui.com/2016/02/28/%E5%85%B3%E4%BA%8EiOS%E4%B8%AD%E7%9A%84autolayout/"/>
    <id>http://peilinghui.com/2016/02/28/关于iOS中的autolayout/</id>
    <published>2016-02-28T14:04:07.000Z</published>
    <updated>2016-03-06T13:31:25.000Z</updated>
    
    <content type="html">&lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;a href=&quot;#autolayout在Storyboard中的使用&quot; class=&quot;headerlink&quot; title=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;/a&gt;autolayout在Storyboard中的使用&lt;/h2&gt;&lt;h2 id=&quot;三个练习：&quot;&gt;&lt;a href=&quot;#三个练习：&quot; class=&quot;headerlink&quot; title=&quot;三个练习：&quot;&gt;&lt;/a&gt;三个练习：&lt;/h2&gt;&lt;h3 id=&quot;1-练习1&quot;&gt;&lt;a href=&quot;#1-练习1&quot; class=&quot;headerlink&quot; title=&quot;1.练习1&quot;&gt;&lt;/a&gt;1.练习1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在控制器view底部添加2个view，1个蓝色，1个红色
2个view宽度、高度永远相等
距离父控件左边、右边、下边间距和2个view之间的间距相等  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E7%AD%94%E6%A1%88.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;就是设置蓝色View的左边和下边和右边(相对于红色view)，设置红色view的右边和下边，选中俩个，再设置equal width和height，或者是设置顶部对齐和底部对齐。     &lt;/p&gt;
&lt;h3 id=&quot;练习2&quot;&gt;&lt;a href=&quot;#练习2&quot; class=&quot;headerlink&quot; title=&quot;练习2&quot;&gt;&lt;/a&gt;练习2&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在控制器view顶部添加2个view，1个蓝色，1个红色
2个view高度永远相等,等于50
红色view和蓝色view右边对齐
蓝色view距离父控件左边、右边、上边间距相等,等于30
蓝色view距离红色view间距固定,等于30
红色view的左边和父控件的中点对齐
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%AD%94%E6%A1%882.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E7%AD%94%E6%A1%88.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;练习3&quot;&gt;&lt;a href=&quot;#练习3&quot; class=&quot;headerlink&quot; title=&quot;练习3&quot;&gt;&lt;/a&gt;练习3&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E7%AD%94%E6%A1%88.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;理解垂直居中和水平居中，还有左对齐，右对齐，底部顶部对齐，利用公式：Superview.center Y = Button center Y * 1 -constant &lt;/p&gt;
&lt;h1 id=&quot;代码实现Autolayout&quot;&gt;&lt;a href=&quot;#代码实现Autolayout&quot; class=&quot;headerlink&quot; title=&quot;代码实现Autolayout&quot;&gt;&lt;/a&gt;代码实现Autolayout&lt;/h1&gt;&lt;h3 id=&quot;1-代码实现Autolayout的步骤&quot;&gt;&lt;a href=&quot;#1-代码实现Autolayout的步骤&quot; class=&quot;headerlink&quot; title=&quot;1.代码实现Autolayout的步骤&quot;&gt;&lt;/a&gt;1.代码实现Autolayout的步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;利用NSLayoutConstraint类创建具体的约束对象&lt;br&gt;一个NSLayoutConstraint对象就代表一个约束&lt;br&gt;创建约束对象的常用方法&lt;br&gt;&lt;code&gt;+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;&lt;/code&gt;&lt;br&gt; view1 ：要约束的控件&lt;br&gt; attr1 ：约束的类型（做怎样的约束）&lt;br&gt; relation ：与参照控件之间的关系&lt;br&gt; view2 ：参照的控件&lt;br&gt; attr2 ：约束的类型（做怎样的约束）&lt;br&gt; multiplier ：乘数&lt;br&gt; c ：常量&lt;br&gt; 自动布局有个核心公式&lt;br&gt;obj1.property1 =（obj2.property2 * multiplier）+ constant value&lt;/li&gt;
&lt;li&gt;添加约束对象到相应的view上&lt;br&gt;&lt;code&gt;- (void)addConstraint:(NSLayoutConstraint *)constraint;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)addConstraints:(NSArray *)constraints;&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;VFL语言实现layout&quot;&gt;&lt;a href=&quot;#VFL语言实现layout&quot; class=&quot;headerlink&quot; title=&quot;VFL语言实现layout&quot;&gt;&lt;/a&gt;VFL语言实现layout&lt;/h1&gt;&lt;p&gt;1.VFL全称是Visual Format Language，翻译过来是“可视化格式语言”&lt;br&gt;VFL是苹果公司为了简化Autolayout的编码而推出的抽象语言。&lt;/p&gt;
&lt;p&gt;2.使用VFL来创建约束数组&lt;br&gt;&lt;code&gt;+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;&lt;/code&gt;&lt;br&gt;format ：VFL语句&lt;br&gt;opts ：约束类型&lt;br&gt;metrics ：VFL语句中用到的具体数值&lt;br&gt;views ：VFL语句中用到的控件&lt;br&gt;VFL示例：&lt;br&gt;H:[cancelButton(72)]-12-[acceptButton(50)]&lt;br&gt;canelButton宽72，acceptButton宽50，它们之间间距12 &lt;/p&gt;
&lt;p&gt;3.创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义&lt;br&gt;NSDictionaryOfVariableBindings(…)  &lt;/p&gt;
&lt;h1 id=&quot;Masonry&quot;&gt;&lt;a href=&quot;#Masonry&quot; class=&quot;headerlink&quot; title=&quot;Masonry&quot;&gt;&lt;/a&gt;Masonry&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h2&gt;&lt;p&gt; Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。  &lt;/p&gt;
&lt;h2 id=&quot;2-框架下载地址：&quot;&gt;&lt;a href=&quot;#2-框架下载地址：&quot; class=&quot;headerlink&quot; title=&quot;2.框架下载地址：&quot;&gt;&lt;/a&gt;2.框架下载地址：&lt;/h2&gt;&lt;p&gt;   &lt;a href=&quot;https://github.com/Masonry/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Masonry/Masonry&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;3-Masonry介绍与使用实践-快速上手Autolayout&quot;&gt;&lt;a href=&quot;#3-Masonry介绍与使用实践-快速上手Autolayout&quot; class=&quot;headerlink&quot; title=&quot;3.Masonry介绍与使用实践(快速上手Autolayout)&quot;&gt;&lt;/a&gt;3.Masonry介绍与使用实践(快速上手Autolayout)&lt;/h2&gt;&lt;p&gt;  &lt;a href=&quot;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&lt;/a&gt;   &lt;/p&gt;
&lt;h2 id=&quot;4-案例讲解：&quot;&gt;&lt;a href=&quot;#4-案例讲解：&quot; class=&quot;headerlink&quot; title=&quot;4.案例讲解：&quot;&gt;&lt;/a&gt;4.案例讲解：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-使用方法：&quot;&gt;&lt;a href=&quot;#5-使用方法：&quot; class=&quot;headerlink&quot; title=&quot;5.使用方法：&quot;&gt;&lt;/a&gt;5.使用方法：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ios122.com/2015/09/masonry/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ios122.com/2015/09/masonry/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用方法：&quot;&gt;&lt;a href=&quot;#常用方法：&quot; class=&quot;headerlink&quot; title=&quot;常用方法：&quot;&gt;&lt;/a&gt;常用方法：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.三个添加约束方法区别
mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错
mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况
mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束
三种函数善加利用 就可以应对各种情况了

2、两个赋值方法区别（equalTo 和 mas_equalTo）
#define equalTo(...)  mas_equalTo(__VA_ARGS__)
#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) 
mas_equalTo对其参数进行了一个自动装箱操作， 除了支持NSNumber数值类型之外还支持CGPoint CGSize UIEdgeInsets
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;基于Autolayout的动画&quot;&gt;&lt;a href=&quot;#基于Autolayout的动画&quot; class=&quot;headerlink&quot; title=&quot;基于Autolayout的动画&quot;&gt;&lt;/a&gt;基于Autolayout的动画&lt;/h1&gt;&lt;p&gt;在修改了约束之后，只要执行下面代码，就能做动画效果&lt;br&gt;&lt;code&gt;[UIView animateWithDuration:1.0 animations:^{
    添加了约束的view layoutIfNeeded];
}];&lt;/code&gt;&lt;br&gt;参考学习：&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://peilinghui.com/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="autolayout" scheme="http://peilinghui.com/tags/autolayout/"/>
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>创建博客</title>
    <link href="http://peilinghui.com/2016/02/25/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://peilinghui.com/2016/02/25/创建博客/</id>
    <published>2016-02-25T07:21:14.000Z</published>
    <updated>2016-03-05T07:32:39.000Z</updated>
    
    <content type="html">&lt;p&gt;偶然发现大家（周围厉害的同学）还有网上的各种大牛都有属于自己的博客，记录自己的学习历程，然后自己也开始探索搭建博客的历程.  &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最初搭建了一个Octopress+Github Page的博客，开始就使用的最初的主题，就如图所示：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/octopress%E6%9C%80%E5%88%9D.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后就开始逛其他人的博客，发现大家博客的主题都好好看，瞬间觉得自己该换个主题了，然后发现了octopress的&lt;a href=&quot;https://github.com/tommy351/Octopress-Theme-Slash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;slash主题&lt;/a&gt;然后弄完的样子就是下面如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/slash%E4%B8%BB%E9%A2%98.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来比系统自带的主题好看多了，是吧！  &lt;/p&gt;
&lt;p&gt;当然，在网上逛别人的博客的时候，看到很多博客的主题都是作者自己写的，还有一个自学前端的97年的男生自己搭建了一个网站，还看到看到一个96年的搭建的博客简直炫酷，瞬间计算机这个东西完全靠兴趣啊！然后开始模仿&lt;a href=&quot;http://kittenyang.com/myfirstblog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kitten&lt;/a&gt;的这篇文章开始了ghost博客之旅，他是在阿里云服务器ECS和Ubuntu系统上安装Ghost博客，开始我想mac和Ubuntu差不多就开始在mac下搞，然后我就去Godaddy（狗爹）上买了二级域名，租了个阿里云服务器，mac上可以显示如图：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/ghost%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后发现其实mac和Ubuntu还是差别挺大的，比如mac上就没有apt-get这个命令，瞬间那个心情。。。自己挖的坑还的要自己填啊！然后就在我那台win10系统上又装了Ubuntu系统，本来是弄得双系统，估计在装的时候选错了，然后就发现win10不见了，555~，然后在Ubuntu下还是没有配置成功。。。真是辛酸泪啊！租的服务器也不会用额。。。。&lt;/p&gt;
&lt;p&gt;然后发现更多的人使用的是Hexo+Github Page,而且网上有关hexo的学习资料还是很多的，于是我就决定转向hexo了。而且hexo写博文很方便也支持markdown,而且主题很多，也很炫酷，就开始了hexo的博客之旅。&lt;br&gt;对于搭建博客，然后在知乎的一篇文章上看到了&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo的主题&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(iissnan/hexo-theme-next · GitHub,  470)&lt;/a&gt;  这个是next主题，我同学好几个都是用这个主题的。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(litten/hexo-theme-yilia, 265)&lt;/a&gt;  然后就是我现在用的这个主题。  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yangjian.me/pacman/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(A-limon/pacman, 243)&lt;/a&gt;这个主题也挺经典的。（吃豆子）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xiangming/landscape-plus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(xiangming/landscape-plus, 147)&lt;/a&gt;优化hexo官方主题landscape。&lt;br&gt;还有很多主题呢！有时间再去尝试一下吧！    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参考： 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Octopress：&lt;br&gt;&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/18/octopressbo-ke-da-jian/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cnbin.github.io/blog/2015/05/18/octopressbo-ke-da-jian/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e208ade30f08&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e208ade30f08&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/imathis/octopress/wiki/Octopress-Sites&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/imathis/octopress/wiki/Octopress-Sites&lt;/a&gt;&lt;br&gt;ghost:&lt;br&gt;&lt;a href=&quot;http://jas0n.me/2014/12/05/ghost_blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jas0n.me/2014/12/05/ghost_blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22755373&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/22755373&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kittenyang.com/myfirstblog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://kittenyang.com/myfirstblog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22755373&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/22755373&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://snowz.me/how-to-install-ghost/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://snowz.me/how-to-install-ghost/&lt;/a&gt;&lt;br&gt;hexo:&lt;br&gt;&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ibruce.info/2013/11/22/hexo-your-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://iread.io/archives/page/2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://iread.io/archives/page/2/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://zipperary.com/categories/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zipperary.com/categories/hexo/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://lucifr.com/2013/01/02/from-octopress-to-hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lucifr.com/2013/01/02/from-octopress-to-hexo/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;最后来几个我同学的博客地址：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;a href=&quot;http://blog.xuanzhangjiong.xyz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;囧囧囧-网易大神&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ios大神-人生大赢家-网易&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://sunus.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里学长&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.changhuiyuan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;惠源&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.hxdavid.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PAT大神&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://longliqiang88.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;龙哥-云计算&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://pangjiuzala.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;北大兴爷-大数据&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://imhuchao.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;胡超-凤凰网&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://lysongzi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;小松子&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://cspilgrimzww.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;蔚蔚&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;偶然发现大家（周围厉害的同学）还有网上的各种大牛都有属于自己的博客，记录自己的学习历程，然后自己也开始探索搭建博客的历程.  &lt;/p&gt;
    
    </summary>
    
      <category term="创建博客" scheme="http://peilinghui.com/categories/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Octopress" scheme="http://peilinghui.com/tags/Octopress/"/>
    
      <category term="ghost" scheme="http://peilinghui.com/tags/ghost/"/>
    
      <category term="hexo" scheme="http://peilinghui.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://peilinghui.com/2016/02/25/git%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/02/25/git学习/</id>
    <published>2016-02-25T04:21:14.000Z</published>
    <updated>2016-02-29T06:27:21.000Z</updated>
    
    <content type="html">&lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;本地&quot;&gt;&lt;a href=&quot;#本地&quot; class=&quot;headerlink&quot; title=&quot;本地&quot;&gt;&lt;/a&gt;本地&lt;/h1&gt;&lt;h2 id=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;a href=&quot;#git的配置，邮箱地址和用户名&quot; class=&quot;headerlink&quot; title=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;/a&gt;git的配置，邮箱地址和用户名&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置邮箱&lt;/strong&gt;&lt;br&gt;$ git config –global user.email “799745776@qq.com”  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置用户名&lt;/strong&gt;&lt;br&gt;$ git config –global user.name “plh”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看当前的配置&lt;/strong&gt;&lt;br&gt;$ cat .git/config&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;git命令&quot;&gt;&lt;a href=&quot;#git命令&quot; class=&quot;headerlink&quot; title=&quot;git命令&quot;&gt;&lt;/a&gt;git命令&lt;/h2&gt;&lt;h3 id=&quot;初始化一个Git仓库使用&quot;&gt;&lt;a href=&quot;#初始化一个Git仓库使用&quot; class=&quot;headerlink&quot; title=&quot;初始化一个Git仓库使用&quot;&gt;&lt;/a&gt;初始化一个Git仓库使用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;添加文件到Git仓库&quot;&gt;&lt;a href=&quot;#添加文件到Git仓库&quot; class=&quot;headerlink&quot; title=&quot;添加文件到Git仓库&quot;&gt;&lt;/a&gt;添加文件到Git仓库&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;放在暂缓区的命令&lt;/strong&gt;&lt;br&gt;$ git add .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地提交仓库&lt;/strong&gt;&lt;br&gt;$ git commit -m “提交代码”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ git push origin master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;br&gt;$ git staus&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新本地代码&lt;/strong&gt;&lt;br&gt;$ git pull&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示当前分支的版本历史&lt;/strong&gt;&lt;br&gt;$ git log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前一个版本&lt;/strong&gt;&lt;br&gt;git reset –hard HEAD^  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前两个版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD^^ &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前 N 版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD~N  &lt;/p&gt;
&lt;!--N 是数字--&gt; 
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复指定版本&lt;/strong&gt;&lt;br&gt;$ (git lg) git reset –hard 版本号 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看指令使用历史，确定要回到未来的哪个版本&lt;/strong&gt;&lt;br&gt;$ git reflog&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看所有本地分支&lt;/strong&gt;&lt;br&gt;$ git branch  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列出所有远程分支&lt;/strong&gt;&lt;br&gt;$ git branch -r&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建分支&lt;/strong&gt;&lt;br&gt;$ git branch name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切换分支&lt;/strong&gt;&lt;br&gt;$ git checkout name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;合并分支&lt;/strong&gt;&lt;br&gt;$  git merge name &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除分支&lt;/strong&gt;&lt;br&gt;$ git branch -d name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除远程分支&lt;/strong&gt;&lt;br&gt;$ git push origin –delete name&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$ git branch -dr [remote/branch]&lt;/p&gt;
&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git rm 文件名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;远程&quot;&gt;&lt;a href=&quot;#远程&quot; class=&quot;headerlink&quot; title=&quot;远程&quot;&gt;&lt;/a&gt;远程&lt;/h2&gt;&lt;h3 id=&quot;创建SSH-Key&quot;&gt;&lt;a href=&quot;#创建SSH-Key&quot; class=&quot;headerlink&quot; title=&quot;创建SSH Key&quot;&gt;&lt;/a&gt;创建SSH Key&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh-keygen -t rsa -C &lt;span class=&quot;string&quot;&gt;&quot;youremail@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;从远程库克隆&quot;&gt;&lt;a href=&quot;#从远程库克隆&quot; class=&quot;headerlink&quot; title=&quot;从远程库克隆&quot;&gt;&lt;/a&gt;从远程库克隆&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; git@github.com:.......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;远程同步&quot;&gt;&lt;a href=&quot;#远程同步&quot; class=&quot;headerlink&quot; title=&quot;远程同步&quot;&gt;&lt;/a&gt;远程同步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;下载远程仓库的所有变动&lt;/strong&gt;&lt;br&gt;$ git fetch [remote] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示所有远程仓库&lt;/strong&gt;&lt;br&gt;$ git remote -v&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示某个远程仓库的信息&lt;/strong&gt;&lt;br&gt;$ git remote show [remote]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加一个新的远程仓库，并命名&lt;/strong&gt;&lt;br&gt;$ git remote add [shortname] [url]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;取回远程仓库的变化，并与本地分支合并&lt;/strong&gt;&lt;br&gt;$ git pull [remote] [branch] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;上传本地指定分支到远程仓库&lt;/strong&gt;&lt;br&gt;$  git push [remote] [branch]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;强行推送当前分支到远程仓库，即使有冲突&lt;/strong&gt;&lt;br&gt;$ git push [remote] –force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;推送所有分支到远程仓库&lt;/strong&gt;&lt;br&gt;$ git push [remote] –all &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h2&gt;&lt;h3 id=&quot;显示本地git库：&quot;&gt;&lt;a href=&quot;#显示本地git库：&quot; class=&quot;headerlink&quot; title=&quot;显示本地git库：&quot;&gt;&lt;/a&gt;显示本地git库：&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;隐藏本地git库&quot;&gt;&lt;a href=&quot;#隐藏本地git库&quot; class=&quot;headerlink&quot; title=&quot;隐藏本地git库&quot;&gt;&lt;/a&gt;隐藏本地git库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://peilinghui.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://peilinghui.com/tags/git/"/>
    
  </entry>
  
</feed>
