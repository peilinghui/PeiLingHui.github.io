<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2016-03-10T06:01:42.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中的地图定位</title>
    <link href="http://peilinghui.com/2016/03/09/iOS%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%AE%9A%E4%BD%8D/"/>
    <id>http://peilinghui.com/2016/03/09/iOS中的地图定位/</id>
    <published>2016-03-09T08:55:30.000Z</published>
    <updated>2016-03-10T06:01:42.000Z</updated>
    
    <content type="html">&lt;p&gt;花一天时间学习一下iOS中的地图定位.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;CoreLocation框架的使用&quot;&gt;&lt;a href=&quot;#CoreLocation框架的使用&quot; class=&quot;headerlink&quot; title=&quot;CoreLocation框架的使用&quot;&gt;&lt;/a&gt;CoreLocation框架的使用&lt;/h1&gt;&lt;p&gt;先要导入框架，导入头文件&lt;br&gt;    &lt;code&gt;#import &amp;lt;CoreLocation/CoreLocation.h&amp;gt;&lt;/code&gt;&lt;br&gt;CoreLocation框架中所有数据类型的前缀都是CL,CoreLocation中使用CLLocationManager对象来做用户定位.&lt;/p&gt;
&lt;h3 id=&quot;CLLocationManager&quot;&gt;&lt;a href=&quot;#CLLocationManager&quot; class=&quot;headerlink&quot; title=&quot;CLLocationManager&quot;&gt;&lt;/a&gt;CLLocationManager&lt;/h3&gt;&lt;p&gt;CLLocationManager的常用操作 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开始用户定位&lt;br&gt; &lt;code&gt;- (void)startUpdatingLocation;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;停止用户定位&lt;br&gt; &lt;code&gt;- (void) stopUpdatingLocation;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当调用了startUpdatingLocation方法后，就开始不断地定位用户的位置，中途会频繁地调用代理的下面方法&lt;br&gt;    &lt;code&gt;- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations;&lt;/code&gt;&lt;br&gt;locations参数里面装着CLLocation对象&lt;/p&gt;
&lt;h3 id=&quot;CLLocation&quot;&gt;&lt;a href=&quot;#CLLocation&quot; class=&quot;headerlink&quot; title=&quot;CLLocation&quot;&gt;&lt;/a&gt;CLLocation&lt;/h3&gt;&lt;p&gt;CLLocation用来表示某个位置的地理信息，比如经纬度、海拔等等.&lt;br&gt;经纬度&lt;br&gt;     &lt;code&gt;@property(readonly, nonatomic) CLLocationCoordinate2D coordinate;&lt;/code&gt;&lt;br&gt; CLLocationCoordinate2D是一个用来表示经纬度的结构体，定义如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct {
    CLLocationDegrees latitude; // 纬度
    CLLocationDegrees longitude; // 经度
} CLLocationCoordinate2D;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般用CLLocationCoordinate2DMake函数来创建CLLocationCoordinate2D&lt;br&gt;补充：天朝的经纬度范围&lt;br&gt;纬度范围：N 3°51′ ~  N 53°33′&lt;br&gt;经度范围：E 73°33′ ~  E 135°05′&lt;br&gt;海拔&lt;br&gt;    &lt;code&gt;@property(readonly, nonatomic) CLLocationDistance altitude;&lt;/code&gt;&lt;br&gt;路线，航向（取值范围是0.0° ~ 359.9°，0.0°代表真北方向）      &lt;code&gt;@property(readonly, nonatomic) CLLocationDirection course;&lt;/code&gt;&lt;br&gt;行走速度（单位是m/s）&lt;br&gt;    &lt;code&gt;@property(readonly, nonatomic) CLLocationSpeed speed;&lt;/code&gt;&lt;br&gt;计算2个位置之间的距离方法&lt;br&gt;    &lt;code&gt;- (CLLocationDistance)distanceFromLocation:(const CLLocation *)location&lt;/code&gt;&lt;br&gt;*plist文件添加隐私描述  &lt;/p&gt;
&lt;p&gt;Privacy - Location Usage Description    &lt;/p&gt;
&lt;h3 id=&quot;CLGeocoder&quot;&gt;&lt;a href=&quot;#CLGeocoder&quot; class=&quot;headerlink&quot; title=&quot;CLGeocoder&quot;&gt;&lt;/a&gt;CLGeocoder&lt;/h3&gt;&lt;p&gt;使用CLGeocoder可以完成“地理编码”和“反地理编码”&lt;br&gt;地理编码：根据给定的地名，获得具体的位置信息（比如经纬度、地址的全称等）&lt;br&gt;反地理编码：根据给定的经纬度，获得具体的位置信息  &lt;/p&gt;
&lt;p&gt;地理编码方法&lt;br&gt;    &lt;code&gt;- (void)geocodeAddressString:(NSString *)addressString completionHandler:(CLGeocodeCompletionHandler)completionHandler;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反地理编码方法&lt;br&gt;    &lt;code&gt;- (void)reverseGeocodeLocation:(CLLocation *)location completionHandler:(CLGeocodeCompletionHandler)completionHandler;&lt;/code&gt;&lt;br&gt;当地理\反地理编码完成时，就会调用CLGeocodeCompletionHandler&lt;br&gt;    &lt;code&gt;typedef void (^CLGeocodeCompletionHandler)(NSArray *placemarks, NSError *error);&lt;/code&gt;&lt;br&gt;这个block传递2个参数&lt;br&gt;error ：当编码出错时（比如编码不出具体的信息）有值&lt;br&gt;placemarks ：里面装着CLPlacemark对象 &lt;/p&gt;
&lt;h3 id=&quot;CLPlacemark&quot;&gt;&lt;a href=&quot;#CLPlacemark&quot; class=&quot;headerlink&quot; title=&quot;CLPlacemark&quot;&gt;&lt;/a&gt;CLPlacemark&lt;/h3&gt;&lt;p&gt;CLPlacemark的字面意思是地标，封装详细的地址位置信息.&lt;br&gt;地理位置&lt;br&gt;    &lt;code&gt;@property (nonatomic, readonly) CLLocation *location;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;区域&lt;br&gt;    &lt;code&gt;@property (nonatomic, readonly) CLRegion *region;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;详细的地址信息&lt;br&gt;    &lt;code&gt;@property (nonatomic, readonly) NSDictionary *addressDictionary;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;地址名称&lt;br&gt;    &lt;code&gt;@property (nonatomic, readonly) NSString *name;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;城市&lt;br&gt;    &lt;code&gt;@property (nonatomic, readonly) NSString *locality;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;MapKit框架的使用&quot;&gt;&lt;a href=&quot;#MapKit框架的使用&quot; class=&quot;headerlink&quot; title=&quot;MapKit框架的使用&quot;&gt;&lt;/a&gt;MapKit框架的使用&lt;/h1&gt;&lt;p&gt;先要导入框架，导入头文件&lt;br&gt;    &lt;code&gt;#import &amp;lt;MapKit/MapKit.h&amp;gt;&lt;/code&gt;&lt;br&gt;MapKit框架中所有数据类型的前缀都是MK&lt;br&gt;MapKit有一个比较重要的UI控件 ：MKMapView，专门用于地图显示&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;花一天时间学习一下iOS中的地图定位.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的第三方框架</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的第三方框架/</id>
    <published>2016-03-05T06:08:53.000Z</published>
    <updated>2016-03-08T03:22:43.000Z</updated>
    
    <content type="html">&lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;FMDB&quot;&gt;&lt;a href=&quot;#FMDB&quot; class=&quot;headerlink&quot; title=&quot;FMDB&quot;&gt;&lt;/a&gt;FMDB&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是FMDB：&lt;br&gt;FMDB是iOS平台的SQLite数据库框架；&lt;br&gt;FMDB以OC的方式封装了SQLite的C语言API&lt;/li&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码&lt;/li&gt;
&lt;li&gt;对比苹果自带的Core Data框架，更加轻量级和灵活&lt;/li&gt;
&lt;li&gt;提供了多线程安全的数据库操作方法，有效地防止数据混乱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FMDB的github地址:  &lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ccgus/fmdb&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h1&gt;&lt;p&gt;HTTP请求&lt;br&gt;提供了GET请求和Post请求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AFN 与 ASI 有什么区别&lt;br&gt;AFN基于NSURL，ASI基于底层的CFNetwork框架，因此ASI的性能优于AFN&lt;br&gt;AFN采取block的方式处理请求，ASI最初采取delegate的方式处理请求，后面也增加了block的方式&lt;br&gt;AFN只封装了一些常用功能，满足基本需求，直接忽略了很多扩展功能，比如没有封装同步请求；ASI提供的功能较多，预留了各种接口和工具供开发者自行扩展&lt;br&gt;AFN直接解析服务器返回的JSON、XML等数据，而ASI比较原始，返回的是NSData二进制数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;SDWebImage&quot;&gt;&lt;a href=&quot;#SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;SDWebImage&quot;&gt;&lt;/a&gt;SDWebImage&lt;/h1&gt;&lt;p&gt;SDWebImage具体如何实现&lt;br&gt;利用NSOperationQueue和NSOperation下载图片, 还使用了GCD的一些函数(解码GIF图片)&lt;br&gt;利用URL作为key，NSOperation作为value&lt;br&gt;利用URL作为key，UIImage作为value&lt;/p&gt;
&lt;h1 id=&quot;MBProgressHUD&quot;&gt;&lt;a href=&quot;#MBProgressHUD&quot; class=&quot;headerlink&quot; title=&quot;MBProgressHUD&quot;&gt;&lt;/a&gt;MBProgressHUD&lt;/h1&gt;&lt;h1 id=&quot;JSONKit&quot;&gt;&lt;a href=&quot;#JSONKit&quot; class=&quot;headerlink&quot; title=&quot;JSONKit&quot;&gt;&lt;/a&gt;JSONKit&lt;/h1&gt;&lt;h1 id=&quot;Extension&quot;&gt;&lt;a href=&quot;#Extension&quot; class=&quot;headerlink&quot; title=&quot;Extension&quot;&gt;&lt;/a&gt;Extension&lt;/h1&gt;&lt;p&gt;字典转模型&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的数据存储</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的数据存储/</id>
    <published>2016-03-05T05:59:07.000Z</published>
    <updated>2016-03-08T13:44:35.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的数据存储方式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS中的数据存储方式&quot;&gt;&lt;a href=&quot;#iOS中的数据存储方式&quot; class=&quot;headerlink&quot; title=&quot;iOS中的数据存储方式&quot;&gt;&lt;/a&gt;iOS中的数据存储方式&lt;/h1&gt;&lt;h2 id=&quot;Plist（NSArray-NSDictionary）&quot;&gt;&lt;a href=&quot;#Plist（NSArray-NSDictionary）&quot; class=&quot;headerlink&quot; title=&quot;Plist（NSArray\NSDictionary）&quot;&gt;&lt;/a&gt;Plist（NSArray\NSDictionary）&lt;/h2&gt;&lt;p&gt;只能存储数组，字典，但是数组和字典里面不能有自定义对象&lt;/p&gt;
&lt;h2 id=&quot;Preference（偏好设置-NSUserDefaults）&quot;&gt;&lt;a href=&quot;#Preference（偏好设置-NSUserDefaults）&quot; class=&quot;headerlink&quot; title=&quot;Preference（偏好设置\NSUserDefaults）&quot;&gt;&lt;/a&gt;Preference（偏好设置\NSUserDefaults）&lt;/h2&gt;&lt;h2 id=&quot;NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot;&gt;&lt;a href=&quot;#NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot; class=&quot;headerlink&quot; title=&quot;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&quot;&gt;&lt;/a&gt;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&lt;/h2&gt;&lt;p&gt;存储自定义对象，局限：一次性做读取的存储的操作&lt;/p&gt;
&lt;h2 id=&quot;SQLite3&quot;&gt;&lt;a href=&quot;#SQLite3&quot; class=&quot;headerlink&quot; title=&quot;SQLite3&quot;&gt;&lt;/a&gt;SQLite3&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是SQLite？&lt;br&gt;SQLite是一款轻型的嵌入式数据库;它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了;它的处理速度比Mysql、PostgreSQL这两款著名的数据库都还快  &lt;/li&gt;
&lt;li&gt;怎么解决sqlite锁定的问题？&lt;br&gt;设置数据库锁定的处理函数&lt;br&gt;int sqlite3_busy_handler(sqlite3&lt;em&gt;, int(&lt;/em&gt;)(void&lt;em&gt;,int), void&lt;/em&gt;);&lt;br&gt;设定锁定时的等待时间&lt;br&gt;int sqlite3_busy_timeout(sqlite3*, 60); ：&lt;h2 id=&quot;Core-Data&quot;&gt;&lt;a href=&quot;#Core-Data&quot; class=&quot;headerlink&quot; title=&quot;Core Data&quot;&gt;&lt;/a&gt;Core Data&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;什么是Core Data？&lt;br&gt;Core Data是iOS5以后才出现的一个框架，它提供了对象-关系映射（ORM）关系，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象，不用编写任何SQL语言（类似于Hibernate框架，没有那么强大）&lt;/li&gt;
&lt;li&gt;使用步骤&lt;ul&gt;
&lt;li&gt;创建模型文件，&lt;strong&gt;相当于数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加实体，&lt;strong&gt;相对于表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;创建实体类，&lt;strong&gt;相当于模型类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成&lt;strong&gt;上下文&lt;/strong&gt; 关联模型文件生成数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的数据存储方式&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的多线程网络</title>
    <link href="http://peilinghui.com/2016/03/04/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C/"/>
    <id>http://peilinghui.com/2016/03/04/iOS中的多线程网络/</id>
    <published>2016-03-04T13:31:31.000Z</published>
    <updated>2016-03-08T06:47:00.000Z</updated>
    
    <content type="html">&lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是多线程&lt;br&gt;进程：是指在系统中正在运行的一个应用程序。1个进程要想执行任务，必须得有线程。（一个进程至少要有一个线程）&lt;br&gt;线程：是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。&lt;br&gt;多线程：在一个进程中可以开启多个线程，每条线程可以并发（同时）执行不同的任务。&lt;/li&gt;
&lt;li&gt;iOS中如何实现多线程&lt;ul&gt;
&lt;li&gt;pthread（一套通用的多线程API，使用难度大 &lt;strong&gt;C语言（底层）&lt;/strong&gt;）程序员管理，几乎不用&lt;br&gt;&lt;code&gt;#include &amp;lt;pthread.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;NSThread（面向对象，简单易用，可直接操作多线程对象,&lt;strong&gt;OC&lt;/strong&gt;），偶尔使用&lt;/li&gt;
&lt;li&gt;GCD（旨在替代NSThread等线程技术，充分利用设备的多核，&lt;strong&gt;C语言&lt;/strong&gt;）自动管理，经常使用&lt;/li&gt;
&lt;li&gt;NSOperation（基于GCD，比GCD多了一些简单实用的功能，&lt;strong&gt;OC&lt;/strong&gt;）自动管理，经常使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间通讯的方法&lt;br&gt;控制器在子线程发送请求给服务器&lt;br&gt;服务器在主线程刷新UI界面到控制器&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;还可以使用GCD，主线程和子线程的通信。&lt;br&gt; &lt;code&gt;dispath_async(dispatch_get_main_queue(),^{
 });&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89NSOperation%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;利用字典（图片地址为key，下载操作为value）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程安全的几种解决办法及多线程安全怎么控制？&lt;br&gt;线程安全的概念: 就是在多个线程同时执行的时候，能够保证资源信息的准确性.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;苹果约定，&lt;strong&gt;所有程序的更新UI都在主线程进行&lt;/strong&gt;，也就不会出现多个线程同时改变一个资源。在主线程更新UI，有什么好处？只在主线程更新UI，就不会出现多个线程同时改变同一个UI控件;主线程的优先级最高。也就意味UI的更新优先级高。 会让用户感觉很流畅    .&lt;/li&gt;
&lt;li&gt;如果要防止资源抢夺，得用synchronized进行加锁保护.&lt;br&gt;线程同步：多条线程按顺序的执行任务（互斥锁）互斥锁使用格式&lt;br&gt;&lt;code&gt;@synchronized(锁对象){
//需要锁定的代码
}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果异步操作要保证线程安全等问题, 尽量使用GCD(有些函数默认就是安全的)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD内部怎么实现的&lt;br&gt;1&amp;gt; iOS和OS X的核心是XNU内核，GCD是基于XNU内核实现的&lt;br&gt;2&amp;gt; GCD的API全部在libdispatch库中&lt;br&gt;3&amp;gt; GCD的底层实现主要有Dispatch Queue和Dispatch Source&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dispatch Queue ：管理block(操作)&lt;/li&gt;
&lt;li&gt;Dispatch Source ：处理事件(比如线程间的通讯)&lt;br&gt;补充：GCD：Grand Central Dispatch “牛逼的中枢调度器”，自动利用更多CPU内核，自动管理线程的生命周期（创建线程，调度任务，销毁线程).使用2个步骤：  &lt;/li&gt;
&lt;li&gt;定制任务（执行什么操作）用block来封装任务  &lt;/li&gt;
&lt;li&gt;将任务添加到队列中（自动将队列中的任务取出，放到对应的线程中执行）（先进先出，后进后出）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD和NSoperation区别&lt;br&gt;1&amp;gt;GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装&lt;br&gt;2&amp;gt;GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序、设置最大并发数量&lt;br&gt;3&amp;gt;NSOperationQueue可以在轻松在Operation间设置依赖关系，而GCD需要写很多的代码才能实现&lt;br&gt;4&amp;gt;NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）&lt;br&gt;5&amp;gt;GCD的执行速度比NSOperationQueue快&lt;br&gt;任务之间不太互相依赖：GCD&lt;br&gt;任务之间有依赖(或者要监听任务的执行情况)：NSOperationQueue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Socket的实现原理以及Socket是如何实现通信的？&lt;br&gt;Socket：称之为套接字，是一种用于网络传输的“工具”。&lt;br&gt;socket的实现原理：是基于TCP/UDP的（TCP：传输控制协议，是一种面向连接的，安全的，基于IP传输层的协议，三次握手。例如：XMPP等网络聊天）（UDP：传输控制协议，是一种面向连接的，不安全的，基于IP传输层的协议，特点：快，只管发，不管收到没有。例如：游戏,QQ视频，红蜘蛛）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;http协议的实现&lt;br&gt;HTTP：是一种超文本协议，定义了网络传输的格式（短连接）&lt;br&gt;如果利用HTTP做聊天，每次都要重新创建连接，因为HTTP是短连接，一次回话后就断开了，如果利用HTTP做聊天，如果聊天特别频繁，会不断的创建连接，消耗资源，性能不好，服务端不会主动给客户端发送请求。      &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;runloop定时源和输入源?&lt;br&gt;1&amp;gt;你创建的程序不需要显示的创建run loop；每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象, 主线程会自行创建并运行run loop&lt;br&gt;2&amp;gt;Run loop处理的输入事件有两种不同的来源：输入源（input source）（异步）（处理其他线程回到主线程的消息）和定时源（timer source）（同步）（定时检查界面上有没有点击事件，检查主线程的事件）&lt;br&gt;3&amp;gt;输入源传递异步消息，通常来自于其他线程或者程序。定时源则传递同步消息，在特定时间或者一定的时间间隔发生&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runloop.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;NSRunLoop的实现机制,及在多线程中如何使用&lt;br&gt;NSRunLoop是IOS消息机制的处理模式.&lt;blockquote&gt;
&lt;p&gt;1.NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。&lt;br&gt;2.NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)异步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。&lt;br&gt;3.runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;只有在为你的程序创建次线程的时候，才需要运行run loop。对于程序的主线程而言，run loop是关键部分。Cocoa提供了运行主线程run loop的代码同时也会自动运行run loop。IOS程序UIApplication中的run方法在程序正常启动的时候就会启动run loop。如果你使用xcode提供的模板创建的程序，那你永远不需要自己去启动run loop&lt;/li&gt;
&lt;li&gt;在多线程中，你需要判断是否需要run loop。如果需要run loop，那么你要负责配置run loop并启动。你不需要在任何情况下都去启动run loop。比如，你使用线程去处理一个预先定义好的耗时极长的任务时，你就可以毋需启动run loop。Run loop只在你要和线程有交互时才需要&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="多线程" scheme="http://peilinghui.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocosPods</title>
    <link href="http://peilinghui.com/2016/03/04/CocosPods/"/>
    <id>http://peilinghui.com/2016/03/04/CocosPods/</id>
    <published>2016-03-04T08:54:28.000Z</published>
    <updated>2016-03-04T09:20:16.000Z</updated>
    
    <content type="html">&lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;CocoaPods是什么？&quot;&gt;&lt;a href=&quot;#CocoaPods是什么？&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods是什么？&quot;&gt;&lt;/a&gt;CocoaPods是什么？&lt;/h1&gt;&lt;p&gt;CocoaPods应该是iOS最常用最有名的类库管理工具.开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;a href=&quot;https://blog.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPod&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;Cocoapods原理&quot;&gt;&lt;a href=&quot;#Cocoapods原理&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods原理&quot;&gt;&lt;/a&gt;Cocoapods原理&lt;/h1&gt;&lt;p&gt;Pods项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。&lt;br&gt;对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh的 bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;br&gt;CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;
&lt;h1 id=&quot;安装CocoaPods&quot;&gt;&lt;a href=&quot;#安装CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;安装CocoaPods&quot;&gt;&lt;/a&gt;安装CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要先确保电脑本地是否有 Ruby环境，因为CocoaPods运行于 Ruby之上，默认情况下，Mac 是自带了 Ruby 环境的，可以通过命令行 ruby -v查看当前Ruby的版本。&lt;br&gt;执行命令：&lt;br&gt; &lt;code&gt;$ ruby -v&lt;/code&gt;&lt;br&gt;已经安装了Ruby开发环境，那么在终端（Terminal）中使用以下命令即可直接安装：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ pod setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装过程中可能遇到的问题&lt;br&gt;①执行完install命令半天没反应&lt;br&gt;这有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：&lt;br&gt; &lt;code&gt;$ gem sources --remove https://rubygems.org/&lt;/code&gt;&lt;br&gt;//等有反应之后再敲入以下命令&lt;br&gt; &lt;code&gt;$ gem sources -a http://ruby.taobao.org/&lt;/code&gt;&lt;br&gt;要想验证是否替换成功了，可以执行：&lt;br&gt; &lt;code&gt;$ gem sources -l&lt;/code&gt;&lt;br&gt;正常的输出是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%9B%BE1%EF%BC%88%E9%95%9C%E5%83%8F%EF%BC%89.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;②gem版本过老&lt;br&gt;gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：&lt;br&gt;    &lt;code&gt;$ sudo gem update --system&lt;/code&gt;&lt;br&gt;③安装完成后，执行pod setup命令时报错：&lt;br&gt;这就是路径设置的问题，可以通过执行：&lt;br&gt;    &lt;code&gt;$ rvm use ruby-1.9.3-p448&lt;/code&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级CocoaPods&lt;br&gt;升级很简单，再次执行安装命令即可：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看pod版本输入命令：&lt;br&gt; &lt;code&gt;$ pod --version&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;使用CocoaPods&quot;&gt;&lt;a href=&quot;#使用CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods&quot;&gt;&lt;/a&gt;使用CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建一个项目，比如swift或者oc项目，然后在终端下打开文件夹：&lt;br&gt;输入命令：&lt;br&gt; &lt;code&gt;$ touch Podfile&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ vi Podfile&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;可以输入命令&lt;br&gt; &lt;code&gt;$ pod search ...&lt;/code&gt;来找到所需要的版本  &lt;/li&gt;
&lt;li&gt;在Podfile中输入&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/podfile.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意：ios小写。一般设置为‘8.0’，这样就可以适配多个版本。&lt;/li&gt;
&lt;li&gt;然后仍旧是在项目根目录下执行如下命令&lt;br&gt; &lt;code&gt;$ pod install&lt;/code&gt;&lt;br&gt;现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。&lt;/li&gt;
&lt;li&gt;每次更改了 Podfile 文件，你需要重新执行一次pod update命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&lt;/a&gt;&lt;br&gt;深入理解CocoaPods:&lt;a href=&quot;http://objccn.io/issue-6-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://objccn.io/issue-6-4/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CocoaPods" scheme="http://peilinghui.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题总结</title>
    <link href="http://peilinghui.com/2016/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2016/03/01/iOS面试题总结/</id>
    <published>2016-03-01T08:57:25.000Z</published>
    <updated>2016-03-08T06:53:56.000Z</updated>
    
    <content type="html">&lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;a href=&quot;#内存管理（MRC和ARC）&quot; class=&quot;headerlink&quot; title=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;/a&gt;内存管理（MRC和ARC）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;讲解：&lt;a href=&quot;http://www.jianshu.com/p/3129ce12e020&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/3129ce12e020&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于类方法（静态方法）默认是autorelease的。所有类方法都会这样吗？&lt;br&gt;系统自带的绝大数类方法返回的对象,都是经过autorelease的&lt;/li&gt;
&lt;li&gt;block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？&lt;br&gt;注意：1&amp;gt;block的内存管理 (block的实现是基于指针和函数指针) &lt;ul&gt;
&lt;li&gt;如果没有copy操作，block代码默认放在栈内存（弱引用）。&lt;/li&gt;
&lt;li&gt;如果有copy操作，block升级放在堆内存（强引用）。&lt;br&gt;2&amp;gt;防止循环引用&lt;br&gt; 解决：非ARC（MRC）：&lt;strong&gt;__block&lt;/strong&gt;&lt;br&gt;ARC：&lt;strong&gt;__weak&lt;/strong&gt;或者&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动释放池底层怎么实现&lt;br&gt;自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.&lt;/li&gt;
&lt;li&gt;怎么保证多人开发进行内存泄露的检查.&lt;br&gt;1&amp;gt;使用Product-&amp;gt;Analyze进行代码的静态分析&lt;br&gt;2&amp;gt;为避免不必要的麻烦, 多人开发时尽量使用ARC&lt;/li&gt;
&lt;li&gt;什么情况下会发生内存泄漏和内存溢出？&lt;br&gt;当程序在申请内存后，无法释放已申请的内存空间(例如一个对象或者变量使用完成后没有释放,这个对象一直占用着内存)，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。内存泄露会最终会导致内存溢出！&lt;br&gt;当程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;单例设计模式-Singleton&quot;&gt;&lt;a href=&quot;#单例设计模式-Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式(Singleton)&quot;&gt;&lt;/a&gt;单例设计模式(Singleton)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;定义：它可以保证某个类创建出来的对象永远只有1个。&lt;/li&gt;
&lt;li&gt;作用：节省内存资源，一个应用就一个对象  例如：工具类(音频Sound)&lt;/li&gt;
&lt;li&gt;实现：MRC和ARC&lt;/li&gt;
&lt;li&gt;单例模式实现代码：（MRC）&lt;br&gt; &lt;code&gt;static MJSoundTool *_soundTool = nil;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8D%95%E4%BE%8B%E6%8A%BD%E5%87%BA%E5%AE%8F.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;若是ARC：&lt;br&gt;在build加标记-fobjc-arc&lt;br&gt;与MRC类似，只是没有了release，retain。&lt;br&gt;在宏中用&lt;code&gt;if__has_feature(objc_arc)&lt;/code&gt;判断&lt;br&gt;创建单例设计模式的基本步骤：&lt;ul&gt;
&lt;li&gt;声明一个单件对象的静态实例,并初始化为nil。 &lt;/li&gt;
&lt;li&gt;创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类的实例&lt;/li&gt;
&lt;li&gt;实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和初始化对象时,不会产 生另一个对象。&lt;br&gt;&lt;code&gt;@interface MJSoundTool : NSObject&amp;lt;NSCopying&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;覆盖release、autorelease、retain、retainCount方法, 以此确保单例的状态。 &lt;/li&gt;
&lt;li&gt;在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实例被正确的创建和初始化。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;&lt;p&gt;作用：间接通过字符串类型的key取出对应的属性值&lt;br&gt;字典中key必须和模型的属性名称一模一样&lt;br&gt;    &lt;code&gt;self.answer = dic[@&amp;quot;answer&amp;quot;];&lt;/code&gt;等价于：&lt;br&gt;    &lt;code&gt;[self setValue:dict[@&amp;quot;answer&amp;quot;] forKeyPath:@&amp;quot;answer&amp;quot;];&lt;/code&gt;&lt;br&gt;一句话：&lt;br&gt;    &lt;code&gt;[self setValuesForKeysWithDictionary:dict];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;keyPath包含了key的功能&lt;br&gt;key：只能访问当前对象的属性&lt;br&gt;keyPath：能利用运算符一层一层往内部访问属性  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;键值编码（key-value coding）是一种间接更改对象状态的方式。通过传入的字符串（key）查找要更改的对象的状态。查找的规则是，先查找以字符串（key）命名的getter和setter方法。如果没有找到对应的方法，再查找key和_key的实例变量。KVC 是字典转模型，模型转字典的神器  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KVC中基本调用的两个方法：&lt;br&gt;valueForKey:&lt;br&gt; &lt;code&gt;NSString *name = [self.studentModel valueForKey:@&amp;quot;name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKey:&lt;br&gt; &lt;code&gt;[self.studentModel setValue:@&amp;quot;李四&amp;quot; forKey:@&amp;quot;name&amp;quot;];&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于标量值，会自动进行装箱和拆箱。&lt;br&gt;使用键路径：&lt;br&gt;valueForKeyPath:&lt;br&gt; &lt;code&gt;NSString *phone = [self.schoolModel valueForKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKeyPath:&lt;br&gt; &lt;code&gt;[self.schoolModel setValue:@&amp;quot;初三五班&amp;quot; forKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;p&gt;作用：属性监听&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVO.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;讲解&lt;/strong&gt;：&lt;a href=&quot;http://www.jianshu.com/p/0492b841b500&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/0492b841b500&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/8f83f592a354#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/8f83f592a354#&lt;/a&gt;&lt;br&gt;内部实现原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KVO是基于runtime机制实现的&lt;/li&gt;
&lt;li&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。&lt;br&gt;派生类在被重写的 setter 方法实现真正的通知机制（Person-&amp;gt;NSKVONotifying_Person）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Foundation&quot;&gt;&lt;a href=&quot;#Foundation&quot; class=&quot;headerlink&quot; title=&quot;Foundation&quot;&gt;&lt;/a&gt;Foundation&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否可以把比较耗时的操作放在NSNotificationCenter中&lt;br&gt;如果在异步线程发的通知，那么可以执行比较耗时的操作；&lt;br&gt;如果在主线程发的通知，那么就不可以执行比较耗时的操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Foundation对象与Core Foundation对象有什么区别  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Foundation对象是OC的，Core Foundation对象是C对象&lt;/li&gt;
&lt;li&gt;数据类型之间的转换&lt;br&gt;ARC:&lt;strong&gt;__bridge_retained&lt;/strong&gt;,&lt;strong&gt;__bridge_transfer&lt;/strong&gt;&lt;br&gt;非ARC:&lt;strong&gt;__bridge&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不用中间变量,用两种方法交换A和B的值&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B7%A7%E4%BA%A4%E6%8D%A2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;或者使用&lt;strong&gt;位运算符&lt;/strong&gt;异或&lt;br&gt;A = A^B;&lt;br&gt;B = A^B;&lt;br&gt;A = A^B;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否使用Core Text（核心文本（富文本））或者Core Image等？如果使用过，请谈谈你使用Core Text或者Core Image的体验。&lt;br&gt;Core Text：随意修改文本的样式，图文混排(纯C语言)第三方框架:Niumb（国外）&lt;br&gt;Core Image(滤镜处理框架)： 能调节图片的各种属性(对比度, 色温, 色差等)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;controllers间怎么进行通信。&lt;br&gt;在IOS应用不断的出现三种模式来实现这种通信：（可以做到监听）&lt;ul&gt;
&lt;li&gt;委托delegation代理；（一个controller定义了一个协议（一对一）监听scroll的滚动，使用安全，比较规范，但是代码多，先用协议-&amp;gt;代理属性-&amp;gt;设置代理-&amp;gt;实现代理方法）&lt;/li&gt;
&lt;li&gt;通知中心Notification Center；(通知比较灵活(1个通知能被多个对象接收, 1个对象能接收多个通知(多对多)，监听键盘弹出)&lt;/li&gt;
&lt;li&gt;键值观察key value observing，KVO(KVO性能不好(底层会动态产生新的类)，只能监听某个对象属性的改变, 不推荐使用(1个对象的属性能被多个对象监听(一对多)监听对象属性的改变)&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/dqjyong/article/details/7685933&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/dqjyong/article/details/7685933&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是runtime？&lt;br&gt;1&amp;gt; runtime是一套比较底层的纯C语言API, 属于1个C语言库&lt;br&gt;2&amp;gt; 平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者&lt;br&gt;3&amp;gt; 举例:&lt;br&gt;OC：&lt;code&gt;[[Person alloc] init]&lt;/code&gt;&lt;br&gt;runtime: &lt;code&gt;objc_msgSend(objc_msgSend(&amp;quot;Person&amp;quot; , &amp;quot;alloc&amp;quot;), &amp;quot;init&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有什么用？&lt;br&gt;runtime是属于OC的底层, 可以进行一些非常底层的操作。&lt;br&gt;1&amp;gt; 在程序运行过程中，动态创建一个类（比如KVO的底层实现）&lt;br&gt;2&amp;gt; 在程序运行过程中，动态的为某个类添加属性\方法，修改属性\方法.&lt;br&gt;3&amp;gt; 遍历一个类的所有的成员变量(属性)\方法  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的头文件：&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt; : 成员变量、类、方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/message.h&amp;gt;: 消息机制&lt;/code&gt;&lt;br&gt; 常见的方法：&lt;br&gt; &lt;code&gt;Ivar class_copyIvarList : 获得某个类内部的所有成员变量&lt;/code&gt;（Ivar是成员变量）&lt;br&gt; &lt;code&gt;Method * class_copyMethodList : 获得某个类内部的所有方法&lt;/code&gt; （Method是成员方法）&lt;br&gt; &lt;code&gt;Method class_getInstanceMethod: 获得某个实例方法（对象方法，减号-开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getClassMethod : 获得某个类方法（加号+开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;method_exchangeImplementations : 交换2个方法的具体实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;objc_msgSend(....)：给对象发送消息&lt;/code&gt;&lt;br&gt;相关应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSCoding(利用runtime遍历模型对象的所有属性来归档和解档）&lt;/li&gt;
&lt;li&gt;字典–&amp;gt;模型（利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）&lt;/li&gt;
&lt;li&gt;KVO（利用runtime动态产生一个类）&lt;ul&gt;
&lt;li&gt;用于封装框架（想怎么改就怎么改）&lt;br&gt;示例第一种应用：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;h1 id=&quot;UI&quot;&gt;&lt;a href=&quot;#UI&quot; class=&quot;headerlink&quot; title=&quot;UI&quot;&gt;&lt;/a&gt;UI&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍一下isa指针,怎么用？&lt;br&gt;每一个对象内部都有一个ISA指针，对象的ISA指针就指向它的真实类型它所属的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;控制器的生命周期&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%89%AF%E6%9C%AC.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;怎么解决缓存池满的问题(cell)&lt;br&gt;ios中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会再创建新对象。缓存池里最多也就一两个对象（缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放）&lt;/li&gt;
&lt;li&gt;如何渲染自定义格式字符串的UILabel?&lt;br&gt;通过NSAttributedString类&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UILabel.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;显示效果如下：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/label%E6%98%BE%E7%A4%BA.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;IOS7之前,后台执行内容有几种形式,都是什么？&lt;br&gt;一般的应用在进入后台的时候可以获取一定时间来运行相关任务，也就是说可以在后台运行一小段时间(10S左右)。&lt;ul&gt;
&lt;li&gt;后台播放音乐&lt;/li&gt;
&lt;li&gt;后台GPS跟踪&lt;/li&gt;
&lt;li&gt;后台voip支持（网络电话）&lt;/li&gt;
&lt;li&gt;7以后查看，在Support Interface orientations中添加Requried background modes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;APP的启动过程,从main文件开始说起&lt;br&gt;程序启动分为两类:&lt;br&gt;1&amp;gt;有storyboard&lt;ul&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain(创建UIApplication对象,创建UIApplication的delegate对象)&lt;/li&gt;
&lt;li&gt;根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(创建UIWindow,创建和设置UIWindow的rootViewController,显示窗口)&lt;br&gt;2&amp;gt;没有storyboard情况下:&lt;/li&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain（创建UIApplication对象，创建UIApplication的delegate对象）&lt;/li&gt;
&lt;li&gt;delegate对象开始处理(监听)系统事件(没有storyboard)&lt;br&gt;程序启动完毕的时候, 就会调用代理的&lt;br&gt;&lt;code&gt;application:didFinishLaunchingWithOptions:方法&lt;/code&gt;&lt;br&gt;&lt;code&gt;在application:didFinishLaunchingWithOptions:中创建UIWindow&lt;/code&gt;&lt;br&gt;创建和设置UIWindow的rootViewController&lt;br&gt;显示窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把程序自己关掉和程序进入后台,远程推送的区别&lt;br&gt;1&amp;gt;关掉后不执行任何代码, 不能处理事件&lt;br&gt;2&amp;gt;应用程序进入&lt;strong&gt;后台状态&lt;/strong&gt;不久后转入&lt;strong&gt;挂起状态&lt;/strong&gt;。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。只有当用户再次运行此应用，应用才会从挂起状态唤醒，代码得以继续执行&lt;br&gt;3&amp;gt;或者进入后台时开启多任务状态，保留在内存中，这样就可以&lt;br&gt;执行系统允许的动作&lt;br&gt;4&amp;gt;远程推送是由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序,当应用程序收到推送的消息会自动调用特定的方法执行事先写好的代码&lt;/li&gt;
&lt;li&gt;本地通知和远程推送通知对基本概念和用法？&lt;br&gt;本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.&lt;br&gt;本地通知由本应用负责调用,只能从当前设备上的iOS发出&lt;br&gt;远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;h1 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;客户端安全性处理方式？&lt;ul&gt;
&lt;li&gt;网络数据传输(敏感数据[账号\密码\消费数据\银行卡账号], 不能明文发送)&lt;/li&gt;
&lt;li&gt;协议的问题(自定义协议, 游戏代练)&lt;/li&gt;
&lt;li&gt;本地文件存储(游戏的存档)&lt;/li&gt;
&lt;li&gt;源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sip是什么？&lt;br&gt;SIP（Session Initiation Protocol），会话发起协议&lt;br&gt;SIP是建立VOIP连接的 IETF 标准，IETF是全球互联网最具权威的技术标准化组织.&lt;br&gt;所谓VOIP，就是网络电话，直接用互联网打电话，不用耗手机话费.&lt;/li&gt;
&lt;li&gt;有些图片加载的比较慢怎么处理?你是怎么优化程序的性能的?&lt;br&gt;图片下载放在异步线程;&lt;br&gt;图片下载过程中使用占位图片;&lt;br&gt;如果图片较大，可以考虑多线程断点下载.&lt;/li&gt;
&lt;li&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;ul&gt;
&lt;li&gt;提供给外界的接口功能是否实用、够用&lt;/li&gt;
&lt;li&gt;别人使用我的框架时，能不能根据类名、方法名就猜出接口的具体作用&lt;/li&gt;
&lt;li&gt;别人调用接口时，提供的参数是否够用、调用起来是否简单&lt;/li&gt;
&lt;li&gt;别人使用我的框架时，要不要再导入依赖其他的框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;App需要加载超大量的数据，给服务器发送请求，但是服务器卡住了如何解决？  &lt;ul&gt;
&lt;li&gt;设置请求超时&lt;/li&gt;
&lt;li&gt;给用户提示请求超时&lt;/li&gt;
&lt;li&gt;根据用户操作再次请求数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;json解析的具体实现&lt;br&gt;SBJson&lt;br&gt;JSONKit&lt;br&gt;NSJSONSerialization&lt;/li&gt;
&lt;li&gt;如果在网络数据处理过程中,发现一处比较卡,一般怎么解决？&lt;br&gt;检查网络请求操作是否被放在主线程了&lt;br&gt;看看异步请求的数量是否太多了（子线程数量）&lt;br&gt;数据量是否太大？如果太大，先清除一些不必要的对象（看不见的数据、图片）&lt;br&gt;手机CPU使用率和内存问题&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS面试" scheme="http://peilinghui.com/categories/iOS%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OC" scheme="http://peilinghui.com/tags/OC/"/>
    
      <category term="iOS面试" scheme="http://peilinghui.com/tags/iOS%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS中的autolayout</title>
    <link href="http://peilinghui.com/2016/02/28/%E5%85%B3%E4%BA%8EiOS%E4%B8%AD%E7%9A%84autolayout/"/>
    <id>http://peilinghui.com/2016/02/28/关于iOS中的autolayout/</id>
    <published>2016-02-28T14:04:07.000Z</published>
    <updated>2016-03-06T13:31:25.000Z</updated>
    
    <content type="html">&lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;a href=&quot;#autolayout在Storyboard中的使用&quot; class=&quot;headerlink&quot; title=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;/a&gt;autolayout在Storyboard中的使用&lt;/h2&gt;&lt;h2 id=&quot;三个练习：&quot;&gt;&lt;a href=&quot;#三个练习：&quot; class=&quot;headerlink&quot; title=&quot;三个练习：&quot;&gt;&lt;/a&gt;三个练习：&lt;/h2&gt;&lt;h3 id=&quot;1-练习1&quot;&gt;&lt;a href=&quot;#1-练习1&quot; class=&quot;headerlink&quot; title=&quot;1.练习1&quot;&gt;&lt;/a&gt;1.练习1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在控制器view底部添加2个view，1个蓝色，1个红色
2个view宽度、高度永远相等
距离父控件左边、右边、下边间距和2个view之间的间距相等  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E7%AD%94%E6%A1%88.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;就是设置蓝色View的左边和下边和右边(相对于红色view)，设置红色view的右边和下边，选中俩个，再设置equal width和height，或者是设置顶部对齐和底部对齐。     &lt;/p&gt;
&lt;h3 id=&quot;练习2&quot;&gt;&lt;a href=&quot;#练习2&quot; class=&quot;headerlink&quot; title=&quot;练习2&quot;&gt;&lt;/a&gt;练习2&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在控制器view顶部添加2个view，1个蓝色，1个红色
2个view高度永远相等,等于50
红色view和蓝色view右边对齐
蓝色view距离父控件左边、右边、上边间距相等,等于30
蓝色view距离红色view间距固定,等于30
红色view的左边和父控件的中点对齐
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%AD%94%E6%A1%882.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E7%AD%94%E6%A1%88.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;练习3&quot;&gt;&lt;a href=&quot;#练习3&quot; class=&quot;headerlink&quot; title=&quot;练习3&quot;&gt;&lt;/a&gt;练习3&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E7%AD%94%E6%A1%88.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;理解垂直居中和水平居中，还有左对齐，右对齐，底部顶部对齐，利用公式：Superview.center Y = Button center Y * 1 -constant &lt;/p&gt;
&lt;h1 id=&quot;代码实现Autolayout&quot;&gt;&lt;a href=&quot;#代码实现Autolayout&quot; class=&quot;headerlink&quot; title=&quot;代码实现Autolayout&quot;&gt;&lt;/a&gt;代码实现Autolayout&lt;/h1&gt;&lt;h3 id=&quot;1-代码实现Autolayout的步骤&quot;&gt;&lt;a href=&quot;#1-代码实现Autolayout的步骤&quot; class=&quot;headerlink&quot; title=&quot;1.代码实现Autolayout的步骤&quot;&gt;&lt;/a&gt;1.代码实现Autolayout的步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;利用NSLayoutConstraint类创建具体的约束对象&lt;br&gt;一个NSLayoutConstraint对象就代表一个约束&lt;br&gt;创建约束对象的常用方法&lt;br&gt;&lt;code&gt;+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;&lt;/code&gt;&lt;br&gt; view1 ：要约束的控件&lt;br&gt; attr1 ：约束的类型（做怎样的约束）&lt;br&gt; relation ：与参照控件之间的关系&lt;br&gt; view2 ：参照的控件&lt;br&gt; attr2 ：约束的类型（做怎样的约束）&lt;br&gt; multiplier ：乘数&lt;br&gt; c ：常量&lt;br&gt; 自动布局有个核心公式&lt;br&gt;obj1.property1 =（obj2.property2 * multiplier）+ constant value&lt;/li&gt;
&lt;li&gt;添加约束对象到相应的view上&lt;br&gt;&lt;code&gt;- (void)addConstraint:(NSLayoutConstraint *)constraint;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)addConstraints:(NSArray *)constraints;&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;VFL语言实现layout&quot;&gt;&lt;a href=&quot;#VFL语言实现layout&quot; class=&quot;headerlink&quot; title=&quot;VFL语言实现layout&quot;&gt;&lt;/a&gt;VFL语言实现layout&lt;/h1&gt;&lt;p&gt;1.VFL全称是Visual Format Language，翻译过来是“可视化格式语言”&lt;br&gt;VFL是苹果公司为了简化Autolayout的编码而推出的抽象语言。&lt;/p&gt;
&lt;p&gt;2.使用VFL来创建约束数组&lt;br&gt;&lt;code&gt;+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;&lt;/code&gt;&lt;br&gt;format ：VFL语句&lt;br&gt;opts ：约束类型&lt;br&gt;metrics ：VFL语句中用到的具体数值&lt;br&gt;views ：VFL语句中用到的控件&lt;br&gt;VFL示例：&lt;br&gt;H:[cancelButton(72)]-12-[acceptButton(50)]&lt;br&gt;canelButton宽72，acceptButton宽50，它们之间间距12 &lt;/p&gt;
&lt;p&gt;3.创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义&lt;br&gt;NSDictionaryOfVariableBindings(…)  &lt;/p&gt;
&lt;h1 id=&quot;Masonry&quot;&gt;&lt;a href=&quot;#Masonry&quot; class=&quot;headerlink&quot; title=&quot;Masonry&quot;&gt;&lt;/a&gt;Masonry&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.概念&quot;&gt;&lt;/a&gt;1.概念&lt;/h2&gt;&lt;p&gt; Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。  &lt;/p&gt;
&lt;h2 id=&quot;2-框架下载地址：&quot;&gt;&lt;a href=&quot;#2-框架下载地址：&quot; class=&quot;headerlink&quot; title=&quot;2.框架下载地址：&quot;&gt;&lt;/a&gt;2.框架下载地址：&lt;/h2&gt;&lt;p&gt;   &lt;a href=&quot;https://github.com/Masonry/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Masonry/Masonry&lt;/a&gt;  &lt;/p&gt;
&lt;h2 id=&quot;3-Masonry介绍与使用实践-快速上手Autolayout&quot;&gt;&lt;a href=&quot;#3-Masonry介绍与使用实践-快速上手Autolayout&quot; class=&quot;headerlink&quot; title=&quot;3.Masonry介绍与使用实践(快速上手Autolayout)&quot;&gt;&lt;/a&gt;3.Masonry介绍与使用实践(快速上手Autolayout)&lt;/h2&gt;&lt;p&gt;  &lt;a href=&quot;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&lt;/a&gt;   &lt;/p&gt;
&lt;h2 id=&quot;4-案例讲解：&quot;&gt;&lt;a href=&quot;#4-案例讲解：&quot; class=&quot;headerlink&quot; title=&quot;4.案例讲解：&quot;&gt;&lt;/a&gt;4.案例讲解：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-使用方法：&quot;&gt;&lt;a href=&quot;#5-使用方法：&quot; class=&quot;headerlink&quot; title=&quot;5.使用方法：&quot;&gt;&lt;/a&gt;5.使用方法：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.ios122.com/2015/09/masonry/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ios122.com/2015/09/masonry/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用方法：&quot;&gt;&lt;a href=&quot;#常用方法：&quot; class=&quot;headerlink&quot; title=&quot;常用方法：&quot;&gt;&lt;/a&gt;常用方法：&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.三个添加约束方法区别
mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错
mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况
mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束
三种函数善加利用 就可以应对各种情况了

2、两个赋值方法区别（equalTo 和 mas_equalTo）
#define equalTo(...)  mas_equalTo(__VA_ARGS__)
#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) 
mas_equalTo对其参数进行了一个自动装箱操作， 除了支持NSNumber数值类型之外还支持CGPoint CGSize UIEdgeInsets
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;基于Autolayout的动画&quot;&gt;&lt;a href=&quot;#基于Autolayout的动画&quot; class=&quot;headerlink&quot; title=&quot;基于Autolayout的动画&quot;&gt;&lt;/a&gt;基于Autolayout的动画&lt;/h1&gt;&lt;p&gt;在修改了约束之后，只要执行下面代码，就能做动画效果&lt;br&gt;&lt;code&gt;[UIView animateWithDuration:1.0 animations:^{
    添加了约束的view layoutIfNeeded];
}];&lt;/code&gt;&lt;br&gt;参考学习：&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS学习笔记" scheme="http://peilinghui.com/categories/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="autolayout" scheme="http://peilinghui.com/tags/autolayout/"/>
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>创建博客</title>
    <link href="http://peilinghui.com/2016/02/25/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://peilinghui.com/2016/02/25/创建博客/</id>
    <published>2016-02-25T07:21:14.000Z</published>
    <updated>2016-03-09T14:39:00.000Z</updated>
    
    <content type="html">&lt;p&gt;偶然发现大家（周围厉害的同学）还有网上的各种大牛都有属于自己的博客，记录自己的学习历程，然后自己也开始探索搭建博客的历程.  &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;最初搭建了一个Octopress+Github Page的博客，开始就使用的最初的主题，就如图所示：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/octopress%E6%9C%80%E5%88%9D.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;然后就开始逛其他人的博客，发现大家博客的主题都好好看，瞬间觉得自己该换个主题了，然后发现了octopress的&lt;a href=&quot;https://github.com/tommy351/Octopress-Theme-Slash&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;slash主题&lt;/a&gt;然后弄完的样子就是下面如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/slash%E4%B8%BB%E9%A2%98.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看起来比系统自带的主题好看多了，是吧！  &lt;/p&gt;
&lt;p&gt;当然，在网上逛别人的博客的时候，看到很多博客的主题都是作者自己写的，还有一个自学前端的97年的男生自己搭建了一个网站，还看到看到一个96年的搭建的博客简直炫酷，瞬间计算机这个东西完全靠兴趣啊！然后开始模仿&lt;a href=&quot;http://kittenyang.com/myfirstblog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kitten&lt;/a&gt;的这篇文章开始了ghost博客之旅，他是在阿里云服务器ECS和Ubuntu系统上安装Ghost博客，开始我想mac和Ubuntu差不多就开始在mac下搞，然后我就去Godaddy（狗爹）上买了二级域名，租了个阿里云服务器，mac上可以显示如图：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/ghost%E5%88%9D%E5%A7%8B%E5%8D%9A%E5%AE%A2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;然后发现其实mac和Ubuntu还是差别挺大的，比如mac上就没有apt-get这个命令，瞬间那个心情。。。自己挖的坑还的要自己填啊！然后就在我那台win10系统上又装了Ubuntu系统，本来是弄得双系统，估计在装的时候选错了，然后就发现win10不见了，555~，然后在Ubuntu下还是没有配置成功。。。真是辛酸泪啊！租的服务器也不会用额。。。。&lt;/p&gt;
&lt;p&gt;然后发现更多的人使用的是Hexo+Github Page,而且网上有关hexo的学习资料还是很多的，于是我就决定转向hexo了。而且hexo写博文很方便也支持markdown,而且主题很多，也很炫酷，就开始了hexo的博客之旅。&lt;br&gt;对于搭建博客，然后在知乎的一篇文章上看到了&lt;a href=&quot;https://www.zhihu.com/question/24422335&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo的主题&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(iissnan/hexo-theme-next · GitHub,  470)&lt;/a&gt;  这个是next主题，我同学好几个都是用这个主题的。 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(litten/hexo-theme-yilia, 265)&lt;/a&gt;  然后就是我现在用的这个主题。  &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://yangjian.me/pacman/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(A-limon/pacman, 243)&lt;/a&gt;这个主题也挺经典的。（吃豆子）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xiangming/landscape-plus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;(xiangming/landscape-plus, 147)&lt;/a&gt;优化hexo官方主题landscape。&lt;br&gt;还有很多主题呢！有时间再去尝试一下吧！    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参考： 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Octopress：&lt;br&gt;&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/18/octopressbo-ke-da-jian/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cnbin.github.io/blog/2015/05/18/octopressbo-ke-da-jian/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e208ade30f08&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e208ade30f08&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/imathis/octopress/wiki/Octopress-Sites&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/imathis/octopress/wiki/Octopress-Sites&lt;/a&gt;&lt;br&gt;ghost:&lt;br&gt;&lt;a href=&quot;http://jas0n.me/2014/12/05/ghost_blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jas0n.me/2014/12/05/ghost_blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22755373&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/22755373&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://kittenyang.com/myfirstblog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://kittenyang.com/myfirstblog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zhihu.com/question/22755373&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/22755373&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://snowz.me/how-to-install-ghost/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://snowz.me/how-to-install-ghost/&lt;/a&gt;&lt;br&gt;hexo:&lt;br&gt;&lt;a href=&quot;http://ibruce.info/2013/11/22/hexo-your-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ibruce.info/2013/11/22/hexo-your-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://iread.io/archives/page/2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://iread.io/archives/page/2/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.shijinrong.cn/2016/01/03/2016-01-03-how-to-build-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://dearb.me/archive/2015-05-10/use-hexo-build-your-own-blog/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://zipperary.com/categories/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zipperary.com/categories/hexo/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://lucifr.com/2013/01/02/from-octopress-to-hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://lucifr.com/2013/01/02/from-octopress-to-hexo/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;最后来几个我同学的博客地址：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;a href=&quot;http://blog.xuanzhangjiong.xyz/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;囧囧囧-网易大神&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ios大神-人生大赢家-网易&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://sunus.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阿里学长&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.changhuiyuan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;惠源&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://www.hxdavid.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PAT大神&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://longliqiang88.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;龙哥-云计算&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://pangjiuzala.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;北大兴爷-大数据&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://imhuchao.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;胡超-凤凰网&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://lysongzi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;小松子&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://cspilgrimzww.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;蔚蔚&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;http://han.pm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;大数据的英国交换生&lt;/a&gt; &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;偶然发现大家（周围厉害的同学）还有网上的各种大牛都有属于自己的博客，记录自己的学习历程，然后自己也开始探索搭建博客的历程.  &lt;/p&gt;
    
    </summary>
    
      <category term="创建博客" scheme="http://peilinghui.com/categories/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Octopress" scheme="http://peilinghui.com/tags/Octopress/"/>
    
      <category term="ghost" scheme="http://peilinghui.com/tags/ghost/"/>
    
      <category term="hexo" scheme="http://peilinghui.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://peilinghui.com/2016/02/25/git%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/02/25/git学习/</id>
    <published>2016-02-25T04:21:14.000Z</published>
    <updated>2016-02-29T06:27:21.000Z</updated>
    
    <content type="html">&lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h1 id=&quot;本地&quot;&gt;&lt;a href=&quot;#本地&quot; class=&quot;headerlink&quot; title=&quot;本地&quot;&gt;&lt;/a&gt;本地&lt;/h1&gt;&lt;h2 id=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;a href=&quot;#git的配置，邮箱地址和用户名&quot; class=&quot;headerlink&quot; title=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;/a&gt;git的配置，邮箱地址和用户名&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置邮箱&lt;/strong&gt;&lt;br&gt;$ git config –global user.email “799745776@qq.com”  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置用户名&lt;/strong&gt;&lt;br&gt;$ git config –global user.name “plh”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看当前的配置&lt;/strong&gt;&lt;br&gt;$ cat .git/config&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;git命令&quot;&gt;&lt;a href=&quot;#git命令&quot; class=&quot;headerlink&quot; title=&quot;git命令&quot;&gt;&lt;/a&gt;git命令&lt;/h2&gt;&lt;h3 id=&quot;初始化一个Git仓库使用&quot;&gt;&lt;a href=&quot;#初始化一个Git仓库使用&quot; class=&quot;headerlink&quot; title=&quot;初始化一个Git仓库使用&quot;&gt;&lt;/a&gt;初始化一个Git仓库使用&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;添加文件到Git仓库&quot;&gt;&lt;a href=&quot;#添加文件到Git仓库&quot; class=&quot;headerlink&quot; title=&quot;添加文件到Git仓库&quot;&gt;&lt;/a&gt;添加文件到Git仓库&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;放在暂缓区的命令&lt;/strong&gt;&lt;br&gt;$ git add .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地提交仓库&lt;/strong&gt;&lt;br&gt;$ git commit -m “提交代码”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$ git push origin master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;br&gt;$ git staus&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新本地代码&lt;/strong&gt;&lt;br&gt;$ git pull&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示当前分支的版本历史&lt;/strong&gt;&lt;br&gt;$ git log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前一个版本&lt;/strong&gt;&lt;br&gt;git reset –hard HEAD^  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前两个版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD^^ &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前 N 版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD~N  &lt;/p&gt;
&lt;!--N 是数字--&gt; 
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复指定版本&lt;/strong&gt;&lt;br&gt;$ (git lg) git reset –hard 版本号 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看指令使用历史，确定要回到未来的哪个版本&lt;/strong&gt;&lt;br&gt;$ git reflog&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看所有本地分支&lt;/strong&gt;&lt;br&gt;$ git branch  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列出所有远程分支&lt;/strong&gt;&lt;br&gt;$ git branch -r&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建分支&lt;/strong&gt;&lt;br&gt;$ git branch name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切换分支&lt;/strong&gt;&lt;br&gt;$ git checkout name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;合并分支&lt;/strong&gt;&lt;br&gt;$  git merge name &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除分支&lt;/strong&gt;&lt;br&gt;$ git branch -d name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除远程分支&lt;/strong&gt;&lt;br&gt;$ git push origin –delete name&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$ git branch -dr [remote/branch]&lt;/p&gt;
&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git rm 文件名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;远程&quot;&gt;&lt;a href=&quot;#远程&quot; class=&quot;headerlink&quot; title=&quot;远程&quot;&gt;&lt;/a&gt;远程&lt;/h2&gt;&lt;h3 id=&quot;创建SSH-Key&quot;&gt;&lt;a href=&quot;#创建SSH-Key&quot; class=&quot;headerlink&quot; title=&quot;创建SSH Key&quot;&gt;&lt;/a&gt;创建SSH Key&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh-keygen -t rsa -C &lt;span class=&quot;string&quot;&gt;&quot;youremail@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;从远程库克隆&quot;&gt;&lt;a href=&quot;#从远程库克隆&quot; class=&quot;headerlink&quot; title=&quot;从远程库克隆&quot;&gt;&lt;/a&gt;从远程库克隆&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; git@github.com:.......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;远程同步&quot;&gt;&lt;a href=&quot;#远程同步&quot; class=&quot;headerlink&quot; title=&quot;远程同步&quot;&gt;&lt;/a&gt;远程同步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;下载远程仓库的所有变动&lt;/strong&gt;&lt;br&gt;$ git fetch [remote] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示所有远程仓库&lt;/strong&gt;&lt;br&gt;$ git remote -v&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示某个远程仓库的信息&lt;/strong&gt;&lt;br&gt;$ git remote show [remote]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加一个新的远程仓库，并命名&lt;/strong&gt;&lt;br&gt;$ git remote add [shortname] [url]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;取回远程仓库的变化，并与本地分支合并&lt;/strong&gt;&lt;br&gt;$ git pull [remote] [branch] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;上传本地指定分支到远程仓库&lt;/strong&gt;&lt;br&gt;$  git push [remote] [branch]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;强行推送当前分支到远程仓库，即使有冲突&lt;/strong&gt;&lt;br&gt;$ git push [remote] –force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;推送所有分支到远程仓库&lt;/strong&gt;&lt;br&gt;$ git push [remote] –all &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h2&gt;&lt;h3 id=&quot;显示本地git库：&quot;&gt;&lt;a href=&quot;#显示本地git库：&quot; class=&quot;headerlink&quot; title=&quot;显示本地git库：&quot;&gt;&lt;/a&gt;显示本地git库：&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;隐藏本地git库&quot;&gt;&lt;a href=&quot;#隐藏本地git库&quot; class=&quot;headerlink&quot; title=&quot;隐藏本地git库&quot;&gt;&lt;/a&gt;隐藏本地git库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://peilinghui.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://peilinghui.com/tags/git/"/>
    
  </entry>
  
</feed>
