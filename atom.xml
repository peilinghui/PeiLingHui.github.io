<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2017-08-17T15:01:28.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-native重构项目中所遇到的坑</title>
    <link href="http://peilinghui.com/2017/08/10/React-native%E9%87%8D%E6%9E%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://peilinghui.com/2017/08/10/React-native重构项目中所遇到的坑/</id>
    <published>2017-08-10T04:46:45.000Z</published>
    <updated>2017-08-17T15:01:28.000Z</updated>
    
    <content type="html">&lt;p&gt;在上一篇中写道了在开发RN的时候所需用的常用开源组件。这一篇就写一下开发历程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;整个项目的逻辑大概就是： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建项目，导入项目的图片资源，APP的图标，启动图，ios的启动图在Xcode中直接设置Launch Image和icon，对于安卓的启动图要写代码实现才行。对于项目的图片资源，可以两套系统共用一套图片那就可以放在一个文件夹下，引入的时候用相对路径导入；也可以放在Xcode或者是Android Studio中进行uri:+图片名称导入。&lt;/li&gt;
&lt;li&gt;用上一篇的第三方组件和一些基本组件大概完成了一些页面，完成了登录，手势解锁页，还有主页面的框架和主页面中一些子页面的大体显示。接下来遇到的问题大概有两个：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一：如何跳转，把这个页面都串起来，就像一些珠子如何才能串成一串：导航的使用：Navigator已经废弃，就要使用react-naviagtion来导航。&lt;/p&gt;
&lt;p&gt;第二：如何进行数据处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;是如何从服务器获取数据.&lt;/li&gt;
&lt;li&gt;是如何把从服务器获取的数据进行持久化存储。&lt;/li&gt;
&lt;li&gt;如何在页面间进行参数的传递&lt;br&gt;对于数据的处理也是难点。&lt;br&gt;首先对于网络请求要用fetch，&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;遇到的相关问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取设备ID：用第三方库，补充：JS中如何把字符串中的?替换为&amp;amp;:&lt;br&gt;&lt;code&gt;var str_replaced = str.replace(/\?/g,&amp;quot;&amp;amp;&amp;quot;);//加g就是替换所有的？号&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;React-Natvie用RSA加密用户的密码:&lt;br&gt;&lt;a href=&quot;https://github.com/z-hao-wang/react-native-rsa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native-rsa&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rzcoder/node-rsa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-rsa&lt;/a&gt;&lt;br&gt;虽然有这些第三方库，但是我并没有用，这个简直搞到我头大，终于搞定了！&lt;br&gt;主要是参照这两个网址：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/Grart/p/5080228.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/Grart/p/5080228.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;node-rsa的基础库&lt;/strong&gt;&lt;a href=&quot;http://www-cs-students.stanford.edu/~tjw/jsbn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www-cs-students.stanford.edu/~tjw/jsbn/&lt;/a&gt;&lt;br&gt;因为密码需要先用公钥RSA加密，然后在用base64加密，加密以后的字符串传给服务器，服务器那边再先base64解密，然后再用私钥解密。&lt;br&gt;在使用的时候最大的问题就是你要传一个N和E的参数来setPublic，这个问题困扰了我一天之久，终于后端的同学帮我搞定了，Java里面有方法可以根据已有的公钥来逆向出N和E的值，然后再使用下面的那个网页，网页，没错，就是下载下来那个网页，然后就有基本的JS文件了，其实RN就是JS，只怪自己前端不佳，然后把JS文件转化成RN可以用的JS组件库导入直接调用就可以加密成功了！终于加密成功了。感动哭。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置假数据显示一般来说都是容易的，与后台交互就需要用网络请求了。一般是GET和POST请求。POST的请求头：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般常见的网络请求：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; login=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;data,doSuccess,doError&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fetch(&lt;span class=&quot;string&quot;&gt;&#39;http://&#39;&lt;/span&gt;+url+&lt;span class=&quot;string&quot;&gt;&#39;/login&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          method: &lt;span class=&quot;string&quot;&gt;&#39;POST&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          headers: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;Accept&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;application/json&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;application/json&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          body: &lt;span class=&quot;built_in&quot;&gt;JSON&lt;/span&gt;.stringify(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; response.json();&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .then(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resData&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        doSuccess(resData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .done();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而我们这个post请求头呢？是下面这样的。&lt;/p&gt;
&lt;figure class=&quot;highlight ocaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;&#39;Content&lt;/span&gt;-&lt;span class=&quot;type&quot;&gt;Type&#39;&lt;/span&gt;:&lt;span class=&quot;symbol&quot;&gt;&#39;application&lt;/span&gt;/x-www-form-urlencoded&#39;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般在post的body中是用：&lt;br&gt;{userName:this.state.userName,passWord:_pwd}这样的JSON传过去，再body: JSON.stringify(data)。。。&lt;br&gt;而我们这个呢？data是拼接起来的，我也是醉了，这我是用Charles发请求后才发现的，也是折腾了半天才明白的。也用postman还有终端httpie发现都可以请求成功，唯独用这个请求不到，后来就拼接了一下，成功了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSON.stringify(result);和JSON.parse(result)有什么区别啊？&lt;br&gt;用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript。&lt;br&gt;JSON.stringify将JavaScript对象转换为JSON文本，并将该JSON文本存储在字符串中。&lt;br&gt;JSON.parse将一串JSON文本转换成Javascript对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你在fetch请求后 .then((response)=&amp;gt; response.json())的时候就不用解析直接用.取。。。&lt;br&gt;当你在fetch请求后， .then((response) =&amp;gt; response.text())的时候就需要JSON.parse(result);&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初学者最容易犯错误的地方就是this指针了！！我是在导航跳转的时候意识到这个问题的。每个组件都是有props和states的。&lt;br&gt;子组件如何调用父组件：this.props。&lt;br&gt;父组件如何调用子组件：首先用属性ref给子组件取个名字吧，this.refs.名字.getDOMNode().&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从服务返回的JSON数据的解析，有些需要遍历一下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; brandata = &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;.dangqiAnalysisBrandList;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; brandeach=brandata.map((val) =&amp;gt; &amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; val[&#39;dangqiAnalysisList&#39;] &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中写道了在开发RN的时候所需用的常用开源组件。这一篇就写一下开发历程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative的常用组件</title>
    <link href="http://peilinghui.com/2017/07/27/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2017/07/27/ReactNative的常用组件/</id>
    <published>2017-07-27T02:16:21.000Z</published>
    <updated>2017-08-19T03:08:25.000Z</updated>
    
    <content type="html">&lt;p&gt;在开发RN的时候所需用的常用开源组件。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h1&gt;&lt;p&gt;刚开始开发的时候用的是Webstrom或者是Sublime，后来发现一个超级IDE：&lt;br&gt;&lt;a href=&quot;https://www.decoide.org/docs&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.decoide.org/docs&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除了官方文档的一些常用组件，还有一些在项目开发中的常用组件。&lt;/p&gt;
&lt;h1 id=&quot;常用组件&quot;&gt;&lt;a href=&quot;#常用组件&quot; class=&quot;headerlink&quot; title=&quot;常用组件&quot;&gt;&lt;/a&gt;常用组件&lt;/h1&gt;&lt;h2 id=&quot;获取设备相关信息&quot;&gt;&lt;a href=&quot;#获取设备相关信息&quot; class=&quot;headerlink&quot; title=&quot;获取设备相关信息&quot;&gt;&lt;/a&gt;获取设备相关信息&lt;/h2&gt;&lt;p&gt;设备deviceID：&lt;a href=&quot;https://github.com/rebeccahughes/react-native-device-info&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native-device-info&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;登录&quot;&gt;&lt;a href=&quot;#登录&quot; class=&quot;headerlink&quot; title=&quot;登录&quot;&gt;&lt;/a&gt;登录&lt;/h2&gt;&lt;p&gt;手势解锁：&lt;a href=&quot;https://github.com/spikef/react-native-gesture-password&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gesture-password&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面那个经过测试不好用,用这个：&lt;br&gt;&lt;strong&gt;大小手势解锁：&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/react-native-component/react-native-smart-gesture-password&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native-smart-gesture-password&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Touch id指纹解锁：&lt;a href=&quot;https://github.com/naoufal/react-native-touch-id&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;touch-id&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搜索框：&lt;a href=&quot;https://github.com/umhan35/react-native-search-bar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ios可以用的搜索框&lt;/a&gt;&lt;br&gt;&lt;strong&gt;好看的搜索Box：&lt;/strong&gt;：&lt;a href=&quot;&quot;&gt;react-native-search-box&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;导航&quot;&gt;&lt;a href=&quot;#导航&quot; class=&quot;headerlink&quot; title=&quot;导航&quot;&gt;&lt;/a&gt;导航&lt;/h2&gt;&lt;p&gt;底部tab组件：&lt;a href=&quot;https://github.com/happypancake/react-native-tab-navigator&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native-tab-navigator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;侧滑栏：&lt;/strong&gt;&lt;a href=&quot;https://github.com/react-native-community/react-native-side-menu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;side-Menu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顶部tab的滑动&lt;/strong&gt;：&lt;a href=&quot;https://github.com/skv-headless/react-native-scrollable-tab-view&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;scrollable-tab-view&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提示框toast：&lt;a href=&quot;https://github.com/magicismight/react-native-root-toast&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;toast&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下拉刷新组件 &lt;a href=&quot;https://github.com/jsdf/react-native-refreshable-listview&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/jsdf/react-native-refreshable-listview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;模态框 &lt;a href=&quot;https://github.com/brentvatne/react-native-modal&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/brentvatne/react-native-modal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;react-native-navbar &lt;a href=&quot;https://github.com/react-native-fellowship/react-native-navbar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/react-native-fellowship/react-native-navbar&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;下拉选择菜单：&lt;/strong&gt;&lt;a href=&quot;https://github.com/WheelerLee/react-native-dropdown-menu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dropdown-menu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;折线图，柱状图，条形图：&lt;a href=&quot;https://github.com/somonus/react-native-echarts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;react-native-echarts&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;日历&quot;&gt;&lt;a href=&quot;#日历&quot; class=&quot;headerlink&quot; title=&quot;日历&quot;&gt;&lt;/a&gt;日历&lt;/h1&gt;&lt;p&gt;发现超好用还好看的日历组件：&lt;a href=&quot;https://github.com/xgfe/react-native-datepicker&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;datepicker&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在开发RN的时候所需用的常用开源组件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS应用APP架构</title>
    <link href="http://peilinghui.com/2017/07/14/iOS%E5%BA%94%E7%94%A8APP%E6%9E%B6%E6%9E%84/"/>
    <id>http://peilinghui.com/2017/07/14/iOS应用APP架构/</id>
    <published>2017-07-14T02:54:01.000Z</published>
    <updated>2017-07-14T07:31:47.000Z</updated>
    
    <content type="html">&lt;p&gt;对于网络层的改造其实就相当于iOS应用的APP的架构了，然后就去查了相关的资料。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;发现几篇很好的博文：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/ios-app-arch-part-01?utm_source=infoq&amp;amp;utm_campaign=user_page&amp;amp;utm_medium=link&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS应用架构谈（一）：架构设计的方法论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/ios-app-arch-2-1?utm_source=infoq&amp;amp;utm_campaign=user_page&amp;amp;utm_medium=link&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS应用架构谈（二）：View层的组织和调用方案（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/ios-app-arch-3-1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS应用架构谈（三）：网络层设计方案(上)&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于网络层的改造其实就相当于iOS应用的APP的架构了，然后就去查了相关的资料。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络层的封装</title>
    <link href="http://peilinghui.com/2017/07/10/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://peilinghui.com/2017/07/10/iOS网络层的封装/</id>
    <published>2017-07-10T13:26:39.000Z</published>
    <updated>2017-07-13T09:44:38.000Z</updated>
    
    <content type="html">&lt;p&gt;对于项目的重构，很重要的就是对网络层的重构，其实也就是对AFN的二次封装。对于AFN的介绍在前一篇：&lt;a href=&quot;&quot;&gt;研究AFNetworking框架&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;AFN2.0是基于NSURLConnection封装的。而AFN3.0是基于NSURLSession封装的。(NSURLSession是iOS7推出的是为了取代NSURLConnection的)。&lt;/p&gt;
&lt;h1 id=&quot;关于AFN3-0&quot;&gt;&lt;a href=&quot;#关于AFN3-0&quot; class=&quot;headerlink&quot; title=&quot;关于AFN3.0&quot;&gt;&lt;/a&gt;关于AFN3.0&lt;/h1&gt;&lt;h2 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;客户端发给服务器的HTTP请求包含了：&lt;br&gt;&lt;strong&gt;请求行&lt;/strong&gt;：请求方法、请求资源路径、HTTP协议版本号&lt;br&gt;GET /index.htm HTTP/1.1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;请求头：&lt;/strong&gt;对客户端环境的描述，客户端请求的主机的地址。&lt;br&gt;HOST: 192.168.1.105：8080&lt;br&gt;User-Agent:MAC或者IPhone （客户端环境）&lt;br&gt;Accept：text/html   (客户端所能接受的数据类型)&lt;br&gt;Accept-Language：zh-cn   （客户端的语言）&lt;/p&gt;
&lt;p&gt;在POST中有&lt;strong&gt;请求体：&lt;/strong&gt;客户端发给服务器的具体数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器返回给客户端的HTTP响应包含了：（NSHTTPUELResponse）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;状态行：&lt;/strong&gt;协议版本、状态码、状态英文名称&lt;br&gt;HTTP/1.1 200 OK&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应头：&lt;/strong&gt;对服务器的描述、对返回数据的描述。&lt;br&gt;Server：Apache             （服务器）&lt;br&gt;Date: Sat,  22:07:00 GMT&lt;br&gt;Content-Length: 500      （返回数据长度）&lt;br&gt;Content-Type: text/html  (返回数据类型)  &lt;/p&gt;
&lt;p&gt;&lt;html&gt;…..&lt;/html&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体内容：&lt;/strong&gt;服务器返回给客户端的具体数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1436896-f274db501af46b86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2016-11-07 下午4.44.02.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GET与POST&lt;br&gt;GET：所有的请求参数都拼接在URL后面，如果访问资源，向服务器索要数据就是GET请求。URL长度有限，不能发送太多数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;POST：把所有请求参数放在请求体(HTTPBody)中，发给服务器的长度没有限制，&lt;br&gt;200：请求成功。 400：客户端请求的语法错误，服务器无法解析。&lt;br&gt;404：服务器无法根据客户端的请求找到资源。&lt;br&gt;500：服务器内部错误，无法完成请求。&lt;/p&gt;
&lt;p&gt;URL还要注意对中文的转码：&lt;br&gt;方法：&lt;code&gt;urlString = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何使用-NSURLSession-发出-HTTP-请求&quot;&gt;&lt;a href=&quot;#如何使用-NSURLSession-发出-HTTP-请求&quot; class=&quot;headerlink&quot; title=&quot;如何使用 NSURLSession 发出 HTTP 请求&quot;&gt;&lt;/a&gt;如何使用 NSURLSession 发出 HTTP 请求&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.得到session对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSURLSession&lt;/span&gt; *session = [&lt;span class=&quot;built_in&quot;&gt;NSURLSession&lt;/span&gt; sharedSession];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *url = [&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://。。。/Server/login&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建一个请求&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;NSMutableURLRequest&lt;/span&gt; *request = [&lt;span class=&quot;built_in&quot;&gt;NSMutableURLRequest&lt;/span&gt; requestWithURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request&lt;span class=&quot;variable&quot;&gt;.HTTPMethod&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;@&quot;POST&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置请求体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;request&lt;span class=&quot;variable&quot;&gt;.HTTPBody&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;@&quot;username=123&amp;amp;pwd=123&quot;&lt;/span&gt; dataUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 设置请求头信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[request setValue:&lt;span class=&quot;string&quot;&gt;@&quot;iPhone 6&quot;&lt;/span&gt; forHTTPHeaderField:&lt;span class=&quot;string&quot;&gt;@&quot;User-Agent&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; *task = [session dataTaskWithRequest:request completionHandler:^(&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data, &lt;span class=&quot;built_in&quot;&gt;NSURLResponse&lt;/span&gt; *response, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//系统的解析方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *dict = [&lt;span class=&quot;built_in&quot;&gt;NSJSONSerialization&lt;/span&gt; JSONObjectWithData:data options:&lt;span class=&quot;built_in&quot;&gt;NSJSONReadingMutableLeaves&lt;/span&gt; error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;----%@&quot;&lt;/span&gt;, dict);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3.开始任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[task resume];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;如何使用-AFNetworking-发出-HTTP-请求&quot;&gt;&lt;a href=&quot;#如何使用-AFNetworking-发出-HTTP-请求&quot; class=&quot;headerlink&quot; title=&quot;如何使用 AFNetworking 发出 HTTP 请求&quot;&gt;&lt;/a&gt;如何使用 AFNetworking 发出 HTTP 请求&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;manager&lt;span class=&quot;variable&quot;&gt;.responseSerializer&lt;/span&gt; = [AFHTTPResponseSerializer serializer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[manager POST:&lt;span class=&quot;string&quot;&gt;@&quot;http://baidu.com/verification/user/loginNew.htm?token=&amp;amp;random=27289&amp;amp;version=1.19.0&quot;&lt;/span&gt; parameters:dict progress:^(&lt;span class=&quot;built_in&quot;&gt;NSProgress&lt;/span&gt; * _Nonnull downloadProgress) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;请求成功&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;success:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nonnull task, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;  _Nullable responseObject) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//请求返回的数据(二进制数据)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;responseObject(二进制) = %@&quot;&lt;/span&gt;,responseObject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//转化二进制数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;responseObject = %@&quot;&lt;/span&gt;, [[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; alloc] initWithData:responseObject encoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; oaLoginSuccess];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;failure:^(&lt;span class=&quot;built_in&quot;&gt;NSURLSessionDataTask&lt;/span&gt; * _Nullable task, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nonnull   error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,error);  &lt;span class=&quot;comment&quot;&gt;//这里打印错误信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：在 iOS9 中，苹果默认全局 HTTPs，如果你要发送不安全的 HTTP 请求，需要在 info.plist 中加入如下键值对才能发出不安全的 HTTP 请求.&lt;br&gt;还有一件事情是要注意的是，AFNetworking 默认接收 json 格式的响应（因为这是在 iOS 平台上的框架，一般不需要 text/html），如果想要返回 html，需要设置 acceptableContentTypes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;AFN中的相应类&quot;&gt;&lt;a href=&quot;#AFN中的相应类&quot; class=&quot;headerlink&quot; title=&quot;AFN中的相应类&quot;&gt;&lt;/a&gt;AFN中的相应类&lt;/h3&gt;&lt;h5 id=&quot;AFURLSessionManager-核心类&quot;&gt;&lt;a href=&quot;#AFURLSessionManager-核心类&quot; class=&quot;headerlink&quot; title=&quot;AFURLSessionManager(核心类)&quot;&gt;&lt;/a&gt;AFURLSessionManager(核心类)&lt;/h5&gt;&lt;p&gt;AFURLSessionManager 是 AFHTTPSessionManager 的父类&lt;br&gt;AFURLSessionManager 负责生成 NSURLSession 的实例，管理 AFSecurityPolicy 和 AFNetworkReachabilityManager，来保证请求的安全和查看网络连接情况，它有一个 AFJSONResponseSerializer 的实例来序列化 HTTP 响应&lt;/p&gt;
&lt;h5 id=&quot;AFHTTPSessionManager&quot;&gt;&lt;a href=&quot;#AFHTTPSessionManager&quot; class=&quot;headerlink&quot; title=&quot;AFHTTPSessionManager&quot;&gt;&lt;/a&gt;AFHTTPSessionManager&lt;/h5&gt;&lt;p&gt;其中 AFHTTPSessionManager 有着自己的 AFHTTPRequestSerializer 和 AFJSONResponseSerializer 来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能&lt;/p&gt;
&lt;h5 id=&quot;AFURLRequestSerialization&quot;&gt;&lt;a href=&quot;#AFURLRequestSerialization&quot; class=&quot;headerlink&quot; title=&quot;AFURLRequestSerialization&quot;&gt;&lt;/a&gt;AFURLRequestSerialization&lt;/h5&gt;&lt;p&gt;主要用于 AFHTTPSessionManager 中，因为它主要用于修改 HTTP 头部，提供了一些语义明确的接口设置 HTTP 头部字段。HTTP 头部字段 Accept-Language User-Agent&lt;/p&gt;
&lt;h5 id=&quot;AFURLResponseSerialization&quot;&gt;&lt;a href=&quot;#AFURLResponseSerialization&quot; class=&quot;headerlink&quot; title=&quot;AFURLResponseSerialization&quot;&gt;&lt;/a&gt;AFURLResponseSerialization&lt;/h5&gt;&lt;p&gt;处理响应的模块，将请求返回的数据解析成对应的格式。这个模块使用在 AFURLSessionManager 也就是核心类中&lt;/p&gt;
&lt;h3 id=&quot;为什么要对AFN进行二次封装呢？&quot;&gt;&lt;a href=&quot;#为什么要对AFN进行二次封装呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么要对AFN进行二次封装呢？&quot;&gt;&lt;/a&gt;为什么要对AFN进行二次封装呢？&lt;/h3&gt;&lt;p&gt;上面这种写法可维护性差：主要是因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址是写死的字符串，对于一个应用来说，网络请求的地址通常是统一而且具有规律的。如果大量的请求都用这种写法，那么想要统一进行修改的话就变得很困难。&lt;/li&gt;
&lt;li&gt;没有统一的请求和响应过滤机制。通常客户端开发当中需要对于请求和响应进行一些处理，例如在请求中加入验证字段（如 Token），以验证请求的合法性。&lt;/li&gt;
&lt;li&gt;对 AFNetworking 产生了强依赖，如果要进行网络库的替换，成本会非常高。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着应用复杂程度的增加，上面这种在控制层直接对网络请求层进行交互的方式，会产生越来越多的问题。因此有必要通过单独的一层把控制层（业务层）和网络请求层隔离开来，这一层我们暂时把它叫做“网络封装层”。&lt;/p&gt;
&lt;h3 id=&quot;封装的目标&quot;&gt;&lt;a href=&quot;#封装的目标&quot; class=&quot;headerlink&quot; title=&quot;封装的目标&quot;&gt;&lt;/a&gt;封装的目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;监测网络状态&lt;/li&gt;
&lt;li&gt;业务层和网络层分离&lt;/li&gt;
&lt;li&gt;处理环境的变化，开发，测试，预发布，发布&lt;/li&gt;
&lt;li&gt;处理GET、POST、下载、上传的操作&lt;/li&gt;
&lt;li&gt;&lt;h2 id=&quot;如何封装&quot;&gt;&lt;a href=&quot;#如何封装&quot; class=&quot;headerlink&quot; title=&quot;如何封装&quot;&gt;&lt;/a&gt;如何封装&lt;/h2&gt;封装主要是把业务层和网络层分开，此次的封装分为三层：&lt;blockquote&gt;
&lt;p&gt;第一层：首先，从应用层ViewController获取参数，这个参数传到第二层的业务Service，在回调中利用网络请求返回的responseModel来显示在页面上。&lt;br&gt;第二层：设置一个BaseService，然后+LoginService。BaseService中主要是配置公有的参数。在每个业务层的Service中设置每一个的接口定义。业务层主要是暴露接口的定义，而BaseService中定义了BaseRequestModel来实现发起请求到第三层Client。&lt;br&gt;第三层：这层就是CLient，由ASI或者AFN充当，发起网络请求。这一层最好是个单例，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BaseRequestModel中定义了：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PLHRequestModel&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//网络请求参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, nonnull, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * serverRoot; &lt;span class=&quot;comment&quot;&gt;//网络请求的根地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, nonnull, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * actionPath;&lt;span class=&quot;comment&quot;&gt;//发起响应的二级地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;float&lt;/span&gt; timeout;  &lt;span class=&quot;comment&quot;&gt;//时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) PLHHTTPRequestType requestType;  &lt;span class=&quot;comment&quot;&gt;//网络请求方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, nonnull, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; * serviceName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, nullable, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *apiVersion;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, nullable, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *parameters; &lt;span class=&quot;comment&quot;&gt;// 请求参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) PLHHTTPServiceType serviceType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Client&quot;&gt;&lt;a href=&quot;#Client&quot; class=&quot;headerlink&quot; title=&quot;Client&quot;&gt;&lt;/a&gt;Client&lt;/h3&gt;&lt;p&gt;单例的，定义了AFURLSessionManager *sessionManager;生成并且发出网络请求。或者直接继承自AFURLSessionManager&lt;/p&gt;
&lt;h4 id=&quot;PLHHTTPRequestSerializer&quot;&gt;&lt;a href=&quot;#PLHHTTPRequestSerializer&quot; class=&quot;headerlink&quot; title=&quot;PLHHTTPRequestSerializer&quot;&gt;&lt;/a&gt;PLHHTTPRequestSerializer&lt;/h4&gt;&lt;p&gt;单例的，生成AFHTTPRequestSerializer，或者直接继承自AFHTTPRequestSerializer。为的是生成NSURLRequest&lt;/p&gt;
&lt;h4 id=&quot;PLHRequestModel&quot;&gt;&lt;a href=&quot;#PLHRequestModel&quot; class=&quot;headerlink&quot; title=&quot;PLHRequestModel&quot;&gt;&lt;/a&gt;PLHRequestModel&lt;/h4&gt;&lt;h4 id=&quot;PLHResponseModel&quot;&gt;&lt;a href=&quot;#PLHResponseModel&quot; class=&quot;headerlink&quot; title=&quot;PLHResponseModel&quot;&gt;&lt;/a&gt;PLHResponseModel&lt;/h4&gt;&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://draveness.me/afnetworking1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AFNetworking 概述&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于项目的重构，很重要的就是对网络层的重构，其实也就是对AFN的二次封装。对于AFN的介绍在前一篇：&lt;a href=&quot;&quot;&gt;研究AFNetworking框架&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目重构遇到的问题</title>
    <link href="http://peilinghui.com/2017/07/05/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2017/07/05/项目重构遇到的问题/</id>
    <published>2017-07-05T07:12:10.000Z</published>
    <updated>2017-07-20T07:23:55.000Z</updated>
    
    <content type="html">&lt;p&gt;在项目重构的时候难免会遇到问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;加入了新公司，也是接手了一个14年的项目，项目大概6万行代码。然后准备做一些业务并且重构，做了一个需求以后开始重构，然后发现每走一步都是坑啊。上家公司也是14年的代码，那个时候是我们那个老大架构师也是刚去的带我们重构(顺便说一句上家公司代码大概20万行)现在自己准备着手的时候感觉我上一个老大真的好厉害额。5年工作经验额。我等菜鸟还要慢慢踩坑，慢慢修炼呐~&lt;/p&gt;
&lt;p&gt;不得不说，这两个旧的项目有很多共同点呐，可能那个时候流行那么写，不过从上家公司走的时候那个代码都已经重构的很不错了额。关键是上家公司做iOS的人就接近10个了。实话说，我都觉得自己的用处不大了。然后现在就我和我老大两个做iOS的了。不管怎么说，加油💪把！努力提高自己才是关键。&lt;/p&gt;
&lt;p&gt;旧项目的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用老式框架 ASI，并且没有做任何封装和抽取； 如果工程是ARC的 第三方文件编译选项加上-fno-objc-arc -O0&lt;/li&gt;
&lt;li&gt;字典转模型用的是Jastor.&lt;/li&gt;
&lt;li&gt;没有使用 Cocoa Pods，所有框架都是拖进去的。&lt;/li&gt;
&lt;li&gt;所有的网络请求只用了两个方法，一个同步一个异步。&lt;/li&gt;
&lt;li&gt;所有的VC都是用的代码写的，布局用的frame，这点还好一点，上家公司一大片storyboard，新加需求能把人逼疯的那种。&lt;/li&gt;
&lt;li&gt;一个VC的数据模型在一个类中。&lt;/li&gt;
&lt;li&gt;代码不规范，没有用固定的前缀，Deployment Target设置为6.0.当你把target设置为8.0的时候，警告暴增，很多的方法以及过期了。&lt;/li&gt;
&lt;li&gt;目录结构：项目中目录结构还算清晰，文件中的目录都没有，一大片.h和.m文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了上家公司的经验，我有个初步的计划和构想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把第三方的库可以把一些替换成Pod管理。&lt;/li&gt;
&lt;li&gt;对于网络层以前用的ASI，如果有新的需求就要用AFN，然后对于AFN进行一些封装，写的网络请求的方法要有successBlock和failureBlock。对于数据转模型用yymodel。&lt;/li&gt;
&lt;li&gt;可以写if debug运行环境的配置代码，来切换测试，预发和正式环境。或者我发现用SwitchHost直接切换环境开发的人比较方便，对于测试的人，就得用Charles或者是fiddler的抓包工具设置代理连到自己的电脑来切换到不同的环境测试。&lt;/li&gt;
&lt;li&gt;打包现在是用Xcode的手工打包可以引入Jenkins来实现自动化打包的模式。这就需要搭建Jenkins服务器和配置到gitlab上面。&lt;/li&gt;
&lt;li&gt;Jenkins也可以结合OCLint实现代码的review。&lt;/li&gt;
&lt;li&gt;使用 fir 和 fastlane 实现 iOS 持续集成。实现iOS应用发布流程的自动化&lt;/li&gt;
&lt;li&gt;对于推送可以使用极光推送还有一些统计崩溃率的第三方工具，还有设置埋点来统计APP的功能。&lt;/li&gt;
&lt;li&gt;对于一些登录还有一些公共组件可以抽取成私有的Pod，然后打tag，以便可以共用。&lt;/li&gt;
&lt;li&gt;对于业务方面就是要把数据和业务分离，对于重复出现的tableview可以写基类，然后再进行扩展。&lt;/li&gt;
&lt;li&gt;对于页面的布局要用masonary框架。&lt;/li&gt;
&lt;li&gt;对于一些第三方的框架和组件旧的逐步替换成新的第三方(一直有人维护和更新)的框架。&lt;/li&gt;
&lt;li&gt;当然最最重要的就是把代码进行完善，然后实现业务需求的继续扩张。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，上面都是我暂时的目标和想法，还有待去实践和一步步的改造。需要足够的耐心和坚持。&lt;/p&gt;
&lt;p&gt;在这期间遇到的一些问题：&lt;/p&gt;
&lt;h1 id=&quot;错误1：clang-error-Linker-command-failed-with-exit-code-1&quot;&gt;&lt;a href=&quot;#错误1：clang-error-Linker-command-failed-with-exit-code-1&quot; class=&quot;headerlink&quot; title=&quot;错误1：clang error: Linker command failed with exit code 1&quot;&gt;&lt;/a&gt;错误1：clang error: Linker command failed with exit code 1&lt;/h1&gt;&lt;h2 id=&quot;解决方法：-m文件被重复编译&quot;&gt;&lt;a href=&quot;#解决方法：-m文件被重复编译&quot; class=&quot;headerlink&quot; title=&quot;解决方法：.m文件被重复编译&quot;&gt;&lt;/a&gt;解决方法：.m文件被重复编译&lt;/h2&gt;&lt;p&gt;好好检查代码，看是不是在.m文件中的引入写成了引入.m文件。&lt;br&gt;看看是不是有新添加的文件跟之前文件同名&lt;br&gt;2，错误信息中出现了某个类的名字，去原文件中看看#import了哪些第三方库，把这些库挨个注释排除，找到出错的那个库，然后按照官方提供的步骤重新添加一遍。&lt;/p&gt;
&lt;h2 id=&quot;解决方法：使用Pod管理的时候&quot;&gt;&lt;a href=&quot;#解决方法：使用Pod管理的时候&quot; class=&quot;headerlink&quot; title=&quot;解决方法：使用Pod管理的时候&quot;&gt;&lt;/a&gt;解决方法：使用Pod管理的时候&lt;/h2&gt;&lt;p&gt;在把引入的第三方库改为Cocoapods管理的时候，遇到Linker command failed。&lt;br&gt;链接文件没有找到CocoaPods中的文件，&lt;/p&gt;
&lt;h3 id=&quot;解决方法1：&quot;&gt;&lt;a href=&quot;#解决方法1：&quot; class=&quot;headerlink&quot; title=&quot;解决方法1：&quot;&gt;&lt;/a&gt;解决方法1：&lt;/h3&gt;&lt;p&gt;找到 Build settings-&amp;gt;Linking-&amp;gt;Other Linker Flags&lt;br&gt;将此属性修改成-all_load 或者 -ObjC ，这个视情况而定。总之可以多试几次。&lt;/p&gt;
&lt;h3 id=&quot;解决方法2：&quot;&gt;&lt;a href=&quot;#解决方法2：&quot; class=&quot;headerlink&quot; title=&quot;解决方法2：&quot;&gt;&lt;/a&gt;解决方法2：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Go to project path and remove Pods folder and Podfile.lock file.&lt;/li&gt;
&lt;li&gt;Reinstall pods again using “pod install” command.&lt;/li&gt;
&lt;li&gt;Open xcworkspace and clean it before running.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;解决方法3：&quot;&gt;&lt;a href=&quot;#解决方法3：&quot; class=&quot;headerlink&quot; title=&quot;解决方法3：&quot;&gt;&lt;/a&gt;解决方法3：&lt;/h3&gt;&lt;p&gt;如果添加的是第三方静态库（.a文件）&lt;br&gt;这种情况就可能是这个静态库路径混乱导致的链接错误。解决方法：Build settings-&amp;gt;Search Path-&amp;gt;Library Search Paths 添加静态库的相应路径。&lt;/p&gt;
&lt;h1 id=&quot;CocoaPods的相关问题&quot;&gt;&lt;a href=&quot;#CocoaPods的相关问题&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods的相关问题&quot;&gt;&lt;/a&gt;CocoaPods的相关问题&lt;/h1&gt;&lt;h3 id=&quot;pod-install-和-pod-update-的区别：&quot;&gt;&lt;a href=&quot;#pod-install-和-pod-update-的区别：&quot; class=&quot;headerlink&quot; title=&quot;pod install 和 pod update 的区别：&quot;&gt;&lt;/a&gt;pod install 和 pod update 的区别：&lt;/h3&gt;&lt;p&gt;使用 pod install，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。&lt;/p&gt;
&lt;p&gt;使用 pod update，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件&lt;br&gt;&lt;a href=&quot;http://www.samirchen.com/about-podfile-lock/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;关于 Podfile.lock 带来的痛&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用CocoaPods开发并打包静态库&quot;&gt;&lt;a href=&quot;#使用CocoaPods开发并打包静态库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods开发并打包静态库&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.cnblogs.com/brycezhang/p/4117180.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用CocoaPods开发并打包静态库&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;用-CocoaPods-集成本地私有库&quot;&gt;&lt;a href=&quot;#用-CocoaPods-集成本地私有库&quot; class=&quot;headerlink&quot; title=&quot;用 CocoaPods 集成本地私有库&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.samirchen.com/use-cocoapods-to-manage-private-libs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用 CocoaPods 集成本地私有库&lt;/a&gt;&lt;/h3&gt;&lt;h1 id=&quot;静态库-a打包成支持64位的&quot;&gt;&lt;a href=&quot;#静态库-a打包成支持64位的&quot; class=&quot;headerlink&quot; title=&quot;静态库.a打包成支持64位的&quot;&gt;&lt;/a&gt;静态库.a打包成支持64位的&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;2015年2月1日不允许不支持arm64的应用的提交；&lt;/li&gt;
&lt;li&gt;iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢…”；&lt;/li&gt;
&lt;li&gt;iOS10.3公测版发布:封杀32位应用；&lt;/li&gt;
&lt;li&gt;苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;i386是针对intel通用微处理器32位处理器&lt;br&gt;x86_64是针对x86架构的64位处理器&lt;br&gt;模拟器32位处理器测试需要i386架构&lt;br&gt;模拟器64位处理器测试需要x86_64架构&lt;br&gt;真机32位处理器需要armv7,或者armv7s架构&lt;br&gt;真机64位处理器需要arm64架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/567d3b730608&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS armv7, armv7s, arm64区别与应用32位、64位配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;制作方法：一般只要是模拟器一运行就会生成.a的静态库，然后cd到目录下输入lipo -info XXX.a就可以打印出支持的是x86_34,还是什么了，现在一般都要求32位和64位了，如果要是某些项目要在模拟器上运行还要支持i386,所以，可以进行.a静态包的合并。用命令输入lipo -create XX.a XXX.a -output XXXX.a 就可以生成了XXXX.a的静态包。然后导入工程并且在building setting中设置支持arm7,arm7s和arm64即可。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/kaqijiang/blog/649632&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS静态库.a 和framework&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.zybuluo.com/qidiandasheng/note/603907&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS里的动态库和静态库&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.sunnyxx.com/2014/12/20/64-bit-tips/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;64-bit Tips&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Xib问题&quot;&gt;&lt;a href=&quot;#Xib问题&quot; class=&quot;headerlink&quot; title=&quot;Xib问题&quot;&gt;&lt;/a&gt;Xib问题&lt;/h1&gt;&lt;p&gt;由于更新手机系统iOS11以及xcode9 beta，然后项目在xcode9运行出现一些错误：Compiling IB documents for earlier than iOS 7 is no longer supported.如截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1244409-5cf0c15ba87dd1f2.png?imageMogr2/auto-orient/strip%7CimageView2/2&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决办法是：Builds for更改版本7之后，我更改成9.0&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1244409-e59c5cbfe0074c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;关于APP一启动就crash&quot;&gt;&lt;a href=&quot;#关于APP一启动就crash&quot; class=&quot;headerlink&quot; title=&quot;关于APP一启动就crash&quot;&gt;&lt;/a&gt;关于APP一启动就crash&lt;/h1&gt;&lt;p&gt;由于更新手机系统iOS11以及xcode9 beta，然后项目在xcode9运行出现_runWithMainScene:transitionContext:completion错误。解决方法在&lt;code&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&lt;/code&gt;方法中的UIWindow必须设置它的rootViewController&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在项目重构的时候难免会遇到问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的图表Charts</title>
    <link href="http://peilinghui.com/2017/06/30/iOS%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8Charts/"/>
    <id>http://peilinghui.com/2017/06/30/iOS中的图表Charts/</id>
    <published>2017-06-30T12:17:16.000Z</published>
    <updated>2017-07-06T03:28:17.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的图表，包括：折线图，柱状图，饼图。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于数据的展示，最常见的就是柱状图，折线图了。在的上家公司用的柱状图都是自己写的，自己封装的。现在公司接手的项目原来是用core-plot&lt;a href=&quot;https://github.com/core-plot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/core-plot&lt;/a&gt;的第三方库。现在打算尝试一下新的第三方库：&lt;strong&gt;Charts&lt;/strong&gt;&lt;a href=&quot;https://github.com/danielgindi/Charts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/danielgindi/Charts&lt;/a&gt;界面更加的好看了。&lt;/p&gt;
&lt;h1 id=&quot;charts的前期准备&quot;&gt;&lt;a href=&quot;#charts的前期准备&quot; class=&quot;headerlink&quot; title=&quot;charts的前期准备&quot;&gt;&lt;/a&gt;charts的前期准备&lt;/h1&gt;&lt;p&gt;可以看它那个READMe.md,就写了使用，一种共识直接拖进项目，由于是用swift写的，OC也可以使用，因此要设置桥接文件，才可以。一种是使用cocoapods，还有一种是使用Carthage安装。&lt;/p&gt;
&lt;p&gt;我用的是cocoapods的方式：&lt;/p&gt;
&lt;h2 id=&quot;先cocoads安装：&quot;&gt;&lt;a href=&quot;#先cocoads安装：&quot; class=&quot;headerlink&quot; title=&quot;先cocoads安装：&quot;&gt;&lt;/a&gt;先cocoads安装：&lt;/h2&gt;&lt;p&gt;$sudo gem install -n /usr/local/bin cocoapods&lt;/p&gt;
&lt;p&gt;$pod setup&lt;/p&gt;
&lt;h2 id=&quot;集成Charts：&quot;&gt;&lt;a href=&quot;#集成Charts：&quot; class=&quot;headerlink&quot; title=&quot;集成Charts：&quot;&gt;&lt;/a&gt;集成Charts：&lt;/h2&gt;&lt;p&gt;新建一个项目TestChatDemos&lt;/p&gt;
&lt;p&gt;cd 把工程直接拖过来&lt;/p&gt;
&lt;h2 id=&quot;创建podfile文件&quot;&gt;&lt;a href=&quot;#创建podfile文件&quot; class=&quot;headerlink&quot; title=&quot;创建podfile文件&quot;&gt;&lt;/a&gt;创建podfile文件&lt;/h2&gt;&lt;p&gt;touch podfile&lt;/p&gt;
&lt;p&gt;open -a xcode podfile &lt;/p&gt;
&lt;p&gt;在podfile文件中输入&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;platform&lt;/span&gt; :iOS, &lt;span class=&quot;string&quot;&gt;&#39;8.1&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;use_frameworks!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;target &lt;span class=&quot;string&quot;&gt;&#39;TestCharsDemo&#39;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;do&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;Charts&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &lt;span class=&quot;string&quot;&gt;&#39;Charts/Realm&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;post_install &lt;span class=&quot;built_in&quot;&gt;do&lt;/span&gt; |installer|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    installer.pods_project.targets.&lt;span class=&quot;keyword&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;do&lt;/span&gt; |target|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       target.build_configurations.&lt;span class=&quot;keyword&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;do&lt;/span&gt; |config|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           config.build_settings[&lt;span class=&quot;string&quot;&gt;&#39;SWIFT_VERSION&#39;&lt;/span&gt;] = &lt;span class=&quot;string&quot;&gt;&#39;3.0&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pod search Charts&lt;/p&gt;
&lt;p&gt;pod install&lt;/p&gt;
&lt;h2 id=&quot;设置桥接文件&quot;&gt;&lt;a href=&quot;#设置桥接文件&quot; class=&quot;headerlink&quot; title=&quot;设置桥接文件&quot;&gt;&lt;/a&gt;设置桥接文件&lt;/h2&gt;&lt;p&gt;建立与Swift的桥接文件，建立一个以swift文件，提示是否建立桥接，点击creat bridging header&lt;/p&gt;
&lt;p&gt;将pods——testChatDemos。frameworkios添加到 general-&amp;gt;embedded binaries&lt;/p&gt;
&lt;p&gt;在桥接文件中写上要引用的swift头文件 @import Charts；&lt;/p&gt;
&lt;p&gt;用到时导入 #import “testChartDemos-bridging-header.h”的头文件，然后就可以使用Charts里的东西了&lt;/p&gt;
&lt;p&gt;使用ChartsDemos里的东西的时候，要配置product module name 为（TestCharsDemo）系统会自动生成&lt;/p&gt;
&lt;p&gt;“TestCharsDemo-Swift.h”导入&lt;br&gt;“Chart-swift.h”的文件导入&lt;/p&gt;
&lt;p&gt;这样基本就可以运行程序看到ChartsDemo里的案例了。&lt;/p&gt;
&lt;h1 id=&quot;使用Charts&quot;&gt;&lt;a href=&quot;#使用Charts&quot; class=&quot;headerlink&quot; title=&quot;使用Charts&quot;&gt;&lt;/a&gt;使用Charts&lt;/h1&gt;&lt;p&gt;接下来就可以参照GitHUB官网上的Demo来写你需要的图形了。&lt;/p&gt;
&lt;p&gt;使用这个库无非就是几个问题：&lt;br&gt;写界面，放入数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看你的需求是需要那种图，各个图的样式的属性。&lt;/li&gt;
&lt;li&gt;x轴，y轴的数据是从哪里获得的。&lt;/li&gt;
&lt;li&gt;x轴和y轴的数据是否可以动态变化。&lt;/li&gt;
&lt;li&gt;该如何把从服务器传过来的数组对应到图中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;LineChart折线图&quot;&gt;&lt;a href=&quot;#LineChart折线图&quot; class=&quot;headerlink&quot; title=&quot;LineChart折线图&quot;&gt;&lt;/a&gt;LineChart折线图&lt;/h2&gt;&lt;h3 id=&quot;Line-Chart单折线&quot;&gt;&lt;a href=&quot;#Line-Chart单折线&quot; class=&quot;headerlink&quot; title=&quot;Line Chart单折线&quot;&gt;&lt;/a&gt;Line Chart单折线&lt;/h3&gt;&lt;p&gt;1.首先是需要LineChartView。&lt;br&gt;然后是ChartLimitLine-x轴的限制线。&lt;br&gt;ChartLimitLine-Y轴的限制线&lt;br&gt;ChartYAxis设置Y轴，有左边的Y轴leftAxis和右边的Y轴rightAxis。&lt;br&gt;BalloonMarker&lt;/p&gt;
&lt;p&gt;设置x轴和Y轴的数据的方法.&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *values = [[NSMutableArray alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;typename&quot;&gt;double&lt;/span&gt; val = arc4random_uniform(range) + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [values &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;[[ChartDataEntry alloc] &lt;span class=&quot;string&quot;&gt;initWithX:&lt;/span&gt;i &lt;span class=&quot;string&quot;&gt;y:&lt;/span&gt;val &lt;span class=&quot;string&quot;&gt;icon:&lt;/span&gt; [UIImage &lt;span class=&quot;string&quot;&gt;imageNamed:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;icon&quot;&lt;/span&gt;]]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于0到Count的x轴的值，随机的产生y值，并放入数组values中，其中values是&lt;__nsarraym 0x600000057670=&quot;&quot;&gt;(&lt;br&gt;ChartDataEntry, x: 0.0, y 53.0,&lt;br&gt;ChartDataEntry, x: 1.0, y 91.0,&lt;br&gt;ChartDataEntry, x: 2.0, y 44.0）这样的。&lt;/__nsarraym&gt;&lt;/p&gt;
&lt;p&gt;然后是LineChartDataSet，每一个set对应一条折线。把上面的values放入这个set中当做这条线的各个坐标点。设置它的属性。&lt;br&gt;把每一个set都放入dataSets中，作为LineChartData的数据源，也就是chartView的data源了。&lt;/p&gt;
&lt;h3 id=&quot;Line-Chart-Dual-YAxis-双折线&quot;&gt;&lt;a href=&quot;#Line-Chart-Dual-YAxis-双折线&quot; class=&quot;headerlink&quot; title=&quot;Line Chart(Dual YAxis)双折线&quot;&gt;&lt;/a&gt;Line Chart(Dual YAxis)双折线&lt;/h3&gt;&lt;p&gt;ChartLegend设置图例，就是每条线Dataset的说明。&lt;br&gt;对于其他同上面，其中上面的values变成了三个yVals.放入三个LineChartDataSet中，设置每一个set的属性。&lt;/p&gt;
&lt;h3 id=&quot;Multiple-Lines-Chart多种折线图&quot;&gt;&lt;a href=&quot;#Multiple-Lines-Chart多种折线图&quot; class=&quot;headerlink&quot; title=&quot;Multiple Lines Chart多种折线图&quot;&gt;&lt;/a&gt;Multiple Lines Chart多种折线图&lt;/h3&gt;&lt;p&gt;设置ChartLegend，没有设置x轴和y轴。其他同上。&lt;/p&gt;
&lt;h3 id=&quot;Colored-Line-Chart彩色的折线图&quot;&gt;&lt;a href=&quot;#Colored-Line-Chart彩色的折线图&quot; class=&quot;headerlink&quot; title=&quot;Colored Line Chart彩色的折线图&quot;&gt;&lt;/a&gt;Colored Line Chart彩色的折线图&lt;/h3&gt;&lt;p&gt;设置了_chartViews的Count为4，然后对于每一个_chartViews固定了range就是高度为100.其他同上。&lt;/p&gt;
&lt;h3 id=&quot;TimeLine-Chart时间线的折线图&quot;&gt;&lt;a href=&quot;#TimeLine-Chart时间线的折线图&quot; class=&quot;headerlink&quot; title=&quot;TimeLine Chart时间线的折线图&quot;&gt;&lt;/a&gt;TimeLine Chart时间线的折线图&lt;/h3&gt;&lt;p&gt;LineChartTimeViewController&lt;/p&gt;
&lt;h3 id=&quot;Filled-Line-Chart-填充的折线图&quot;&gt;&lt;a href=&quot;#Filled-Line-Chart-填充的折线图&quot; class=&quot;headerlink&quot; title=&quot;Filled Line Chart 填充的折线图&quot;&gt;&lt;/a&gt;Filled Line Chart 填充的折线图&lt;/h3&gt;&lt;h2 id=&quot;BarChart柱状条形图&quot;&gt;&lt;a href=&quot;#BarChart柱状条形图&quot; class=&quot;headerlink&quot; title=&quot;BarChart柱状条形图&quot;&gt;&lt;/a&gt;BarChart柱状条形图&lt;/h2&gt;&lt;h3 id=&quot;Bar-Chart竖的条形图&quot;&gt;&lt;a href=&quot;#Bar-Chart竖的条形图&quot; class=&quot;headerlink&quot; title=&quot;Bar Chart竖的条形图&quot;&gt;&lt;/a&gt;Bar Chart竖的条形图&lt;/h3&gt;&lt;p&gt;和折线图也差不多。设置x轴ChartXAxis，设置y轴ChartYAxis的leftAxis和rightAxis，图例ChartLegend.&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *yVals = [[NSMutableArray alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; i = start; i &amp;lt; start + count + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;typename&quot;&gt;double&lt;/span&gt; mult = (range + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;typename&quot;&gt;double&lt;/span&gt; val = (&lt;span class=&quot;typename&quot;&gt;double&lt;/span&gt;) (arc4random_uniform(mult));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arc4random_uniform(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &amp;lt; &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [yVals &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;[[BarChartDataEntry alloc] &lt;span class=&quot;string&quot;&gt;initWithX:&lt;/span&gt;i &lt;span class=&quot;string&quot;&gt;y:&lt;/span&gt;val &lt;span class=&quot;string&quot;&gt;icon:&lt;/span&gt; [UIImage &lt;span class=&quot;string&quot;&gt;imageNamed:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;icon&quot;&lt;/span&gt;]]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [yVals &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;[[BarChartDataEntry alloc] &lt;span class=&quot;string&quot;&gt;initWithX:&lt;/span&gt;i &lt;span class=&quot;string&quot;&gt;y:&lt;/span&gt;val]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;po yVals&lt;/p&gt;
&lt;p&gt;&lt;__nsarraym 0x60800004d4d0=&quot;&quot;&gt;(&lt;br&gt;ChartDataEntry, x: 1.0, y 18.0,&lt;br&gt;ChartDataEntry, x: 2.0, y 36.0,&lt;br&gt;ChartDataEntry, x: 3.0, y 17.0&lt;br&gt;)&lt;/__nsarraym&gt;&lt;/p&gt;
&lt;p&gt;每一个BarChartDataSet是一个柱状图，然后放到datasets中他们会作为BarChartData的数据源。也是_chartView的data&lt;/p&gt;
&lt;h3 id=&quot;Horizontal-Bar-Chart横的条形图&quot;&gt;&lt;a href=&quot;#Horizontal-Bar-Chart横的条形图&quot; class=&quot;headerlink&quot; title=&quot;Horizontal Bar Chart横的条形图&quot;&gt;&lt;/a&gt;Horizontal Bar Chart横的条形图&lt;/h3&gt;&lt;p&gt;就是左边的Y轴是数据的X轴，下面的一条x轴是数据的Y轴。yVals是&lt;__nsarraym 0x6100000591a0=&quot;&quot;&gt;(&lt;br&gt;ChartDataEntry, x: 0.0, y 3.0,&lt;br&gt;ChartDataEntry, x: 10.0, y 20.0,&lt;br&gt;ChartDataEntry, x: 20.0, y 50.0,&lt;br&gt;ChartDataEntry, x: 30.0, y 7.0,&lt;br&gt;ChartDataEntry, x: 40.0, y 33.0,&lt;br&gt;ChartDataEntry, x: 50.0, y 19.0,&lt;br&gt;ChartDataEntry, x: 60.0, y 26.0）&lt;/__nsarraym&gt;&lt;/p&gt;
&lt;h3 id=&quot;Multiple-Bars-Chart多种条形图&quot;&gt;&lt;a href=&quot;#Multiple-Bars-Chart多种条形图&quot; class=&quot;headerlink&quot; title=&quot;Multiple Bars Chart多种条形图&quot;&gt;&lt;/a&gt;Multiple Bars Chart多种条形图&lt;/h3&gt;&lt;h3 id=&quot;Stack-Bar-Chart堆积的柱状条形图&quot;&gt;&lt;a href=&quot;#Stack-Bar-Chart堆积的柱状条形图&quot; class=&quot;headerlink&quot; title=&quot;Stack Bar Chart堆积的柱状条形图&quot;&gt;&lt;/a&gt;Stack Bar Chart堆积的柱状条形图&lt;/h3&gt;&lt;h3 id=&quot;Stack-Bar-Chart-Negative堆积的反向柱状条形图&quot;&gt;&lt;a href=&quot;#Stack-Bar-Chart-Negative堆积的反向柱状条形图&quot; class=&quot;headerlink&quot; title=&quot;Stack Bar Chart Negative堆积的反向柱状条形图&quot;&gt;&lt;/a&gt;Stack Bar Chart Negative堆积的反向柱状条形图&lt;/h3&gt;&lt;h3 id=&quot;Another-Bar-Chart干净的条形图&quot;&gt;&lt;a href=&quot;#Another-Bar-Chart干净的条形图&quot; class=&quot;headerlink&quot; title=&quot;Another Bar Chart干净的条形图&quot;&gt;&lt;/a&gt;Another Bar Chart干净的条形图&lt;/h3&gt;&lt;h3 id=&quot;Sinus-Bar-Chart正弦柱状图&quot;&gt;&lt;a href=&quot;#Sinus-Bar-Chart正弦柱状图&quot; class=&quot;headerlink&quot; title=&quot;Sinus Bar Chart正弦柱状图&quot;&gt;&lt;/a&gt;Sinus Bar Chart正弦柱状图&lt;/h3&gt;&lt;h3 id=&quot;BarChart-positive-negative正反向的柱状图&quot;&gt;&lt;a href=&quot;#BarChart-positive-negative正反向的柱状图&quot; class=&quot;headerlink&quot; title=&quot;BarChart positive/negative正反向的柱状图&quot;&gt;&lt;/a&gt;BarChart positive/negative正反向的柱状图&lt;/h3&gt;&lt;h2 id=&quot;PieChart饼图&quot;&gt;&lt;a href=&quot;#PieChart饼图&quot; class=&quot;headerlink&quot; title=&quot;PieChart饼图&quot;&gt;&lt;/a&gt;PieChart饼图&lt;/h2&gt;&lt;p&gt;PieChartView.不再是X轴和Y轴，而是表示一共把饼图分几块和一共的百分比。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *values = [[NSMutableArray alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [values &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;[[PieChartDataEntry alloc] &lt;span class=&quot;string&quot;&gt;initWithValue:&lt;/span&gt;(arc4random_uniform(mult) + mult / &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;label:&lt;/span&gt;parties[i % parties.count] &lt;span class=&quot;string&quot;&gt;icon:&lt;/span&gt; [UIImage &lt;span class=&quot;string&quot;&gt;imageNamed:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;icon&quot;&lt;/span&gt;]]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把values放入PieChartDataSet中，其中values是下面的：&lt;/p&gt;
&lt;figure class=&quot;highlight perl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pie entries &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; have &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;values&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;__NSArrayM &lt;span class=&quot;number&quot;&gt;0x610000042910&lt;/span&gt;&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ChartDataEntry, &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;96.03017578125&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ChartDataEntry, &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;118.03017578125&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ChartDataEntry, &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;27.03017578125&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ChartDataEntry, &lt;span class=&quot;keyword&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;115.03017578125&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Pie-Chart饼图、&quot;&gt;&lt;a href=&quot;#Pie-Chart饼图、&quot; class=&quot;headerlink&quot; title=&quot;Pie Chart饼图、&quot;&gt;&lt;/a&gt;Pie Chart饼图、&lt;/h3&gt;&lt;h3 id=&quot;Pie-Chart-With-Value-lines带有值的饼图&quot;&gt;&lt;a href=&quot;#Pie-Chart-With-Value-lines带有值的饼图&quot; class=&quot;headerlink&quot; title=&quot;Pie Chart With Value lines带有值的饼图&quot;&gt;&lt;/a&gt;Pie Chart With Value lines带有值的饼图&lt;/h3&gt;&lt;h3 id=&quot;Half-Pie-Chart一半的饼图&quot;&gt;&lt;a href=&quot;#Half-Pie-Chart一半的饼图&quot; class=&quot;headerlink&quot; title=&quot;Half Pie Chart一半的饼图&quot;&gt;&lt;/a&gt;Half Pie Chart一半的饼图&lt;/h3&gt;&lt;h2 id=&quot;Scatter-Chart离散图&quot;&gt;&lt;a href=&quot;#Scatter-Chart离散图&quot; class=&quot;headerlink&quot; title=&quot;Scatter Chart离散图&quot;&gt;&lt;/a&gt;Scatter Chart离散图&lt;/h2&gt;&lt;h2 id=&quot;Bubble-Chart气泡图&quot;&gt;&lt;a href=&quot;#Bubble-Chart气泡图&quot; class=&quot;headerlink&quot; title=&quot;Bubble Chart气泡图&quot;&gt;&lt;/a&gt;Bubble Chart气泡图&lt;/h2&gt;&lt;h2 id=&quot;Combine-Chart结合的图&quot;&gt;&lt;a href=&quot;#Combine-Chart结合的图&quot; class=&quot;headerlink&quot; title=&quot;Combine Chart结合的图&quot;&gt;&lt;/a&gt;Combine Chart结合的图&lt;/h2&gt;&lt;h2 id=&quot;Radar-Chart雷达分散图&quot;&gt;&lt;a href=&quot;#Radar-Chart雷达分散图&quot; class=&quot;headerlink&quot; title=&quot;Radar Chart雷达分散图&quot;&gt;&lt;/a&gt;Radar Chart雷达分散图&lt;/h2&gt;&lt;h2 id=&quot;Candle-Stick-Chart蜡烛状的图&quot;&gt;&lt;a href=&quot;#Candle-Stick-Chart蜡烛状的图&quot; class=&quot;headerlink&quot; title=&quot;Candle Stick Chart蜡烛状的图&quot;&gt;&lt;/a&gt;Candle Stick Chart蜡烛状的图&lt;/h2&gt;&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHDemo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;其他图表框架&quot;&gt;&lt;a href=&quot;#其他图表框架&quot; class=&quot;headerlink&quot; title=&quot;其他图表框架&quot;&gt;&lt;/a&gt;其他图表框架&lt;/h1&gt;&lt;p&gt;PNChart&lt;a href=&quot;https://github.com/peilinghui/PNChart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/PNChart&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的图表，包括：折线图，柱状图，饼图。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动应用的设计模式</title>
    <link href="http://peilinghui.com/2017/06/26/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://peilinghui.com/2017/06/26/移动应用的设计模式/</id>
    <published>2017-06-26T10:55:14.000Z</published>
    <updated>2017-06-27T10:48:13.000Z</updated>
    
    <content type="html">&lt;p&gt;在我们平时使用APP的时候，尤其是现在那些主流的APP，它们的设计模式。是如何迎合用户的需求和喜好。如果你自己做的一款产品你自己都不喜欢的话，如何让更多的用户去使用这个APP呢？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;对于iPhone手机的系统的不断的更新，也是在不断的融合用户的喜好。从指纹解锁，唤起APP的模式。还有通知栏的设计，控制中心的设计，各个应用的排列和图标的显示，只有在意了每个细节才能造就一个更加完美的产品。&lt;br&gt;而对于一个开发人员来讲，不仅要关注现在市场的技术的革新，更重要的是不断的研究其他的主流的产品和主流产品的设计。不然你连自己都不知道自己的产品设计已经out了。&lt;/p&gt;
&lt;h1 id=&quot;导航&quot;&gt;&lt;a href=&quot;#导航&quot; class=&quot;headerlink&quot; title=&quot;导航&quot;&gt;&lt;/a&gt;导航&lt;/h1&gt;&lt;p&gt;导航有主导航和次级导航。&lt;br&gt;对于iOS用户来讲，一个APP可能更偏好于使用左右滑动的模式。因为上下滑动的模式很容易和系统的控制中心、通知的手势冲突。&lt;/p&gt;
&lt;h2 id=&quot;主导航&quot;&gt;&lt;a href=&quot;#主导航&quot; class=&quot;headerlink&quot; title=&quot;主导航&quot;&gt;&lt;/a&gt;主导航&lt;/h2&gt;&lt;p&gt;没错，在前几年比较流行的就是那种侧边抽屉的主导航，就是“突破画布”的思维来打破虚拟的边界，让这个屏幕尺寸有限的手机可以呈现更多的内容。&lt;br&gt;但是，facebook在千万级用户批量测试中，选项卡式完胜侧边抽屉式和其他类型的导航模式。这也是为什么现在打开很多主流的APP。你会发现很多的APP都使用的是选项式的导航，就是下面的tab的切换，最多只有5个tab。  &lt;/p&gt;
&lt;p&gt;微信：下面有4个tab。微信、通讯录、发现和我。使用用户偏好的左右滑动的手势来实现了聊天记录的标记与删除。而在上部使用简洁的搜索和一个＋的点击，来发起群聊，添加朋友，扫一扫和收付款，这就说明了在顶部的导航，应该放一些比较显目，提醒用户或是做一些常用的功能的入口。&lt;/p&gt;
&lt;p&gt;微博：下面有5个tab。微博、消息、弹框、发现和我。而微博的新版也为了迎合用户喜好的左右滑动，把常用的热门的功能放在外面（原来是在发现里面的）和全部微博平行的左右滑动的入口。左边还是照相机，推出了微博的新功能，微博故事–可以用来拍摄照片和视频，类似朋友圈的小视频，时间大于10秒，而且可以用户个性化的编辑，添加表情、文字、图片，而且类似直播的画面设计，粉丝可以关注然后评论。很赞！&lt;br&gt;右边是扫一扫和打车的入口。顶部是简洁的搜索。  &lt;/p&gt;
&lt;p&gt;京东：下面是5个tab，首页，分类，觅Me，购物车和我的。上面是搜索框。左边是扫一扫，右边是消息。&lt;br&gt;实话说，我比较喜欢京东的设计，尤其是分类tab中的两级的菜单的显示。左边是菜单的项，联动的是菜单下面的collectionView的显示。很容易找到自己所喜欢的类别。然后是觅Me的tab，上面是ScrollView的滑动，很符合用户的左右滑动的习惯，而且一点也不卡的显示了视频精选、直播、关注、清单、问答、视频够、社区、生活、亲子、风尚、美食，滑动特别的流畅，对于视频的缓存，图片和文字的排版，图片的缓存还有下拉图标的动画是一个快递员。真的很好的设计呐~&lt;/p&gt;
&lt;p&gt;淘宝：下面也是5个tab，首页、微淘、问大家、购物车和我的淘宝。上面也同样是扫一扫和搜索框，还有消息。我一直觉得淘宝的拍照购物很神奇，不过现在好像很多电商：比如京东，都实现了这种是一种类似算法匹配的搜索吧。虽然有的时候也不是很准啦。第一个tab还实现了点击一个图标的跳动，显示成了火箭🚀的标识。直接跳转到了猜你喜欢的一系列（这个应该是现在最流行的机器学习大数据来统计用户的喜好）来推荐你的习惯和购物习惯来定制的为你推荐产品，促进你的购物消费。&lt;/p&gt;
&lt;p&gt;支付宝：&lt;/p&gt;
&lt;p&gt;网易云音乐：&lt;/p&gt;
&lt;p&gt;简书：&lt;/p&gt;
&lt;p&gt;手机QQ：手机QQ及更不用说了，都好多年沉淀的技术了，好多的功能的隐藏。都没有注意到过，主要现在跟多的在玩微博，很少玩QQ了，QQ里面有个日迹的入口和微博故事很像。但是入口就没有微博辣么明显了。&lt;/p&gt;
&lt;p&gt;对于这种主流的导航可以写一些个Demo了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在我们平时使用APP的时候，尤其是现在那些主流的APP，它们的设计模式。是如何迎合用户的需求和喜好。如果你自己做的一款产品你自己都不喜欢的话，如何让更多的用户去使用这个APP呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jenkins搭建来实现自动化打包</title>
    <link href="http://peilinghui.com/2017/06/14/Jenkins%E6%90%AD%E5%BB%BA%E6%9D%A5%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"/>
    <id>http://peilinghui.com/2017/06/14/Jenkins搭建来实现自动化打包/</id>
    <published>2017-06-14T10:45:34.000Z</published>
    <updated>2017-06-19T08:53:21.000Z</updated>
    
    <content type="html">&lt;p&gt;Jenkins持续集成自动化打包平台在一般公司都会使用，但是有的时候都不用我来弄，凡事都是觉知此事要躬行，只有亲身经历了才会知道怎么做额。好了，就来探索一下吧。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;配置Java环境&quot;&gt;&lt;a href=&quot;#配置Java环境&quot; class=&quot;headerlink&quot; title=&quot;配置Java环境&quot;&gt;&lt;/a&gt;配置Java环境&lt;/h1&gt;&lt;p&gt;mac OS 10.6及以前的版本中系统已经自带了JDK 1.6可以直接使用JDK1.6 ，现在最新是jdk1.8&lt;/p&gt;
&lt;p&gt;在mac OS 10.7及之后的版本中苹果移除了Java的本地支持，所以需要手动安装JDK&lt;/p&gt;
&lt;p&gt;一、  JDK 的下载与安装&lt;br&gt;下载jdk：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Oracle官方下载链接:&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;版本 $ java -version &lt;/li&gt;
&lt;li&gt;&lt;p&gt;mac系统自带的jdk的安装目录在如下目录：/System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home&lt;br&gt;在mac系统里面jdk的路径是要到Home这里的，所以我们在后面配置环境变量的时候一点要记住选择到home这个文件这里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们自己安装的jdk的目录一般在：/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home  下,也就是到Library这个目录下面去找应该就可以找到。找到路径以后就是如何配置环境变量的问题，配置环境变量比较简单：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置jdk环境变量&lt;br&gt;编辑profile文件: $ vi /etc/profile,配置JAVA_HOME,Java JDK安装路径,根据你自己的版本来写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xquery&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.&lt;span class=&quot;number&quot;&gt;7.0_79&lt;/span&gt;.jdk/Contents/Home&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLASSPAHT=.:&lt;span class=&quot;variable&quot;&gt;$JAVA&lt;/span&gt;_HOME/lib/dt.jar:&lt;span class=&quot;variable&quot;&gt;$JAVA&lt;/span&gt;_HOME/lib/tools.jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;variable&quot;&gt;$JAVA&lt;/span&gt;_HOME/bin:&lt;span class=&quot;variable&quot;&gt;$PATH&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export JAVA_HOME&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export CLASSPATH&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;保存退出 ,&lt;code&gt;$ source .bash_profile&lt;/code&gt;&lt;br&gt;环境变量是否已经配置成功：&lt;code&gt;echo $JAVA_HOME&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装Jenkins&quot;&gt;&lt;a href=&quot;#安装Jenkins&quot; class=&quot;headerlink&quot; title=&quot;安装Jenkins&quot;&gt;&lt;/a&gt;安装Jenkins&lt;/h1&gt;&lt;p&gt;访问 &lt;a href=&quot;http://localhost:8080&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Jenkins Master/Slave 架构&lt;/p&gt;
&lt;p&gt;Master/Slave 相当于 Server 和 agent 的概念。Master 提供 web 接口让用户来管理 job 和 slave，job 可以运行在 master 本机或者被分配到 slave 上运行。一个 master 可以关联多个 slave 用来为不同的 job 或相同的 job 的不同配置来服务。&lt;/p&gt;
&lt;p&gt;当 job 被分配到 slave 上运行的时候，此时 master 和 slave 其实是建立的双向字节流的连接， 其中连接方法主要有如下几种:&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Jenkins持续集成自动化打包平台在一般公司都会使用，但是有的时候都不用我来弄，凡事都是觉知此事要躬行，只有亲身经历了才会知道怎么做额。好了，就来探索一下吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>做一个搜索框的Demo</title>
    <link href="http://peilinghui.com/2017/05/27/%E5%81%9A%E4%B8%80%E4%B8%AA%E6%90%9C%E7%B4%A2%E6%A1%86%E7%9A%84Demo/"/>
    <id>http://peilinghui.com/2017/05/27/做一个搜索框的Demo/</id>
    <published>2017-05-27T15:11:25.000Z</published>
    <updated>2017-07-03T23:49:02.000Z</updated>
    
    <content type="html">&lt;p&gt;打开手机，就会发现我们用的最多的就是TableView和搜索框了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;打开手机，从通知中心的搜索，APP store的搜索，通讯录的搜索，设置页面的搜索，照片搜索，信息搜索，再到打开每一个APP，都有的搜索。看了下，实现的需求类似，基本上都是输入关键字从网络接口上来搜索，只要点击过的都会保存到历史记录中，然后显示到历史记录的tableview中，下次可以直接点击然后搜索。可以清空单个记录或者所有的历史记录。还有一些APP还有热门搜索的标签。&lt;br&gt;所以，鉴于此，决定做一个Demo出来。&lt;/p&gt;
&lt;h1 id=&quot;搜索框&quot;&gt;&lt;a href=&quot;#搜索框&quot; class=&quot;headerlink&quot; title=&quot;搜索框&quot;&gt;&lt;/a&gt;搜索框&lt;/h1&gt;&lt;p&gt;对于搜索框可以用系统自带的UISearchBar，UISearchController，UISearchDisplayController，或者是自定义搜索框–把UIView和UITextField代理结合起来，&lt;/p&gt;
&lt;h1 id=&quot;搜索功能&quot;&gt;&lt;a href=&quot;#搜索功能&quot; class=&quot;headerlink&quot; title=&quot;搜索功能&quot;&gt;&lt;/a&gt;搜索功能&lt;/h1&gt;&lt;p&gt;对于搜索功能的实现，&lt;br&gt;动态的：可以在输入一个字符，根据关键字去请求接口来返回数据加载在tableView上。&lt;br&gt;静态的：如果数据是本地的，或者是已经加载出来的数据中来搜索的话，可以用&lt;br&gt;NSPredicate来做过滤筛选出想要搜索的结果。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSPredicate&lt;/span&gt; *resultPredicate = [&lt;span class=&quot;built_in&quot;&gt;NSPredicate&lt;/span&gt; predicateWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;SELF contains[cd] %@&quot;&lt;/span&gt;, searchText];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.searchResults&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.items&lt;/span&gt; filteredArrayUsingPredicate:resultPredicate];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;历史记录的存储&quot;&gt;&lt;a href=&quot;#历史记录的存储&quot; class=&quot;headerlink&quot; title=&quot;历史记录的存储&quot;&gt;&lt;/a&gt;历史记录的存储&lt;/h1&gt;&lt;p&gt;对于已经搜索过的历史记录可以选择的数据化存储有NSUserDefault，存在本地的Plist。还有就是Core Data的存储。&lt;br&gt;在APPdelegate中打印NSLog(@”%@”, NSHomeDirectory());记录本地存储的地址。&lt;br&gt;一般是/Users/peilinghui/Library/Developer/CoreSimulator/Devices/44CFA0DF-507C-4C90-A9E2-215F6706FB36/data/Containers/Data/Application/AA25A5E2-6E19-47F4-AB43-D4C73B1C3DE5。每次登陆都不一样额。&lt;/p&gt;
&lt;p&gt;[[NSUserDefaults standardUserDefaults] objectForKey:obj];&lt;/p&gt;
&lt;p&gt;对于多用户的历史记录的存储要拼接用户名&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *paths = &lt;span class=&quot;built_in&quot;&gt;NSSearchPathForDirectoriesInDomains&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSDocumentDirectory&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSUserDomainMask&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *docDir = [paths objectAtIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// NSString *historyScheduleListPath = [docDir stringByAppendingPathComponent:@&quot;historySchedule.plist&quot;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *historyScheduleListPath = [docDir stringByAppendingPathComponent:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; stringWithFormat:&lt;span class=&quot;string&quot;&gt;@&quot;history--%@.plist&quot;&lt;/span&gt;,UserDefaultsObjectForKey(LOGINUSERNAME)]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;tableView的数据源&quot;&gt;&lt;a href=&quot;#tableView的数据源&quot; class=&quot;headerlink&quot; title=&quot;tableView的数据源&quot;&gt;&lt;/a&gt;tableView的数据源&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;如果是从接口查询数据的话，必然有历史记录的table和查询结果table。这个需要用到两个tableView两个数据源。通过判断来加载不同的数据源。&lt;/li&gt;
&lt;li&gt;如果是从已经有的数据源中搜索结果，不论是静态的还是先从历史记录中搜索，用到谓词匹配的时候，也可以设置两个数据源来刷新一个table，或者是两个table两个数据源.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;键盘的收起&quot;&gt;&lt;a href=&quot;#键盘的收起&quot; class=&quot;headerlink&quot; title=&quot;键盘的收起&quot;&gt;&lt;/a&gt;键盘的收起&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;当数据加载到tableview上，然后滚动时，要收起键盘：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark - &lt;span class=&quot;title&quot;&gt;&amp;lt; UIScrollViewDelegate &amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewWillBeginDragging:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)scrollView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.searchBar&lt;/span&gt; setShowsCancelButton:&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt; animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.searchBar&lt;/span&gt; endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;点击searchBar的确定搜索和取消按钮的时候，要收起键盘：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;[searchBar resignFirstResponder];&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当进入后台的时候要收起键盘：不用view实现endEditing的方法&lt;br&gt;&lt;code&gt;[[[UIApplication sharedApplication] keyWindow] endEditing:YES];&lt;/code&gt;&lt;br&gt;或者&lt;br&gt;&lt;code&gt;[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击背景View的时候收起键盘：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;点击背景收起键盘可以实现view的&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;UITouch&lt;/span&gt; *&amp;gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event方法，然后执行view的- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)endEditing:(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)force;方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)touchesBegan:(&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;UITouch&lt;/span&gt; *&amp;gt; *)touches withEvent:(&lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt; endEditing:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;span class=&quot;comment&quot;&gt;//实现该方法是需要注意view需要是继承UIControl而来的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在背景view上面加手势，添加UIButton或者view，然后在对应的点击事件的监听方法中实现resignFirstResponder或者endEditing。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; *tapGestureRecognizer = [[&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(keyboardHide:)];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置成NO表示当前控件响应后会传播到其他控件上，默认为YES。  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tapGestureRecognizer&lt;span class=&quot;variable&quot;&gt;.cancelsTouchesInView&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将触摸事件添加到view上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt; addGestureRecognizer:tapGestureRecognizer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)keyboardHide:(&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt;*)tap&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [textFiled resignFirstResponder];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/%E7%A4%BA%E4%BE%8B%E6%90%9C%E7%B4%A2%E6%A1%86%E7%9A%84Table&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/%E7%A4%BA%E4%BE%8B%E6%90%9C%E7%B4%A2%E6%A1%86%E7%9A%84Table&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;打开手机，就会发现我们用的最多的就是TableView和搜索框了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何使用Mac本地服务器</title>
    <link href="http://peilinghui.com/2017/05/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Mac%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://peilinghui.com/2017/05/27/如何使用Mac本地服务器/</id>
    <published>2017-05-27T14:27:26.000Z</published>
    <updated>2017-05-27T15:42:26.000Z</updated>
    
    <content type="html">&lt;p&gt;我们经常性的需要使用局域网搭建 Web 服务器测试环境，如部署局域网无线安装企业应用，模拟某个接口的返回JSON的时候，Mac OS X 自带了 Apache 和 PHP 环境，我们只需要简单的启动它就行了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;启动-Apache&quot;&gt;&lt;a href=&quot;#启动-Apache&quot; class=&quot;headerlink&quot; title=&quot;启动 Apache&quot;&gt;&lt;/a&gt;启动 Apache&lt;/h1&gt;&lt;h4 id=&quot;查看Apache版本&quot;&gt;&lt;a href=&quot;#查看Apache版本&quot; class=&quot;headerlink&quot; title=&quot;查看Apache版本&quot;&gt;&lt;/a&gt;查看Apache版本&lt;/h4&gt;&lt;p&gt;打开终端，输入&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ httpd -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Server version: Apache/&lt;span class=&quot;number&quot;&gt;2.4&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.25&lt;/span&gt; (Unix)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Server built:   Feb  &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;08&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;启动Apache&quot;&gt;&lt;a href=&quot;#启动Apache&quot; class=&quot;headerlink&quot; title=&quot;启动Apache&quot;&gt;&lt;/a&gt;启动Apache&lt;/h4&gt;&lt;p&gt;在终端输入 sudo apachectl start 即可启动 Apache。&lt;br&gt;启动后，在浏览器中输入 &lt;a href=&quot;http://127.0.0.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1&lt;/a&gt; 或 &lt;a href=&quot;http://localhost&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost&lt;/a&gt; 如果看到 It Works! 页面。那么 Apache 就启动成功了，站点的根目录为系统级根目录 /Library/WebServer/Documents。&lt;/p&gt;
&lt;p&gt;启动后，你可以通过编辑 /etc/apache2/httpd.conf 文件来修改 Apache 配置&lt;/p&gt;
&lt;h4 id=&quot;停止-Apache：sudo-apachectl-stop&quot;&gt;&lt;a href=&quot;#停止-Apache：sudo-apachectl-stop&quot; class=&quot;headerlink&quot; title=&quot;停止 Apache：sudo apachectl stop&quot;&gt;&lt;/a&gt;停止 Apache：sudo apachectl stop&lt;/h4&gt;&lt;h4 id=&quot;重启-Apache：sudo-apachectl-restart&quot;&gt;&lt;a href=&quot;#重启-Apache：sudo-apachectl-restart&quot; class=&quot;headerlink&quot; title=&quot;重启 Apache：sudo apachectl restart&quot;&gt;&lt;/a&gt;重启 Apache：sudo apachectl restart&lt;/h4&gt;&lt;h2 id=&quot;创建用户级根目录&quot;&gt;&lt;a href=&quot;#创建用户级根目录&quot; class=&quot;headerlink&quot; title=&quot;创建用户级根目录&quot;&gt;&lt;/a&gt;创建用户级根目录&lt;/h2&gt;&lt;p&gt;我们也可以创建用户级根目录，更方便管理和操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在用户目录下创建 Sites 目录，cd; mkdir Sites; touch Sites/.localized，旧的 Mac 系统中如果该目录已存在，则略过。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cd /etc/apache2/users 检查目录下是否存在 username.conf 文件，username 为当前用户名，如果没有则创建一个 sudo touch username.conf，并修改文件权限 sudo chmod 644 username.conf。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建之后，打开 username.conf 文件，sudo vi  username.conf 将下面的配置信息写入文件，username 依然为当前用户名：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;Directory &quot;/Users/username/Sites/&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;common&quot;&gt;Options&lt;/span&gt;&lt;/span&gt; Indexes MultiViews FollowSymLinks&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;AllowOverride&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;All&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;common&quot;&gt;Order&lt;/span&gt;&lt;/span&gt; allow,deny&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;common&quot;&gt;Allow&lt;/span&gt;&lt;/span&gt; from &lt;span class=&quot;literal&quot;&gt;all&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;Require&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;all&lt;/span&gt; granted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;编辑 /etc/apache2/httpd.conf 文件，找到下列代码，并将前面的注释符号 # 删除：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Include &lt;span class=&quot;regexp&quot;&gt;/private/&lt;/span&gt;etc&lt;span class=&quot;regexp&quot;&gt;/apache2/&lt;/span&gt;extra/httpd-userdir.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoadModule userdir_module libexec&lt;span class=&quot;regexp&quot;&gt;/apache2/&lt;/span&gt;mod_userdir.so&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编辑 /etc/apache2/extra/httpd-userdir.conf 文件，找到下列代码，并将前面的注释符号 # 删除：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Include /private/etc/apache2/users/*.conf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重启 Apache：sudo apachectl restart&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在浏览器中输入 &lt;a href=&quot;http://127.0.0.1/~username&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://127.0.0.1/~username&lt;/a&gt; 或 &lt;a href=&quot;http://localhost/~username，即可测试用户目录是否工作。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost/~username，即可测试用户目录是否工作。&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常性的需要使用局域网搭建 Web 服务器测试环境，如部署局域网无线安装企业应用，模拟某个接口的返回JSON的时候，Mac OS X 自带了 Apache 和 PHP 环境，我们只需要简单的启动它就行了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS打包和发布流程</title>
    <link href="http://peilinghui.com/2017/05/10/iOS%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/"/>
    <id>http://peilinghui.com/2017/05/10/iOS打包和发布流程/</id>
    <published>2017-05-10T08:56:16.000Z</published>
    <updated>2017-05-28T17:41:11.000Z</updated>
    
    <content type="html">&lt;p&gt;学习iOS的打包和发布流程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;两种证书&quot;&gt;&lt;a href=&quot;#两种证书&quot; class=&quot;headerlink&quot; title=&quot;两种证书&quot;&gt;&lt;/a&gt;两种证书&lt;/h2&gt;&lt;p&gt;App证书分为两种：开发证书、发布证书。App发布证书分：AppStore(正常的发布到商店) 及 Adhoc（内部测试发布） 两种。&lt;/p&gt;
&lt;h2 id=&quot;真机运行-dev&quot;&gt;&lt;a href=&quot;#真机运行-dev&quot; class=&quot;headerlink&quot; title=&quot;真机运行(dev)&quot;&gt;&lt;/a&gt;真机运行(dev)&lt;/h2&gt;&lt;p&gt;真机调试指 mac 连上 iphone, xcode 可以直接以这台 iphone 设备为 build target, 能在 iphone 里执行编译结果&lt;br&gt;为什么真机调试？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部分功能需要硬件支持，模拟器是不支持的，如：&lt;br&gt;传感器：磁力计、陀螺仪、距离传感器等&lt;br&gt;特定功能：拍照、打电话、发短信、蓝牙等&lt;/p&gt;
&lt;p&gt;真机的环境和模拟器的环境是不一样，模拟器是使用电脑的环境， CPU、Memory、Disk、Network 这些和真机环境都不一样，有些bug可能会在特定的环境才会出现，比如网络非常慢，内存特别小的时候，可能在模拟器上不会有bug，在真机上就有可能出现bug&lt;br&gt;使用真机开发比使用模拟器体验更好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Xcode7以前：&quot;&gt;&lt;a href=&quot;#Xcode7以前：&quot; class=&quot;headerlink&quot; title=&quot;Xcode7以前：&quot;&gt;&lt;/a&gt;Xcode7以前：&lt;/h4&gt;&lt;p&gt;真机调试的主要步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登录开发者主页&lt;/li&gt;
&lt;li&gt;生成cer证书：cer是一个跟电脑相关联的证书文件，让电脑具备真机调试的功能&lt;/li&gt;
&lt;li&gt;添加App ID：调试哪些app？&lt;/li&gt;
&lt;li&gt;注册真机设备：哪台设备需要做真机调试？&lt;/li&gt;
&lt;li&gt;生成MobileProvision文件：结合2、3、4生成一个手机规定文件&lt;/li&gt;
&lt;li&gt;导入cer、MobileProvision文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终会得到2个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cer文件：让电脑具备真机调试的功能&lt;/li&gt;
&lt;li&gt;MobileProvision文件：哪台设备、哪些app、哪台电脑需要做真机调试？&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Xcode7以后&quot;&gt;&lt;a href=&quot;#Xcode7以后&quot; class=&quot;headerlink&quot; title=&quot;Xcode7以后&quot;&gt;&lt;/a&gt;Xcode7以后&lt;/h4&gt;&lt;p&gt;Xcode–&amp;gt;Preferences—&amp;gt;Accounts—&amp;gt; Add Apple ID 然后选择真机直接允许App，弹出来个框点击Fix Issue即可，这样就完成真机测试了。&lt;/p&gt;
&lt;p&gt;Xcode7.0真机测试Apple ID必须加入苹果开发者计划，而Xcode7.0之后直接使用普通的Apple ID即可真机测试。注意Xcode7.0之后并不是不需要.cer和.mobileprovision文件，而是苹果已经生产了这两个文件，并将.cer文件安装到钥匙串访问里，.mobileprovision已经复制到Library/MobileDevice/Provisioning Profiles文件夹中.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ios.jobbole.com/89870/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS真机调试详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;测试打包&quot;&gt;&lt;a href=&quot;#测试打包&quot; class=&quot;headerlink&quot; title=&quot;测试打包&quot;&gt;&lt;/a&gt;测试打包&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;登录apple的开发者主页:developer.apple.com&lt;/li&gt;
&lt;li&gt;选择Ad Hoc生成一个ios_distribution.cer: 让电脑具备打包程序的能力&lt;/li&gt;
&lt;li&gt;新建一个App ID : 方便打包哪个程序&lt;/li&gt;
&lt;li&gt;利用用户设备的UDID注册设备&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择Ad Hoc利用ios_distribution.cer + 设备UDID + App ID –&amp;gt; 描述文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(描述文件的作用:
1&amp;gt; 能知道在哪台电脑上, 为哪台设备打包哪个程序
2&amp;gt; 哪台设备需要安装打包哪个程序    )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最终产生了3个文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt; CertificateSigningRequest.certSigningRequest(CSR证书)
* 包含了电脑的信息
* 发送给苹果服务器, 苹果服务器根据文件信息来生成一个电脑证书
* 生成的证书就可以让对应的电脑具备某个特殊的能力
2&amp;gt; ios_distribution.cer
* 打包证书
* 安装这个证书后, 电脑就具备打包程序的能力
3&amp;gt; nj_iphone6_news.mobileprovision
* 里面包含了3个信息:ios_distribution.cer + 设备UDID + App ID
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装证书和描述文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt; ios_distribution.cer
2&amp;gt; nj_iphone6_news.mobileprovision
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;项目Scheme右边的设备选择iOS Device&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;点击Xcode的菜单&lt;br&gt;Product –&amp;gt; Archive –&amp;gt; Distribute –&amp;gt; ….Ad Hoc… –&amp;gt; 选择对应的描述文件&lt;/li&gt;
&lt;li&gt;生成一个ipa文件,发给测试人员和客户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多：&lt;a href=&quot;http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用Jenkins搭建iOS/Android持续集成打包平台&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;发布&quot;&gt;&lt;a href=&quot;#发布&quot; class=&quot;headerlink&quot; title=&quot;发布&quot;&gt;&lt;/a&gt;发布&lt;/h2&gt;&lt;p&gt;四种发布方式：&lt;/p&gt;
&lt;h3 id=&quot;苹果应用商店发布AppStore&quot;&gt;&lt;a href=&quot;#苹果应用商店发布AppStore&quot; class=&quot;headerlink&quot; title=&quot;苹果应用商店发布AppStore&quot;&gt;&lt;/a&gt;苹果应用商店发布AppStore&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;developer.apple.com : 开发者主页, 配置证书\AppId\描述文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt;发布的证书, 说清楚哪台电脑可以发布程序
2&amp;gt;添加发布的描述文件，描述在哪台计算机上能够发布哪些应用程序
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iTunesConnect网站(专门用来发布应用程序)&lt;br&gt;&lt;a href=&quot;https://itunesconnect.apple.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://itunesconnect.apple.com&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt;    如果想挣钱，先设置在Agreements, Tax, and Banking设置个人储蓄卡信息
做一次就行
2&amp;gt; 添加应用程序
－ 名称，不能重复，可以使用 - 添加一些后缀信息
－ 关键字，增加软件被搜中的几率，使用英文的都好分隔，不能超过255个字节
－图片，图片文件名称中不能有中文
－ Rating，设置应用程序的等级，默认都选择最低的，成人，赌博……
－ App Review Information
提供给苹果的审核人员，来辅助测试使用的。
如果有测试帐号，必须提供！
如果有测试数据，需要提供给苹果，例如快递查询！
需要提供联系人的联系方式，电子邮件，电话需要添加国际区号，+86
3&amp;gt; 从Xcode6开始，上传完应用程序之后，程序默认会在prerelease中，需要等待5～50分钟不等。只有Prerelease中的状态变化后，才能够在Versions中添加Build，提示，这个过程中，不要重复在Xcode中上传。    
4&amp;gt; 所有准备就绪后，点Submit按钮提交应用程序，出现的三个选项，都选择No。
卡通形象，第三方内容，商标！
5&amp;gt; 等待，2天～20天不等……
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;苹果应用商店批量购买发布（Volume-Purchase-Program）&quot;&gt;&lt;a href=&quot;#苹果应用商店批量购买发布（Volume-Purchase-Program）&quot; class=&quot;headerlink&quot; title=&quot;苹果应用商店批量购买发布（Volume Purchase Program）&quot;&gt;&lt;/a&gt;苹果应用商店批量购买发布（Volume Purchase Program）&lt;/h3&gt;&lt;h3 id=&quot;Ad-Hoc应用发布方式&quot;&gt;&lt;a href=&quot;#Ad-Hoc应用发布方式&quot; class=&quot;headerlink&quot; title=&quot;Ad Hoc应用发布方式.&quot;&gt;&lt;/a&gt;Ad Hoc应用发布方式.&lt;/h3&gt;&lt;p&gt;Ad Hoc方式发布应用，应用的具体内容也不需要经过苹果的评审，但限制每个应用不能发布到超过100个设备上。如果应用需要小规模的测试或者企业规模很小可以采用这种方式发布企业应用.&lt;/p&gt;
&lt;h3 id=&quot;In-House企业应用发布&quot;&gt;&lt;a href=&quot;#In-House企业应用发布&quot; class=&quot;headerlink&quot; title=&quot;In-House企业应用发布&quot;&gt;&lt;/a&gt;In-House企业应用发布&lt;/h3&gt;&lt;p&gt;In-House企业应用是不能提交到App Store,发布应用的具体内容也是不需要苹果官方审核.安装设备的数量目前也没有任何限制.所以权限最为开放，适合针对支持开放大批量对外用户测试使用.所以你看到很多第三方开放渠道下载IPA其实基于其他企业账号来支持的.&lt;/p&gt;
&lt;h4 id=&quot;内网OTA&quot;&gt;&lt;a href=&quot;#内网OTA&quot; class=&quot;headerlink&quot; title=&quot;内网OTA&quot;&gt;&lt;/a&gt;内网OTA&lt;/h4&gt;&lt;p&gt;OTA即Over-the-Air，是Apple在 iOS4 中新加的一项技术，目的是让开发者能够脱离Appstore，实现从自己的服务器下载并安装iOS应用。简单地说，就是用户只需要在Safari中点开一条链接，就能直接在主界面中安装App。&lt;/p&gt;
&lt;p&gt; 实现步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用Xcode打包release版本&lt;/li&gt;
&lt;li&gt;搭建本地Web服务器&lt;/li&gt;
&lt;li&gt;开启HTTPS&lt;/li&gt;
&lt;li&gt;编写好对应的.plist文件&lt;/li&gt;
&lt;li&gt;上传ipa、.plist、ca证书到Web服务器，配置好index.html&lt;/li&gt;
&lt;li&gt;在手机上用Safari打开链接，完成下载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多参考：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/35ca63ec0d8e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一步一步实现无线安装iOS应用(内网OTA)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/close_marty/article/details/38559673&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jenkins中集成OTA发布&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;APNS远程通知&quot;&gt;&lt;a href=&quot;#APNS远程通知&quot; class=&quot;headerlink&quot; title=&quot;APNS远程通知&quot;&gt;&lt;/a&gt;APNS远程通知&lt;/h2&gt;&lt;p&gt;iOS中提供了2种推送通知:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本地推送通知（Local Notification）:不需要联网就能发出的推送通知（不需要服务器的支持）定时提醒用户完成一些任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;远程推送通知（Remote Notification）：就是从远程服务器推送给客户端的通知（需要联网）远程推送服务，又称为APNs（Apple Push Notification Services）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建支持远程推送功能的App ID&lt;/li&gt;
&lt;li&gt;申请开发者证书，并选中刚刚创建的App ID&lt;/li&gt;
&lt;li&gt;下载CER文件，并导入钥匙串管理&lt;/li&gt;
&lt;li&gt;申请发布证书，并选中刚刚创建的App ID&lt;/li&gt;
&lt;li&gt;下载CER文件，并导入钥匙串管理&lt;/li&gt;
&lt;li&gt;检查App ID，确认证书已经指定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)application:(&lt;span class=&quot;built_in&quot;&gt;UIApplication&lt;/span&gt; *)application didFinishLaunchingWithOptions:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)launchOptions&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef __IPHONE_8_0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注册接收通知的类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; *settings = [&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationSettings&lt;/span&gt; settingsForTypes:&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeAlert&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeBadge&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeSound&lt;/span&gt; categories:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [application registerUserNotificationSettings:settings];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注册允许接收远程推送通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [application registerForRemoteNotifications];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果是iOS7.0，使用以下方法注册&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [application registerForRemoteNotificationTypes:&lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeAlert&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeBadge&lt;/span&gt; | &lt;span class=&quot;built_in&quot;&gt;UIUserNotificationTypeSound&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PushMeBaby是一款用来测试ANPs的开源Mac项目：&lt;a href=&quot;https://github.com/stefanhafeneger/PushMeBaby&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/stefanhafeneger/PushMeBaby&lt;/a&gt;它充当了服务器的作用，用法非常简单。它负责将内容提交给苹果的APNs服务器，苹果的APNs服务器再将内容推送给用户的设备。将推送的调试证书改为名apns.cer，添加到PushMeBaby项目中。&lt;/li&gt;
&lt;li&gt;JPush：&lt;a href=&quot;https://www.jpush.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.jpush.cn&lt;/a&gt;&lt;br&gt;一套远程推送解决方案，支持android和iOS两个平台。&lt;br&gt;它能够快捷地为iOS App增加推送功能，减少集成APNs需要的工作量、开发复杂度。[集成iOS SDK]&lt;br&gt;(&lt;a href=&quot;http://docs.jpush.cn/pages/viewpage.action?pageId=2621727&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.jpush.cn/pages/viewpage.action?pageId=2621727&lt;/a&gt;)&lt;br&gt;JPush会自动记录和管理所有安装过此app的设备deviceToken&lt;br&gt;利用JPush，可以轻易地给所有设备发送远程推送通知.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;更多参考：&quot;&gt;&lt;a href=&quot;#更多参考：&quot; class=&quot;headerlink&quot; title=&quot;更多参考：&quot;&gt;&lt;/a&gt;更多参考：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.qcloud.com/community/article/673429&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS 程序从开发完到上 AppStore 那点事儿&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/mddblog/p/4718228.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果企业账号打包发布APP流程详解&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习iOS的打包和发布流程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS中JS与OC相互调用的方式</title>
    <link href="http://peilinghui.com/2017/05/05/%E5%AD%A6%E4%B9%A0iOS%E4%B8%ADJS%E4%B8%8EOC%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://peilinghui.com/2017/05/05/学习iOS中JS与OC相互调用的方式/</id>
    <published>2017-05-05T06:50:42.000Z</published>
    <updated>2017-05-11T01:24:53.000Z</updated>
    
    <content type="html">&lt;p&gt;Web App即是HTML5 APP框架开发模式，使用HTML5,CSS3以及JavaScript以及服务器端语言来完成开发，Web App具有跨平台的优势。那么就来学习一下iOS中JS与OC相互调用的方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;目前JS与OC相互调用的方式&quot;&gt;&lt;a href=&quot;#目前JS与OC相互调用的方式&quot; class=&quot;headerlink&quot; title=&quot;目前JS与OC相互调用的方式&quot;&gt;&lt;/a&gt;目前JS与OC相互调用的方式&lt;/h1&gt;&lt;p&gt;目前主要的JS与OC相互调用方式主要有如下6种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JS 中做一次URL跳转，然后在OC中拦截跳转。（这里分为UIWebView 和 WKWebView两种，UIWebView兼容iOS 6）&lt;/li&gt;
&lt;li&gt;利用WKWebView 的MessageHandler。(有坑)&lt;/li&gt;
&lt;li&gt;利用系统库JavaScriptCore，来做相互调用。（iOS 7推出）&lt;/li&gt;
&lt;li&gt;利用第三方库WebViewJavascriptBridge。&lt;/li&gt;
&lt;li&gt;利用第三方cordova库，以前叫PhoneGap。（这是一个库平台的库）&lt;/li&gt;
&lt;li&gt;当下盛行的React Native。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8A%E5%8D%8811.49.52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;拦截URL&quot;&gt;&lt;a href=&quot;#拦截URL&quot; class=&quot;headerlink&quot; title=&quot;拦截URL&quot;&gt;&lt;/a&gt;拦截URL&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8A%E5%8D%8811.55.32.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;UIWebView&quot;&gt;&lt;a href=&quot;#UIWebView&quot; class=&quot;headerlink&quot; title=&quot;UIWebView&quot;&gt;&lt;/a&gt;UIWebView&lt;/h2&gt;&lt;p&gt;在以前我们只能通过UIWebView的UIWebViewDelegate协议来实现oc与js的通信交互就是发送消息，也即函数调用。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)stringByEvaluatingJavaScriptFromString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)script;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIWebViewDelegate&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@optional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)webView:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView shouldStartLoadWithRequest:(&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; *)request navigationType:(&lt;span class=&quot;built_in&quot;&gt;UIWebViewNavigationType&lt;/span&gt;)navigationType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webViewDidStartLoad:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webViewDidFinishLoad:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webView:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView didFailLoadWithError:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;oc–&amp;gt;js stringByEvaluatingJavaScriptFromString,其参数是一NSString 字符串内容是js代码（这又可以是一个js函数、一句js代码或他们的组合），当js函数有返回值或一句js代码有值返回可通过stringByEvaluatingJavaScriptFromString的返回值获取&lt;/li&gt;
&lt;li&gt;js–&amp;gt;oc 利用webView的重定向原理（即重新在js中指定document.location的值，此为一url），只要在这个url字符串中按自定义的规则指定好所需调用oc中的函数和参数，然后通过OC中的shouldStartLoadWithRequest函数去捕获处理请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;WKWebView&quot;&gt;&lt;a href=&quot;#WKWebView&quot; class=&quot;headerlink&quot; title=&quot;WKWebView&quot;&gt;&lt;/a&gt;WKWebView&lt;/h2&gt;&lt;p&gt;由于UIWebView比较耗内存，性能上不太好，而苹果在iOS8中推出了WKWebView。同样的用WKWebView也可以拦截URL，做JS与OC交互。WKWebView与UIWebView拦截URL的处理方式基本一样。除了代理方法和WKWebView的使用不太一样。&lt;/p&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;更多的支持HTML5的特性
官方宣称的高达60fps的滚动刷新率以及内置手势
将UIWebViewDelegate与UIWebView拆分成了14类与3个协议,以前很多不方便实现的功能得以实现。文档
Safari相同的JavaScript引擎
占用更少的内存
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;WKWebView的创建有几点不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化多了configuration参数，当然这个参数也可以不传，直接使用默认的设置。&lt;/li&gt;
&lt;li&gt;WKWebView的代理有两个navigationDelegate和UIDelegate。我们要拦截URL，就要通过navigationDelegate的一个代理方法来实现。如果在HTML中要使用alert等弹窗，就必须得实现UIDelegate的相应代理方法。&lt;/li&gt;
&lt;li&gt;在iOS9之前，WKWebView加载本地HTML会有一些问题。（不能加载本地HTML，或者部分CSS/本地图片加载不了等）&lt;/li&gt;
&lt;li&gt;注意加载HTTP和HTTPS的时候要在文件设置App Transport Security Settings的Allow Arbitrary Loads设置为YES。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;WKNavigationDelegate&quot;&gt;&lt;a href=&quot;#WKNavigationDelegate&quot; class=&quot;headerlink&quot; title=&quot;WKNavigationDelegate&quot;&gt;&lt;/a&gt;WKNavigationDelegate&lt;/h4&gt;&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pp&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;webView:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKWebView&lt;/span&gt; *)&lt;/span&gt;webView decidePolicyForNavigationAction:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKNavigationAction&lt;/span&gt; *)&lt;/span&gt;navigationAction decisionHandler:&lt;span class=&quot;params&quot;&gt;(void (^)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKNavigationActionPolicy&lt;/span&gt;)&lt;/span&gt;)decisionHandler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现这个代理方法，必须得调用decisionHandler这个block，否则会导致app 崩溃。block参数是个枚举类型，WKNavigationActionPolicyCancel代表取消加载，相当于UIWebView的代理方法return NO的情况；WKNavigationActionPolicyAllow代表允许加载，相当于UIWebView的代理方法中return YES的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WKWebView中OC直接调用JS方法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *js = &lt;span class=&quot;string&quot;&gt;@&quot;callJsAlert()&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.webView&lt;/span&gt; evaluateJavaScript:js completionHandler:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; _Nullable response, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;response: %@ error: %@&quot;&lt;/span&gt;, response, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;call js alert by native&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;evaluateJavaScript:completionHandler:&lt;/strong&gt;没有返回值，JS 执行成功还是失败会在completionHandler 中返回。所以使用这个API 就可以避免执行耗时的JS，或者alert 导致界面卡住的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WKWebView中JS调用OC原生方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;MessageHandler&quot;&gt;&lt;a href=&quot;#MessageHandler&quot; class=&quot;headerlink&quot; title=&quot;MessageHandler&quot;&gt;&lt;/a&gt;MessageHandler&lt;/h2&gt;&lt;p&gt;利用WKWebView的新特性MessageHandler来实现JS调用原生方法。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8B%E5%8D%881.58.58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;MessageHandler的好处&quot;&gt;&lt;a href=&quot;#MessageHandler的好处&quot; class=&quot;headerlink&quot; title=&quot;MessageHandler的好处&quot;&gt;&lt;/a&gt;MessageHandler的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在JS中写起来简单，不用再用创建URL的方式那么麻烦了。&lt;/li&gt;
&lt;li&gt;JS传递参数更方便。使用拦截URL的方式传递参数，只能把参数拼接在后面，如果遇到要传递的参数中有特殊字符，如&amp;amp;、=、?等，必须得转换，否则参数解析肯定会出错。&lt;/li&gt;
&lt;li&gt;使用MessageHandler就可以避免特殊字符引起的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;p&gt;WKWebView初始化时，有一个参数叫configuration，它是WKWebViewConfiguration类型的参数，而WKWebViewConfiguration有一个属性叫userContentController，它又是WKUserContentController类型的参数。WKUserContentController对象有一个方法- addScriptMessageHandler:name:，我把这个功能简称为MessageHandler。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- addScriptMessageHandler:name:&lt;/code&gt;有两个参数，第一个参数是userContentController的代理对象，第二个参数是JS里发送postMessage的对象。&lt;/p&gt;
&lt;p&gt;所以要使用MessageHandler功能，就必须要实现WKScriptMessageHandler协议。&lt;br&gt;在OC文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;config.userContentController = [[WKUserContentController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 注入JS对象名称AppModel，当JS通过AppModel来调用时，我们可以在WKScriptMessageHandler代理中接收到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[config.userContentController &lt;span class=&quot;string&quot;&gt;addScriptMessageHandler:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;AppModel&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//WKScriptMessageHandler协议&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;userContentController:&lt;/span&gt;(WKUserContentController *)userContentController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;      didReceiveScriptMessage:&lt;/span&gt;(WKScriptMessage *)message &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([message.name &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;AppModel&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, message.body);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现协议方法。&lt;br&gt;这里实现了两个协议&amp;lt; WKUIDelegate,WKScriptMessageHandler &amp;gt;，WKUIDelegate是因为需要在JS中弹出alert。WKScriptMessageHandler是用来处理JS调用OC方法的请求。&lt;strong&gt;名字替换AppModel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JS文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// AppModel是我们所注入的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.webkit&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.messageHandlers&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.AppModel&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.postMessage&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attribute&quot;&gt;body&lt;/span&gt;: response&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;JavaScriptCore&quot;&gt;&lt;a href=&quot;#JavaScriptCore&quot; class=&quot;headerlink&quot; title=&quot;JavaScriptCore&quot;&gt;&lt;/a&gt;JavaScriptCore&lt;/h2&gt;&lt;p&gt;JavaScriptCore自iOS7之后出现，用Objective-C把WebKit的JavaScript引擎封装了一下，提供了简单快捷的方式与JavaScript交互。&lt;/p&gt;
&lt;p&gt;特点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS中调用OC方法更简单，参数的传递也更加简单 &lt;/li&gt;
&lt;li&gt;支持iOS7以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用-1&quot;&gt;&lt;a href=&quot;#使用-1&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;使用前需要先导入JavaScriptCore.framework&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSVirtualMachine直译是JS虚拟机，也就是说JavaScript是在一个虚拟的环境中执行，而JSVirtualMachine为其执行提供底层资源。&lt;/li&gt;
&lt;li&gt;JSContext是为JavaScript的执行提供运行环境，所有的JavaScript的执行都必须在JSContext环境中。JSContext也管理JSVirtualMachine中对象的生命周期。每一个JSValue对象都要强引用关联一个JSContext。当与某JSContext对象关联的所有JSValue释放后，JSContext也会被释放。&lt;/li&gt;
&lt;li&gt;JSValue都是通过JSContext返回或者创建的，并没有构造方法。JSValue包含了每一个JavaScript类型的值，通过JSValue可以将Objective-C中的类型转换为JavaScript中的类型，也可以将JavaScript中的类型转换为Objective-C中的类型。&lt;/li&gt;
&lt;li&gt;JSManagedValue主要用途是解决JSValue对象在Objective-C堆上的安全引用问题。把JSValue保存进Objective-C堆对象中是不正确的，这很容易引发循环引用，而导致JSContext不能释放。但是不常用。&lt;/li&gt;
&lt;li&gt;JSExport是一个协议类，但是该协议并没有任何属性和方法。可以自定义一个协议类，继承自JSExport。无论在JSExport里声明的属性、实例方法还是类方法，继承的协议都会自动的提供给任何JavaScript代码。因此，只需要在自定义的协议类中，添加上属性和方法就可以了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;WKWebVIew中的坑&quot;&gt;&lt;a href=&quot;#WKWebVIew中的坑&quot; class=&quot;headerlink&quot; title=&quot;WKWebVIew中的坑&quot;&gt;&lt;/a&gt;WKWebVIew中的坑&lt;/h1&gt;&lt;h2 id=&quot;WKWebView导致ViewController不调用dealloc方法&quot;&gt;&lt;a href=&quot;#WKWebView导致ViewController不调用dealloc方法&quot; class=&quot;headerlink&quot; title=&quot;WKWebView导致ViewController不调用dealloc方法&quot;&gt;&lt;/a&gt;WKWebView导致ViewController不调用dealloc方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;webview不设置 delegate，可以正常dealloc&lt;/li&gt;
&lt;li&gt;webview.UIDelegate和 navigationDelegate 设置为 self，可以正常dealloc&lt;/li&gt;
&lt;li&gt;webview.configuration.userContentController addScriptMessageHandler 为 self之后，无法正常dealloc，该方法引起ViewController内存泄漏。&lt;/li&gt;
&lt;li&gt;使用 ScriptMessageHandler 作为webview.scriptMessageHandler，当前viewController 可以正常释放。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前 viewController dealloc 方法中，通过 removeScriptMessazgeHanlder 释放掉&lt;br&gt;scriptMessageHandler&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;(1)WeakScriptMessageDelegate&lt;br&gt;可以创建一个新的类WeakScriptMessageDelegate，也可以将@interface-@end写在ViewController.h中，@implementation-@end写在ViewController.m中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeakScriptMessageDelegate&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;WKScriptMessageHandler&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt; scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithDelegate:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt;)scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeakScriptMessageDelegate&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithDelegate:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt;)scriptDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _scriptDelegate = scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.scriptDelegate&lt;/span&gt; userContentController:userContentController didReceiveScriptMessage:message];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2)使用&lt;/p&gt;
&lt;figure class=&quot;highlight pf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_webView = [[WKWebView alloc] initWithFrame:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;.view.bounds configuration:configuration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; _webView.UIDelegate = &lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; _webView.navigationDelegate = &lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController = [WKUserContentController new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//无法正常dealloc[configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController addScriptMessageHandler:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt; name:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//使用代理来实现可以调用dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;] name:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - (void)dealloc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController removeScriptMessageHandlerForName:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHWebViewDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHWebViewDemo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/9513d101e582#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WKWebView使用及注意点(keng)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;扩展&quot;&gt;&lt;a href=&quot;#扩展&quot; class=&quot;headerlink&quot; title=&quot;扩展&quot;&gt;&lt;/a&gt;扩展&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imciel.com/2016/06/18/oc-js-communication/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 JavaScriptCore 实现 JS和OC间的通信&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.brighttj.com/ios/ios-user-safari-debug-webview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用safari对webview进行调试&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Web App即是HTML5 APP框架开发模式，使用HTML5,CSS3以及JavaScript以及服务器端语言来完成开发，Web App具有跨平台的优势。那么就来学习一下iOS中JS与OC相互调用的方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习NSURLProtocol</title>
    <link href="http://peilinghui.com/2017/04/30/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0NSURLProtocol/"/>
    <id>http://peilinghui.com/2017/04/30/深入学习NSURLProtocol/</id>
    <published>2017-04-30T04:59:56.000Z</published>
    <updated>2017-04-30T09:18:27.000Z</updated>
    
    <content type="html">&lt;p&gt;研究一下NSURLProtocol.h。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;NSURLProtocol是什么？&quot;&gt;&lt;a href=&quot;#NSURLProtocol是什么？&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol是什么？&quot;&gt;&lt;/a&gt;NSURLProtocol是什么？&lt;/h1&gt;&lt;p&gt;NSURLProtocol是URL Loading System的重要组成部分。&lt;br&gt;首先虽然名叫NSURLProtocol，但它却不是协议。它是一个抽象类。我们要使用它的时候需要创建它的一个子类。&lt;br&gt;NSURLProtocol在iOS系统中大概处于这样一个位置。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-30%20%E4%B8%8B%E5%8D%882.12.33.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果开发者自定义的一个NSURLProtocol并且注册到app中，那么在这个自定义的NSURLProtocol中我们可以拦截UIWebView，基于系统的NSURLConnection或者NSURLSession进行封装的网络请求，然后做到自定义的response返回。非常强大。&lt;/p&gt;
&lt;h1 id=&quot;NSURLProtocol能拦截哪些网络请求&quot;&gt;&lt;a href=&quot;#NSURLProtocol能拦截哪些网络请求&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol能拦截哪些网络请求&quot;&gt;&lt;/a&gt;NSURLProtocol能拦截哪些网络请求&lt;/h1&gt;&lt;p&gt;URL Loading System&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-30%20%E4%B8%8B%E5%8D%882.13.34.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以，可以拦截的网络请求包括NSURLSession，NSURLConnection以及UIWebVIew。&lt;br&gt;基于CFNetwork的网络请求，以及WKWebView的请求是无法拦截的。&lt;/p&gt;
&lt;p&gt;现在主流的iOS网络库，例如AFNetworking，Alamofire等网络库都是基于NSURLSession或NSURLConnection的，所以这些网络库的网络请求都可以被NSURLProtocol所拦截 。&lt;br&gt;还有一些年代比较久远的网络库，例如ASIHTTPRequest，MKNetwokit等网路库都是基于CFNetwork的，所以这些网络库的网络请求无法被NSURLProtocol拦截。&lt;/p&gt;
&lt;h1 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h1&gt;&lt;p&gt;NSURLProtocol是一个抽象类。我们要使用它的时候需要创建它的一个子类。&lt;br&gt;&lt;code&gt;@interface PLHHTTPProtocol : NSURLProtocol&lt;/code&gt;&lt;br&gt;使用NSURLProtocol的主要可以分为5个步骤：&lt;br&gt;注册—&amp;gt;拦截—&amp;gt;转发—&amp;gt;回调—&amp;gt;结束&lt;/p&gt;
&lt;h2 id=&quot;注册：&quot;&gt;&lt;a href=&quot;#注册：&quot; class=&quot;headerlink&quot; title=&quot;注册：&quot;&gt;&lt;/a&gt;注册：&lt;/h2&gt;&lt;p&gt;在系统加载的时候，把自定义的PLHHTTPProtocol注册到URL加载系统中，这样 所有的URL请求都有机会进入我们自定义的PLHHTTPProtocol进行拦截处理。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (BOOL)&lt;span class=&quot;tag&quot;&gt;application&lt;/span&gt;:(UIApplication *)&lt;span class=&quot;tag&quot;&gt;application&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;didFinishLaunchingWithOptions&lt;/span&gt;:(NSDictionary *)&lt;span class=&quot;tag&quot;&gt;launchOptions&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[NSURLProtocol registerClass:[PLHHTTPURLProtocol class]&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性。&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sessionConfiguration.protocolClasses = @&lt;span class=&quot;string&quot;&gt;[[NSClassFromString(@&quot;CustomURLProtocol&quot;) class]]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;拦截：&quot;&gt;&lt;a href=&quot;#拦截：&quot; class=&quot;headerlink&quot; title=&quot;拦截：&quot;&gt;&lt;/a&gt;拦截：&lt;/h2&gt;&lt;p&gt;在拦截到网络请求后，NSURLProtocol会依次执行下列方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (BOOL)canInitWithRequest:(NSURLRequest *)request&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方法会拿到request的对象，我们可以通过该方法的返回值来筛选request是否需要被NSURLProtocol做拦截处理。&lt;br&gt;如果返回YES则进入该自定义加载器进行处理，如果返回NO则不进入该自定义选择器，使用系统默认行为进行处理。&lt;/p&gt;
&lt;p&gt;重新设置NSURLRequest的信息:&lt;br&gt;&lt;code&gt;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request&lt;/code&gt;&lt;br&gt;比如请求重定向或者添加头部信息等等。如果没有特殊需求，直接返回request就可以了。但是因为这个方法在会在一次请求中被调用多次（暂时我也不知道什么原因为什么需要回调多洗），所以request重定向和添加头部信息也可以在开始加载中startLoading方法中重新设置。&lt;/p&gt;
&lt;h2 id=&quot;转发&quot;&gt;&lt;a href=&quot;#转发&quot; class=&quot;headerlink&quot; title=&quot;转发&quot;&gt;&lt;/a&gt;转发&lt;/h2&gt;&lt;p&gt;在拦截到网络请求，并且对网络请求进行定制处理以后。我们需要将网络请求重新发送出去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id&amp;lt;NSURLProtocolClient&amp;gt;)client&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方法会创建一个NSURLProtocol实例，这里每一个网络请求都会创建一个新的实例。被拦截的请求开始执行的地方.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)startLoading&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来就是转发的核心方法startLoading。在该方法中，我们把处理过的request重新发送出去。至于发送的形式，可以是基于NSURLConnection，NSURLSession甚至CFNetwork。&lt;/p&gt;
&lt;h2 id=&quot;回调&quot;&gt;&lt;a href=&quot;#回调&quot; class=&quot;headerlink&quot; title=&quot;回调&quot;&gt;&lt;/a&gt;回调&lt;/h2&gt;&lt;p&gt;既是面向切面的编程，就不能影响到原来网络请求的逻辑。所以上一步将网络请求转发出去以后，当收到网络请求的返回，还需要再将返回值返回给原来发送网络请求的地方。&lt;br&gt;主要需要需要调用到&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didFailWithError:error]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocolDidFinishLoading:&lt;span class=&quot;keyword&quot;&gt;self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didLoadData:&lt;span class=&quot;preprocessor&quot;&gt;data&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这四个方法来回调给原来发送网络请求的地方。&lt;br&gt;这里假设我们在转发过程中是使用NSURLSession发送的网络请求，那么在NSURLSession的回调方法中，我们做相应的处理即可。并且我们也可以对这些返回，进行定制化处理。&lt;/p&gt;
&lt;h2 id=&quot;结束：&quot;&gt;&lt;a href=&quot;#结束：&quot; class=&quot;headerlink&quot; title=&quot;结束：&quot;&gt;&lt;/a&gt;结束：&lt;/h2&gt;&lt;p&gt;在一个网络请求完全结束以后，NSURLProtocol回调用到.结束加载URL请求&lt;br&gt;&lt;code&gt;- (void)stopLoading&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;p&gt;既然NSURLProtocol功能非常强大，那么在具体开发中，会有哪些应用呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义请求和响应&lt;/li&gt;
&lt;li&gt;网络的缓存处理（H5离线包 和 网络图片缓存）&lt;/li&gt;
&lt;li&gt;重定向网络请求&lt;/li&gt;
&lt;li&gt;为测试提供数据Mocking功能，在没有网络的情况下使用本地数据返回。&lt;/li&gt;
&lt;li&gt;过滤掉一些非法请求&lt;/li&gt;
&lt;li&gt;快速进行测试环境的切换&lt;/li&gt;
&lt;li&gt;拦截图片加载请求，转为从本地文件加载&lt;/li&gt;
&lt;li&gt;可以拦截UIWebView，基于系统的NSURLConnection或者NSURLSession进行封装的网络请求。目前WKWebView无法被NSURLProtocol拦截。&lt;/li&gt;
&lt;li&gt;当有多个自定义NSURLProtocol注册到系统中的话，会按照他们注册的反向顺序依次调用URL加载流程。当其中有一个NSURLProtocol拦截到请求的话，后续的NSURLProtocol就无法拦截到该请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DEMO地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHHTTPDNSDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHHTTPDNSDemo&lt;/a&gt;      &lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/02781c0bbca9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSURLProtocol全攻略&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/55f5ac1ab817&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WKWebView 不支持 NSURLProtocol 吗&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;研究一下NSURLProtocol.h。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIView的Frame和bounds区别</title>
    <link href="http://peilinghui.com/2017/04/21/UIView%E7%9A%84Frame%E5%92%8Cbounds%E5%8C%BA%E5%88%AB/"/>
    <id>http://peilinghui.com/2017/04/21/UIView的Frame和bounds区别/</id>
    <published>2017-04-21T10:48:21.000Z</published>
    <updated>2017-04-22T06:19:05.000Z</updated>
    
    <content type="html">&lt;p&gt;UIView的相关重点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UIview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;frame和bounds简介&quot;&gt;&lt;a href=&quot;#frame和bounds简介&quot; class=&quot;headerlink&quot; title=&quot;frame和bounds简介&quot;&gt;&lt;/a&gt;frame和bounds简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/frame%E5%92%8Cbounds.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;frame: 该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;br&gt;bounds：该view在本地坐标系统中的位置和大小。（参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）&lt;br&gt;center：该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;/p&gt;
&lt;h1 id=&quot;实际例子&quot;&gt;&lt;a href=&quot;#实际例子&quot; class=&quot;headerlink&quot; title=&quot;实际例子&quot;&gt;&lt;/a&gt;实际例子&lt;/h1&gt;&lt;p&gt;Demo：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/FrameAndBoundsDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/FrameAndBoundsDemo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;旋转一个自定义View&quot;&gt;&lt;a href=&quot;#旋转一个自定义View&quot; class=&quot;headerlink&quot; title=&quot;旋转一个自定义View&quot;&gt;&lt;/a&gt;旋转一个自定义View&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark --   例子1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//旋转一个自定义view后，frame改变了，而bounds没有改变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *View1 = [[&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;View1&lt;span class=&quot;variable&quot;&gt;.backgroundColor&lt;/span&gt; = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt; addSubview:View1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;自定义子view的self.view.frame = %@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自定义子view的self.view.frame = &amp;#123;&amp;#123;100, 100&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;自定义子view的self.view.bounds=%@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自定义子view的self.view.bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; transitionWithView:View1 duration:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; options:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    View1&lt;span class=&quot;variable&quot;&gt;.transform&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;CGAffineTransformMakeRotation&lt;/span&gt;(M_PI_4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;completion:^(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; finished)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (finished)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;旋转后子view的self.view.frame = %@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//旋转后子view的self.view.frame = &amp;#123;&amp;#123;89.644660940672622, 89.644660940672622&amp;#125;, &amp;#123;70.710678118654755, 70.710678118654755&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;旋转后子view的self.view.bounds=%@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//旋转后子view的self.view.bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.09.35.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.09.00.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在旋转动画后，frame发生改变，bounds依然没变。下面的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;frame的位置是根据父容器来计算的，正方形在动画开始前的x=100,y=100是相对于self.view的坐标系统而言的，从而确定当前视图在父视图中的位置。&lt;/li&gt;
&lt;li&gt;bounds的x,y是根据自己的坐标系统而言的。没错，每个view都有自己的坐标系。以自己左上角点为坐标原点。所以bounds的x,y默认为(0,0),除非调用setBounds方法；&lt;/li&gt;
&lt;li&gt;frame的size不一定等于bounds的size，在旋转后它们的size就不一样了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把frame理解为占用区域，把bounds理解为边界。View在旋转过程中，其实自己的坐标系统并没有发生改变，bounds中的origin只能通过setBounds方法修改。&lt;/p&gt;
&lt;h3 id=&quot;把一个子View放到父View中，改变父View的bounds&quot;&gt;&lt;a href=&quot;#把一个子View放到父View中，改变父View的bounds&quot; class=&quot;headerlink&quot; title=&quot;把一个子View放到父View中，改变父View的bounds&quot;&gt;&lt;/a&gt;把一个子View放到父View中，改变父View的bounds&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; *fatherView = [[&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; alloc]&lt;span class=&quot;symbol&quot;&gt;initWithFrame:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatherView.backgroundColor = [&lt;span class=&quot;constant&quot;&gt;UIColor&lt;/span&gt; yellowColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view &lt;span class=&quot;symbol&quot;&gt;addSubview:&lt;/span&gt;fatherView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; *sunView = [[&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; alloc]&lt;span class=&quot;symbol&quot;&gt;initWithFrame:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sunView.backgroundColor = [&lt;span class=&quot;constant&quot;&gt;UIColor&lt;/span&gt; redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[fatherView &lt;span class=&quot;symbol&quot;&gt;addSubview:&lt;/span&gt;sunView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;NSLog&lt;/span&gt;(@&lt;span class=&quot;string&quot;&gt;&quot;父view的frame = %@,bounds=%@,中心点=：%@&quot;&lt;/span&gt;,&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(fatherView.frame),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(fatherView.bounds),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGPoint&lt;/span&gt;(fatherView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;父view的frame = &lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,bounds=&lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,中心点=：&amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;NSLog&lt;/span&gt;(@&lt;span class=&quot;string&quot;&gt;&quot;子view的frame = %@,bounds=%@,中心点=：%@&quot;&lt;/span&gt;,&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(sunView.frame),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(sunView.bounds),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGPoint&lt;/span&gt;(sunView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;子view的frame = &lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,bounds=&lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,中心点=：&amp;#123;&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;regexp&quot;&gt;/1. 改变父View的bounds的位置,父view的bounds改变了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateWithDuration:4 animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [fatherView setBounds:CGRectMake(30, 30, 200, 200)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;completion:^(BOOL finished)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;改变父坐标bounds的位置后父view的frame = %@,bounds=%@,中心点=：%@&quot;,NSStringFromCGRect(fatherView.frame),NSStringFromCGRect(fatherView.bounds),NSStringFromCGPoint(fatherView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 改变父坐标bounds的位置后父view的frame = &amp;#123;&amp;#123;100, 100&amp;#125;, &amp;#123;200, 200&amp;#125;&amp;#125;,bounds=&amp;#123;&amp;#123;30, 30&amp;#125;, &amp;#123;200, 200&amp;#125;&amp;#125;,中心点=：&amp;#123;200, 200&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	NSLog(@&quot;改变父坐标bounds的位置后子view的frame = %@,bounds=%@,中心点=：%@&quot;,NSStringFromCGRect(sunView.frame),NSStringFromCGRect(sunView.bounds),NSStringFromCGPoint(sunView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/改变父坐标bounds的位置后子view的frame = &amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;,bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;,中心点=：&amp;#123;25, 25&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.22.30.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.21.21.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.24.15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;setBounds 强制将自己坐标系的左上角点改为（30，30）。那么真正的原点(0,0)自然向右上角偏移(30,30);&lt;br&gt;若是setBounds设为（-30，-30） ，则子view向右下角移动，偏移(30,30)。&lt;br&gt;注意：setBounds中的(x,y)只改变自己的坐标系统。子view的bounds和frame并不会改变。&lt;br&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setBounds中的(x,y)只改变自己的坐标系统，子View的bounds和frame并不会改变；&lt;/li&gt;
&lt;li&gt;setBounds是修改自己坐标系的原点位置，进而影响到子View的显示位置；&lt;/li&gt;
&lt;li&gt;bounds改变位置时，改变的是子视图的位置，自身没有影响，其实就是改变了自身的坐标系原点，默认原点在左上角。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;改变父View的bounds的大小&quot;&gt;&lt;a href=&quot;#改变父View的bounds的大小&quot; class=&quot;headerlink&quot; title=&quot;改变父View的bounds的大小&quot;&gt;&lt;/a&gt;改变父View的bounds的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setBounds:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.11.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.22.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;使用setBounds方法减小了父View的bounds.size ,可以看到把frame也改变了。总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改bounds的大小，bounds的大小代表当前视图的长和宽，修改长宽后，中心点继续保持不变，长宽进行改变，通过bounds修改长宽就像是以中心点为基准点对长宽两边同时进行缩放。&lt;/li&gt;
&lt;li&gt;center是根据父容器的相对位置来计算的，无论是修改父容器的bounds还是自身的bounds，都不会改变center。况且使用bounds来缩放view，都是根据center中心点来缩放的，所以center不会改变。&lt;/li&gt;
&lt;li&gt;setBounds也可以修改view的大小，进而修改frame。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;改子视图的bounds的位置&quot;&gt;&lt;a href=&quot;#改子视图的bounds的位置&quot; class=&quot;headerlink&quot; title=&quot;改子视图的bounds的位置&quot;&gt;&lt;/a&gt;改子视图的bounds的位置&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[sunView setBounds:CGRectMake(-&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;图像没有变化，与把一个子View放到父View中那个图一样的。&lt;/p&gt;
&lt;h3 id=&quot;修改子视图的bounds的大小&quot;&gt;&lt;a href=&quot;#修改子视图的bounds的大小&quot; class=&quot;headerlink&quot; title=&quot;修改子视图的bounds的大小&quot;&gt;&lt;/a&gt;修改子视图的bounds的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[sunView setBounds:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.48.46.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.53.04.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;修改子视图的bounds的大小，只是把子视图以中心点为中心扩大了，改变了子视图的frame的位置和bounds，父view不受影响。&lt;/p&gt;
&lt;h3 id=&quot;改变父view的frame的位置&quot;&gt;&lt;a href=&quot;#改变父view的frame的位置&quot; class=&quot;headerlink&quot; title=&quot;改变父view的frame的位置&quot;&gt;&lt;/a&gt;改变父view的frame的位置&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.01.36.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.01.43.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从效果图上可以看到，我们改变了父View的位置和大小（坐标系原点仍然是(0,0),但是实际位置已经改变了，坐标系改变），子View的位置也改变了。但是子View的frame和bounds并没有改变。因为子View.origin是相对于父View的而言的，这并没有改变。&lt;/p&gt;
&lt;h3 id=&quot;改变父view的frame的大小&quot;&gt;&lt;a href=&quot;#改变父view的frame的大小&quot; class=&quot;headerlink&quot; title=&quot;改变父view的frame的大小&quot;&gt;&lt;/a&gt;改变父view的frame的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.12.26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.13.02.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.13.26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;setFrame改变大小和setBounds改变大小是完全不一样的，setFrame改变长宽是从左上角原点进行缩放的，固定的是原点。而setBounds则固定的是center。&lt;/p&gt;
&lt;p&gt;一句话说：使用frame改变view大小，center改变，因为缩放参考点为左上角。使用bounds改变view大小，center不变，因为缩放参考点为center。&lt;br&gt;frame是参考父view的坐标系来设置自己左上角的位置。&lt;br&gt;设置bounds可以修改自己坐标系的原点位置，进而影响到其“子view”的显示位置。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想修改view的位置而不影响其他，修改自身frame的位置；想修改view的大小，修改frame的大小或者bounds的大小（考虑相对位置的改变）。&lt;/li&gt;
&lt;li&gt;如果想修改view的所有子view的位置，修改view的bounds的位置（父容器坐标系）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;bounds使用场景&quot;&gt;&lt;a href=&quot;#bounds使用场景&quot; class=&quot;headerlink&quot; title=&quot;bounds使用场景&quot;&gt;&lt;/a&gt;bounds使用场景&lt;/h1&gt;&lt;p&gt;其实bounds我们一直在使用，就是我们使用scrollview的时候。&lt;br&gt;为什么我们滚动scrollview可以看到超出显示屏的内容。就是因为scrollview在不断改变自己的bounds，从而改变scrollview上的子view的frame，让他们的frame始终在最顶级view（window）的frame内部，这样我们就可以始终看到内容了。&lt;/p&gt;
&lt;p&gt;向上滚动scrollview，我们就不断增加scrollview的bounds的y值，也就是不断把scrollview的本地坐标系原点向下偏移（相对于scrollview的父view的坐标系，y值越大，越向下偏移）。那么此时scrollview的子控件的frame设置的(0,0)就是不断向上偏移&lt;/p&gt;
&lt;p&gt;假设某一时刻scrollview的坐标系原点为(0,100)，那么scrollview的(0,0)位置就是相对于坐标系原点向上偏移100的距离，设置scrollview的子控件的frame为(0,0)，就是设置子控件左上角在scrollview中的(0,0)位置，那么子控件就会向上偏移100，你也就看到scrollview的内容（子控件）向上滚动的效果。&lt;/p&gt;
&lt;p&gt;我们可以不断增加fatherView的bounds的y值，来看看是不是可以达到同样的效果：fatherView不动，Sunview在不断向上滚动&lt;br&gt;理解 Scroll Views:&lt;a href=&quot;https://objccn.io/issue-3-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-3-2/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UIView的相关重点。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习React-Native的与原生的交互</title>
    <link href="http://peilinghui.com/2017/03/21/%E5%AD%A6%E4%B9%A0React-Native%E7%9A%84%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://peilinghui.com/2017/03/21/学习React-Native的与原生的交互/</id>
    <published>2017-03-21T09:12:44.000Z</published>
    <updated>2017-07-21T10:34:57.000Z</updated>
    
    <content type="html">&lt;p&gt;在用RN开发的时候，遇到一些情况也需要来扩展原生的组件，就需要与OC来交互。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;通讯的机制与流程&quot;&gt;&lt;a href=&quot;#通讯的机制与流程&quot; class=&quot;headerlink&quot; title=&quot;通讯的机制与流程&quot;&gt;&lt;/a&gt;通讯的机制与流程&lt;/h1&gt;&lt;h1 id=&quot;自定义Native-API组件&quot;&gt;&lt;a href=&quot;#自定义Native-API组件&quot; class=&quot;headerlink&quot; title=&quot;自定义Native API组件&quot;&gt;&lt;/a&gt;自定义Native API组件&lt;/h1&gt;&lt;h2 id=&quot;模块和方法的定义&quot;&gt;&lt;a href=&quot;#模块和方法的定义&quot; class=&quot;headerlink&quot; title=&quot;模块和方法的定义&quot;&gt;&lt;/a&gt;模块和方法的定义&lt;/h2&gt;&lt;p&gt;模块类就是一个实现了RCTBridgeModule协议的类。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CalendarManager.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;React/RCTBridgeModule.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#import &lt;span class=&quot;title&quot;&gt;&amp;lt;React/RCTLog.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CalendarManager&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;RCTBridgeModule&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了实现RCTBridgeModule协议，你的类需要包含RCT_EXPORT_MODULE()宏.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;RCT_EXPORT_MODULE();//向系统注册模块&lt;br&gt;RCT_REMAP_METHOD();//暴露模块方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript和OC之间要通信，完成数据类型的转化，标准的JSON的类型都是支持的。&lt;br&gt;RCT_EXPORT_METHOD 支持所有标准JSON类型，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;string (NSString)&lt;/li&gt;
&lt;li&gt;number (NSInteger, float, double, CGFloat, NSNumber)&lt;/li&gt;
&lt;li&gt;boolean (BOOL, NSNumber)&lt;/li&gt;
&lt;li&gt;array (NSArray) 包含本列表中任意类型&lt;/li&gt;
&lt;li&gt;object (NSDictionary) 包含string类型的键和本列表中任意类型的值&lt;/li&gt;
&lt;li&gt;function (RCTResponseSenderBlock)&lt;br&gt;还支持一些常用类型：NSDate、UIColor、UIfont、NSURL、NSURLRequest、UIColorArray、CGPoint。。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;回调函数&quot;&gt;&lt;a href=&quot;#回调函数&quot; class=&quot;headerlink&quot; title=&quot;回调函数&quot;&gt;&lt;/a&gt;回调函数&lt;/h2&gt;&lt;p&gt;原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给JavaScript。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(^RCTResponseSenderBlock)(NSArray &lt;em&gt;)接收多个参数的回调函数&lt;br&gt;(^RCTRespomseErrorBlock)(NSError &lt;/em&gt;)接受错误参数的回调函数&lt;br&gt;(^RCTPromiseResolveBlock)(id result):处理Promise Resolve&lt;br&gt;(^RCTPromiseRejectBlock)(NSError *):处理Promise Reject&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;React-Native代码与OC代码的互通&quot;&gt;&lt;a href=&quot;#React-Native代码与OC代码的互通&quot; class=&quot;headerlink&quot; title=&quot;React Native代码与OC代码的互通&quot;&gt;&lt;/a&gt;React Native代码与OC代码的互通&lt;/h1&gt;&lt;p&gt;为了实现消息互通，需要建立一个原生语言模块负责与React Native桥接&lt;/p&gt;
&lt;p&gt;OC代码向React Native发送消息有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过回调接口。这种方式要求React Native代码先将接口传递给OC代码，然后OC代码才可以通过这个回调接口向React Native代码发送消息。&lt;/li&gt;
&lt;li&gt;通过eventDispatcher向React Native模块发送事件。这样能够做到OC代码主动向React Native发送消息。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在用RN开发的时候，遇到一些情况也需要来扩展原生的组件，就需要与OC来交互。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习React-Native的API和组件</title>
    <link href="http://peilinghui.com/2017/03/10/%E5%AD%A6%E4%B9%A0React-Native%E7%9A%84API%E5%92%8C%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2017/03/10/学习React-Native的API和组件/</id>
    <published>2017-03-10T09:09:04.000Z</published>
    <updated>2017-07-21T09:02:25.000Z</updated>
    
    <content type="html">&lt;p&gt;在学习了React-Native的搭建以后，然后就在网上找了一些Demo来学习，并且开始练习。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://reactnative.cn/docs/0.46/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://reactnative.cn/docs/0.46/getting-started.html&lt;/a&gt;&lt;br&gt;几个Demo链接：&lt;br&gt;&lt;a href=&quot;https://github.com/peilinghui/react-native-Gank&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GankIO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;运行的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git clone &lt;a href=&quot;https://github.com/wangdicoder/react-native-Gank&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/wangdicoder/react-native-Gank&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;cd react-native-Gank&lt;/li&gt;
&lt;li&gt;npm install&lt;/li&gt;
&lt;li&gt;react-native link (this step is for add the icon component)&lt;/li&gt;
&lt;li&gt;react-native run-android / run-ios&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;常用组件&quot;&gt;&lt;a href=&quot;#常用组件&quot; class=&quot;headerlink&quot; title=&quot;常用组件&quot;&gt;&lt;/a&gt;常用组件&lt;/h1&gt;&lt;h3 id=&quot;View组件&quot;&gt;&lt;a href=&quot;#View组件&quot; class=&quot;headerlink&quot; title=&quot;View组件&quot;&gt;&lt;/a&gt;View组件&lt;/h3&gt;&lt;p&gt;类似于div的组件就是View容器组件，视图布局都是用它，支持flexbox的布局。&lt;/p&gt;
&lt;h3 id=&quot;Text组件&quot;&gt;&lt;a href=&quot;#Text组件&quot; class=&quot;headerlink&quot; title=&quot;Text组件&quot;&gt;&lt;/a&gt;Text组件&lt;/h3&gt;&lt;p&gt;一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。有onPress事件，可以给text组件绑定触摸点击事件。&lt;/p&gt;
&lt;h3 id=&quot;TextInput组件&quot;&gt;&lt;a href=&quot;#TextInput组件&quot; class=&quot;headerlink&quot; title=&quot;TextInput组件&quot;&gt;&lt;/a&gt;TextInput组件&lt;/h3&gt;&lt;p&gt;TextInput是一个允许用户在应用中通过键盘输入文本的基本组件。本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等。&lt;/p&gt;
&lt;h3 id=&quot;Touchable组件&quot;&gt;&lt;a href=&quot;#Touchable组件&quot; class=&quot;headerlink&quot; title=&quot;Touchable组件&quot;&gt;&lt;/a&gt;Touchable组件&lt;/h3&gt;&lt;h4 id=&quot;TouchableHighlight&quot;&gt;&lt;a href=&quot;#TouchableHighlight&quot; class=&quot;headerlink&quot; title=&quot;TouchableHighlight&quot;&gt;&lt;/a&gt;TouchableHighlight&lt;/h4&gt;&lt;p&gt;高亮触摸，用户点击的时候会产生高亮的效果。&lt;/p&gt;
&lt;h4 id=&quot;TouchableOpacity&quot;&gt;&lt;a href=&quot;#TouchableOpacity&quot; class=&quot;headerlink&quot; title=&quot;TouchableOpacity&quot;&gt;&lt;/a&gt;TouchableOpacity&lt;/h4&gt;&lt;p&gt;透明触摸，用户点击时，点击的组件会出现透明过度的效果。&lt;br&gt;activeOpacity number&lt;br&gt;指定封装的视图在被触摸操作激活时以多少不透明度显示（通常在0到1之间）。&lt;/p&gt;
&lt;h4 id=&quot;TouchableWithoutFeedback&quot;&gt;&lt;a href=&quot;#TouchableWithoutFeedback&quot; class=&quot;headerlink&quot; title=&quot;TouchableWithoutFeedback&quot;&gt;&lt;/a&gt;TouchableWithoutFeedback&lt;/h4&gt;&lt;p&gt;一般不要使用。&lt;/p&gt;
&lt;h3 id=&quot;NavigatorIOS组件&quot;&gt;&lt;a href=&quot;#NavigatorIOS组件&quot; class=&quot;headerlink&quot; title=&quot;NavigatorIOS组件&quot;&gt;&lt;/a&gt;NavigatorIOS组件&lt;/h3&gt;&lt;p&gt;对UIKit Navigation的封装，实质就是调用了这个。属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;barTintColor：导航条的背景颜色&lt;/li&gt;
&lt;li&gt;initialRoute:初始化路由&lt;/li&gt;
&lt;li&gt;itemWrapperStyle:设置每个页面的背景颜色&lt;/li&gt;
&lt;li&gt;navigationHidden:是否隐藏阴影&lt;/li&gt;
&lt;li&gt;tintColor:导航条上的按钮的颜色的设置&lt;/li&gt;
&lt;li&gt;titleTextColor：导航栏上字体的颜色&lt;/li&gt;
&lt;li&gt;translucent：导航条是否是半透明的&lt;/li&gt;
&lt;li&gt;push到新的页面&lt;/li&gt;
&lt;li&gt;pop返回&lt;/li&gt;
&lt;li&gt;replace替换当前路由&lt;/li&gt;
&lt;li&gt;replacePrevious(route)替换前一个页面的视图并且回退过去&lt;/li&gt;
&lt;li&gt;resetTo(reset)取代最顶层的路由并且回退过去&lt;/li&gt;
&lt;li&gt;popToTop：回到最上层的视图&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    render()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;&lt;span class=&quot;type&quot;&gt;Provider&lt;/span&gt; store=&amp;#123;store&amp;#125;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;lt;&lt;span class=&quot;type&quot;&gt;Navigator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    initialRoute=&amp;#123;&amp;#123;component: &lt;span class=&quot;type&quot;&gt;MainPage&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    renderScene=&amp;#123;(route, navigator) =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;lt;route.component &amp;#123;...route.args&amp;#125; navigator=&amp;#123;navigator&amp;#125; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;/&lt;span class=&quot;type&quot;&gt;Provider&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    componentDidMount()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;SplashScreen&lt;/span&gt;.hide();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;TabBarIOS组件&quot;&gt;&lt;a href=&quot;#TabBarIOS组件&quot; class=&quot;headerlink&quot; title=&quot;TabBarIOS组件&quot;&gt;&lt;/a&gt;TabBarIOS组件&lt;/h3&gt;&lt;p&gt;有TabBarIOS和TabBarIOS.item两种，后者是前者的附属组件。&lt;br&gt;TabBarIOS属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;barTintColor：标签栏的背景颜色。&lt;/li&gt;
&lt;li&gt;tintColor:当前被选中的标签图标的颜色。&lt;/li&gt;
&lt;li&gt;unselectedItemTintColor string&lt;br&gt;当前没有被选中的标签图标的颜色。仅在iOS 10及以上版本有效.&lt;/li&gt;
&lt;li&gt;translucent bool 一个布尔值，决定标签栏是否需要半透明化。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TabBarIOS.Item属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;badge：在图标右上角显示一个红色的气泡。&lt;/li&gt;
&lt;li&gt;icon 给当前标签指定一个自定义的图标。如果定义了systemIcon属性， 这个属性会被忽略。&lt;/li&gt;
&lt;li&gt;onPress 当此标签被选中时调用。你应该修改组件的状态来使得selected={true}。&lt;/li&gt;
&lt;li&gt;selected 这个属性决定了子视图是否可见。&lt;/li&gt;
&lt;li&gt;selectedIcon 当标签被选中的时候显示的自定义图标。如果定义了systemIcon属性，这个属性会被忽略。如果定义了icon而没定义这个属性，在选中的时候图标会染上蓝色。&lt;/li&gt;
&lt;li&gt;systemIcon enum(‘bookmarks’, ‘contacts’, ‘downloads’, ‘favorites’, ‘featured’, ‘history’, ‘more’, ‘most-recent’, ‘most-viewed’, ‘recents’, ‘search’, ‘top-rated’) 一些预定义的系统图标。注意如果你使用了此属性，标题和自定义图标都会被覆盖为系统定义的值。&lt;/li&gt;
&lt;li&gt;title在图标下面显示的标题文字。如果定义了systemIcon属性，这个属性会被忽略。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Image&quot;&gt;&lt;a href=&quot;#Image&quot; class=&quot;headerlink&quot; title=&quot;Image&quot;&gt;&lt;/a&gt;Image&lt;/h3&gt;&lt;p&gt;一个用于显示多种不同类型图片的React组件，包括网络图片、静态资源、临时的本地图片、以及本地磁盘上的图片（如相册）等。详细用法参阅图片文档。&lt;br&gt;resizeMode enum(‘cover’, ‘contain’, ‘stretch’, ‘repeat’, ‘center’)&lt;br&gt;决定当组件尺寸和图片尺寸不成比例的时候如何调整图片的大小。&lt;/p&gt;
&lt;h3 id=&quot;FlatList&quot;&gt;&lt;a href=&quot;#FlatList&quot; class=&quot;headerlink&quot; title=&quot;FlatList&quot;&gt;&lt;/a&gt;FlatList&lt;/h3&gt;&lt;p&gt;高性能的简单列表组件，支持下面这些常用的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全跨平台。&lt;/li&gt;
&lt;li&gt;支持水平布局模式。&lt;/li&gt;
&lt;li&gt;行组件显示或隐藏时可配置回调事件。&lt;/li&gt;
&lt;li&gt;支持单独的头部组件。&lt;/li&gt;
&lt;li&gt;支持单独的尾部组件。&lt;/li&gt;
&lt;li&gt;支持自定义行间分隔线。&lt;/li&gt;
&lt;li&gt;支持下拉刷新。&lt;/li&gt;
&lt;li&gt;支持上拉加载。&lt;/li&gt;
&lt;li&gt;支持跳转到指定行（ScrollToIndex）。&lt;br&gt;如果需要分组/类/区（section），请使用&lt;sectionlist&gt;。&lt;h3 id=&quot;WebView&quot;&gt;&lt;a href=&quot;#WebView&quot; class=&quot;headerlink&quot; title=&quot;WebView&quot;&gt;&lt;/a&gt;WebView&lt;/h3&gt;创建一个原生的WebView，可以用于访问一个网页。&lt;br&gt;属性：&lt;/sectionlist&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;onError 加载失败时调用。&lt;/li&gt;
&lt;li&gt;onLoad 加载成功时调用。&lt;/li&gt;
&lt;li&gt;onLoadEnd 加载结束时（无论成功或失败）调用。&lt;/li&gt;
&lt;li&gt;onLoadStart 加载开始时调用。&lt;/li&gt;
&lt;li&gt;onMessage 在webview内部的网页中调用window.postMessage方法时可以触发此属性对应的函数，从而实现网页和RN之间的数据交换。 设置此属性的同时会在webview中注入一个postMessage的全局函数并覆盖可能已经存在的同名实现。&lt;br&gt;网页端的window.postMessage只发送一个参数data，此参数封装在RN端的event对象中，即event.nativeEvent.data。data 只能是一个字符串。&lt;/li&gt;
&lt;li&gt;injectedJavaScript 设置在网页加载之前注入的一段JS代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot; class=&quot;headerlink&quot; title=&quot;API&quot;&gt;&lt;/a&gt;API&lt;/h1&gt;&lt;h3 id=&quot;AppRegistry&quot;&gt;&lt;a href=&quot;#AppRegistry&quot; class=&quot;headerlink&quot; title=&quot;AppRegistry&quot;&gt;&lt;/a&gt;AppRegistry&lt;/h3&gt;&lt;p&gt;其中iOS代码的入口在index.ios.js中，&lt;br&gt;在index.ios.js中注册入口：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AppRegistry.registerComponent(&amp;#39;GankIO&amp;#39;, () =&amp;gt; App);&lt;/code&gt;当注册完应用程序组件后，Native的系统就会加载jsbundle文件并且触发AppRegistry.runApplication运行程序。AppRegistry有以下的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;registerConfig:静态方法，注册配置&lt;/li&gt;
&lt;li&gt;registerComponent注册入口组件&lt;/li&gt;
&lt;li&gt;registerRunnable：注册函数监听&lt;/li&gt;
&lt;li&gt;getAppKey:获取registerRunnable注册的监听键&lt;/li&gt;
&lt;li&gt;runApplication运行程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;AlertIOS&quot;&gt;&lt;a href=&quot;#AlertIOS&quot; class=&quot;headerlink&quot; title=&quot;AlertIOS&quot;&gt;&lt;/a&gt;AlertIOS&lt;/h3&gt;&lt;p&gt;启动一个提示对话框，包含对应的标题和信息。&lt;/p&gt;
&lt;p&gt;你还可以指定一系列的按钮，点击对应的按钮会调用对应的onPress回调并且关闭提示框。默认情况下，对话框会仅有一个’确定’按钮。&lt;/p&gt;
&lt;h3 id=&quot;PixelRatio&quot;&gt;&lt;a href=&quot;#PixelRatio&quot; class=&quot;headerlink&quot; title=&quot;PixelRatio&quot;&gt;&lt;/a&gt;PixelRatio&lt;/h3&gt;&lt;p&gt;告知开发者像素的密度。&lt;br&gt;根据像素密度获取指定大小的图片。&lt;br&gt;像素网格对齐。&lt;/p&gt;
&lt;h3 id=&quot;AppState&quot;&gt;&lt;a href=&quot;#AppState&quot; class=&quot;headerlink&quot; title=&quot;AppState&quot;&gt;&lt;/a&gt;AppState&lt;/h3&gt;&lt;p&gt;AppState能告诉你应用当前是在前台还是在后台，并且能在状态变化的时候通知你。&lt;/p&gt;
&lt;p&gt;AppState通常在处理推送通知的时候用来决定内容和对应的行为。&lt;br&gt;active - 应用正在前台运行&lt;br&gt;background - 应用正在后台运行。用户既可能在别的应用中，也可能在桌面。&lt;br&gt;inactive - 此状态表示应用正在前后台的切换过程中，或是处在系统的多任务视图，又或是处在来电状态中。&lt;/p&gt;
&lt;h3 id=&quot;CameraRoll&quot;&gt;&lt;a href=&quot;#CameraRoll&quot; class=&quot;headerlink&quot; title=&quot;CameraRoll&quot;&gt;&lt;/a&gt;CameraRoll&lt;/h3&gt;&lt;p&gt;CameraRoll模块提供了访问本地相册的功能。在iOS上使用这个模块之前，你需要先链接RCTCameraRoll库。&lt;br&gt;从iOS10开始，访问相册需要用户授权。你需要在Info.plist中添加一条名为NSCameraUsageDescription的键，然后在其值中填写向用户请求权限的具体描述。编辑完成后这个键在Xcode中实际会显示为Privacy - Camera Usage Description。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;static saveImageWithTag(tag)&lt;br&gt;保存一个图片到相册。&lt;/li&gt;
&lt;li&gt;static saveToCameraRoll&lt;/li&gt;
&lt;li&gt;getPhotos(params: object)&lt;br&gt;返回一个带有图片标识符对象的Promise。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Geolocation&quot;&gt;&lt;a href=&quot;#Geolocation&quot; class=&quot;headerlink&quot; title=&quot;Geolocation&quot;&gt;&lt;/a&gt;Geolocation&lt;/h3&gt;&lt;p&gt;你需要在Info.plist中增加NSLocationWhenInUseUsageDescription字段来启用定位功能。如果你使用react-native init创建项目，定位会被默认启用。&lt;br&gt;属性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;getCurrentPosition(geo_success: Function, geo_error?: Function, geo_options?: GeoOptions) 获取当前位置，&lt;br&gt;成功时会调用geo_success回调，参数中包含最新的位置信息。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;watchPosition(success: Function, error?: Function, options?: GeoOptions) 持续监听位置，每当位置变化之后都调用success回调。支持的选项：timeout (ms), maximumAge (ms), enableHighAccuracy (bool)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static clearWatch(watchID: number) 依据ID清除检测&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;stopObserving()停止检测&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;AsyncStorage&quot;&gt;&lt;a href=&quot;#AsyncStorage&quot; class=&quot;headerlink&quot; title=&quot;AsyncStorage&quot;&gt;&lt;/a&gt;AsyncStorage&lt;/h3&gt;&lt;p&gt;AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的。它用来代替LocalStorage。&lt;/p&gt;
&lt;p&gt;每个方法都有一个回调函数，回调函数的第一个参数都是错误对象，如果发生错误就会展示错误对象，否则为null。所有方法执行后，都会返回一个Promise对象。&lt;br&gt;方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;static getItem(key: string, callback?: ?(error: ?Error, result: ?string) =&amp;gt; void)&lt;br&gt;根据键来获取值，获取的结果会在回调函数，第一个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static setItem(key: string, value: string, callback?: ?(error: ?Error) =&amp;gt; void) 设置键值对&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;static removeItem(key: string, callback?: ?(error: ?Error) =&amp;gt; void)&lt;br&gt;根据键值移除对象&lt;/li&gt;
&lt;li&gt;static mergeItem(key: string, value: string, callback?: ?(error: ?Error) =&amp;gt; void) 合并现有值和输入值。&lt;/li&gt;
&lt;li&gt;static clear(callback?: ?(error: ?Error) =&amp;gt; void) qing&lt;/li&gt;
&lt;li&gt;static getAllKeys(callback?: ?(error: ?Error, keys: ?Array&lt;string&gt;) =&amp;gt; void)&lt;br&gt;获取所有的键。&lt;/string&gt;&lt;/li&gt;
&lt;li&gt;static flushGetRequests() 清除所有进行中的查询操作。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static multiGet(keys: Array&lt;string&gt;, callback?: ?(errors: ?Array&lt;error&gt;, result: ?Array&lt;array&lt;string&gt;&amp;gt;) =&amp;gt; void)&lt;br&gt;获取多项&lt;br&gt;multiGet([‘k1’, ‘k2’], cb) -&amp;gt; cb([[‘k1’, ‘val1’], [‘k2’, ‘val2’]])&lt;/array&lt;string&gt;&lt;/error&gt;&lt;/string&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;static multiSet(keyValuePairs: Array&lt;array&lt;string&gt;&amp;gt;, callback?: ?(errors: ?Array&lt;error&gt;) =&amp;gt; void)&lt;br&gt;设置多项。&lt;/error&gt;&lt;/array&lt;string&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;multiSet和multiMerge都接受一个与multiGet输出值一致的key-value数组的数组。返回一个Promise对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;multiSet([[‘k1’, ‘val1’], [‘k2’, ‘val2’]], cb);&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;static multiRemove(keys: Array&lt;string&gt;, callback?: ?(errors: ?Array&lt;error&gt;) =&amp;gt; void) &lt;/error&gt;&lt;/string&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;删除所有键在keys数组中的数据。返回一个Promise对象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;static multiMerge(keyValuePairs: Array&lt;array&lt;string&gt;&amp;gt;, callback?: ?(errors: ?Array&lt;error&gt;) =&amp;gt; void) 多个键值对合并。&lt;/error&gt;&lt;/array&lt;string&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还没有被所有原生实现都支持。&lt;/p&gt;
&lt;h3 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h3&gt;&lt;h4 id=&quot;setTimeout&quot;&gt;&lt;a href=&quot;#setTimeout&quot; class=&quot;headerlink&quot; title=&quot;setTimeout&quot;&gt;&lt;/a&gt;setTimeout&lt;/h4&gt;&lt;p&gt;用于设定一个定时任务&lt;/p&gt;
&lt;h4 id=&quot;setInterval&quot;&gt;&lt;a href=&quot;#setInterval&quot; class=&quot;headerlink&quot; title=&quot;setInterval&quot;&gt;&lt;/a&gt;setInterval&lt;/h4&gt;&lt;p&gt;主要用于设定循环&lt;/p&gt;
&lt;h4 id=&quot;setImmediate&quot;&gt;&lt;a href=&quot;#setImmediate&quot; class=&quot;headerlink&quot; title=&quot;setImmediate&quot;&gt;&lt;/a&gt;setImmediate&lt;/h4&gt;&lt;p&gt;用于设置立即执行的任务&lt;/p&gt;
&lt;h2 id=&quot;网络数据请求&quot;&gt;&lt;a href=&quot;#网络数据请求&quot; class=&quot;headerlink&quot; title=&quot;网络数据请求&quot;&gt;&lt;/a&gt;网络数据请求&lt;/h2&gt;&lt;h3 id=&quot;XMLHttpRequest-即俗称的ajax&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-即俗称的ajax&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest(即俗称的ajax)&quot;&gt;&lt;/a&gt;XMLHttpRequest(即俗称的ajax)&lt;/h3&gt;&lt;p&gt;与web的一样，                                                                        &lt;/p&gt;
&lt;h3 id=&quot;Fetch&quot;&gt;&lt;a href=&quot;#Fetch&quot; class=&quot;headerlink&quot; title=&quot;Fetch&quot;&gt;&lt;/a&gt;Fetch&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;fetch(&amp;apos;https://mywebsite.com/endpoint/&amp;apos;, {
  method: &amp;apos;POST&amp;apos;,
  headers: {
    &amp;apos;Accept&amp;apos;: &amp;apos;application/json&amp;apos;,
    &amp;apos;Content-Type&amp;apos;: &amp;apos;application/json&amp;apos;,
  },
  body: JSON.stringify({
    firstParam: &amp;apos;yourValue&amp;apos;,
    secondParam: &amp;apos;yourOtherValue&amp;apos;,
  })
})
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在学习了React-Native的搭建以后，然后就在网上找了一些Demo来学习，并且开始练习。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习React Native入门</title>
    <link href="http://peilinghui.com/2017/03/02/%E5%AD%A6%E4%B9%A0React-Native%E5%85%A5%E9%97%A8/"/>
    <id>http://peilinghui.com/2017/03/02/学习React-Native入门/</id>
    <published>2017-03-02T09:51:37.000Z</published>
    <updated>2017-07-24T08:27:32.000Z</updated>
    
    <content type="html">&lt;p&gt;抽时间学习一下&lt;a href=&quot;https://github.com/facebook/react-native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;React-Native-简介&quot;&gt;&lt;a href=&quot;#React-Native-简介&quot; class=&quot;headerlink&quot; title=&quot;React Native 简介&quot;&gt;&lt;/a&gt;React Native 简介&lt;/h1&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装Node.js&lt;br&gt;下载node.js：&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;br&gt;或者安装brew来安装node.js.&lt;br&gt;&lt;code&gt;node -v&lt;/code&gt;最新的版本&lt;/li&gt;
&lt;li&gt;安装React Native&lt;br&gt;先通过HomeBrew安装watchman和flow&lt;br&gt;&lt;code&gt;brew install watchman&lt;/code&gt;&lt;br&gt;&lt;code&gt;brew install flow&lt;/code&gt;&lt;br&gt;再通过npm安装react-native-cli的工具&lt;br&gt;&lt;code&gt;sudo npm install -g react-native-cli&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用NVM来管理node.js版本&lt;br&gt;&lt;code&gt;git clone https://github.com/creationix/nvm&lt;/code&gt;或者&lt;code&gt;git clone https://github.com/cnpm/nvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建项目   &lt;/li&gt;
&lt;li&gt;安装命令行工具：sudo npm install -g react-native-cli&lt;/li&gt;
&lt;li&gt;创建项目Hello：用react-native init命令&lt;code&gt;react-native init Hello&lt;/code&gt;，打开Xcode文件后运行，自动启动终端和模拟器。然后模拟器就出现了字，显示成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;在安卓上运行的环境配置&quot;&gt;&lt;a href=&quot;#在安卓上运行的环境配置&quot; class=&quot;headerlink&quot; title=&quot;在安卓上运行的环境配置&quot;&gt;&lt;/a&gt;在安卓上运行的环境配置&lt;/h2&gt;&lt;h4 id=&quot;基础软件安装&quot;&gt;&lt;a href=&quot;#基础软件安装&quot; class=&quot;headerlink&quot; title=&quot;基础软件安装&quot;&gt;&lt;/a&gt;基础软件安装&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装JDK jdk-8u101-macosx-x64.dmg&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看版本，命令行中运行javac -version&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Android Studio&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;勾选Performance和Android Virtual Device&lt;/li&gt;
&lt;li&gt;安装相关SDK Platforms，记得勾选Show Package Details&lt;/li&gt;
&lt;li&gt;安装SDK Tools 必须是这个版本 Android SDK Build-Tools 23.0.1，记得勾选Show Package Details。&lt;/li&gt;
&lt;li&gt;ANDROID_HOME环境变量设置。（见下面 环境变量配置）方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安装 免费VirtualBox虚拟机&lt;/li&gt;
&lt;li&gt;安装模拟器Genymotion&lt;ul&gt;
&lt;li&gt;注册帐号&lt;/li&gt;
&lt;li&gt;下载Genymotion&lt;/li&gt;
&lt;li&gt;安装Genymotion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;坑： brew install android-sdk不支持了。&lt;br&gt;应该先用brew tap caskroom/cask&lt;br&gt;再用brew cask install android-sdk还有brew cask install android-platform-tools&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;环境变量配置&quot;&gt;&lt;a href=&quot;#环境变量配置&quot; class=&quot;headerlink&quot; title=&quot;环境变量配置&quot;&gt;&lt;/a&gt;环境变量配置&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;把Android SDK的tools和platform-tools目录添加到PATH变量中，以便在终端中运行一些Android工具，例如android avd或是adb logcat等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在~/.bash_profile中添加(如果你安装的 ZSH 则在 ~/.zshrc中添加)：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; ANDROID_SDK_ROOT=/Users/peilinghui/Library/Android/sdk &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PATH=&lt;span class=&quot;string&quot;&gt;&quot;/usr/local/share/android-sdk/platform-tools:&lt;span class=&quot;variable&quot;&gt;$&amp;#123;PATH&amp;#125;&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改完需要运行source ~/.bash_profile （注意：你的SDK的具体路径可能不同）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在Android studio中配置SDK的环境地址，然后下载component的相关东西。&lt;/li&gt;
&lt;li&gt;在genymotion中的setting-ADB-设置SDK的地址为你配置的地址。一定要重启genymotion！！！一定要重启！一定要重启！！重要的事情说三次，因为没重启一直不成功。。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在执行react-native run-android一直不成功的时候，一直说是&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* What went &lt;span class=&quot;string&quot;&gt;wrong:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Execution failed &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; task &lt;span class=&quot;string&quot;&gt;&#39;:app:installDebug&#39;&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.builder.testing.api.&lt;span class=&quot;string&quot;&gt;DeviceException:&lt;/span&gt; Could not create ADB Bridge. ADB &lt;span class=&quot;string&quot;&gt;location:&lt;/span&gt; &lt;span class=&quot;regexp&quot;&gt;/Applications/&lt;/span&gt;ADT&lt;span class=&quot;regexp&quot;&gt;/sdk/&lt;/span&gt;platform-tools/adb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;p&gt;的报错，然后按上面3就解决了，然后或者在Android文件夹下app/build/outputs/apk,drag the app-debug.apk to the genymotion.now it works。&lt;/p&gt;
&lt;p&gt;GET IT！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试服务端&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这时候可以用浏览器访问&lt;br&gt;&lt;a href=&quot;http://localhost:8081/index.android.bundle?platform=android&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:8081/index.android.bundle?platform=android&lt;/a&gt;&lt;br&gt;如果可以访问表示服务器端已经可以了。&lt;/p&gt;
&lt;h2 id=&quot;debug的方式&quot;&gt;&lt;a href=&quot;#debug的方式&quot; class=&quot;headerlink&quot; title=&quot;debug的方式&quot;&gt;&lt;/a&gt;debug的方式&lt;/h2&gt;&lt;p&gt;在模拟器上点击commend+D，出现下面的界面。开始调试。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;reload：刷新页面，只有修改了JS文件的时候刷新有效。&lt;/li&gt;
&lt;li&gt;Debug Remote JS主要是在chrome上，开发者工具(Commod)&lt;br&gt;APPdelegate中改bug，打开注释，进行debug。或者使用工具nuclide。&lt;/li&gt;
&lt;li&gt;Enable Live Reload：自动刷新，&lt;h1 id=&quot;React-Native组件&quot;&gt;&lt;a href=&quot;#React-Native组件&quot; class=&quot;headerlink&quot; title=&quot;React Native组件&quot;&gt;&lt;/a&gt;React Native组件&lt;/h1&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React JS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://facebook.github.io/react-native/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://nuclide.io/docs/quick-start/getting-started/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nuclide插件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Render-amp-JSX&quot;&gt;&lt;a href=&quot;#Render-amp-JSX&quot; class=&quot;headerlink&quot; title=&quot;Render&amp;amp;JSX&quot;&gt;&lt;/a&gt;Render&amp;amp;JSX&lt;/h2&gt;&lt;figure class=&quot;highlight dust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;render() &lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;variable&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;txt&lt;/span&gt; = &#39;&lt;span class=&quot;variable&quot;&gt;Hello&lt;/span&gt;&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;variable&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;say&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;return&lt;/span&gt; &#39;&lt;span class=&quot;variable&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;am&lt;/span&gt; &#39;+&lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;This is a title!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;txt&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Image&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;source&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;require&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/img&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/bg.png&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Image&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;source&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;require&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/img&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/icon.png&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;say&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;React&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;组件生命周期&quot;&gt;&lt;a href=&quot;#组件生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件生命周期&quot;&gt;&lt;/a&gt;组件生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;初始化&lt;ul&gt;
&lt;li&gt;getDefaultProps&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getInitialState&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentDidMount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillReceiveProps&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shouldComponentUpdate&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;shouldComponentUpdate(nextProps, nextState) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;command&quot;&gt;return&lt;/span&gt; nextProps.&lt;span class=&quot;property&quot;&gt;id&lt;/span&gt; !== this.props.&lt;span class=&quot;property&quot;&gt;id&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentWillUpdate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁&lt;ul&gt;
&lt;li&gt;componentWillUnmount&lt;br&gt;更多：&lt;a href=&quot;https://race604.com/react-native-component-lifecycle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://race604.com/react-native-component-lifecycle/&lt;/a&gt;&lt;h2 id=&quot;Props-amp-States&quot;&gt;&lt;a href=&quot;#Props-amp-States&quot; class=&quot;headerlink&quot; title=&quot;Props &amp;amp; States&quot;&gt;&lt;/a&gt;Props &amp;amp; States&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Props:properties属性，在初始化的时候传入并且可以显示不同的状态。&lt;br&gt;props不可变&lt;br&gt;states不可变&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以在浏览器中debug&lt;/p&gt;
&lt;h2 id=&quot;Styles&quot;&gt;&lt;a href=&quot;#Styles&quot; class=&quot;headerlink&quot; title=&quot;Styles&quot;&gt;&lt;/a&gt;Styles&lt;/h2&gt;&lt;h2 id=&quot;flexbox布局&quot;&gt;&lt;a href=&quot;#flexbox布局&quot; class=&quot;headerlink&quot; title=&quot;flexbox布局&quot;&gt;&lt;/a&gt;flexbox布局&lt;/h2&gt;&lt;p&gt;可以开发出动态宽高自适应的UI布局。&lt;br&gt;位置：position。取值为relative或者absolute。当设置为relative的时候，是表示当前组件距离上一个同级组件的距离。当设置为absolute的时候，是表示当前组件距离父组件的距离来描述位置top,bottom,left,right.与宽高相关的有：width，height，maxheight，maxwidth，minheight,minwidth。  &lt;/p&gt;
&lt;h3 id=&quot;排列子组件&quot;&gt;&lt;a href=&quot;#排列子组件&quot; class=&quot;headerlink&quot; title=&quot;排列子组件&quot;&gt;&lt;/a&gt;排列子组件&lt;/h3&gt;&lt;p&gt;优点Lbuxuyao指定子组件的绝对位置，也不需要根据运行时屏幕大小动态计算子组件的大小，而是通过排列一个个长方形来进行布局。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flexDirection&lt;/strong&gt;&lt;br&gt;决定了组件内部的子组件是如何排列的。row、row-reverse、column、column-reverse。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flexWrap&lt;/strong&gt;&lt;br&gt;flexWrap取值为warp，并且alignItem键不能取值为”stretch”的时候才能实现子组件的自动换行排列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;justifyContent&lt;/strong&gt;&lt;br&gt;定义在一个方向上如何排列子组件，flex-start、flex-end、center、space-between、space-around 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alignItems&lt;/strong&gt;&lt;br&gt;定义了view组件中所有子组件的对齐股则。flex-start（顶部对齐）、flex-end（底部对齐）、center（中部对齐）、stretch（拉长对齐）。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;边框border，空隙margin，填充Padding&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Absolute-amp-Relative&quot;&gt;&lt;a href=&quot;#Absolute-amp-Relative&quot; class=&quot;headerlink&quot; title=&quot;Absolute &amp;amp; Relative&quot;&gt;&lt;/a&gt;Absolute &amp;amp; Relative&lt;/h3&gt;&lt;h3 id=&quot;Size-amp-Dimensions-amp-onLayout&quot;&gt;&lt;a href=&quot;#Size-amp-Dimensions-amp-onLayout&quot; class=&quot;headerlink&quot; title=&quot;Size &amp;amp; Dimensions &amp;amp; onLayout&quot;&gt;&lt;/a&gt;Size &amp;amp; Dimensions &amp;amp; onLayout&lt;/h3&gt;&lt;h2 id=&quot;Architecture&quot;&gt;&lt;a href=&quot;#Architecture&quot; class=&quot;headerlink&quot; title=&quot;Architecture&quot;&gt;&lt;/a&gt;Architecture&lt;/h2&gt;&lt;p&gt;MVC的问题：&lt;/p&gt;
&lt;h3 id=&quot;Redux&quot;&gt;&lt;a href=&quot;#Redux&quot; class=&quot;headerlink&quot; title=&quot;Redux&quot;&gt;&lt;/a&gt;Redux&lt;/h3&gt;&lt;h1 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/reactnativecn/react-native-guide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React-Native学习指南&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.gitbook.com/book/unbug/react-native-training/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gitbook&lt;/a&gt;—–&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLC_rYRxEnwQGLQqrHR0aho33U6DCeJamC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对应的视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/crazycodeboy/react-native-awesome&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native学习资源精选仓库&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.devio.org/tags/#React Native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;抽时间学习一下&lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习React知识</title>
    <link href="http://peilinghui.com/2017/02/22/%E5%AD%A6%E4%B9%A0React%E7%9F%A5%E8%AF%86/"/>
    <id>http://peilinghui.com/2017/02/22/学习React知识/</id>
    <published>2017-02-22T06:26:54.000Z</published>
    <updated>2017-07-24T08:43:48.000Z</updated>
    
    <content type="html">&lt;p&gt;React是JavaScript的库，把用户页面抽象成组件。在学习React-native前，先了解一下React。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/facebook/react&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;了解React&quot;&gt;&lt;a href=&quot;#了解React&quot; class=&quot;headerlink&quot; title=&quot;了解React&quot;&gt;&lt;/a&gt;了解React&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Virtual DOM提升了React的性能。React可以映射为对应的原生控件，所以React-Native就可以实现一次编程，多次使用。&lt;/li&gt;
&lt;li&gt;函数式编程的思想&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSX的语法编写&quot;&gt;&lt;a href=&quot;#JSX的语法编写&quot; class=&quot;headerlink&quot; title=&quot;JSX的语法编写&quot;&gt;&lt;/a&gt;JSX的语法编写&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;XML语法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;定义标签时，只允许被一个标签包裹&lt;/li&gt;
&lt;li&gt;标签一定要闭合.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;元素的类型和属性&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;DOM元素的属性是标准规范属性，除了Class和for，转换为className和htmlFor.&lt;/li&gt;
&lt;li&gt;小写首字母对应的是DOM元素，大写首字母对应的是组件元素。&lt;br&gt;JSX特有的属性表达：&lt;/li&gt;
&lt;li&gt;Boolean属性：省略表示bool值设为了true，要传false必须用属性表达式，如：disable、require、checked、readonly&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Flux架构&quot;&gt;&lt;a href=&quot;#Flux架构&quot; class=&quot;headerlink&quot; title=&quot;Flux架构&quot;&gt;&lt;/a&gt;Flux架构&lt;/h1&gt;&lt;p&gt;不是MVC的架构，Flux三大部分组成：1. dispatcher、store、view。dispatcher负责分发事件，store负责保存数据、view负责订阅store中的数据，并使用这些数据渲染相应的页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与MVC的主要区别：&lt;/strong&gt;&lt;br&gt;没有职责明确的Controller，存在一个Controller-view的角色，将view和store进行绑定，并没有Controller需要承担的复杂的逻辑。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;dispatcher与action&lt;/strong&gt;&lt;br&gt;dispatcher的实现就是下面两个API:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;.register(callback)方法用来注册一个监听器。&lt;br&gt;.dispatch(action)用来分发一个action。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;action是一个普通的JavaScript对象，一般包含type、payload字段，用于描述一个事件以及需要改变的相关数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;store&lt;/strong&gt;&lt;br&gt;负责保存数据，并且修改数据的逻辑，调用dispatcher的register(callback)方法将自己注册为一个监听器。&lt;br&gt;当.dispatch(action)用来分发一个action时，store注册的监听器就会被调用，同时得到这个action作为参数。store之暴露getter不暴露setter，只能读取不能修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Controller-view&lt;/strong&gt;&lt;br&gt;最顶层view，主要进行store与React组件(view层)之间的数据的绑定，定义数据更新以及传递的方式。会调用store保留的getter获取存储其中的数据并设置为自己的state，在render时以props的形式传给自己的子组件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;view&lt;/strong&gt;&lt;br&gt;React组件扮演。结合Angular、Vue来发挥Flux的能力。&lt;br&gt;一条特殊的约定：&lt;strong&gt;Flux的view不能直接修改数据，如果页面操作需要修改数据，则必须使用dispatcher分发一个action。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;actionCreator&lt;/strong&gt;&lt;br&gt;用来创造action的。为什么需要？因为在分发action的时候代码是冗余的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Redux架构&quot;&gt;&lt;a href=&quot;#Redux架构&quot; class=&quot;headerlink&quot; title=&quot;Redux架构&quot;&gt;&lt;/a&gt;Redux架构&lt;/h1&gt;&lt;h2 id=&quot;Redux简介&quot;&gt;&lt;a href=&quot;#Redux简介&quot; class=&quot;headerlink&quot; title=&quot;Redux简介&quot;&gt;&lt;/a&gt;Redux简介&lt;/h2&gt;&lt;p&gt;Redux的核心代码是一个库，类似Flux的架构思想，&lt;/p&gt;
&lt;h3 id=&quot;三大原则&quot;&gt;&lt;a href=&quot;#三大原则&quot; class=&quot;headerlink&quot; title=&quot;三大原则&quot;&gt;&lt;/a&gt;三大原则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单一数据源&lt;br&gt;一个应用永远只有唯一的一个数据源，整个应用状态都保存在一个对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;状态是只读的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Flux中store没有setter只有getter，而Redux中没有store，只有reducer，根据当前触发的action对当前应用state进行迭代。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;状态修改均由纯函数完成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redux与Flux最大的不同。&lt;br&gt;在Flux中，我们在actionCreator里调用APPDispatcher.dispatch方法来触发action，直接修改了store中数据.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;React是JavaScript的库，把用户页面抽象成组件。在学习React-native前，先了解一下React。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动化测试</title>
    <link href="http://peilinghui.com/2017/02/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://peilinghui.com/2017/02/16/自动化测试/</id>
    <published>2017-02-16T11:17:25.000Z</published>
    <updated>2017-04-17T11:50:25.000Z</updated>
    
    <content type="html">&lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;测试基础&quot;&gt;&lt;a href=&quot;#测试基础&quot; class=&quot;headerlink&quot; title=&quot;测试基础&quot;&gt;&lt;/a&gt;测试基础&lt;/h1&gt;&lt;h2 id=&quot;按测试手段分&quot;&gt;&lt;a href=&quot;#按测试手段分&quot; class=&quot;headerlink&quot; title=&quot;按测试手段分&quot;&gt;&lt;/a&gt;按测试手段分&lt;/h2&gt;&lt;h3 id=&quot;黑盒测试和白盒测试-按可见度分&quot;&gt;&lt;a href=&quot;#黑盒测试和白盒测试-按可见度分&quot; class=&quot;headerlink&quot; title=&quot;黑盒测试和白盒测试(按可见度分)&quot;&gt;&lt;/a&gt;黑盒测试和白盒测试(按可见度分)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;黑盒测试&lt;/strong&gt;&lt;br&gt;黑盒测试主要是通过相关的暴露的接口，接收输入，然后看是否能够输出正确。  &lt;/p&gt;
&lt;p&gt;优点：容易实施，不需要关注内部实现，主要关注的是用户需求。&lt;/p&gt;
&lt;p&gt;缺点：测试覆盖率低，不到40%，自动化测试覆盖率低，维护成本高，&lt;/p&gt;
&lt;p&gt;测试内容：是否有不正确或遗漏的功能？接口上输入是否能正确接受，输出是否能输出正确的结果？性能上是否能满足？&lt;/p&gt;
&lt;p&gt;测试方法：等价类划分法、流程分析法、边界值分析、状态迁移图、正交试验法、因果图法、错误推测法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白盒测试&lt;/strong&gt;&lt;br&gt;内部结构对测试人员透明，用逻辑覆盖率(语句，判断，条件，分支，路径)&lt;/p&gt;
&lt;p&gt;优点：迫使测试人员思考软件的实现，理解原理。&lt;br&gt;可以检测代码的每条分支和路径。揭示隐藏在代码中的错误。对代码的测试比较彻底。&lt;/p&gt;
&lt;p&gt;缺点：昂贵。无法检测代码中遗漏的路径和数据敏感性错误。不能直接验证需求的正确性。&lt;/p&gt;
&lt;p&gt;测试方法：代码检测法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径法&lt;/p&gt;
&lt;h3 id=&quot;静态测试和动态测试&quot;&gt;&lt;a href=&quot;#静态测试和动态测试&quot; class=&quot;headerlink&quot; title=&quot;静态测试和动态测试&quot;&gt;&lt;/a&gt;静态测试和动态测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态测试&lt;/strong&gt;&lt;br&gt;不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程，评审软件文档或代码。只做静态检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态测试&lt;/strong&gt;&lt;br&gt;运行被测试的程序，检查运行结果和预期结果的差异，并分析运行效率和健壮性等性能。这种方法由三部分组成:构造测试实例、执行程序、分析程序癿输出结果。软件的动态测试，就是通过运行软件来检验软件的动态行为和运行结构的正确性。目前，动态测试也是公司的测试工作的主要方式。 根据动态测试在软件开发过程中所处的阶段和作用。动态测试可分为如下几个步骤:1、单元测试 2、集成测试 3、系统测试 4、验收测试 5、回归测试。&lt;br&gt;单元测试：&lt;br&gt;JUnit、OCUnit、GHUnit、GTM&lt;br&gt;集成测试：&lt;br&gt;API接口测试和iOS功能集成测试。&lt;br&gt;系统测试：&lt;/p&gt;
&lt;h3 id=&quot;手工测试和自动化测试&quot;&gt;&lt;a href=&quot;#手工测试和自动化测试&quot; class=&quot;headerlink&quot; title=&quot;手工测试和自动化测试&quot;&gt;&lt;/a&gt;手工测试和自动化测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;手工测试&lt;/strong&gt;&lt;br&gt;测试人员从用户视角来满足设计要求，深度测试和主观判断的测试，分为众包测试和探索式测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化测试&lt;/strong&gt;&lt;br&gt;借助单独的测试工具软件，控制测试的自动化执行以及对预期和结果进行自动检查。主要分为：单元测试，接口测试和性能测试。&lt;/p&gt;
&lt;h2 id=&quot;按测试模式来分类&quot;&gt;&lt;a href=&quot;#按测试模式来分类&quot; class=&quot;headerlink&quot; title=&quot;按测试模式来分类&quot;&gt;&lt;/a&gt;按测试模式来分类&lt;/h2&gt;&lt;p&gt;瀑布模式，敏捷测试，基于脚本的测试，基于风险的测试，探索式测试。&lt;br&gt;&lt;strong&gt;瀑布模型&lt;/strong&gt;&lt;br&gt;项目计划–需求分析–软件设计–程序开发–软件测试–集成维护&lt;/p&gt;
&lt;p&gt;扩展模型：&lt;br&gt;V模型，W 模型、H 模型、X 模型和前置模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏捷测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强调从客户角度，重点关注迭代测试新功能。尽早测试，不间断测试。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;&lt;a href=&quot;#性能测试&quot; class=&quot;headerlink&quot; title=&quot;性能测试&quot;&gt;&lt;/a&gt;性能测试&lt;/h2&gt;&lt;p&gt;负载测试，压力测试和稳定性的测试&lt;/p&gt;
&lt;p&gt;考虑并发用户数(VU)和每秒事务数(TPS)&lt;br&gt;来看系统响应时间和设备的性能。&lt;/p&gt;
&lt;p&gt;测试工具：LoadRunner，&lt;/p&gt;
&lt;h1 id=&quot;ios中自动化测试UI-Automation&quot;&gt;&lt;a href=&quot;#ios中自动化测试UI-Automation&quot; class=&quot;headerlink&quot; title=&quot;ios中自动化测试UI Automation&quot;&gt;&lt;/a&gt;ios中自动化测试UI Automation&lt;/h1&gt;&lt;p&gt;UI Automation不但支持脚本编写方式的自动化测试，还支持录制回放方式的自动化测试，是一款功能强大的自动化测试工具。&lt;br&gt;Instruments工具还自带了UI Automation脚本的录制功能。用户只需开启录制功能，然后在真是的设备或模拟器上进行操作即可。操作的动作会被翻译成自动化脚本显示在脚本的编辑区，等待用户确认。在脚本录制完成以后，可以通过选择来编辑脚本，如果选项中没有我们需要的操作选项，则只能删除手动写脚本。&lt;/p&gt;
&lt;h1 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;headerlink&quot; title=&quot;Selenium&quot;&gt;&lt;/a&gt;Selenium&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SeleniumHQ/selenium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SeleniumHQ/selenium&lt;/a&gt;&lt;br&gt;Web自动化测试中，Selenium是最成熟且应用最广泛的Web自动化测试工具。WebDriver的原理结构：&lt;br&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server&lt;/p&gt;
&lt;p&gt;WebDriver API：这一层表示WebDriver提供给使用者的最外层接口，使用者可以使用这些API进行自动化脚本的编辑。例如：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;diver.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;findElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(By.name(&lt;span class=&quot;string&quot;&gt;&quot;q&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;element.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Json Wire Protocol:是WebDriver的开发者们制定并命名的一种协议，使用REST风格的，并且以Json方法进行传输，协议传输测试脚本需要控制的控件，并且通知Selenium Server。&lt;/p&gt;
&lt;p&gt;Selenium Server：接受Json Wire Protocol协议并且解析，可以控制启动或者停止某一款浏览器，也可以完成对某一个控件的具体操作。&lt;/p&gt;
&lt;h1 id=&quot;Appium&quot;&gt;&lt;a href=&quot;#Appium&quot; class=&quot;headerlink&quot; title=&quot;Appium&quot;&gt;&lt;/a&gt;Appium&lt;/h1&gt;&lt;p&gt;适用于iOS，Android和Windows应用的自动化。&lt;br&gt;GitHub地址：&lt;a href=&quot;https://github.com/appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/appium&lt;/a&gt;&lt;br&gt;API:&lt;a href=&quot;http://appium.io/slate/cn/master/?ruby#about-appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://appium.io/slate/cn/master/?ruby#about-appium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Appium简介&quot;&gt;&lt;a href=&quot;#Appium简介&quot; class=&quot;headerlink&quot; title=&quot;Appium简介&quot;&gt;&lt;/a&gt;Appium简介&lt;/h2&gt;&lt;p&gt;Appium使用WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。  &lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Appium在不同平台中使用了标准的自动化APIs，所以在跨平台时，不需要重新编译或者修改自己的应用。&lt;/li&gt;
&lt;li&gt;Appium支持Selenium WebDriver支持的所有语言，如java、Object-C、JavaScript、Php、Python、Ruby、C#、Clojure，或者Perl语言，更可以使用Selenium WebDriver的Api。Appium支持任何一种测试框架。&lt;br&gt;如果只使用Apple的UIAutomation，我们只能用javascript来编写测试用例，而且只能用Instruction来运行测试用例。&lt;br&gt;如果只使用Google的UIAutomation，我们就只能用java来编写测试用例。Appium实现了真正的跨平台自动化测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;p&gt;提供各个语言的第三方库，将测试脚本转化成 WebDriver 协议下的 URL，通过 Node 服务发送到各个平台上的代理工具，代理工具在运行过程中不断接收 URL，根据 WebDriver 协议解析出要执行的操作，然后调用各个平台上的原生测试框架完成测试，再将测试结果返回给 Node 服务器。&lt;/p&gt;
&lt;p&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server–&amp;gt;UI Automation&lt;/p&gt;
&lt;h2 id=&quot;mac下搭建appium环境&quot;&gt;&lt;a href=&quot;#mac下搭建appium环境&quot; class=&quot;headerlink&quot; title=&quot;mac下搭建appium环境&quot;&gt;&lt;/a&gt;mac下搭建appium环境&lt;/h2&gt;&lt;p&gt;使用node.js实现的，首先确定有没有安装node,可以用HomeBrew安装。再看node解释器是否安装npm,然后下载并启动Appium.&lt;br&gt;参考文章：&lt;a href=&quot;http://www.15yan.com/story/4GbuTwXQKDU/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.15yan.com/story/4GbuTwXQKDU/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-环境搭建Java和Android开发环境&quot;&gt;&lt;a href=&quot;#windows-环境搭建Java和Android开发环境&quot; class=&quot;headerlink&quot; title=&quot;windows 环境搭建Java和Android开发环境&quot;&gt;&lt;/a&gt;windows 环境搭建Java和Android开发环境&lt;/h2&gt;&lt;p&gt;参考书:&lt;a href=&quot;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&lt;/a&gt;&lt;br&gt;英文版：&lt;a href=&quot;https://nishantverma.gitbooks.io/appium-for-android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nishantverma.gitbooks.io/appium-for-android/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS的持续集成&quot;&gt;&lt;a href=&quot;#iOS的持续集成&quot; class=&quot;headerlink&quot; title=&quot;iOS的持续集成&quot;&gt;&lt;/a&gt;iOS的持续集成&lt;/h1&gt;&lt;p&gt;持续集成工具可以对代码库进行监测，一旦发现有代码变动，该工具会自动编译和测试应用程序。如果出现错误，会立即通知开发人员。&lt;/p&gt;
&lt;p&gt;持续集成可以提供更快的反馈，从而降低项目风险。是集成和回归问题更快、更流畅，出现的错误更少。通过部署过程自动化，持续集成可以帮助软件测试人员更快、更可靠地、更省力地搭建测试环境和执行自动化测试。&lt;/p&gt;
&lt;h2 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Jenkins&quot;&gt;&lt;/a&gt;Jenkins&lt;/h2&gt;&lt;p&gt;Jenkins易于安装，不需要数据库的支持，直接通过Web界面进行配置，而且集成了RSS/Email的通知机制，支持分布式构建，具有丰富的插件，这些都是Jenkins相比其他持续集成服务器的优势所在。&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的安装&quot;&gt;&lt;a href=&quot;#Jenkins的安装&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的安装&quot;&gt;&lt;/a&gt;Jenkins的安装&lt;/h3&gt;&lt;p&gt;在Jenkins的官网&lt;a href=&quot;https://jenkins.io/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jenkins.io/index.html&lt;/a&gt;下载war包，并且执行 ‘java -jar jenkins.war’正确配置Java环境。&lt;/p&gt;
&lt;p&gt;mac下直接下载mac版本的Jenkins安装程序&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的相关插件&quot;&gt;&lt;a href=&quot;#Jenkins的相关插件&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的相关插件&quot;&gt;&lt;/a&gt;Jenkins的相关插件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode integration&lt;br&gt;通过对Xcode integration的简单设置，即可完成iOS项目的编译打包，还可以修改iOS应用的Technical Version和Marketing Version。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git Plugin&lt;br&gt;通过Git Plugin，用户可以很方便的下载项目的源代码，不是默认安装，需要用户手动安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Junit test result report&lt;br&gt;是Jenkins默认安装的插件之一。只需指定测试工具生成的XML形式的report文件，插件会自动解析XML，并且以更易查看的方式展现测试结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;a href=&quot;#iOS测试策略以及测试方法&quot; class=&quot;headerlink&quot; title=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;/a&gt;iOS测试策略以及测试方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能测试：根据产品需求、用户的使用场景和代码实现方式等设计测试用例。&lt;/li&gt;
&lt;li&gt;兼容性测试：硬件、软件、数据兼容性。iOS设备的多样化兼容测试&lt;/li&gt;
&lt;li&gt;网络流量的测试：根据不同的网络状况测试，网速，弱网环境的测试。&lt;/li&gt;
&lt;li&gt;升级测试：老版本升级到新版本的测试、&lt;/li&gt;
&lt;li&gt;性能测试：服务器端性能测试。客户端性能测试：大数据测试，显示速度。&lt;/li&gt;
&lt;li&gt;稳定性测试：检测应用程序长期稳定的运行能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Instrument&quot;&gt;&lt;a href=&quot;#Instrument&quot; class=&quot;headerlink&quot; title=&quot;Instrument&quot;&gt;&lt;/a&gt;&lt;strong&gt;Instrument&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;网络流量监测数据，监控电量、监控GPS和WIFI是否开启等状态。丽日：在一些音乐APP和一些FM的APP中是否支持自动同步喜欢的歌曲到设备上。当网络接入点只选择了在WiFi情况下同步，就必须保证用户的流量不被使用。Net Activity运行库图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能测试：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;快速启动测试：用instruments中TimeProfile来分析启动时的CPU消耗，并且以消耗CPU的数据为依据进行优化。&lt;/li&gt;
&lt;li&gt;内存泄露的检查：用Xcode分析（Analyze）代码。静态分析器可以根据经验猜测执行代码后可能发生的情况并报告问题，这些问题中可以存在内存泄露问题。静态分析器在检查代码时会枚举所有的代码路径，分别检查所以的函数和方法。为了看到静态分析的结构，在Recipes项目中可以随意找到几处release或者autorelease的调用项并删除，然后运行静态分析，用Instrument的两个组件来组合查看内存泄露的问题：Allocations和Leaks.&lt;/li&gt;
&lt;li&gt;Allocations：是监控对象调用了alloc方法申请内存以后的内存使用情况，可以记录对象这个生命周期内的内存引用计数的变化，在对象被正常释放后，Allocations 不再继续追踪。Leaks会监控内存泄露，一般和Allocations一起使用，因为在监控到内存泄露时需要定位问题。可以得到详细的内存泄露信息。&lt;/li&gt;
&lt;li&gt;稳定性测试：猴子测试，直接在instruments中运行UI Automation脚本。考虑在一些零界条件下对应用程序进行稳定性测试。考虑：1.频繁收到内存警告。2.电池电量低。3.3G网络不稳定时断时续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;及时响应用户交互和优秀的内存管理。通过测试定位并且解决问题。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;国内首家移动测试的社区网站：&lt;a href=&quot;https://testerhome.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://testerhome.com/&lt;/a&gt;&lt;br&gt;构建基于Jenkins + Github的持续集成环境 &lt;a href=&quot;http://blog.csdn.net/john_cdy/article/details/7738393&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/john_cdy/article/details/7738393&lt;/a&gt;&lt;br&gt;电子书：&lt;a href=&quot;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计读书笔记</title>
    <link href="http://peilinghui.com/2017/02/13/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</id>
    <published>2017-02-13T07:37:24.000Z</published>
    <updated>2017-02-15T12:59:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 JavaScript简介&quot;&gt;&lt;/a&gt;第一章 JavaScript简介&lt;/h1&gt;&lt;p&gt;JavaScript有下列三个不同的部分组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMA-262规定的语言组成部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法
类型
语句
关键字
保留字
操作符
对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DOM：&lt;br&gt;DOM把真个页面映射为一个多层结点结构。&lt;br&gt;DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。&lt;br&gt;DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。&lt;br&gt;DOM3级：以统一方式加载和保存文档的方法。验证文档的方法&lt;br&gt;BOM：&lt;br&gt;处理浏览器窗口和框架。&lt;/p&gt;
&lt;h1 id=&quot;第二章-在HTML中使用JavaScript&quot;&gt;&lt;a href=&quot;#第二章-在HTML中使用JavaScript&quot; class=&quot;headerlink&quot; title=&quot;第二章 在HTML中使用JavaScript&quot;&gt;&lt;/a&gt;第二章 在HTML中使用JavaScript&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;把JavaScript插入到HTML页面中要使用&amp;lt;script&amp;gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&amp;lt;script&amp;gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&amp;lt;script&amp;gt;元素中的代码之后，才会开始解析后面的&amp;lt;script&amp;gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&amp;lt;script&amp;gt;元素中的代码，然后再解析后面的内容，所以一般应该把&amp;lt;script&amp;gt;元素放在页面最后，即主要内容后面，&amp;lt;/body&amp;gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第三章-基本概念&quot;&gt;&lt;a href=&quot;#第三章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本概念&quot;&gt;&lt;/a&gt;第三章 基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript中的函数与其他语言中的函数有诸多不同之处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Undefined类型&lt;/strong&gt;&lt;br&gt;Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Null类型&lt;/strong&gt;&lt;br&gt;Null类型是第二个只有一个值的数据类型，这个特殊值时null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;br&gt;该类型只有两个字面值：true和false。&lt;br&gt;虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; messageAsBoolean&lt;/span&gt; = &lt;span class=&quot;typename&quot;&gt;Boolean&lt;/span&gt;(message);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给出各数据类型及其转换的规则：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alert(isNaN(NaN));              //true&lt;br&gt;alert(isNaN(10));               //false（10是一个数值）&lt;br&gt;alert(isNaN(“10”));             //false（可以被转换成数值10）&lt;br&gt;alert(isNaN(“blue”));           //false（不能被转换成数值）&lt;br&gt;alert(isNaN(true));             //false（可以被转换成数值1）&lt;/p&gt;
&lt;p&gt;有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&amp;quot;name&amp;quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;p&gt;一元操作符&lt;br&gt;递增操作符     ++&lt;br&gt;递减操作符     –&lt;br&gt;一元加操作符     +&lt;br&gt;一元减操作符     -&lt;br&gt;位操作符&lt;br&gt;按位非     NOT(~)&lt;br&gt;按位与     AND(&amp;amp;)&lt;br&gt;按位或     OR(|)     var result=25 | 3;alert(result);//27&lt;br&gt;按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26&lt;br&gt;左移     &amp;lt;&amp;lt;     var oldValue=2;var newValue=oldValue &amp;lt;&amp;lt; 5;//64&lt;br&gt;有符号的右移     &amp;gt;&amp;gt;     var oldValue=64;var newValue=oldValue &amp;gt;&amp;gt; 5;//2&lt;br&gt;无符号的右移     &amp;gt;&amp;gt;&amp;gt;     var oldValue=-64;var newValue=oldValue &amp;gt;&amp;gt;&amp;gt; 5;//134217726&lt;br&gt;布尔操作符&lt;br&gt;逻辑非     !     alert(!false);//true&lt;br&gt;逻辑与     &amp;amp;&amp;amp;     var result=true &amp;amp;&amp;amp; false;//false&lt;br&gt;逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true&lt;br&gt;乘性操作符（略）&lt;br&gt;加性操作符（略）&lt;br&gt;关系操作符（略）&lt;br&gt;条件操作符（略）&lt;br&gt;赋值操作符（略）&lt;br&gt;逗号操作符（略）         &lt;/p&gt;
&lt;p&gt;相等操作符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。&lt;/p&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h1 id=&quot;第四章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第四章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第四章 变量、作用域和内存问题&lt;/h1&gt;&lt;p&gt;JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。&lt;/p&gt;
&lt;h1 id=&quot;第五章-引用类型&quot;&gt;&lt;a href=&quot;#第五章-引用类型&quot; class=&quot;headerlink&quot; title=&quot;第五章 引用类型&quot;&gt;&lt;/a&gt;第五章 引用类型&lt;/h1&gt;&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;p&gt;大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。&lt;br&gt;第一种是使用new操作符后跟Object构造函数，如&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是使用对象字面量表示法，如&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;age :&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert(person[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);              &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);                 &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示方法&lt;/strong&gt;&lt;br&gt;创建数组的基本方式有两种。&lt;br&gt;第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;//空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含三个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含一个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是使用数组字面量表示法。如&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;//创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var names = []&lt;span class=&quot;comment&quot;&gt;;//创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含2或3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var options = [, , , , ,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含5或6项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;&lt;br&gt;数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测数组&lt;/strong&gt;&lt;br&gt;自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。&lt;br&gt;对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;isArray&lt;/span&gt;(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;转换方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toLocaleString() :&lt;br&gt;toString() :&lt;br&gt;valueOf() : &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈方法和队列方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。&lt;/p&gt;
&lt;p&gt;实现栈的方式（LIFO）后进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()： 栈中项插入
pop()：栈中项移除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现队列的方法（FIFO）先进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重排序方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组中已经存在两个可以直接用来重排序的方法：&lt;br&gt;reverse()和sort()方法。&lt;/p&gt;
&lt;p&gt;reverse()方法会反转数组项的顺序。&lt;/p&gt;
&lt;p&gt;默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。&lt;br&gt;另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需将其作为参数传递给sort()方法即可。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values.sort(compare);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(values);  &lt;span class=&quot;comment&quot;&gt;//0, 1, 5, 10, 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;ECMAScript为操作已经包含在数组中的项提供了很多内置方法。&lt;/p&gt;
&lt;p&gt;concat()：&lt;br&gt;该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.concat(&lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);  &lt;span class=&quot;comment&quot;&gt;//red, green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//red, green, blue, yellow, black, brown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;slice()：  &lt;/p&gt;
&lt;p&gt;该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors3&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow, purple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors3);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;splice()：&lt;br&gt;该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var removed = colors.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//删除第一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//red, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orange&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//从位置1开始插入两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, yellow, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//返回的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//插入两项，删除一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, red, purple, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//yellow, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。&lt;br&gt;这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。&lt;/p&gt;
&lt;p&gt;var person = {  name: “Nicholas” };&lt;br&gt;var people = [{ name: “Nicholas” }];&lt;/p&gt;
&lt;p&gt;var morePeople = [person];&lt;/p&gt;
&lt;p&gt;alert(people.indexOf(person));          //-1&lt;br&gt;alert(morePeople.indexOf(person));  //0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上方法都不会修改数组中的包含的值。&lt;/p&gt;
&lt;p&gt;其中，every()和filter()方法最相似。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var everyResult = numbers.every(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(everyResult);     &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var someResult = numbers.some(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(someResult);      &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var filterResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(filterResult);            &lt;span class=&quot;comment&quot;&gt;//[3, 4, 5, 4, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map()可以用来创建包含的项与另一个数组一一对应的项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var mapResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(mapResult);           &lt;span class=&quot;comment&quot;&gt;//[2, 4, 6, 8, 10, 8, 6, 4, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forEach()本质上和使用for循环迭代数组一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers.forEach(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;归并方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。&lt;br&gt;这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。&lt;br&gt;使用reduce()方法可以执行数组中所有值求和操作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var sum = values.reduce(function(prev, cur, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev + cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(sum);     &lt;span class=&quot;comment&quot;&gt;//15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Date类型&quot;&gt;&lt;a href=&quot;#Date类型&quot; class=&quot;headerlink&quot; title=&quot;Date类型&quot;&gt;&lt;/a&gt;Date类型&lt;/h2&gt;&lt;p&gt;创建日期对象，使用new操作符和Date构造函数即可。&lt;/p&gt;
&lt;p&gt;var now = new Date()&lt;/p&gt;
&lt;p&gt;根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。&lt;br&gt;Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式&lt;br&gt;var someDate = new Date(Date.parse(“May 25, 2004”));&lt;/p&gt;
&lt;p&gt;Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。&lt;/p&gt;
&lt;p&gt;//GMT时间2000年1月1日午夜零时&lt;br&gt;var y2k = new Date(Date.UTC(2000, 0));&lt;/p&gt;
&lt;p&gt;//GMT时间2005年5月5日下午5:55:55&lt;br&gt;var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));&lt;/p&gt;
&lt;p&gt;Date类型还有一些专门用于将日期格式化为字符串的方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.&lt;/p&gt;
&lt;h2 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h2&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。&lt;/p&gt;
&lt;p&gt;var expression = / pattern / flags ;&lt;/p&gt;
&lt;p&gt;其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。&lt;br&gt;关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。&lt;br&gt;另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。&lt;/p&gt;
&lt;h2 id=&quot;Function类型&quot;&gt;&lt;a href=&quot;#Function类型&quot; class=&quot;headerlink&quot; title=&quot;Function类型&quot;&gt;&lt;/a&gt;Function类型&lt;/h2&gt;&lt;p&gt;ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数声明与函数表达式&lt;/p&gt;
&lt;p&gt;解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;没有重载！&lt;/strong&gt;&lt;br&gt;由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为返回值的函数&lt;/strong&gt;&lt;br&gt;由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。&lt;br&gt;函数作为返回值是极有用的技术，是“闭包”技术的基础之一。&lt;br&gt;比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction (propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var data = [&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Zachary&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;&amp;#125;, &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据name来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Nicholas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据age来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Zachary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数内部属性（重点）&lt;/strong&gt;&lt;br&gt;在函数内部，有两个特殊的对象：arguments和this。&lt;/p&gt;
&lt;p&gt;arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//与函数名紧紧耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用arguments.callee替代函数名，消除耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * arguments.callee (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; trueFactorial = factorial;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;factorial = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(trueFactiorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));           &lt;span class=&quot;comment&quot;&gt;//120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));                    &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();             &lt;span class=&quot;comment&quot;&gt;//&quot;red&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor = sayColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor();           &lt;span class=&quot;comment&quot;&gt;//&quot;blue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。&lt;/p&gt;
&lt;p&gt;ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数属性和方法（重点）&lt;/strong&gt;&lt;br&gt;ECMAScript中函数是对象，因此也有属性和方法。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。&lt;br&gt;诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//传入arguments对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, [num1, num2]);       &lt;span class=&quot;comment&quot;&gt;//传入数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum1(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum2(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));     &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();                     &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(o);               &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; objectSayColor = sayColor.bind(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectSayColor();           &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2&lt;/span&gt; = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问s1时，访问过程处于读取模式，后台自动完成下列处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上三个步骤可以想象成下列代码&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。&lt;br&gt;引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed()：按指定小数位返回数值的字符串表示。&lt;/li&gt;
&lt;li&gt;toExponential()：返回以指数表示法表示的数值的字符串形式。&lt;/li&gt;
&lt;li&gt;toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符方法&lt;/strong&gt;&lt;br&gt;两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串操作方法&lt;/strong&gt;&lt;br&gt;concat()：&lt;br&gt;用于将一或多个字符串拼接起来，接受任意多个参数。&lt;/p&gt;
&lt;p&gt;slice()、substr()和substring()：&lt;br&gt;这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。&lt;/p&gt;
&lt;p&gt;当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串位置方法&lt;/strong&gt;&lt;br&gt;有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。&lt;br&gt;两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。&lt;br&gt;在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trim()方法&lt;/strong&gt;&lt;br&gt;该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串大小写转换方法&lt;/strong&gt;&lt;br&gt;ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串的模式匹配方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;match()：&lt;br&gt;在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。&lt;/p&gt;
&lt;p&gt;search()：&lt;br&gt;参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。&lt;/p&gt;
&lt;p&gt;replace()：&lt;br&gt;接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。&lt;/p&gt;
&lt;p&gt;split()：&lt;br&gt;该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。&lt;/p&gt;
&lt;p&gt;localeCompare()方法;&lt;br&gt;该方法比较两个字符串，并返回下列值中的一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fromCharCode()方法：&lt;/p&gt;
&lt;p&gt;String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。&lt;/p&gt;
&lt;h2 id=&quot;单体内置对象&quot;&gt;&lt;a href=&quot;#单体内置对象&quot; class=&quot;headerlink&quot; title=&quot;单体内置对象&quot;&gt;&lt;/a&gt;单体内置对象&lt;/h2&gt;&lt;p&gt;除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。&lt;/p&gt;
&lt;h3 id=&quot;Global对象&quot;&gt;&lt;a href=&quot;#Global对象&quot; class=&quot;headerlink&quot; title=&quot;Global对象&quot;&gt;&lt;/a&gt;Global对象&lt;/h3&gt;&lt;p&gt;所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()&lt;br&gt;isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI编码方法&lt;/strong&gt;&lt;br&gt;Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval()方法&lt;/strong&gt;&lt;br&gt;eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。&lt;br&gt;当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：&lt;/p&gt;
&lt;p&gt;var msg = “hello world”;&lt;br&gt;eval(“alert(msg)”);     //“hello world”&lt;/p&gt;
&lt;p&gt;变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Global对象的属性&lt;/strong&gt;&lt;br&gt;Global对象的所有属性：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window对象&lt;/strong&gt;&lt;br&gt;ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。&lt;/p&gt;
&lt;h3 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math()对象&quot;&gt;&lt;/a&gt;Math()对象&lt;/h3&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Math对象的属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Math对象的方法&lt;/strong&gt;&lt;br&gt;min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.&lt;br&gt;Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。&lt;br&gt;Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//选择一个介于2到10之间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var num = Math.&lt;span class=&quot;built_in&quot;&gt;floor&lt;/span&gt;(Math.random() * &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下函数可以直接指定随机范围（整数）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectFrom&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lowerValue, upperValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; choices = upperValue - lowerValue +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() * choices + lowerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = selectFrom(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(num);     &lt;span class=&quot;comment&quot;&gt;//介于2和10之间（包括2和10）的一个数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.abs(num)     返回num的绝对值&lt;br&gt;Math.asin(x)     返回x的反正弦值&lt;br&gt;Math.exp(num)     返回Math.E的num次幂&lt;br&gt;     Math.atan(x)     返回x的反正切值&lt;br&gt;Math.log(num)     返回num的自然对数&lt;br&gt;Math.atan2(y,x)     返回y/x的反正切值&lt;br&gt;Math.pow(num, power)     返回num的power次幂&lt;br&gt;Math.cos(x)     返回x的余弦值&lt;br&gt;Math.sqrt(num)     返回num的平方根&lt;br&gt;Math.sin(x)     返回x的正弦值&lt;br&gt;Math.acos(x)     返回x的反余弦值&lt;br&gt;Math.tan(x)     返回x的正切值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第六章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h3&gt;&lt;p&gt;ECMAScript中有两种属性：数据属性和访问器属性。&lt;br&gt;&lt;strong&gt;数据属性&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。&lt;br&gt;要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：&lt;br&gt;注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//抛出错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问器属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。&lt;br&gt;访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; book = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _year: &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edition: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(book, &lt;span class=&quot;string&quot;&gt;&quot;year&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.edition += newValue - &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;book.year = &lt;span class=&quot;number&quot;&gt;2005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(book.edition);        &lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一个属性的值会导致其他属性发生变化。&lt;br&gt;注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义多个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取属性的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。&lt;/p&gt;
&lt;p&gt;注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。&lt;/p&gt;
&lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;构造函数模式&quot;&gt;&lt;a href=&quot;#构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式&quot;&gt;&lt;/a&gt;构造函数模式&lt;/h3&gt;&lt;p&gt;像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age, job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;br&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。&lt;br&gt;创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将构造函数当做函数&lt;/strong&gt;&lt;br&gt;任何函数，只要通过new操作符来调用，那它就可以作为构造函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数的问题&lt;/strong&gt;&lt;br&gt;构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.&lt;/p&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;br&gt;创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。&lt;br&gt;如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。&lt;/p&gt;
&lt;p&gt;isPrototypeOf()：确定对象原型方法。&lt;br&gt;&lt;code&gt;alert(Person.prototype.isPrototypeOf(person1)); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; Object.getPrototypeOf()：ECMAScript 5新增方法。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt; == Person.prototype)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;  //true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt;.name)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; //&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;原型与in操作符&lt;/strong&gt;&lt;br&gt;有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;p&gt;而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function hasPrototypeProperty(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;/span&gt;name) &amp;amp;&amp;amp; (name in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。&lt;/p&gt;
&lt;p&gt;Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。&lt;/p&gt;
&lt;p&gt;如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型的动态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;h3 id=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;a href=&quot;#组合使用构造函数模式和原型模式&quot; class=&quot;headerlink&quot; title=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;/a&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。&lt;/p&gt;
&lt;h3 id=&quot;动态原型模式&quot;&gt;&lt;a href=&quot;#动态原型模式&quot; class=&quot;headerlink&quot; title=&quot;动态原型模式&quot;&gt;&lt;/a&gt;动态原型模式&lt;/h3&gt;&lt;p&gt;动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。&lt;/p&gt;
&lt;h3 id=&quot;寄生构造函数模式&quot;&gt;&lt;a href=&quot;#寄生构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;寄生构造函数模式&quot;&gt;&lt;/a&gt;寄生构造函数模式&lt;/h3&gt;&lt;p&gt;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。&lt;/p&gt;
&lt;h3 id=&quot;稳妥构造函数模式&quot;&gt;&lt;a href=&quot;#稳妥构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;稳妥构造函数模式&quot;&gt;&lt;/a&gt;稳妥构造函数模式&lt;/h3&gt;&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());    &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链的问题&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。&lt;br&gt;原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。&lt;/p&gt;
&lt;h3 id=&quot;借用构造函数&quot;&gt;&lt;a href=&quot;#借用构造函数&quot; class=&quot;headerlink&quot; title=&quot;借用构造函数&quot;&gt;&lt;/a&gt;借用构造函数&lt;/h3&gt;&lt;p&gt;在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递参数&lt;/strong&gt;&lt;br&gt;相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数的问题&lt;/strong&gt;&lt;br&gt;如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。&lt;/p&gt;
&lt;h3 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h3&gt;&lt;p&gt;组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SupType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Nicolas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayAge();         &lt;span class=&quot;comment&quot;&gt;//29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayAge();         &lt;span class=&quot;comment&quot;&gt;//27&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。&lt;br&gt;组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;/h3&gt;&lt;p&gt;借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    F.prototype = o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anttherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Rob&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yetAnotherPerosn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Linda&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Barbie&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.friends);  &lt;span class=&quot;comment&quot;&gt;//&quot;Shelby, Court, Van, Rob, Barbie&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。&lt;br&gt;ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。&lt;br&gt;object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。&lt;/p&gt;
&lt;h3 id=&quot;寄生式继承&quot;&gt;&lt;a href=&quot;#寄生式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生式继承&quot;&gt;&lt;/a&gt;寄生式继承&lt;/h3&gt;&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(original)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; = object(original);    &lt;span class=&quot;comment&quot;&gt;//通过调用函数创建一个新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;       &lt;span class=&quot;comment&quot;&gt;//以某种方式来增强这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;hi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;;                    &lt;span class=&quot;comment&quot;&gt;//返回这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson = createAnother(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.sayHi();  &lt;span class=&quot;comment&quot;&gt;//&quot;hi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。&lt;br&gt;注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。&lt;/p&gt;
&lt;h3 id=&quot;寄生组合式继承&quot;&gt;&lt;a href=&quot;#寄生组合式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生组合式继承&quot;&gt;&lt;/a&gt;寄生组合式继承&lt;/h3&gt;&lt;p&gt;组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);             &lt;span class=&quot;comment&quot;&gt;//第二次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();        &lt;span class=&quot;comment&quot;&gt;//第一次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。&lt;br&gt;而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(subType, superType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prototype = object(superType.prototype);    &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prototype.constructor = subType;                &lt;span class=&quot;comment&quot;&gt;//增强对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subType.prototype = prototype;                  &lt;span class=&quot;comment&quot;&gt;//指定对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inheritPrototype(SubType, SuperType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：&lt;br&gt;1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。&lt;br&gt;2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。&lt;br&gt;3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。&lt;br&gt;JavaScript主要使用原型链实现继承。&lt;strong&gt;原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的&lt;/strong&gt;。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。&lt;br&gt;使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。&lt;br&gt;此外，还存在下列可供选择的继承模式：&lt;br&gt;1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。&lt;br&gt;2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。&lt;br&gt;3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;h1 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h1&gt;&lt;p&gt;定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; functionName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num * arguments.callee(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var factorial = (&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;num * &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;不少开发人员总是搞不清匿名函数和闭包这两个概念。&lt;br&gt;&lt;strong&gt;闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;而匿名函数是指没有函数名称的函数。&lt;/strong&gt;&lt;br&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。&lt;br&gt;在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = compare(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 &lt;/p&gt;
&lt;p&gt;无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。&lt;br&gt;在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compare = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compare(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compareNames = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compareNames(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//解除对匿名函数的引用（以便释放内存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compareNames = null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包与变量&quot;&gt;&lt;a href=&quot;#闭包与变量&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数会返回一个函数数组，而其中的每个函数都返回10。&lt;br&gt;我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //匿名函数直接赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function(num) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于this对象&quot;&gt;&lt;a href=&quot;#关于this对象&quot; class=&quot;headerlink&quot; title=&quot;关于this对象&quot;&gt;&lt;/a&gt;关于this对象&lt;/h3&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;The Window&quot;（在非严格模式下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; that.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;My Object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(element.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//防止内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = element.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。&lt;/p&gt;
&lt;h2 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h2&gt;&lt;p&gt;JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。&lt;br&gt;用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//立即调用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里是块级作用域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数。&lt;br&gt;函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。&lt;/p&gt;
&lt;p&gt;无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outputNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(i);    &lt;span class=&quot;comment&quot;&gt;//导致一个错误！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。&lt;/p&gt;
&lt;h2 id=&quot;私有变量&quot;&gt;&lt;a href=&quot;#私有变量&quot; class=&quot;headerlink&quot; title=&quot;私有变量&quot;&gt;&lt;/a&gt;私有变量&lt;/h2&gt;&lt;p&gt;严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。&lt;br&gt;如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。&lt;br&gt;我们把有权访问私有变量和私有函数的公有方法成为&lt;strong&gt;特权方法&lt;/strong&gt;（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。&lt;br&gt;利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nihcholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。&lt;br&gt;构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。&lt;/p&gt;
&lt;h3 id=&quot;静态私有变量&quot;&gt;&lt;a href=&quot;#静态私有变量&quot; class=&quot;headerlink&quot; title=&quot;静态私有变量&quot;&gt;&lt;/a&gt;静态私有变量&lt;/h3&gt;&lt;p&gt;通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公有/特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject.prototype.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。&lt;br&gt;这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototye.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototype.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Michael&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person2.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。&lt;br&gt;以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。&lt;/p&gt;
&lt;h3 id=&quot;模块模式&quot;&gt;&lt;a href=&quot;#模块模式&quot; class=&quot;headerlink&quot; title=&quot;模块模式&quot;&gt;&lt;/a&gt;模块模式&lt;/h3&gt;&lt;p&gt;前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : value,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; : function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是方法的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权/公有方法和属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicProperty: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; application = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; components = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    components.push(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaseComponent());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公共&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getComponentCount : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; components.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerComponent : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; component == &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                components.push(component);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。&lt;br&gt;简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。&lt;/p&gt;
&lt;h3 id=&quot;增强的模块模式&quot;&gt;&lt;a href=&quot;#增强的模块模式&quot; class=&quot;headerlink&quot; title=&quot;增强的模块模式&quot;&gt;&lt;/a&gt;增强的模块模式&lt;/h3&gt;&lt;p&gt;有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。&lt;/p&gt;
&lt;h2 id=&quot;小结：&quot;&gt;&lt;a href=&quot;#小结：&quot; class=&quot;headerlink&quot; title=&quot;小结：&quot;&gt;&lt;/a&gt;小结：&lt;/h2&gt;&lt;p&gt;在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包还可以用于在对象中创建私有变量，相关概念和要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。&lt;/p&gt;
&lt;h1 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h1&gt;&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。&lt;/p&gt;
&lt;p&gt;定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。&lt;br&gt;尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，&lt;/p&gt;
&lt;h3 id=&quot;窗口关系及框架&quot;&gt;&lt;a href=&quot;#窗口关系及框架&quot; class=&quot;headerlink&quot; title=&quot;窗口关系及框架&quot;&gt;&lt;/a&gt;窗口关系及框架&lt;/h3&gt;&lt;p&gt;如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。&lt;br&gt;每个window对象都有一个name属性，其中包含框架的名称。&lt;br&gt;top对象始终指向最高（最外）层的框架，也就是浏览器窗口。&lt;br&gt;与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。&lt;/p&gt;
&lt;h3 id=&quot;窗口的位置&quot;&gt;&lt;a href=&quot;#窗口的位置&quot; class=&quot;headerlink&quot; title=&quot;窗口的位置&quot;&gt;&lt;/a&gt;窗口的位置&lt;/h3&gt;&lt;p&gt;使用如下代码可以取得窗口左边和上边的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; leftPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenY;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;moveTo():接收新位置的x,y坐标值&lt;/p&gt;
&lt;p&gt;moveBy():接收在水平和垂直方向上移动的像素数&lt;/p&gt;
&lt;h3 id=&quot;窗口大小&quot;&gt;&lt;a href=&quot;#窗口大小&quot; class=&quot;headerlink&quot; title=&quot;窗口大小&quot;&gt;&lt;/a&gt;窗口大小&lt;/h3&gt;&lt;p&gt;四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.&lt;/p&gt;
&lt;p&gt;resizeTo():接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy():接收新窗口与原窗口的宽度和高度之差&lt;/p&gt;
&lt;p&gt;innerWidth和innerHeight表示该容器中页面视图区的大小&lt;/p&gt;
&lt;h3 id=&quot;导航和打开新窗口&quot;&gt;&lt;a href=&quot;#导航和打开新窗口&quot; class=&quot;headerlink&quot; title=&quot;导航和打开新窗口&quot;&gt;&lt;/a&gt;导航和打开新窗口&lt;/h3&gt;&lt;p&gt;使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。&lt;/p&gt;
&lt;h3 id=&quot;间歇调用和超时调用&quot;&gt;&lt;a href=&quot;#间歇调用和超时调用&quot; class=&quot;headerlink&quot; title=&quot;间歇调用和超时调用&quot;&gt;&lt;/a&gt;间歇调用和超时调用&lt;/h3&gt;&lt;p&gt;javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。&lt;br&gt;超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。&lt;/p&gt;
&lt;p&gt;间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。&lt;/p&gt;
&lt;h3 id=&quot;系统对话框&quot;&gt;&lt;a href=&quot;#系统对话框&quot; class=&quot;headerlink&quot; title=&quot;系统对话框&quot;&gt;&lt;/a&gt;系统对话框&lt;/h3&gt;&lt;p&gt;浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;查询字符串参数&quot;&gt;&lt;a href=&quot;#查询字符串参数&quot; class=&quot;headerlink&quot; title=&quot;查询字符串参数&quot;&gt;&lt;/a&gt;查询字符串参数&lt;/h3&gt;&lt;p&gt;location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  &lt;/p&gt;
&lt;h3 id=&quot;位置操作&quot;&gt;&lt;a href=&quot;#位置操作&quot; class=&quot;headerlink&quot; title=&quot;位置操作&quot;&gt;&lt;/a&gt;位置操作&lt;/h3&gt;&lt;p&gt;用location对象改变浏览器位置的多种方式：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);  
window.location=&amp;quot;htttp://www.wrox.com&amp;quot;;  
location.href=&amp;quot;htttp://www.wrox.com&amp;quot;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。&lt;/p&gt;
&lt;p&gt;  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;&lt;a href=&quot;#navigator对象&quot; class=&quot;headerlink&quot; title=&quot;navigator对象&quot;&gt;&lt;/a&gt;navigator对象&lt;/h2&gt;&lt;p&gt;navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。&lt;/p&gt;
&lt;h3 id=&quot;检测插件&quot;&gt;&lt;a href=&quot;#检测插件&quot; class=&quot;headerlink&quot; title=&quot;检测插件&quot;&gt;&lt;/a&gt;检测插件&lt;/h3&gt;&lt;p&gt;navigator.plugins[]表示浏览器所用的插件的集合。&lt;br&gt;name: 插件的名字&lt;/p&gt;
&lt;p&gt;description:插件的描述&lt;/p&gt;
&lt;p&gt;filename:插件的文件名&lt;/p&gt;
&lt;p&gt;length:插件所处理的MIME类型数量&lt;/p&gt;
&lt;h3 id=&quot;注册处理程序&quot;&gt;&lt;a href=&quot;#注册处理程序&quot; class=&quot;headerlink&quot; title=&quot;注册处理程序&quot;&gt;&lt;/a&gt;注册处理程序&lt;/h3&gt;&lt;p&gt;FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。&lt;/p&gt;
&lt;p&gt;registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。&lt;/p&gt;
&lt;p&gt;navigator.registerContentHandler(‘application/rss+xml’, ‘&lt;a href=&quot;http://www.sohu.com?feed=%s’&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sohu.com?feed=%s’&lt;/a&gt;, ‘some Reader’);&lt;/p&gt;
&lt;p&gt;FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。&lt;/p&gt;
&lt;h2 id=&quot;screen对象&quot;&gt;&lt;a href=&quot;#screen对象&quot; class=&quot;headerlink&quot; title=&quot;screen对象&quot;&gt;&lt;/a&gt;screen对象&lt;/h2&gt;&lt;p&gt;screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;&lt;a href=&quot;#history对象&quot; class=&quot;headerlink&quot; title=&quot;history对象&quot;&gt;&lt;/a&gt;history对象&lt;/h2&gt;&lt;p&gt;history.go(-1) | history.back(); //后退一页&lt;/p&gt;
&lt;p&gt;history.go(1) | history.forward();//前进一页&lt;/p&gt;
&lt;p&gt;history.go(n);//前进n页&lt;/p&gt;
&lt;p&gt;history.go(‘sohu.com’);//跳转到最后的sohu页面&lt;/p&gt;
&lt;p&gt;history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。&lt;/p&gt;
&lt;h1 id=&quot;第9章，客户端检测&quot;&gt;&lt;a href=&quot;#第9章，客户端检测&quot; class=&quot;headerlink&quot; title=&quot;第9章，客户端检测&quot;&gt;&lt;/a&gt;第9章，客户端检测&lt;/h1&gt;&lt;p&gt;尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案&lt;/p&gt;
&lt;h2 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h2&gt;&lt;p&gt;检测浏览器是否具备某一能力。&lt;/p&gt;
&lt;p&gt;尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险&lt;/p&gt;
&lt;p&gt;并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。&lt;/p&gt;
&lt;h2 id=&quot;怪癖检测&quot;&gt;&lt;a href=&quot;#怪癖检测&quot; class=&quot;headerlink&quot; title=&quot;怪癖检测&quot;&gt;&lt;/a&gt;怪癖检测&lt;/h2&gt;&lt;p&gt;检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。&lt;/p&gt;
&lt;h2 id=&quot;用户代理检测&quot;&gt;&lt;a href=&quot;#用户代理检测&quot; class=&quot;headerlink&quot; title=&quot;用户代理检测&quot;&gt;&lt;/a&gt;用户代理检测&lt;/h2&gt;&lt;p&gt;通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。&lt;br&gt;识别呈现引擎&lt;/p&gt;
&lt;p&gt;注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera&lt;/p&gt;
&lt;p&gt;注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别&lt;br&gt;识别浏览器&lt;br&gt;识别平台&lt;br&gt;识别windows操作系统&lt;br&gt;识别移动设备&lt;br&gt;识别游戏系统&lt;br&gt;完整的用户代理检测代码&lt;/p&gt;
&lt;h1 id=&quot;第10章-DOM&quot;&gt;&lt;a href=&quot;#第10章-DOM&quot; class=&quot;headerlink&quot; title=&quot;第10章 DOM&quot;&gt;&lt;/a&gt;第10章 DOM&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
