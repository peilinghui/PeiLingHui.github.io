<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2016-05-06T13:48:39.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>91夺宝项目</title>
    <link href="http://peilinghui.com/2016/05/06/91%E5%A4%BA%E5%AE%9D%E9%A1%B9%E7%9B%AE/"/>
    <id>http://peilinghui.com/2016/05/06/91夺宝项目/</id>
    <published>2016-05-06T13:35:37.000Z</published>
    <updated>2016-05-06T13:48:39.000Z</updated>
    
    <content type="html">&lt;p&gt;视频学习总结。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目介绍：&quot;&gt;&lt;a href=&quot;#项目介绍：&quot; class=&quot;headerlink&quot; title=&quot;项目介绍：&quot;&gt;&lt;/a&gt;项目介绍：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;登录注册，还有第三方登录(微信和微博),获取验证码，&lt;/li&gt;
&lt;li&gt;首页功能：轮播页，商品展示，销量展示，下拉刷新，上拉加载更多。&lt;/li&gt;
&lt;li&gt;宝贝详情页面：销量展示，图文详情，夺宝码，已经购买的记录，支付夺宝。&lt;/li&gt;
&lt;li&gt;晒单-简易朋友圈：晒单列表，晒单-从相册选取图片，相册浏览器&lt;/li&gt;
&lt;li&gt;我的页面：分享，个人资料管理，充值，夺宝记录，夺宝码，获得商品，收货地址管理和设置。&lt;br&gt;6.使用移动云服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;用GPUImage实现图片高斯模糊&quot;&gt;&lt;a href=&quot;#用GPUImage实现图片高斯模糊&quot; class=&quot;headerlink&quot; title=&quot;用GPUImage实现图片高斯模糊&quot;&gt;&lt;/a&gt;用GPUImage实现图片高斯模糊&lt;/h3&gt;&lt;p&gt;用Cocospods来管理第三方框架，Cocospods我也写过一个使用介绍：&amp;lt;&amp;gt;&lt;br&gt;用GPUImage中的GPUImageGaussianBlurFilter来实现图片高斯模糊。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;视频学习总结。&lt;br&gt;
    
    </summary>
    
    
      <category term="oc,视频学习" scheme="http://peilinghui.com/tags/oc-%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>仿iMessage聊天页面开发</title>
    <link href="http://peilinghui.com/2016/05/06/%E4%BB%BFiMessage%E8%81%8A%E5%A4%A9%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <id>http://peilinghui.com/2016/05/06/仿iMessage聊天页面开发/</id>
    <published>2016-05-06T12:27:24.000Z</published>
    <updated>2016-05-06T13:24:24.000Z</updated>
    
    <content type="html">&lt;p&gt;视频学习笔记。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;视频地址：&lt;a href=&quot;http://www.maiziedu.com/course/ios/754-10847/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.maiziedu.com/course/ios/754-10847/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UItableView控件基础&quot;&gt;&lt;a href=&quot;#UItableView控件基础&quot; class=&quot;headerlink&quot; title=&quot;UItableView控件基础&quot;&gt;&lt;/a&gt;UItableView控件基础&lt;/h2&gt;&lt;h3 id=&quot;UITableView的基础用法&quot;&gt;&lt;a href=&quot;#UITableView的基础用法&quot; class=&quot;headerlink&quot; title=&quot;UITableView的基础用法&quot;&gt;&lt;/a&gt;UITableView的基础用法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;UITableView的创建方式与生命周期&lt;br&gt;设置UITableView的dataSource、delegate。&lt;br&gt;UITableViewDataSource协议：必须实现：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一共有多少组数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)numberOfSectionsInTableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//每一组有多少行数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView numberOfRowsInSection:(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)section;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//每一行显示什么内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)tableView:(&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *)tableView cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;UITableView中cell的重用机制&lt;br&gt;原理：进入屏幕，当UITableView要求dataSource返回UITableViewCell时,dataSource会先查看这个复用池，如果池中有未使用的UITableViewCell，dataSource会用新的数据配置这个UITableViewCell，然后返回给UITableView，重新显示到窗口中，从而避免创建新对象.当滚动列表时，画出屏幕时，部分UITableViewCell会移出窗口，UITableView会将窗口外的UITableViewCell放入一个对象池中，等待重用。&lt;br&gt;方法：可以在初始化UITableViewCell的时候传入一个特定的字符串标识来设置reuseIdentifier(一般用UITableViewCell的类名)。当UITableView要求dataSource返回UITableViewCell时，先通过一个字符串标识到对象池中查找对应类型的UITableViewCell对象，如果有，就重用，如果没有，就传入这个字符串标识来初始化一个UITableViewCell对象。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UITableViewDataSource协议中方法的意义与使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UITableViewDelegate协议中方法的意义与使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;定制UITableViewCell&quot;&gt;&lt;a href=&quot;#定制UITableViewCell&quot; class=&quot;headerlink&quot; title=&quot;定制UITableViewCell&quot;&gt;&lt;/a&gt;定制UITableViewCell&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;UITableViewCell的几种系统fengg&lt;/li&gt;
&lt;li&gt;自定义UITableViewCell&lt;/li&gt;
&lt;li&gt;使用Xib文件进行可视化的UITableViewCell开发&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;UITableView的编辑操作&quot;&gt;&lt;a href=&quot;#UITableView的编辑操作&quot; class=&quot;headerlink&quot; title=&quot;UITableView的编辑操作&quot;&gt;&lt;/a&gt;UITableView的编辑操作&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;向UITableView中进行增删改查&lt;/li&gt;
&lt;li&gt;对UITableView中每行数据进行重新排序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iMessages主页面的设计开发&quot;&gt;&lt;a href=&quot;#iMessages主页面的设计开发&quot; class=&quot;headerlink&quot; title=&quot;iMessages主页面的设计开发&quot;&gt;&lt;/a&gt;iMessages主页面的设计开发&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;信息cell的设计&lt;/li&gt;
&lt;li&gt;组合使用搜索栏控件&lt;/li&gt;
&lt;li&gt;增加编辑模式&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;视频学习笔记。&lt;br&gt;
    
    </summary>
    
    
      <category term="swift，视频学习" scheme="http://peilinghui.com/tags/swift%EF%BC%8C%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最近学习总结</title>
    <link href="http://peilinghui.com/2016/05/06/%E6%9C%80%E8%BF%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2016/05/06/最近学习总结/</id>
    <published>2016-05-06T08:44:09.000Z</published>
    <updated>2016-05-06T08:50:08.000Z</updated>
    
    <content type="html">&lt;p&gt;最近看了三天代码。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【iOS】#include、#import和@class区别&lt;br&gt;在OC中，引用文件可以通过#include、#import、@class三种方式，本文将讲解这三种方式的不同之处以及选择方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一. #include&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在C语言中，我们使用#include来引入头文件。使用#include “xx.h”来引入自定义的头文件，使用#include&lt;xx.h&gt;来引入库中的头文件。&lt;/xx.h&gt;&lt;/li&gt;
&lt;li&gt;但是#include并不能防止重复引用头文件，如果在文件中，重复引用头文件，将会报错。（如：A引入了B，B引入了C，A再引入C，就会报错）&lt;br&gt;所以在OC中，几乎没有使用#incldue引头的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二. #import&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;#import是#include的升级版，可以防止重复引入头文件这种现象的发生。&lt;/li&gt;
&lt;li&gt;#import在引入头的时候，就是完全将头文件拷贝到现在的文件中。所以也有效率上的问题。&lt;/li&gt;
&lt;li&gt;#import最大的问题在于，需要避免出现头文件递归引入的现象。（如：A引入B，B引入A，那么A、B的头文件会互相不停的拷贝）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三. @class&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;@class用来告诉编译器，有这样一个类，使书写代码时，不报错。&lt;/li&gt;
&lt;li&gt;因为#import引入头文件有效率问题，所以，当还没有调用类中方法，仅仅是定义类变量的时候，使用@class来提醒编译器。而在真正需要调用类方法的时候，进行#import。&lt;br&gt;（如：现在需要在Student.h文件中定义一个Book类的变量book&lt;br&gt;那么不需要在Student.h中#import “Book.h”&lt;br&gt;而是在Student.h中@class Book 来是编译器不报错，告诉编译器我现在使用的Book是一个类，可以定义变量book&lt;br&gt;在之后的Student.m文件中，需要调用book方法时，在#import “Book.h”&lt;br&gt;从而降低#import在效率上的问题。）&lt;/li&gt;
&lt;li&gt;如果A是B的父类，那么这是在B.h中就必须要使用#import来引入A的头，因为需要知道A类中有哪些变量和方法，以免B类中重复定义。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了三天代码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>斯坦福iPhone开发</title>
    <link href="http://peilinghui.com/2016/05/01/%E6%96%AF%E5%9D%A6%E7%A6%8FiPhone%E5%BC%80%E5%8F%91/"/>
    <id>http://peilinghui.com/2016/05/01/斯坦福iPhone开发/</id>
    <published>2016-05-01T04:21:56.000Z</published>
    <updated>2016-05-07T02:29:21.000Z</updated>
    
    <content type="html">&lt;p&gt;视频学习。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;课程网站：&lt;a href=&quot;http://cs193p.stanford.edu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cs193p.stanford.edu&lt;/a&gt;&lt;br&gt;其他网站：&lt;a href=&quot;http://developer.apple.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.apple.com&lt;/a&gt;&lt;br&gt;开发者论坛：&lt;a href=&quot;http://devforums.apple.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://devforums.apple.com&lt;/a&gt;&lt;br&gt;iPhone OS&lt;br&gt;Cocoa Touch : Multi-Touch Events,Alerts,Multi-Touch Controls,Web View,Accelerometer,People Picker,View hierarchy,Image Picker,Localization,Camera&lt;/p&gt;
&lt;p&gt;Media: Core Audio,JPG,PNG,TIFF,OpenAL,PDF,Audio Mixing,Quartz(2D),Audio Recording,Core Animation,Video Playback,OpenGL ES&lt;/p&gt;
&lt;p&gt;Core Service：Collections,Core Location,Address Book,Net Service,Networking,Threading,File Access,Preferences,SQLite,URL utilities.&lt;/p&gt;
&lt;p&gt;Core OS: OS X Kernel,Power Mgmt,Mach 3.0,Keychain,BSD,Certificates,Sockets,File System,Security,Bonjours.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://develper.apple.com/iphone/library/documentation/Cocoa/Conceptual/OOP_ObjC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://develper.apple.com/iphone/library/documentation/Cocoa/Conceptual/OOP_ObjC&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;视频学习。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络编程</title>
    <link href="http://peilinghui.com/2016/04/14/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://peilinghui.com/2016/04/14/iOS网络编程/</id>
    <published>2016-04-14T14:07:11.000Z</published>
    <updated>2016-04-14T14:07:58.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS网络编程知识总结&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS网络编程&quot;&gt;&lt;a href=&quot;#iOS网络编程&quot; class=&quot;headerlink&quot; title=&quot;iOS网络编程&quot;&gt;&lt;/a&gt;iOS网络编程&lt;/h1&gt;&lt;h2 id=&quot;检测网络状态&quot;&gt;&lt;a href=&quot;#检测网络状态&quot; class=&quot;headerlink&quot; title=&quot;检测网络状态&quot;&gt;&lt;/a&gt;检测网络状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;检查网络状态。&lt;br&gt;1&amp;gt;下载和添加Reachablity类.&lt;br&gt;2&amp;gt;为项目添加SystemConfiguration.framework框架。&lt;br&gt;若要手动禁用ARC源文件，输入框添加“-fno-objc-arc”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;a href=&quot;#使用CFNetwork实现TCP协议的通信&quot; class=&quot;headerlink&quot; title=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;/a&gt;使用CFNetwork实现TCP协议的通信&lt;/h2&gt;&lt;p&gt;CFNetwork对基于TCP协议的网络通信提供了良好的封装，CFNetwork使用CFSocket来代表两端的通信端口，还可以通过CFStream读/写数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IP地址是32位整数，分为A，B,C,D,E五类。用于唯一标识网络上的一个通信实体&lt;br&gt;A类：10.0.0.0~10.255.255.255&lt;br&gt;B类：172.16.0.0~172.31.255.255&lt;br&gt;C类：192.168.0.0~192.168.255.255&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;端口是16为整数，表示数据交给哪个通信程序处理，是应用程序和外界交流的出入口，包括一些数据结构和I/O。&lt;br&gt;公认端口：从0到1023，紧紧绑定一些特定的服务。&lt;br&gt;注册端口：从1024到49151，松散的绑定一些服务，适用于应用程序。&lt;br&gt;动态和/私有端口：从49152到65535.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP服务器端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个监听Socket Accept的CFSocket,并为kCFSocketAcceptCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketSetAddress()函数，将服务器的CFSocket绑定到本地IP地址和端口。&lt;br&gt;3&amp;gt;将CFSocket作为source添加到指定线程的CFRunLoop上，并运行该线程的CFRunLoop，从而保证该CFSocket能持续不断的接受来自客户端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP客户端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个不监听任何事件或监听Connection的CFSocket。如果要监听Connection，则需要为kCFSocketConnectCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketConnectionToAddress()函数，将客户端的CFSocket；连接到指定IP地址和端口的服务器上。&lt;br&gt;3&amp;gt;得到客户端CFSocket之后，既可直接使用CFSocketNativeHandle进行读/写，也可通过CFSocket获取CFReadStreamRef、CFWriteStreamRef后进行读、写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CocoaAsyncSocket实现TCP客户端&lt;br&gt;降低直接使用CFSocket编程的复杂度，另外有开发者提供了一套开源的CocoaAsyncSocket库。&lt;br&gt;CocoaAsyncSocket封装了CFNetwork底层的CFSocket和CFStream，并提供了异步操作，支持TCP和UDP。&lt;br&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞方式的读和写，而且可设置超时时长。&lt;/li&gt;
&lt;li&gt;自动的socket接受，如果调用它接受连接，它将为每个连接启动新的实例，当然也可以立即关闭这些连接。&lt;/li&gt;
&lt;li&gt;委托支持，错误、连接、接收、完整的读取、完整的写入、进度以及断开连接，都可通过代理模式调用。&lt;/li&gt;
&lt;li&gt;所有操作都封装在一个类中，开发者无需操作socket或流，该类封装了所有操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用NSURLConnection&quot;&gt;&lt;a href=&quot;#使用NSURLConnection&quot; class=&quot;headerlink&quot; title=&quot;使用NSURLConnection&quot;&gt;&lt;/a&gt;使用NSURLConnection&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用NSURLConnection从网络获取数据&lt;br&gt;方法:&lt;br&gt;&lt;code&gt;- (NSURLRequest *)originalRequest://获取该NSURLConnection最初的NSURLRequest对象的深拷贝&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSURLRequest *)currentRequest://返回该该NSURLConnection当前使用的NSURLRequest对象。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1&amp;gt;同步请求获取网络数据：&lt;br&gt;&lt;code&gt;+ sendSynchronousRequest:returningResponse:error:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;异步请求获取网络数据：&lt;br&gt;总指定一个NSURLConnectionDelegate对象，将该对象作为NSURLConnection的delegate，负责服务器响应到来的各种事件。&lt;br&gt;&lt;code&gt;+ connectionWithRequest:delegate://异步请求的方式获取数据&lt;/code&gt;&lt;br&gt;&lt;code&gt;- initWithRequest:delegate//实例方法，必须先调用alloc,再调用该方法。&lt;/code&gt;&lt;br&gt;&lt;code&gt;+ sendAsynchronousRequest:queue:CompletionHandler://表明将请求交给指定的NSOperationQueue处理&lt;/code&gt;&lt;br&gt;&lt;code&gt;- start://开始发送请求&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用使用NSURLConnection从网络获取数据的步骤：&lt;br&gt;1&amp;gt;创建NSURLRequest对象，该对象代表对远程服务器的请求。包括：请求的URL，缓存策略，超时时长等。&lt;br&gt;2&amp;gt;调用NSURLConnection的实例方法或类方法，以NSURLRequest对象为参数创建NSURLConnection即可发送请求。&lt;br&gt;3&amp;gt;以异步方式加载服务器响应，则需要为NSURLConnection对象指定delegate对象，因此还需要为delegate对象实现特定的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用NSMutableURLRequest向服务器发送请求&lt;br&gt;NSURLRequest只能想服务器发送简单的请求，不能添加请求头和请求参数，使用NSMutableURLRequest可以。&lt;br&gt;&lt;code&gt;-addValue:forHTTPHeaderField:为使用NSMutableURLRequest添加请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setAllHTTPHeaderField:通过一个NSDictionary一次性为NSMutableURLRequest设置多个请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBody:设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBodyStream:以NSInputStream为参数设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPMethod:设置提交请求方式，要么是POST，要么是GET。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPShouldHandleCookies:设置该HTTP请求是否处理Cookie。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setValue：forHTTPHeaderField：为指定的请求头设置请求值。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;XML解析&quot;&gt;&lt;a href=&quot;#XML解析&quot; class=&quot;headerlink&quot; title=&quot;XML解析&quot;&gt;&lt;/a&gt;XML解析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DOM与SAX&lt;br&gt;DOM：Document Object Model。文档对象模型、&lt;br&gt;SAX：Simple API for XML。&lt;br&gt;iOS SDK提供了NSXMLParser和libxml2两个类库，还有第三方库GDataXML，TBXML，TouchXML，KissXML等。&lt;br&gt;需要读取和修改XML文档，使用GDataXML，KissXML。&lt;br&gt;需要读取非常大的XML文档，使用libxml2或TBXML。&lt;/li&gt;
&lt;li&gt;NSXMLParser解析XML文档&lt;br&gt;步骤：&lt;ul&gt;
&lt;li&gt;创建NSXMLParser对象。&lt;/li&gt;
&lt;li&gt;为NSXMLParser对象指定delegate对象，该delegate对象必须实现NSXMLParserDelegate协议，并根据需要实现协议中特定的方法。&lt;/li&gt;
&lt;li&gt;调用NSXMLParser对象的parse方法开始解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;libxml2解析XML文档&lt;br&gt;使用C语言的库，准备步骤：&lt;ul&gt;
&lt;li&gt;为项目添加libxml2.dylib库&lt;/li&gt;
&lt;li&gt;添加头文件的搜索路径&lt;br&gt;步骤：    &lt;/li&gt;
&lt;li&gt;创建XMLTextReaderPtr对象.如果以本地XML文档来创建XMLTextReaderPtr对象，则调用XMLTextReaderFilename()函数即可。如果以内存中XML文档来创建该对象，则调用XMLReaderForMemeory（）函数即可。&lt;/li&gt;
&lt;li&gt;依次调用XMLTextReaderxxx()函数来读取XML文档的元素名，元素值，属性等各种内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML解析XML文档&lt;br&gt;第三方开源库，对libxml2的宝座，底层依赖libxml2，既支持解析XML文档 ，也支持修改XML文档，支持XPath方式查询，提供了更好的面向对象的封装。&lt;br&gt;准备步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 调用GDataXMLDocument的初始化方法根据XML文档或XML字符初始化GDataXMLDocument对象。（GDataXMLDocument对象就是XML文档转换得到的DOM树）
- 调用GDataXMLDocument对象的rootElement方法即可获取该文档的根元素
- 获取根元素后，就可以根据XML元素之间的父子关系来逐层遍历，访问该XML文档中的每一个元素，从而获取XML元素的内容。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;GDataXML生成XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法创建 GDataXMLelement对象，并以该对象作为XML文档的根元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法不断创建 GDataXMLelement对象（XML元素），并利用元素之间的父子关系组织这些XML元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLData方法获取XML文档对应的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML修改XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLDocument方法根据指定的XML文档或者XML字符串来生成对应的GDataXMLDocument对象–它代表了XML文档在内存中的形式。&lt;/li&gt;
&lt;li&gt;获取GDataXMLDocument对象的根元素，然后利用元素之间父子关系添加子元素、删除子元素或修改元素的内容。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对应的NSData 对象，调用NSdata的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;p&gt;JSON具有跨平台，跨语言的优势。两种数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 由key-value对组成的数据结构。
- 有序集合  
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;使用JSON语法创建对象&lt;br&gt;直接创建一个JavaScript对象，&lt;/li&gt;
&lt;li&gt;使用JSON语法创建数组&lt;br&gt;&lt;code&gt;var a = [&amp;#39;yeeku&amp;#39;,&amp;#39;nono&amp;#39;];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三方类库解析JSON，使用NSJSONSerialization处理JSON数据&lt;br&gt;满足条件：&lt;br&gt;顶级对象只能是NSArray或NSDictionary。&lt;br&gt;集合中包含对象只能是NSString，NSNumber，NSArray，NSDictionary或NSNull对象。&lt;br&gt;所有NSDictionary的key只能是NSString。&lt;br&gt;NSNumber保证的数值不是NaN或Infinity。  &lt;/li&gt;
&lt;li&gt;使用SBJson解析JSON数据&lt;br&gt;提供了两个工具类：SBJsonParser和SBJsonWriter.&lt;br&gt;SBJsonParser负责吧NSData或NSString形式的JSON数据转换为objective-c对象。&lt;br&gt;SBJSonWriter负责把objective-c对象转换为NSData或NSString形式的JSON数据。&lt;/li&gt;
&lt;li&gt;使用JSONKit解析JSON数据&lt;br&gt;JSONKit速度快，JsonKit1.4不支持ARC，需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;JSONKit采用分类方式为已有的类增加了新方法。用于将JSON数据恢复为objective-c对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;a href=&quot;#使用AFNetworking实现网络通信&quot; class=&quot;headerlink&quot; title=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;/a&gt;使用AFNetworking实现网络通信&lt;/h2&gt;&lt;p&gt;只是需要向web某个站点的某个简单页面提交请求并获取服务器响应，则使用NSURLConnection来完成。为了更好的处理web站点请求，包括处理Session,Cookie，可以用AFNetworking，用于发送HTTP请求，接受HTTP响应。但不会缓存服务器响应，不能执行HTML页面中嵌入的JavaScript代码，也不会对页面内容进行任何解析处理。AFNetworking还支持JSON、Plist属性文件和XML解析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提交GET请求与提交POST请求&lt;br&gt;步骤：&lt;ul&gt;
&lt;li&gt;创建AFHTTRequestOperationManager对象。&lt;/li&gt;
&lt;li&gt;根据服务器响应内容不同，为HTTORequestOperationManager对象指定不同的解析器。（JSON或Plist数据）&lt;/li&gt;
&lt;li&gt;如果需要发送GET请求，调用AFHTTRequestOperationManager对象的GET：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;如果要发送POST请求，调用AFHTTRequestOperationManager对象的POST：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;在success：参数指定的代码块中处理服务器响应成功的正确数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理JSON和Plist响应&lt;br&gt;可以直接将JSON和Plist转化为NSArray或NSDictionary对象。  AFHTTORequestOperationManager默认可以处理JSON或Plist对象。&lt;/li&gt;
&lt;li&gt;处理XML响应&lt;br&gt;为AFHTTORequestOperationManager显示使用&lt;br&gt;AF X MLParserResponseSerializer响应解析器，当使用AF X MLParserResponseSerializer解析器时，服务器返回的数据是一个NSXMLParser对象。&lt;/li&gt;
&lt;li&gt;上传文件&lt;br&gt;AFHTTRequestOperationManager对象的POST：    parameters:constructingBodyWithBlock:success：failure：方法提交POST请求即可，多了三个参数，一个是带AFMultipartFormData形参的代码块。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;a href=&quot;#使用ASIHTTPRequest框架实现网络编程&quot; class=&quot;headerlink&quot; title=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;/a&gt;使用ASIHTTPRequest框架实现网络编程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发送同步或异步的GET请求&lt;br&gt;准备步骤：&lt;br&gt;目前不支持ARC，应该需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用代码块&lt;br&gt;ASIHTTPRequest发送异步请求，即可使用delegate为ASIHTTPRequest设置回调处理代码，也可用代码块来设置回调处理代码。&lt;br&gt;&lt;code&gt;-setCompletionBlock:设置发送请求、获取服务器响应完成时激发的代码块。&lt;/code&gt;&lt;br&gt;`-setFailedBlock:获取发送请求失败时激发的代码块。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS网络编程知识总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>我的iOS学习之路</title>
    <link href="http://peilinghui.com/2016/04/01/%E6%88%91%E7%9A%84iOS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://peilinghui.com/2016/04/01/我的iOS学习之路/</id>
    <published>2016-04-01T05:01:49.000Z</published>
    <updated>2016-04-13T11:46:01.000Z</updated>
    
    <content type="html">&lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;effective-objective-c-2-0&quot;&gt;&lt;a href=&quot;#effective-objective-c-2-0&quot; class=&quot;headerlink&quot; title=&quot;effective objective-c 2.0&quot;&gt;&lt;/a&gt;effective objective-c 2.0&lt;/h1&gt;&lt;p&gt;作者网站：&lt;a href=&quot;http://www.galloway.me.uk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.galloway.me.uk/&lt;/a&gt;&lt;br&gt;英文原版：&lt;a href=&quot;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Objective-C高级编程&quot;&gt;&lt;a href=&quot;#Objective-C高级编程&quot; class=&quot;headerlink&quot; title=&quot;Objective-C高级编程&quot;&gt;&lt;/a&gt;Objective-C高级编程&lt;/h1&gt;&lt;h2 id=&quot;ARC自动引用计数&quot;&gt;&lt;a href=&quot;#ARC自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;ARC自动引用计数&quot;&gt;&lt;/a&gt;ARC自动引用计数&lt;/h2&gt;&lt;p&gt;  Automatic Reference Counting，降低了程序崩溃、内存泄露的风险，很大程度上减少了开发程序的工作量。&lt;br&gt; 使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Xcode4.2或以上版本&lt;/li&gt;
&lt;li&gt;使用LLVM编译器3.0或以上版本&lt;/li&gt;
&lt;li&gt;编译器选项中设置ARC为有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或release代码&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存管理的思考方式&lt;br&gt;1&amp;gt; 自己生成的对象，自己持有&lt;br&gt;alloc,new,copy,mutablecopy(copy方法利用NSCopying方法约定，由各类实现copyWithZone：方法生成并持有不可变对象的副本)&lt;br&gt;2&amp;gt; 非自己生成的对象，自己持有&lt;br&gt;NSMutableArray类的array方法。使用retain方法可以持有&lt;br&gt;&lt;code&gt;id obj = [NSMutableArray array];
 [obj retain];&lt;/code&gt;&lt;br&gt;3&amp;gt;不再需要自己持有的对象时释放&lt;br&gt;用alloc\new\copy\mutableCopy方法生成并持有的对象，或用retain方法持有的对象，一旦不再需要，务必要用release进行释放。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4&amp;gt;无法释放非自己持有的对象&lt;br&gt;&lt;strong&gt;程序崩溃情况&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 再度释放已经释放了的对象
- 访问已经释放的对象时。
- 释放了非自己持有的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;alloc/retain/release/dealloc在GUNstep中的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在objective-c的对象中存有引用计数这一整数值&lt;/li&gt;
&lt;li&gt;调用alloc或是retain方法后，引用计数值加1.&lt;/li&gt;
&lt;li&gt;调用release后，引用计数值减1.&lt;/li&gt;
&lt;li&gt;引用计数值为0时，调用dealloc方法废弃对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GNUstep将用内存块头部管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;少量代码即可完成&lt;/li&gt;
&lt;li&gt;能够统一管理引用计数用内存块与对象用内存块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;苹果实现通过引用技术表来管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象用内存块的分配无需考虑内存块头部&lt;/li&gt;
&lt;li&gt;引用计数表各记录中存有内存块地址，可以从各个记录追溯到各对象的内存块。（在调试的时候，只要内存技术表没有被破坏，就可以确认各内存块的位置；使用工具检测内存泄露时，引用计数表的各记录也有助于检测各对象的持有者是否存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease的具体使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象。&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法。&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease简介&lt;br&gt;1&amp;gt;autorelease方法的基本作用&lt;br&gt;给对象发送一条autorelease消息, 会将对象放到一个自动释放池中&lt;br&gt;当自动释放池被销毁时，会对池子里面的所有对象做一次release操作&lt;br&gt;会返回对象本身&lt;br&gt;调用完autorelease方法后，对象的计数器不变&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;autorelease的好处&lt;br&gt;不用再关心对象释放的时间&lt;br&gt;不用再关心什么时候调用release&lt;/p&gt;
&lt;p&gt;3&amp;gt;autorelease的使用注意&lt;br&gt;占用内存较大的对象不要随便使用autorelease&lt;br&gt;占用内存较小的对象使用autorelease，没有太大影响&lt;br&gt; &lt;strong&gt;release和autorelease区别&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;release立即释放，autorelease不立即释放，先放到autoreleasepool中，当pool结束后自动调用release。&lt;/p&gt;
&lt;p&gt;一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;autorelease的实现&lt;br&gt;autorelease实例方法的本质就是调用了NSAutoreleasePool对象的addObjective类方法。&lt;br&gt;可通过objc4库的runtime/objc-arr.mm来确认苹果中autorelease的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存不足的产生的例子？如何解决？&lt;br&gt;在for循环中读入大量图片的同时，改变其尺寸。图像文件读入到NSData对象，并从中产生UIImage对象，改变该尺寸后生成新的UIImage对象，这种情况就会产生大量的autorelease的对象。不废弃NSAutoreleasePool对象，那么生成的对象就不能释放，就会产生内存不足。&lt;br&gt;解决：在适当的地方生成、持有或废弃NSAutoreleasePool对象；&lt;br&gt;返回NSMutableArray类的arrayWithCapcity方法。来返回autorelease对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ARC的规则&quot;&gt;&lt;a href=&quot;#ARC的规则&quot; class=&quot;headerlink&quot; title=&quot;ARC的规则&quot;&gt;&lt;/a&gt;ARC的规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置ARC有效的编译方法：&lt;ul&gt;
&lt;li&gt;使用clang（LLVM编译器）3.0或以上版本&lt;/li&gt;
&lt;li&gt;指定编译器属性为“-fobjc-arc”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有权修饰符&lt;br&gt;变量类型定义为id类型和各种对象类型。&lt;br&gt;对象类型：指向NSobject这样的OC指针，如：“NSObject &lt;em&gt;”&lt;br&gt;id类型：用于隐藏对象类型的类名部分，相当于C语言的“void &lt;/em&gt;”&lt;br&gt;1&amp;gt;&lt;strong&gt;strong修饰符（默认的）强引用，适用于普通对象,相当于MRC中的retain&lt;br&gt;2&amp;gt;&lt;/strong&gt;weak修饰符，弱引用，解决循环引用(很容易发生内存泄露), 相当于MRC中的assign.&lt;br&gt;3&amp;gt;&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符，和&lt;strong&gt;weak一样，自己生成并持有的对象不能继续为自己所有，所以生成的对象会立即释放。&lt;br&gt;4&amp;gt;&lt;/strong&gt;autorelease修饰符。&lt;br&gt;在ARC有效时，用@autorelease块代替NSAutoreleasePool类，用附有__autorelease修饰符的变量代替autorelease方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能使用retain/release/retainCount/autorelease&lt;/li&gt;
&lt;li&gt;不能使用NSAllocateObject/NSDeallocateObject&lt;/li&gt;
&lt;li&gt;需遵循内存管理的方法命名规则&lt;/li&gt;
&lt;li&gt;不要显示调用dealloc(可以重写dealloc，但是不能调用[super dealloc])&lt;/li&gt;
&lt;li&gt;使用@autoreleasepool块代替NSAutoreleasePool&lt;/li&gt;
&lt;li&gt;不能使用区域（NSZone）&lt;/li&gt;
&lt;li&gt;对象型变量不能作为C语言结构体(struct/union)的成员(可强制转换为void *或者是添加&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符)&lt;/li&gt;
&lt;li&gt;显示转换id和“void &lt;em&gt;”（通过__bridge可以id和void &lt;/em&gt;相互转换，&lt;strong&gt;bridge&lt;/strong&gt;retain可使要转换赋值的变量也持有所赋值的对象相当于retain，&lt;strong&gt;bridge&lt;/strong&gt;transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放相当于release）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Block&quot;&gt;&lt;a href=&quot;#Block&quot; class=&quot;headerlink&quot; title=&quot;Block&quot;&gt;&lt;/a&gt;Block&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://peilinghui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常用算法</title>
    <link href="http://peilinghui.com/2016/03/28/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://peilinghui.com/2016/03/28/常用算法/</id>
    <published>2016-03-28T14:31:18.000Z</published>
    <updated>2016-04-25T06:40:15.000Z</updated>
    
    <content type="html">&lt;p&gt;常用的算法题总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;h3 id=&quot;排序题与sort函数的应用&quot;&gt;&lt;a href=&quot;#排序题与sort函数的应用&quot; class=&quot;headerlink&quot; title=&quot;排序题与sort函数的应用&quot;&gt;&lt;/a&gt;排序题与sort函数的应用&lt;/h3&gt;&lt;p&gt;用C++中的sort来实现排序，定义结构体struct存放学生信息；cmp函数的编写，提供cmp函数实现的排序规则；排名的实现：主要是分数相同的占用同一个排位。&lt;/p&gt;
&lt;h4 id=&quot;A1025-PAT排序&quot;&gt;&lt;a href=&quot;#A1025-PAT排序&quot; class=&quot;headerlink&quot; title=&quot;A1025.PAT排序&quot;&gt;&lt;/a&gt;A1025.PAT排序&lt;/h4&gt;&lt;p&gt;题意：n个考场，每个考场有若干数量的考生，给出考生的准考证号和成绩然后按顺序输出所以考生的准考证号，排名、考场号、考场内排名。&lt;br&gt;Sample Input:&lt;br&gt;2&lt;br&gt;5&lt;br&gt;1234567890001 95&lt;br&gt;1234567890005 100&lt;br&gt;1234567890003 95&lt;br&gt;1234567890002 77&lt;br&gt;1234567890004 85&lt;br&gt;4&lt;br&gt;1234567890013 65&lt;br&gt;1234567890011 25&lt;br&gt;1234567890014 100&lt;br&gt;1234567890012 85&lt;/p&gt;
&lt;p&gt;Sample Output:&lt;br&gt;9&lt;br&gt;1234567890005 1 1 1&lt;br&gt;1234567890014 1 2 1&lt;br&gt;1234567890001 3 1 2&lt;br&gt;1234567890003 3 1 2&lt;br&gt;1234567890004 5 1 4&lt;br&gt;1234567890012 5 2 2&lt;br&gt;1234567890002 7 1 5&lt;br&gt;1234567890013 8 2 3&lt;br&gt;1234567890011 9 2 4&lt;br&gt;思路：1.按考场读入各个考生的信息，对当前考场所有考生进行排序，将排名写入结构体中。2.对所有考生进行排序。3.一边计算总排名，一边输出考生信息。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; student&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; id[&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//准考证号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; grade;&lt;span class=&quot;comment&quot;&gt;//分数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location;&lt;span class=&quot;comment&quot;&gt;//考场号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location_rank;&lt;span class=&quot;comment&quot;&gt;//考场内排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rank;&lt;span class=&quot;comment&quot;&gt;//排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;stu[&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(student a,student b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a.grade != b.grade)  &lt;span class=&quot;comment&quot;&gt;//分数从高到低排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.grade &amp;gt;b.grade;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;//分数相同按准考证号从小到大排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(a.id,b.id) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,k,m=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//num为总考生数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;span class=&quot;comment&quot;&gt;//考场数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;k);&lt;span class=&quot;comment&quot;&gt;//考场内人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;k;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d&quot;&lt;/span&gt;,stu[m].id,&amp;amp;stu[m].grade);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[m].location = i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            m++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(stu+m-k,stu+m,cmp);&lt;span class=&quot;comment&quot;&gt;//将该考场的考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stu[m-k].location_rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//该考场的第一名学生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=m-k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;m;j++)&lt;span class=&quot;comment&quot;&gt;//对该考生剩余的考生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[j].grade == stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;span class=&quot;comment&quot;&gt;//分数相同排名也相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].location_rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//分数不同，排名为该考生前的人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-(m-k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(stu,stu+m,cmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stu[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将所有考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[i].grade == stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d %d %d\n&quot;&lt;/span&gt;,stu[i].id,stu[i].rank,stu[i].location,stu[i].location_rank);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;应用：&lt;ul&gt;
&lt;li&gt;对数据的某种性质进行统计&lt;/li&gt;
&lt;li&gt;使用hash函数H(key)=value将一个元素映射为一个整数，其中哈希函数的选取需要利用元素分布的特点使得值value比较唯一。&lt;br&gt;将较大数据范围的元素（数据个数不多）映射到较小的数据范围内，或者是吧非整数类型的元素映射为整数类型，使得增删改查变得高效。O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用hash进行统计&lt;blockquote&gt;
&lt;p&gt;题目：给出N个正整数，再给出M个正整数，问这M个正整数中的每个数分别是否在N个正整数中出现过。(M,N&amp;lt;=10^5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：遍历所有N个数，看是否有一个数与x相等，时间复杂度O(MN)太大。&lt;/p&gt;
&lt;p&gt;用hash：开一个bool型数组hashtable[N+1],其中hashtable[x]==true表示正整数x在N个正整数中出现过。时间复杂度O(M+N)&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; hashTable[maxn]=&amp;#123;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,m,x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hashTable[x]=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//数字x出现过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;m; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hashTable[x]==&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;YES\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;NO\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;哈希法的应用：对数据的某种性质进行统计。对图进行DFS遍历时就需要设置bool型数组VIS[maxn]来记录结点是否已经被访问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用哈希进行区间映射&lt;br&gt;使用hash函数H(key)=value将一个元素映射为一个整数。&lt;br&gt;一个例子：如何将一个二维整点P坐标映射为一个整数，是整点P可以由该整数唯一的代表。P(x,y)x&amp;gt;=0,y&amp;lt;=range,可以设计hash函数H(p)=x*range+y,用H(p)来唯一的代表坐标。&lt;br&gt;一个例子：字符串hash是将一个字符串S映射为一个整数，使该整数可以唯一的代表字符串S。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h3&gt;&lt;p&gt;分治：将原问题划分成k个规模较小而结构与原问题相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。&lt;br&gt;步骤：  复杂度O（nlogn）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 分解  
- 解决
- 合并  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决的问题必须满足最优子结构.&lt;br&gt;递归来实现分治思想，（1）递归边界（2）递归式&lt;br&gt;例子1：使用递归求解n的阶乘&lt;/p&gt;
&lt;p&gt;例子2：求斐波那契数列的第N项&lt;/p&gt;
&lt;h3 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h3&gt;&lt;h4 id=&quot;月饼-PATB&quot;&gt;&lt;a href=&quot;#月饼-PATB&quot; class=&quot;headerlink&quot; title=&quot;月饼 (PATB)&quot;&gt;&lt;/a&gt;月饼 (PATB)&lt;/h4&gt;&lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;br&gt;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。&lt;br&gt;输入样例：&lt;br&gt;3 20&lt;br&gt;18 15 10&lt;br&gt;75 72 45&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;94.50&lt;br&gt;思路：此为贪心算法。如何获得最大收益，先根据库存量和总售价算出每种月饼的单价，然后从单价高的开始枚举，全部卖出足够需求量，则提供需求量就够了；如果不够需求量，则收益值增加需求量×单价，需求量-这种库存，再看单价第二高的月饼；&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mooncake&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; store;&lt;span class=&quot;comment&quot;&gt;//库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sell;&lt;span class=&quot;comment&quot;&gt;//总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; price;&lt;span class=&quot;comment&quot;&gt;//单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;cake[&lt;span class=&quot;number&quot;&gt;1010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mooncake a,mooncake b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//按单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.price&amp;gt;b.price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;span class=&quot;comment&quot;&gt;//月饼种类数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; D;&lt;span class=&quot;comment&quot;&gt;//需求量同上用浮点数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%lf&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;D);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//先输入每种月饼的库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].store);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//再输入每种月饼的总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].sell);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cake[i].price = cake[i].sell/cake[i].store;&lt;span class=&quot;comment&quot;&gt;//计算单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(cake, cake+n, cmp);&lt;span class=&quot;comment&quot;&gt;//单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; ans=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//收益&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cake[i].store&amp;lt;=D) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量小于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            D-=cake[i].store;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].sell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量大于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].price*D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;组个最小数-PATB&quot;&gt;&lt;a href=&quot;#组个最小数-PATB&quot; class=&quot;headerlink&quot; title=&quot;组个最小数 (PATB)&quot;&gt;&lt;/a&gt;组个最小数 (PATB)&lt;/h4&gt;&lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。&lt;/p&gt;
&lt;p&gt;现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，&lt;strong&gt;顺序表示我们拥有数字0、数字1、……数字9的个数&lt;/strong&gt;。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;在一行中输出能够组成的最小的数。&lt;br&gt;输入样例：&lt;br&gt;2 2 0 0 0 3 0 0 1 0&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;10015558&lt;br&gt;思路：此为贪心算法。就是从最高位开始输出，先从1到9中选择个数不为0的最小数输出，然后从0到9输出数字，每个数字输出次数为剩余个数。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//记录数字0-9的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;count[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从1-9中选择Count不为0的最小数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count[i]&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            count[i]--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从0-9输出对应个数的数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;count[i]; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：贪心算法用来解决最优化问题，希望由局部最优策略来推得全局最优结果，贪心算法适用的问题一定满足最优子结构性质。（组成原问题最优解的子问题的解也是最优的）&lt;/p&gt;
&lt;h3 id=&quot;二分&quot;&gt;&lt;a href=&quot;#二分&quot; class=&quot;headerlink&quot; title=&quot;二分&quot;&gt;&lt;/a&gt;二分&lt;/h3&gt;&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;在有序序列中。时间复杂度O(logn)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A[mid]==x,查找成功，退出查询。
- A[mid]&amp;gt;x,说明x一定在中间位置的左边，在[left,mid-1]继续查找
- A[mid]&amp;lt;x，说明x一定在中间位置的右边，在[mid+1,right]继续查找
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归：  &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = n,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (left&amp;lt;=right) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]==x) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]&amp;gt;x)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d\n&quot;&lt;/span&gt;,binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;),binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际更多的是使用非递归。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;序列中哟重复数字，求序列中第一个x的位置。&lt;/li&gt;
&lt;li&gt;序列中第一个大于x的数的位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;a href=&quot;#扩展（求根号2的近似值）&quot; class=&quot;headerlink&quot; title=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;/a&gt;扩展（求根号2的近似值）&lt;/h4&gt;&lt;p&gt;F(x)=x*x；比较F(x)与2 的大小。&lt;br&gt;若F(x)&amp;gt;2,则令right=mid;&lt;br&gt;若F(x)&lt;2,则令left=mid; 代码：=&quot;&quot; &lt;figure=&quot;&quot; class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; eps=&lt;span class=&quot;number&quot;&gt;1e-5&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//精度为10的-5次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x*x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calSql&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; left =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (right - left &amp;gt; eps) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left + right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f(mid)&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/2,则令left=mid;&gt;&lt;/p&gt;
&lt;h3 id=&quot;two-pointers&quot;&gt;&lt;a href=&quot;#two-pointers&quot; class=&quot;headerlink&quot; title=&quot;two pointers&quot;&gt;&lt;/a&gt;two pointers&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目：给定一个&lt;strong&gt;递增&lt;/strong&gt;的正整数序列和一个正整数M,求序列中的两个不同位置的数a和b,使他们的和恰好为M，输出所有满足条件的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：令下标i的初值为0，下标j的初值为n-1，令i，j分别指向序列的第一个元素和最后一个元素，接下来根据a[i]+a[j]与M的大小来进行下面三种选择，i向右移动，j向左移动，直到i&amp;gt;=j成立。&lt;br&gt;1&amp;gt;如果a[i]+a[j]==M，令i=i+1，j=j-1;&lt;br&gt;2&amp;gt;如果a[i]+a[j]&amp;gt;M,j=j-1;&lt;br&gt;3&amp;gt;如果a[i]+a[j]&amp;lt;M,i=i+1; &lt;/p&gt;
&lt;p&gt;代码：时间复杂度O(n)&lt;br&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]==M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;,i,j)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]&amp;lt;M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目：假设有两个递增序列A和B，要求将它们合并为一个递增序列C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：两个下标i和j，初值均为0，表示分别指向序列A的第一个元素和序列B的第一个元素，然后根据A[i]和B[j]的大小来决定哪一个放入序列C。&lt;br&gt;1&amp;gt;A[i]&lt;b[j],a[i]加入到序列c，i加1. 2=&quot;&quot;&gt;A[i]&amp;gt;B[j],B[i]加入到序列C，j加1.&lt;br&gt;3&amp;gt;A[i]==B[j],任选一个加入到序列C，下标加1.&lt;/b[j],a[i]加入到序列c，i加1.&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;br&gt;&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; merge(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; B[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;m) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=B[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//序列A或B的剩余元素加入序列C&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;m) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回C的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;例如：归并排序和快速排序&lt;/p&gt;
&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;一种用来解决最优化问题的思想。动态规划将一个复杂的问题分解成若干个简单的子问题，通过综合子问题的求解结果来得到原问题的解。&lt;br&gt;本质:通过记录曾经计算过的内容，来避免重复计算。&lt;br&gt;1&amp;gt;递归&lt;br&gt;斐波那契数列&lt;/p&gt;
&lt;p&gt;2&amp;gt;递推&lt;br&gt;数塔DP问题：将一些数字排成数塔形状，其中第一层有一个数字，第二层有两个数字。。。。。第N层有N个数字，形状要从第一层走到第N层，每次只能走向下一层连接的两个数字中的一个，问最后将路径上所以数字相加后得到的和最大是多少？&lt;/p&gt;
&lt;h4 id=&quot;最大练习子序列和&quot;&gt;&lt;a href=&quot;#最大练习子序列和&quot; class=&quot;headerlink&quot; title=&quot;最大练习子序列和&quot;&gt;&lt;/a&gt;最大练习子序列和&lt;/h4&gt;&lt;p&gt;题目：输入一个数字序列a1,a2,求i,j（1&amp;lt;=i&amp;lt;=j&amp;lt;=n）,使得ai+…….aj最大，输出最大和。&lt;/p&gt;
&lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h4&gt;&lt;p&gt;题目：有N件物品，每件物品的重量为W[i],价值为C[i],现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的价值最大，其中每种物品都只有一件。&lt;/p&gt;
&lt;h4 id=&quot;最长不下降子序列&quot;&gt;&lt;a href=&quot;#最长不下降子序列&quot; class=&quot;headerlink&quot; title=&quot;最长不下降子序列&quot;&gt;&lt;/a&gt;最长不下降子序列&lt;/h4&gt;&lt;h4 id=&quot;最长公共子序列（LCS）&quot;&gt;&lt;a href=&quot;#最长公共子序列（LCS）&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列（LCS）&quot;&gt;&lt;/a&gt;最长公共子序列（LCS）&lt;/h4&gt;&lt;p&gt;题目：给定两个字符串A和B，求一个字符串，使得这个字符串是A和B的最长公共部分&lt;/p&gt;
&lt;h4 id=&quot;最长回文字串&quot;&gt;&lt;a href=&quot;#最长回文字串&quot; class=&quot;headerlink&quot; title=&quot;最长回文字串&quot;&gt;&lt;/a&gt;最长回文字串&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常用的算法题总结一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="http://peilinghui.com/2016/03/27/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2016/03/27/iOS面试题/</id>
    <published>2016-03-27T06:37:29.000Z</published>
    <updated>2016-04-19T05:09:12.000Z</updated>
    
    <content type="html">&lt;p&gt;总结一下一些面试题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一组正整数数字，如何找出两个数加为100的组合；&lt;br&gt;（首先要排序）然后two pointers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;http和https的区别；抓包的时候有什么区别；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头     - HTTP 是不安全的，而 HTTPS 是安全的 &lt;/li&gt;
&lt;li&gt;HTTP 标准端口是80 ，而 HTTPS 的标准端口是443&lt;/li&gt;
&lt;li&gt;在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层 &lt;/li&gt;
&lt;li&gt;HTTP 无法加密，而HTTPS 对传输的数据进行加密 &lt;/li&gt;
&lt;li&gt;HTTP无需证书，而HTTPS需要CA机构wosign的颁发的SSL证书 &lt;/li&gt;
&lt;li&gt;HTTP无安全锁，HTTPS有安全锁&lt;/li&gt;
&lt;li&gt;HTTP不能防钓鱼网站，HTTPS可以预防钓鱼网站&lt;/li&gt;
&lt;li&gt;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,要比http协议安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;get和post的区别，其他还有哪些请求方式；&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AF%94%E8%BE%83get%E5%92%8Cpost.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%85%B6%E4%BB%96%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统中的进程的存储结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图文混合的新闻中，如何获取图片的位置；&lt;br&gt;1&amp;gt;纯文字排版文字排版开发组件：CoreText。CoreText库中提供了很多的工具来对文本进行操作，例如CTFont、CTLine、CTFrame等。利用这些工具可以对文字字体每一行每一段落进行操作。&lt;br&gt;2&amp;gt;UIwebview去实现的,内容拼接的好处就是数据显示比较同步&lt;br&gt;过网络请求获得相关的信息,再通过手机端进行拼HTML,然后在WebView进行展示，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Tableview的优化，如果卡顿如何处理；&lt;ul&gt;
&lt;li&gt;复用单元格&lt;/li&gt;
&lt;li&gt;使用不透明的视图，单元格中尽量少使用动画&lt;/li&gt;
&lt;li&gt;图片加载使用异步加载，并且设置图片加载的并发数&lt;/li&gt;
&lt;li&gt;滑动时不加载图片，停止滑动开始加载&lt;/li&gt;
&lt;li&gt;文字图片可以直接drawInRect绘制&lt;/li&gt;
&lt;li&gt;如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths&lt;/li&gt;
&lt;li&gt;如果cell是动态行高，计算出高度后缓存&lt;/li&gt;
&lt;li&gt;cell高度固定的话直接用cell.rowHeight设置高度&lt;br&gt;&lt;a href=&quot;http://www.mamicode.com/info-detail-1125512.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mamicode.com/info-detail-1125512.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/36b6537250ca&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/36b6537250ca&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;autolayout中的优先级；&lt;br&gt;&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&lt;/a&gt;&lt;br&gt;设置Constraint的过程其实就是做算术题的过程，这里提醒大家， xib中有Suggest Constraint的功能，但是大家不要用，特别是在学习Autolayout阶段，Suggest Constraint自动补全的Constraint一般不能直接用，除非你view很少。&lt;br&gt;如果设置Constraint来确定一个view的frame呢，你可以里面想到:  1&amp;gt;frame法,像定义frame一样定义约束，就是设置view.left view.top view.width view.height. 但是实际中很少这样用。&lt;br&gt;2&amp;gt;edge法， 设置 view.left view.top view.bottom view.right。&lt;br&gt;3&amp;gt;居中法， 设置 centerX centerY width height等等方法，然而事实使用中你可能不是只有一个view，有可能有很多的view，相互直接会有很多的约束，约束一多就会容易发生逻辑冲突，这个时候就会发现Constraint优先级的作用了。&lt;br&gt;Constraint还有个属性叫priority， 即优先级，一般是0 ~ 1000之间的整数。 1000代表是必需的， 0则不会生效。理解和使用好优先级是熟练使用Autolayout所必备的。&lt;/li&gt;
&lt;li&gt;三个View并排放置，左右间距固定且相等，两两之间距离相等，如何使用Autolayout实现；&lt;br&gt;&lt;a href=&quot;https://lvwenhan.com/ios/431.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://lvwenhan.com/ios/431.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;View里面放置ScrollView，ScrollView里面再放置View，如何用Autolayout实现；&lt;br&gt;&lt;a href=&quot;http://small.qiang.blog.163.com/blog/static/978493072015292522113/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://small.qiang.blog.163.com/blog/static/978493072015292522113/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件结构是用哪种数据结构实现的，树还是图，&lt;br&gt;答案是B+树；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面之间的数据传递方式；&lt;br&gt;使用SharedApplication,定义一个变量来传递.&lt;br&gt;使用文件，或者NSUserdefault来传递&lt;br&gt;通过一个单例的class来传递&lt;br&gt;通过Delegate来传递。&lt;br&gt;1）采用代理模式 子viewcontroller设计 代理协议，定义协议接口，父viewcontroller 实现协议接口，实现子viewcontroller 退出时将相关数据更新到父视图。&lt;br&gt;2）采用ios的消息机制 父viewcontroller注册消息 子viewcontroller 发送消息，触发父viewcontroller的消息处理。&lt;br&gt;3）采用database做为数据中间的存储媒介，子viewcontroller将状态数据存入DB，父viewcontroller从DB获取数据更新view。&lt;br&gt;4）采用ios的NSDefault 存储&lt;br&gt;5）通过AppDelegate 中定义全局变量实现中间数据的存储。&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/lianbaixue/article/details/8670533&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lianbaixue/article/details/8670533&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面的跳转的两种方式；&lt;br&gt;一种直接跳,一种通过导航.&lt;br&gt;第一种 直接跳转 思路大致就是new一个目的页面，然后设置下页面跳转动画 中间还可以做点目的页面的数据初始化:&lt;br&gt;第二种:利用UINavigationController，调用pushViewController，进行跳转；这种采用压栈和出栈的方式，进行Controller的管理。调用popViewControllerAnimated方法可以返回。&lt;br&gt;&lt;a href=&quot;http://blog.it985.com/13090.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.it985.com/13090.html&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;属性修饰符retain、assign、copy等等之间的区别；&lt;/li&gt;
&lt;li&gt;讲讲block；&lt;/li&gt;
&lt;li&gt;详解runtime，OC为什么是动态的语言，内部机制；&lt;/li&gt;
&lt;li&gt;Tableview要实现哪两个协议；&lt;/li&gt;
&lt;li&gt;category和extension的区别；&lt;br&gt;Category；&lt;ul&gt;
&lt;li&gt;用于给class及其subclass添加新的方法&lt;/li&gt;
&lt;li&gt;有自己单独的 .h 和 .m 文件&lt;/li&gt;
&lt;li&gt;用于添加新方法，而不能添加新属性（property）&lt;br&gt;Extension&lt;/li&gt;
&lt;li&gt;Extension常被称为是匿名的Category&lt;/li&gt;
&lt;li&gt;用于给类添加新方法，但只作用于原始类，不作用于subclass&lt;/li&gt;
&lt;li&gt;只能对有implementation源代码的类写Extension，对于没有implementation源代码的类，比如framework class，是不可以的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extension可以给原始类添加新方法，以及新属性&lt;/strong&gt;&lt;br&gt;category 与extension不同在于后者可以添加属性，后者添加的方法也必须是要实现的。extension是私有的category。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多线程有哪几种实现方式，GCD的具体使用；&lt;/li&gt;
&lt;li&gt;GCD中的数据不安全是怎么处理的；&lt;/li&gt;
&lt;li&gt;dispatch_main,同步和异步如何使用;&lt;/li&gt;
&lt;li&gt;讲讲最近你的项目；&lt;/li&gt;
&lt;li&gt;KVO如何实现，内部机制；&lt;/li&gt;
&lt;li&gt;Core Animation /Core Graphics&lt;br&gt;CoreGraphics是底层绘制框架，我们实际会用到的也就是CG开头的一些底层绘制函数和变量，这是一个纯C语言框架。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;QuartzCore也就是你说的包含了CoreAnimation的框架，是iOS系统的基本渲染框架，是一个OC语言框架，是一套基于CoreGraphics的OC语言封装，封装出了基本渲染类CALayer。&lt;/p&gt;
&lt;p&gt;**一面电面：15min；&lt;br&gt;1.算法：数组中（无序的正整数数）如何找到第n大的数；&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_54f82cc201013tke.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_54f82cc201013tke.html&lt;/a&gt;&lt;br&gt;2.算法：数组中1—100的无序数字如何找到第n大的数；（遍历计数）&lt;br&gt;思路：&lt;br&gt;1&amp;gt;假设数组中有n个元素，a1~an，而我们要求第k大的数字，就相当于求排序后的第m = n - k + 1个数字。&lt;br&gt;2&amp;gt;假设一次快速排序之后，如果枢纽的是第x个（1~n）。&lt;br&gt;3&amp;gt;如果x = m，则这个枢纽ax就是我们要求的第k大的数字，结束；如果x &amp;lt; m，则对a0 ~ ax-1进行一次快速排序，重复第2）步；如果x &amp;gt; m，则对ax+1 ~ an 进行一次快速排序，重复第2）步。&lt;br&gt; 快速选择的代码如下：&lt;br&gt; &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//a[] - 要排序的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//b - 要排序的子区间的开始索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//e - 要排序的子区间的结束索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//k - 求出排序后第k个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickselect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; e, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = b ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = e + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[++i] &amp;lt; x &amp;amp;&amp;amp; i &amp;lt; j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[--j] &amp;gt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i &amp;gt;= j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      swap(a[i], a[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[b] = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[j] = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; == j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quickselect(a, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, e, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quickselect(a, b, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：快速选择可以用于这类面试题：&lt;br&gt;       1）求出无序数组中第k大的数&lt;br&gt;       2）求出无序数组中最大/小的k个数&lt;br&gt;3.讲一讲OC中的运行时，动态性；&lt;br&gt;4.OC中是如何找到一个方法的，通过函数名key的方式找到的，每一个函数名肯定是不一样的；&lt;br&gt;5.OC中有没有函数重载（没有）；Swift中有没有函数重载（有的）；&lt;br&gt;6.内存管理，MRC，ARC的区别；&lt;br&gt;7.releasepool被释放了，里面的对象都会被释放吗？过程是怎样的。&lt;/p&gt;
&lt;p&gt;二面：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C++和OC 的内存管理比较，以及实现方式；&lt;br&gt;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。&lt;br&gt;管理方式：&lt;br&gt;对于栈来讲，是由编译器自动管理，无需我们手工控制；&lt;br&gt;对于堆来说，释放工作由程序员控制，容易产生memory leak。&lt;br&gt;碎片问题：&lt;br&gt;对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。&lt;br&gt;对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。&lt;br&gt;生长方向：&lt;br&gt;对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；&lt;br&gt;对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。&lt;br&gt;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。  它们都可用于申请动态内存和释放内存。&lt;br&gt;Objective-C内存管理：&lt;br&gt;引用计数是实例对象的内存回收唯一参考。&lt;br&gt;引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7583358801014usx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7583358801014usx.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个数组，一个有100万的数据，另一个有1亿的数据，如何找出相同的数据，时间复杂度是什么？&lt;br&gt;hash统计：先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数的HashTable，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；&lt;br&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/03/22/2413055.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/v-July-v/archive/2012/03/22/2413055.html&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OC的MRC，ARC；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C++和OC有哪些区别；&lt;br&gt;1&amp;gt;c++中的对象可以是动态创建的（使用new来创建，返回对象的地址），也可以是直接的创建对象，在c++中就有了 值传递 与指针传递的区别。。&lt;br&gt;在oc中只能动态的创建内存，这也是oc的动态特性之一。&lt;br&gt;2&amp;gt;在C++中，下面三种对象需要调用拷贝构造函数（有时也称“复制构造函数”）：&lt;br&gt;1) 一个对象作为函数参数，以值传递的方式传入函数体；&lt;br&gt;2) 一个对象作为函数返回值，以值传递的方式从函数返回；&lt;br&gt;3) 一个对象用于给另外一个对象进行初始化（常称为复制初始化).&lt;br&gt;务必要注意区分这3种情况与OC种的区别，在OC中是根本不存在这3种情况的。因为oc中只能创建对象的指针，是不能直接创建对象的。&lt;br&gt;c++中的默认拷贝构造函数就类似oc中的浅拷贝，也就是指针拷贝。&lt;br&gt;3&amp;gt;oc中虽然不能直接的创建对象，但是oc中函数调用，以及返回的时候，传入的参数一样会拷贝一份出来，只不过这个拷贝是一个指针，而不是拷贝的一个对象。返回的时候一样是拷贝的一个副本，这个副本是指针。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是因为c++中有直接创建对象与创建对象指针的区别。所以才产生了值传递，与地址传递的区别。它可以传递一个对象，也可以传递这个对象的地址。如果传递的是对象本身，就是值传递。如果传递的是对象的指针，就是指针传递。其实指针传递也是传递的值，传递的是变量的地址值。这个地址值是一个对象的首地址。&lt;/p&gt;
&lt;p&gt;但是在oc与java中，只能传递对象的地址。所以就不用区分上面的情况了。&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/itianyi/article/details/9046231&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/itianyi/article/details/9046231&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7583358801014usx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7583358801014usx.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Swift与OC有哪些区别；&lt;br&gt;Swift没有地址/指针的概念&lt;br&gt;泛型&lt;br&gt;类型严谨 对比oc的动态绑定&lt;br&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/dsxniubility/p/4294658.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/dsxniubility/p/4294658.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/34718b0fc910&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/34718b0fc910&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网易：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介绍一下GCD&lt;/li&gt;
&lt;li&gt;如果没有GCD，你怎样实现多线程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSthread的缺点是什么？使用NSthread怎么实现数据同步？&lt;br&gt;缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销&lt;br&gt;两种锁，一种NSCondition ，一种是：NSLock。我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍protocol？&lt;br&gt;protocol（协议）类似java中的接口，定义了一些类需要公用到的方法，只要遵守这个协议，就可以拥有这些方法并可以去实现它们，这样可以避免许多重复的代码。@required代表协议里的方法必须实现，否则编译器会警告，不写默认是@required，@optional代表协议里的方法是选择实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;protocol，category和继承的区别？&lt;br&gt;protocol的作用是为一些列类仅仅提供一套公用的接口，而完全没 有办法也没可能去提供具体的一些实现情况；&lt;br&gt;category则是为一个已有的类提供一些额外的接口和具体实现；&lt;br&gt;而继承则基于两者之间，既可以想 protocol一样提供只是纯粹提供接口，也可以像Category一样提供完整的实现，而且继承还能对类以后的功能进行改写，所以说继承的力量是最强 大的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;block和delegate你更倾向于用哪个？为什么？&lt;br&gt;Block.&lt;br&gt;block使代码更紧凑,便于阅读,delegate可以设置必选和可选的方法实现.&lt;br&gt;block可以访存局部变量. 不需要像以前的回调一样，把在操作后所有需要用到的数据封装成特定的数据结构, 你完全可以直接访问局部变量.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UIalertviewcontroller的内部实现？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何理解MVC设计模式&lt;br&gt;MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller： &lt;/p&gt;
&lt;p&gt; Model负责存储、定义、操作数据；&lt;br&gt; View用来展示给用户，和用户进行操作交互；&lt;br&gt; Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何理解MVVM设计模式&lt;br&gt;M:模型 V:视图+控制器 VM:视图模型&lt;br&gt;模型(M):保存视图数据。&lt;br&gt;视图+控制器(V):展示内容 + 如何展示&lt;br&gt;视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。&lt;br&gt;MVVM是View和ViewModel相关联，这样做到真正的数据与逻辑跟界面相分离，我们所要关心的地方都在ViewModel里面，控制器和View里面就只需要做很少的事情，&lt;br&gt; ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。&lt;br&gt; View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。&lt;br&gt;&lt;a href=&quot;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;自定义控件怎么做的？&lt;/li&gt;
&lt;li&gt;加密算法？&lt;br&gt;常见的加解密方式(rsa,aes,md5）&lt;br&gt;RSA：基于公钥和私钥的非对程加密算法。适用范围广。&lt;br&gt;AES：是一种对程加密的流行方式。加密涉及矩阵运算。&lt;br&gt;MD5:将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，&lt;/li&gt;
&lt;li&gt;ios应用的调试技巧&lt;br&gt;1&amp;gt;如遇到crash，分析崩溃日志（symbolicatedrash工具的适用）保留崩溃版本的.dSYM文件&lt;br&gt;2&amp;gt;在 XCode 中进入断点管理窗口；然后点击右下方的 +，增加新的 Exception Breakpoint。&lt;br&gt;3&amp;gt;如遇到EXC_BAD_ACCESS，打开Scheme选项选择EditScheme。然后按图勾上Enable Zombie Objects和Malloc Stack那两项。&lt;br&gt;4&amp;gt;有效的日志管理。NSLog和加入一些开源的日志管理框架。&lt;br&gt;5&amp;gt;程序断点debug模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网易二面：&lt;br&gt;学习oc对你有什么提升？&lt;br&gt;nsdictionary如何实现深拷贝？&lt;br&gt;如果有多层，怎样实现？&lt;br&gt;autolayout？&lt;br&gt;主线程可以执行下载任务吗？为什么？&lt;br&gt;主线程使用数据库，想在其他线程也访问数据库，怎么实现？&lt;br&gt;有没有写过category？里面能不能加属性？为什么？&lt;br&gt;谈一下你对mvc模式的理解？&lt;br&gt;ARC和MRC ：&lt;br&gt;ARC是依靠什么实现的？&lt;br&gt;&lt;a href=&quot;https://onevcat.com/2012/06/arc-hand-by-hand/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://onevcat.com/2012/06/arc-hand-by-hand/&lt;/a&gt;&lt;br&gt;release如何实现对象释放？autorelease如何实现？两者的区别与联系？release能做的事情autorelease都能做，那么release可不可以舍弃？为什么？&lt;br&gt;weak和assign的区别？&lt;br&gt;谈一下运行时？&lt;br&gt;kvo的底层实现？&lt;/p&gt;
&lt;p&gt;网易一面：&lt;br&gt;1.UIview中的俩个label的自适应代码。&lt;br&gt;2.项目：音乐播放器，后台实现除了有音乐播放器，还有什么？&lt;br&gt;3.我回答的是通知，通知你用过吗？本地通知和远程通知，有什么区别，远程通知是从哪里获取的。&lt;br&gt;4.音乐播放的数据库是怎么实现的。&lt;br&gt;5.怎么学习iOS的。&lt;br&gt;6.学过JS，JS学的怎么样？JS和OC实现热点会吗？&lt;/p&gt;
&lt;p&gt;网易其他面试题：&lt;br&gt;内存管理基础&lt;br&gt;多线程介绍&lt;br&gt;SDWebImage介绍&lt;br&gt;图片下载，缓存是同步还是异步&lt;br&gt;Objective的对象结构&lt;br&gt;ISA指针是指向什么&lt;br&gt;block在MRC下如何解决循环引用&lt;br&gt;NSCache的优点，使用字典可不可以，优缺点分析&lt;br&gt;JAVA和OC的区别，不同，在哪些上最明显&lt;br&gt;UItableView的优化，为什么这么优化&lt;br&gt;CEll如何计算&lt;br&gt;dealloc里做哪些操作&lt;br&gt;NOtification哪些使用场景，同步还是异步？主线程还是子线程&lt;br&gt;dealloc不remove通知会怎么样&lt;br&gt;KVO的实现原理&lt;br&gt;消息转发原理&lt;br&gt;何时用到串行队列&lt;/p&gt;
&lt;p&gt;越狱后APP的安全&lt;br&gt;动态更新&lt;br&gt;链式反应&lt;br&gt;UIbutton的多次点击&lt;br&gt;网易笔试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户点击某按钮时下载一张图片，当用户再次点击此按钮是下载时取消，为了保证尽量节省用户流量，请尽快取消真实的下载请求。&lt;br&gt;请描述解决此问题的方法和思路。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;实现多线程有哪些方式，各有什么优势？&lt;/li&gt;
&lt;li&gt;请使用category实现NSMutableDictionary的深度拷贝？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用Autolayout实现UIView包含两个子元素[UILabel不定字数]和[UILabel不定字数文字]：&lt;ul&gt;
&lt;li&gt;Label1和Label2横向排布，间距5pt.&lt;/li&gt;
&lt;li&gt;Label需要宽度自适应&lt;/li&gt;
&lt;li&gt;Label1和Label2纵向居中对齐&lt;/li&gt;
&lt;li&gt;两个Label文字不可重叠&lt;/li&gt;
&lt;li&gt;文字过长的时候，优先保证Label2显示完整。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：用autolayout的masonry框架.&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UILabel *label1 = [[UILabel alloc]init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 sizeToFit]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label1.backgroundColor = [UIColor grayColor]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UILabel *label2 = [[UILabel alloc]init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 sizeToFit]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label2.backgroundColor = [UIColor purpleColor]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:label1]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:label2]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label1.text = @&quot;UIlayout的约束&quot;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label2.text = @&quot;文字过长的时候，优先保证Label2&quot;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 mas_makeConstraints:^(MASConstraintMaker *make)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.centerY.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.left.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 setContentCompressionResistancePriority:UILayoutPriorityDefaultLow    forAxis:UILayoutConstraintAxisVertical]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 mas_makeConstraints:^(MASConstraintMaker *make)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.centerY.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.left.equalTo(label1.mas_right).offset(5)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.right.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 效果：&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UILabel%E6%95%88%E6%9E%9C.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其他公司面试题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIView和CALayer的区别？&lt;/li&gt;
&lt;li&gt;UIView继承自哪个父类？&lt;/li&gt;
&lt;li&gt;自动释放池底层是如何实现的？&lt;/li&gt;
&lt;li&gt;runtime 的运行机制？&lt;/li&gt;
&lt;li&gt;宏定义和const关键字的区别？&lt;/li&gt;
&lt;li&gt;GCD和NSOperation的区别？NSOperation并发有顺序吗？&lt;/li&gt;
&lt;li&gt;沙盒的目录，NSUserDefault是存在什么目录下的？哪种形式？&lt;/li&gt;
&lt;li&gt;Runloop的机制？&lt;/li&gt;
&lt;li&gt;SDWebImage的源码研究过吗？&lt;/li&gt;
&lt;li&gt;Git和SVN的区别？&lt;/li&gt;
&lt;li&gt;静态库和动态库的区别？&lt;/li&gt;
&lt;li&gt;H5,JS和网页，Native与iOS开发结合用过吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;腾讯面试题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何绘制一个三角形？&lt;br&gt;1.1 如何绘制大量三角形？&lt;br&gt;1.2 一定要重写drawRect吗？&lt;br&gt;1.3 如何刷新View界面？&lt;br&gt;1.4 Layer好在哪？&lt;/li&gt;
&lt;li&gt;assign和weak的区别&lt;/li&gt;
&lt;li&gt;线程和RunLoop的关系&lt;br&gt;3.1 一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）&lt;/li&gt;
&lt;li&gt;NSTimer有什么需注意的以及和RunLoop的关系？&lt;/li&gt;
&lt;li&gt;NSString copy 和 NSString mutableCopy 的区别&lt;/li&gt;
&lt;li&gt;线程加锁原理（信号量，临界区，自选锁）&lt;/li&gt;
&lt;li&gt;iOS7 - iOS9的区别&lt;/li&gt;
&lt;li&gt;GCD指向了野指针了怎么办&lt;/li&gt;
&lt;li&gt;用HTTP传数据，丢包严重怎么办&lt;/li&gt;
&lt;li&gt;iOS中广播的种类&lt;/li&gt;
&lt;li&gt;app slying&lt;/li&gt;
&lt;li&gt;runtime如何实现weak变量的自动置nil？&lt;/li&gt;
&lt;li&gt;AFNetworking的内部实现原理？&lt;/li&gt;
&lt;li&gt;block循环引用了如何解决？&lt;/li&gt;
&lt;li&gt;如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;/li&gt;
&lt;li&gt;UIKit的框架结构？&lt;br&gt;腾讯面试题：&lt;/li&gt;
&lt;li&gt;&lt;p&gt;app上架流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程和进程区别 及之间通信&lt;br&gt;&lt;a href=&quot;http://1108038.blog.51cto.com/1098038/420330&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://1108038.blog.51cto.com/1098038/420330&lt;/a&gt;&lt;br&gt;进程是表示资源分配的基本单位，又是调度运行的基本单位。&lt;br&gt;线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。&lt;br&gt;进程间通信—&amp;gt;管道(pipe)、信号(signal)、消息队列、共享内存、信号量、套接字；&lt;br&gt;线程间通信—&amp;gt;信号量、消息、事件event&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tableview cell 缓存机制&lt;br&gt;在UITableView内部有一个缓存池，初始化时使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)方法指定一个可重用标识，就可以将这个cell放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的cell然后修改cell内容即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tableview cell高度优化：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;深入理解runloop&lt;br&gt;&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/05/18/runloop/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主线程runloop(mainRunloop)主要执行事件：&lt;br&gt;负责创建Autoreleasepool和释放autoreleasepool,  周期大概是event loop(事件循环)；&lt;br&gt;事件响应—&amp;gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;手势识别—&amp;gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;界面更新—&amp;gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NSTimer事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PerformSelecter—&amp;gt;performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease 具体释放时机：&lt;br&gt;通常在下一次事件循环(event loop)时释放，如果是手动创建的自动释放池则在这个池的外层释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟内存：&lt;br&gt;当应用程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;红黑树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;QQ小红点动画的实现原理&lt;/li&gt;
&lt;li&gt;设计一个网络图片缓存器(SDWebImage实现原理必需要了解)&lt;/li&gt;
&lt;li&gt;PNG和JPG的区别&lt;/li&gt;
&lt;li&gt;如何压缩JPG&lt;/li&gt;
&lt;li&gt;TCP/IP协议&lt;br&gt;自己面试题：&lt;/li&gt;
&lt;li&gt;GCD有何缺点？&lt;/li&gt;
&lt;li&gt;CocosPods?&lt;/li&gt;
&lt;li&gt;项目重构的一些规范和命名规范？&lt;/li&gt;
&lt;li&gt;如何push到某个特定的controller？&lt;/li&gt;
&lt;li&gt;SDWebImage框架是如何实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;腾讯面试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看简历说一下你的项目经验，讲解一下你最拿手的项目？其中各个部分的功能是如何实现的？&lt;/li&gt;
&lt;li&gt;属性ARC下有什么？&lt;/li&gt;
&lt;li&gt;属性中weak和strong的区别？&lt;/li&gt;
&lt;li&gt;assign为何不能修饰对象？如果修饰了会怎么样？&lt;/li&gt;
&lt;li&gt;copy在哪里用？&lt;/li&gt;
&lt;li&gt;Block在栈中还是堆中？全局变量是在栈还是在堆中？成员变量呢？&lt;/li&gt;
&lt;li&gt;怎么定义一个类的属性？写代码。&lt;/li&gt;
&lt;li&gt;——#import与#include的区别？&lt;/li&gt;
&lt;li&gt;如果自己实现一个setter方法，该如何写代码？&lt;/li&gt;
&lt;li&gt;oc中有什么容器？&lt;/li&gt;
&lt;li&gt;写一个数组初始化的代码。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多面试总结题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/ab4e96bcf26a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/ab4e96bcf26a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/e453b28c3222#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e453b28c3222#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5d2163640e26#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/5d2163640e26#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/xieyupeng520/article/details/50832701&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xieyupeng520/article/details/50832701&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;招聘一个靠谱的 iOS：&lt;br&gt;题目：&lt;a href=&quot;http://blog.sunnyxx.com/2015/07/04/ios-interview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/07/04/ios-interview/&lt;/a&gt;&lt;br&gt;答案：&lt;a href=&quot;http://www.cocoachina.com/ios/20150803/12872.html（上）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150803/12872.html（上）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150825/13195.html（下）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150825/13195.html（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下一些面试题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://peilinghui.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://peilinghui.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>iOS小项目</title>
    <link href="http://peilinghui.com/2016/03/26/iOS%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>http://peilinghui.com/2016/03/26/iOS小项目/</id>
    <published>2016-03-26T12:44:02.000Z</published>
    <updated>2016-04-17T10:42:06.000Z</updated>
    
    <content type="html">&lt;p&gt;到了软院以后，选择了移动互联网和游戏开发方向，开设了iOS课程，在老师的引导下，开始自学了iOS。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;仿App第一步：&lt;/p&gt;
&lt;h1 id=&quot;简单的音乐播放器&quot;&gt;&lt;a href=&quot;#简单的音乐播放器&quot; class=&quot;headerlink&quot; title=&quot;简单的音乐播放器&quot;&gt;&lt;/a&gt;简单的音乐播放器&lt;/h1&gt;&lt;p&gt;1.搭建界面&lt;br&gt;①排版与歌曲列表显示&lt;br&gt;navigation controller&lt;br&gt;中间table，然后上面是Cell，&lt;br&gt;②在’播放工具条’显示第一首歌歌手图片、名称、歌手&lt;br&gt; •’播放工具条’的图片截取圆形，并添加边框&lt;br&gt;③暂停与继续按钮的判断&lt;br&gt;④播放当前歌曲、上一首、下一首歌曲&lt;br&gt; •通过代理通知控制器&lt;br&gt; •创建音乐工具类&lt;br&gt; •实现上一首、下一首的循环&lt;br&gt;⑤显示歌曲播放时间与总长度&lt;br&gt; •添加slider与两个label&lt;br&gt; •显示左边歌曲的总时间&lt;br&gt; •添加定时器，实现slider的自动拖动&lt;br&gt;⑥实现歌曲的’时间的拖动’改变’歌曲播放进度’&lt;br&gt;⑦播放完歌曲，自动进入下一首音乐&lt;br&gt;⑧歌手头像转动&lt;br&gt;⑨设置音乐后台播放&lt;br&gt; •要实现后台的音乐播放有三个步骤要设置&lt;br&gt; 1&amp;gt;在didFinishLaunching方法激活音频的会话类型即可，代码如下&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AVAudioSession *session = [AVAudioSession sharedInstance];&amp;#10;[session setCategory:AVAudioSessionCategoryPlayback error:nil];&amp;#10;[session setActive:YES error:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 2&amp;gt;在applicationDidEnterBackground方法开始后台任务，代码如下&lt;br&gt; &lt;code&gt;[application beginBackgroundTaskWithExpirationHandler:nil];&lt;/code&gt;&lt;br&gt; 3&amp;gt;在info.plist中添加’Required background modes’选向，然后再添加’App plays audio or streams audio/video using AirPlay’&lt;br&gt;⑩实现歌曲锁屏&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - 设置锁屏的音乐信息要使用MediaPlayer框架的MPNowPlayingInfoCenter类来实现，
 - 代码设置锁屏时的播放信息代码为[MPNowPlayingInfoCenter defaultCenter].nowPlayingInfo,nowPlayingInfo传入一个字典
- 在didFinishLaunching添加接收远程事件代码,&amp;quot;一定要添加，不然无效果&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  [application beginReceivingRemoteControlEvents];&lt;br&gt;⑪实现锁屏按钮远程事件&lt;br&gt; •在appdelegate中实现remoteControlReceivedWithEvent，来接收远程事件&lt;/p&gt;
&lt;p&gt;主要是有三部分：MVC&lt;br&gt;Model层实现的是存放歌曲名字，本地音乐文件名，歌手名字等。&lt;br&gt;View层实现的是MusicCell，显示cell的数据。&lt;br&gt;            PlayerToolBar，有分类category，设置了歌手图片，音乐名，歌手名，时间的拖动条，总时间，当前播放时间，定时器和是否拖拽。&lt;br&gt;           如果正在播放：更新进度条，更新时间，头像转动。设置当前播放的音乐，并显示数据，更改播放状态，更改拖拽状态。&lt;br&gt;controller层实现的是用第三方框架MJEXtension，实现了字典转模型，懒加载音乐数。tableview表格数据源，播放工具条的代理，播放器的代理。&lt;/p&gt;
&lt;h1 id=&quot;网易新闻客户端&quot;&gt;&lt;a href=&quot;#网易新闻客户端&quot; class=&quot;headerlink&quot; title=&quot;网易新闻客户端&quot;&gt;&lt;/a&gt;网易新闻客户端&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;简介&lt;br&gt;1&amp;gt;需求&lt;ul&gt;
&lt;li&gt;展示不同栏目的新闻列表&lt;/li&gt;
&lt;li&gt;点击新闻列表可以查看详细内容&lt;/li&gt;
&lt;li&gt;支持新闻分享&lt;/li&gt;
&lt;li&gt;可推送重要新闻&lt;br&gt;2&amp;gt;原型：类似网易新闻&lt;br&gt;3&amp;gt;功能：&lt;/li&gt;
&lt;li&gt;显示当天广告&lt;/li&gt;
&lt;li&gt;定制导航栏&lt;/li&gt;
&lt;li&gt;定制底部导航栏&lt;/li&gt;
&lt;li&gt;栏目切换效果&lt;/li&gt;
&lt;li&gt;列表显示效果&lt;/li&gt;
&lt;li&gt;详情页展示&lt;/li&gt;
&lt;li&gt;离线缓存&lt;/li&gt;
&lt;li&gt;微信分享&lt;/li&gt;
&lt;li&gt;消息推送&lt;br&gt;4&amp;gt;掌握  &lt;/li&gt;
&lt;li&gt;良好的习惯&lt;/li&gt;
&lt;li&gt;掌握MOVE模型&lt;/li&gt;
&lt;li&gt;掌握离线缓存策略&lt;/li&gt;
&lt;li&gt;掌握APNS机制&lt;/li&gt;
&lt;li&gt;掌握用户行为统计方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;框架&lt;br&gt;1&amp;gt;JSON解析&lt;br&gt;SBJSON第三方框架：&lt;a href=&quot;https://github.com/groopd/SBJSON-library&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/groopd/SBJSON-library&lt;/a&gt;&lt;br&gt;2&amp;gt;数据库操作&lt;br&gt;FMDB第三方框架：&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ccgus/fmdb&lt;/a&gt;&lt;br&gt;3&amp;gt;小米推送:&lt;br&gt;&lt;a href=&quot;http://dev.xiaomi.com/doc/p=6421/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.xiaomi.com/doc/p=6421/index.html&lt;/a&gt;&lt;br&gt;4&amp;gt;友盟/百度统计&lt;br&gt;&lt;a href=&quot;http://www.umeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.umeng.com/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://tongji.baidu.com/web/welcome/login&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tongji.baidu.com/web/welcome/login&lt;/a&gt;&lt;br&gt;5&amp;gt;天气&lt;br&gt;&lt;a href=&quot;http://apistore.baidu.com/apiworks/servicedetail/112.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://apistore.baidu.com/apiworks/servicedetail/112.html&lt;/a&gt;&lt;br&gt;6&amp;gt;网易的18个开源框架&lt;br&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150522/11884.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150522/11884.html&lt;/a&gt;&lt;br&gt;7&amp;gt;收集App素材：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/1b817affc305&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/1b817affc305&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工具&lt;br&gt;1&amp;gt;Charles(网络抓包工具)&lt;br&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles/&lt;/a&gt;&lt;br&gt;2&amp;gt;代码管理工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SVN和Git：SubVersion：开源版本控制系统，按文件存储。Git：开源分布式的版本控制，按元数据存储。&lt;/li&gt;
&lt;li&gt;GitHub和OSGit（代码托管和团队协作）&lt;a href=&quot;https://github.com(私有收费)和http://git.oschina.net/（完全免费1000个项目）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com(私有收费)和http://git.oschina.net/（完全免费1000个项目）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用Github:（需要翻墙）&lt;a href=&quot;http://peilinghui.com/2016/02/25/git%E5%AD%A6%E4%B9%A0/&quot;&gt;http://peilinghui.com/2016/02/25/git%E5%AD%A6%E4%B9%A0/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用OSGit：&lt;a href=&quot;http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://git.oschina.net/oschina/git-osc/wikis/%E5%B8%AE%E5%8A%A9&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;搭建系统框架&lt;br&gt;1&amp;gt;建立工程：名称，标识，版本&lt;br&gt;2&amp;gt;建立相应目录：Global，Controller(Page,Widget,Cell),Model,Network,DB,Utility,ThirdSDK,Define,Resource(Config,Image,Xib)&lt;br&gt;3&amp;gt;日志输出宏&lt;br&gt;4&amp;gt;设备类型宏&lt;br&gt;5&amp;gt;发布版本设置（AdHoc,AppStore,Debug,Enterprise,Release）&lt;br&gt;形成自己的框架  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置应用图标及启动&lt;br&gt;1&amp;gt;添加预编译头文件（.pch并设置路径）&lt;br&gt;2&amp;gt;整理相关目录&lt;br&gt;3&amp;gt;添加APP图标；加入网易APP图标，设置图片&lt;br&gt;4&amp;gt;点，渲染像素，物理像素，物理设备&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%AE%BE%E5%A4%87%E5%B0%BA%E5%AF%B8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;5&amp;gt;检查设备尺寸&lt;br&gt;6&amp;gt;添加启动图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MVC模型&lt;br&gt;Model-&amp;gt;View：模型改变的时候通知View。&lt;br&gt;View-&amp;gt;Model：向模型索要状态&lt;br&gt;View-&amp;gt;Controller: controller要求View做出相应的改变，View要求controller改变Model。&lt;br&gt;Controller-&amp;gt;Model：Controller调用Model行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MOVE模型：&lt;br&gt;Model，Operation（操作数：登录，注销，获取数据），View，Event（操作改变是发生的事件和通知）&lt;br&gt;1&amp;gt;Model层&lt;br&gt;BaseInfo（基类）&lt;br&gt;AdvertInfo（广告）&lt;br&gt;ColumnInfo（栏目）：标题，id，名称&lt;br&gt;NewsInfo（新闻列表）：图标，标题，摘要&lt;/p&gt;
&lt;p&gt;2&amp;gt;加入JSON库。把JSON库中不需要ARC的文件在Bulid Phase中设置成-fno-objc-arc&lt;br&gt;所需要的服务器主要是用本地的Apache服务器。&lt;br&gt;启动apache服务器&lt;br&gt;$ sudo apachectl start&lt;br&gt;$ sudo apachectl restart&lt;br&gt;停止apache服务器&lt;br&gt;$ sudo apachectl -k stop&lt;br&gt;模仿网易新闻，定义接口JSON文件，与实体相对应。用KVO把数据模型解析为实体。&lt;br&gt;像广告：有id，name，imageurl,linkurl&lt;br&gt;新闻：有id,name,desc,iconurl,contenturl&lt;br&gt;3&amp;gt;Model排序&lt;br&gt;4&amp;gt;Model比较&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;MOVE模型的Operation&lt;br&gt;操作：获取广告，获取栏目，获取新闻列表&lt;br&gt;在URL定义中。宏：正式版和测试版地址，接口。在Build Setting的Apple LLVM 6.1-Preprocessor中定义 Preprocessor Macros的AdHoc,Appstore,Debug,Enterprise,Release的参数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MOVE模型的View&lt;br&gt;基于nib建立的。公共部分在基类中实现。BaseController。&lt;br&gt;把页面分细，实现代码重用。&lt;br&gt;Page:BasePage，广告页，home主页（TabBarController）,新闻页，阅读页面，视听页面，发现页面，我的页面。&lt;br&gt;Wiget:栏目条，基类baseWiget，公共基类TableWidget,栏目条ColumnBarwidget，新闻NewsWidget&lt;br&gt;Cell:&lt;br&gt;用类图UML表示，聚合，关联，继承。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;MOVE模型的Event&lt;br&gt;点击登录按钮，状态改变（WIFI变为3G）&lt;br&gt;登录界面展示：&lt;br&gt;M：UserInfo&lt;br&gt;O: FxLogin&lt;br&gt;V: LoginPage&lt;br&gt;E: LoginButton&lt;br&gt;把数据接口解析为实体。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;显示当天广告&lt;br&gt;广告页需求：先显示默认图，广告下载完毕后显示广告图，显示3秒后消失。&lt;br&gt;1&amp;gt;本地缓存：节省用户流量，本地是否存在，存在，取本地图片，没有存在，取URL中的广告。前后台切换也要显示广告页。&lt;br&gt;2&amp;gt;策略：控制时间，判断是否要显示广告页：把上一次登录时间记录下来，然后在一小时内不再显示启动图。&lt;br&gt;3&amp;gt;根据设备的尺寸获取响应尺寸的广告  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定制导航栏&lt;br&gt;1&amp;gt;给登录页添加导航栏&lt;br&gt;2&amp;gt;设置状态栏的样式：在Info的Custom  iOS Target Properties中的View controller-based status 设置一下&lt;br&gt;状态条初始化的时候是否隐藏：Status bar is initially hidden&lt;br&gt;3&amp;gt;导航栏透明对nib的影响:尽量不要用透明图片。&lt;br&gt;4&amp;gt;定制左右按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置底部导航栏（UITabbarcontroller）&lt;br&gt;1&amp;gt;设置HomePage:&lt;br&gt;2&amp;gt;设置item的字体颜色&lt;br&gt;3&amp;gt;定制图标&lt;br&gt;4&amp;gt;配置文件实现(Plist)：方便维护和扩展。&lt;br&gt;配置plist文件，再定义解析的Model，实例化。&lt;br&gt;HomePage:self.viewControllers = [PageInfo pageControllers];&lt;br&gt;重复代码抽取到Model层：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (PageInfo *pageInfo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; pages) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pageInfo.unLoad) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pageInfo.unLoad) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pageController = [[NSClassFromString(pageInfo.ID) alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       navPage = [[UINavigationController alloc] &lt;span class=&quot;string&quot;&gt;initWithRootViewController:&lt;/span&gt;pageController];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pageController.title = pageInfo.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pageController.tabBarItem.image = [UIImage &lt;span class=&quot;string&quot;&gt;imageNamed:&lt;/span&gt;pageInfo.image];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [controllers &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;navPage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栏目切换效果&lt;br&gt;1&amp;gt;需求分析：选中栏目字体红色，未选择的栏目字体是灰色，栏目条左右两边有阴影，点击的栏目居中显示。&lt;br&gt;2&amp;gt;填空新闻页&lt;br&gt;设置导航栏图标，设置导航栏左右按钮，增加栏目条背景&lt;br&gt;3&amp;gt;实现栏目条效果&lt;br&gt;设置栏目条两边的阴影效果图片，加上scrollView，把视图层次，把视图放后面就能显示阴影图片。&lt;br&gt;4&amp;gt;点击的栏目居中显示&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;新闻列表展示&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;离线缓存-iOS沙盒机制&lt;br&gt;下次取得时候直接从本地取，不需要再去网上下载&lt;br&gt;1&amp;gt;沙盒机制:iOS为每个app创建自己的存储空间，对APP执行各种操作的权限限制。为了安全考虑.&lt;br&gt;2&amp;gt;关键目录：（Xcode：Window-Device）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Document:永久保存目录，文档目录。要保存程序声称的数据，会自动备份到ICloud，iTunes，恢复。&lt;br&gt;/Inbox:文件交互目录，只能读、删；不能写，改。  &lt;/li&gt;
&lt;li&gt;Library：Caches：缓存；Preference：偏好设置(下面有plist)&lt;br&gt;iTunes，iCloud备份+恢复。/Caches:空间不足时会删除&lt;/li&gt;
&lt;li&gt;tmp:临时文件，系统会自动清理，程序重新启动就会清理。&lt;br&gt;设置不备份到iCloud和ITunes中。&lt;br&gt;3&amp;gt;Document Types：从第三方文件拷贝到自己的沙盒中，都放在inbox下。其他程序的文件转存到这个程序。&lt;br&gt;4&amp;gt;文件共享：可以在iTunes中查看inbox文件夹。然后把电脑文件放在程序下面。&lt;br&gt;5&amp;gt;安全策略：越狱之后同样可以获取到文件，所以保证缓存到手机的数据安全，敏感信息必须考虑加密。RSA，AES加密算法。&lt;blockquote&gt;
&lt;p&gt;面试问题：如何实现删除APP，app的数据还能保存在设备中：&lt;br&gt;可以用KeychainUtils（钥匙串），把敏感信息放在钥匙串中。可以起到加密作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据及图片的缓存&lt;br&gt;1&amp;gt;建立统一的缓存目录：/Library/NewsReader&lt;br&gt;2&amp;gt;元数据和图片分别存储在：&lt;br&gt;元数据：新闻列表。用动态库libsqlite3.dylib。FxDBManager中设置一些数据库的建表。&lt;br&gt;图片：图标文件。CacheImage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;H5自动缓存技术&lt;br&gt;在服务器的Document中放入H5文件，里面有清单文件manifest，要缓存的文件有css,js,在HTML的文件中连接了css和JS文件。&lt;br&gt;safari监控：&lt;br&gt;&lt;a href=&quot;http://172.16.20.174.newsreder/h5/content.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://172.16.20.174.newsreder/h5/content.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://172.16.20.174.newsreder/h5/content2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://172.16.20.174.newsreder/h5/content2.html&lt;/a&gt;&lt;br&gt;H5应用指定了manifest 清单，则有应用程序缓存，就指定了缓存的文件，当没有网络时，还可以看到加载的页面。。。。。&lt;br&gt;2.如果不用H5离线缓存技术，就需要存储在数据库中。&lt;br&gt;xcode监控沙盒：&lt;br&gt;/Library/Cache/xxx/ApplicationCache.db&lt;br&gt;CacheResoursData&lt;br&gt;CacheResourses&lt;br&gt;3.内容更新&lt;br&gt;在CSS上有背景颜色的更新，只需要在本地manifest文件中修改Version号，然后告诉H5文件重新加载，本地缓存更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入微信分享&lt;br&gt;1、申请AppKey&lt;br&gt;open.weixin.qq.com&lt;br&gt;微信开放平台上注册，然后创建应用，得到APP ID，可以获得接口，开发者需要在工程中链接上SystemConfiguration.framework,lib.dylib.libsqlite3.0.dylib&lt;br&gt;2、所以要在包中添加SystemConfiguration.framework,包&lt;br&gt;3、在build setting，在Search Paths 中添加libWeChatSDK.a,WXApi.h,WXAPiObject.h三个文件所在位置。&lt;br&gt;4、在Xcode中，选择你的工程设置项，选中TAGETS一栏，在info标签栏的URL type添加“URL scheme”为你所注册的应用程序id&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;] 在你需要使 用微信终端API的文件中import WXApi.h 头文件，并增加 WXApiDelegate 协议。&lt;/p&gt;
&lt;p&gt;4.在代码中使用开发工具包&lt;/p&gt;
&lt;p&gt;[1] 要使你的程序启动后微信终端能响应你的程序，必须在代码中向微信终端注册你的id。（如下图所示，在 AppDelegate 的 didFinishLaunchingWithOptions 函数中向微信注册id）。&lt;/p&gt;
&lt;p&gt;[2] 重写AppDelegate的handleOpenURL和openURL方法：&lt;/p&gt;
&lt;p&gt;[3] 现在，你的程序要实现和微信终端交互的具体请求与回应，因此需要实现WXApiDelegate协议的两个方法：&lt;/p&gt;
&lt;p&gt;-(void) onReq:(BaseReq*)reqonReq是微信终端向第三方程序发起请求，要求第三方程序响应。第三方程序响应完后必须调用sendRsp返回。在调用sendRsp返回时，会切回到微信终端程序界面。&lt;/p&gt;
&lt;p&gt;-(void) onResp:(BaseResp*)resp如果第三方程序向微信发送了sendReq的请求，那么onResp会被回调。sendReq请求调用后，会切到微信终端程序界面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显示当地天气&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;天气接口：&lt;a href=&quot;http://www.mpjacks.cn/post-35.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mpjacks.cn/post-35.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.申请服务&lt;br&gt;&lt;a href=&quot;http://www.k780.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.k780.com&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://openweather.weather.com.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://openweather.weather.com.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;获得APP key&lt;br&gt;2.增加天气页面（MOVE模型）&lt;/p&gt;
&lt;p&gt;3.获取所在城市&lt;br&gt;CoreLocation.framework&lt;br&gt;反地理编码：根据纬度获得地名&lt;/p&gt;
&lt;p&gt;4.查询城市编码&lt;br&gt;&lt;a href=&quot;http://apistore.baidu/com/microservice/cityinfo?cityname=url编码&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://apistore.baidu/com/microservice/cityinfo?cityname=url编码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.获取本地天气&lt;br&gt;&lt;a href=&quot;http://api.780.com:88&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://api.780.com:88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.显示天气图标&lt;/p&gt;
&lt;p&gt;加入地理定位的库CoreLocation&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;APNS消息推送&lt;br&gt;1、申请AppKey&lt;br&gt;&lt;a href=&quot;http://dev.xiaomi.com（小米开放平台）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://dev.xiaomi.com（小米开放平台）&lt;/a&gt;&lt;br&gt;极光：JiPush&lt;br&gt;APPID：&lt;br&gt;2、生成APNS证书&lt;br&gt;&lt;a href=&quot;http://developer.apple.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.apple.com&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3、加入SDK&lt;/p&gt;
&lt;p&gt;apple的push 是不需要其他功夫的 只要服务端下发就好了&lt;br&gt;你就要了解安卓的push机制&lt;br&gt;然后你就要知道 安卓的push进程 然后就要如何进程复活&lt;br&gt;一系列的你都要知道 只有这样你才能拿sp&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计用户行为&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、申请APPID&lt;br&gt;www.umeng.com&lt;br&gt;2.加入SDK&lt;br&gt;3.设计统计文件&lt;br&gt;FxStatic&lt;br&gt;4、定义统计宏&lt;br&gt;5、统计相关行为&lt;/p&gt;
&lt;p&gt;6、加入百度统计&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;功能扩展（还未实现）&lt;br&gt;下拉刷新&lt;br&gt;栏目定制&lt;br&gt;夜间模式:在css中设置&lt;br&gt;字体字号的设置：在css中设置样式，字号：在JS中字体样式替换&lt;br&gt;消息推送设置：&lt;br&gt;实现页面：阅读，试听，发现，我&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;到了软院以后，选择了移动互联网和游戏开发方向，开设了iOS课程，在老师的引导下，开始自学了iOS。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://peilinghui.com/2016/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://peilinghui.com/2016/03/14/数据结构/</id>
    <published>2016-03-14T14:10:13.000Z</published>
    <updated>2016-04-25T05:45:57.000Z</updated>
    
    <content type="html">&lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;黑盒测试：&lt;br&gt;1&amp;gt;单点测试(PAT)&lt;br&gt;该组数据通过测试&lt;br&gt;2&amp;gt;多点测试(ACM)&lt;br&gt;程序一次能运行所有数据，并要求输出的结果必须正确。&lt;br&gt;while(scanf(“%d %d”, &amp;amp;n, &amp;amp;a) != EOF){}EOF为end of file返回值为-1.&lt;/p&gt;
&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;h3 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义 ：&lt;br&gt;静态分配:&lt;br&gt;#define MaxSize 50&lt;br&gt;typedef  struct{//静态分配&lt;br&gt; ElemType data[MaxSize];//顺序表元素&lt;br&gt; int length;//当前长度&lt;br&gt;}SqList;&lt;br&gt;动态分配:&lt;br&gt;#define InitSize 100&lt;br&gt;typedef  struct{//动态分配&lt;br&gt; ElemType *data;//指示动态分配数组的指针&lt;br&gt; int MaxSize,length;//数组最大容量和当前个数&lt;br&gt;}SeqList;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;//初始动态分配&lt;br&gt;&lt;code&gt;L.data=(ElemType *)malloc(sizeof(Elemtype)*InitSize);&lt;/code&gt;&lt;br&gt;//C++动态分配&lt;br&gt;&lt;code&gt;L.data=new ElemType[InitSize];&lt;/code&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作&lt;br&gt;顺序表最主要的特点就是随机访问特性&lt;br&gt;1&amp;gt;插入&lt;br&gt;bool ListInsert(SqList &amp;amp;L,int i,Element e){&lt;br&gt; if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length+1) return false;&lt;br&gt; if (L.length&amp;gt;=MaxSize) return false;&lt;br&gt; //将第i个位置以及以后的元素后移&lt;br&gt; for (int j=L.length; j&amp;gt;=i; j–)&lt;pre&gt;&lt;code&gt;L.data[j]=L.data[j-1];
&lt;/code&gt;&lt;/pre&gt; L.data[i-1]=e;//在位置i处放入e&lt;br&gt; l.length++;//表长加1&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;删除&lt;br&gt;bool ListDelete(SqList &amp;amp;L,int i,int &amp;amp;e){&lt;br&gt;    if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length) return false;&lt;br&gt;    e=L.data[i-1];&lt;br&gt;    //将第i个位置以后的元素前移&lt;br&gt;    for (int j=i; j&amp;lt;L.length; j++)&lt;br&gt;        L.data[j-1]=L.data[j];&lt;br&gt;    L.length–;&lt;br&gt;    return true;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/p&gt;
&lt;p&gt;3&amp;gt;按值查找&lt;br&gt;int LocateElem(SqList L,ElemType e){&lt;br&gt;    int i;&lt;br&gt;    for (i=0; i&amp;lt;L.length; i++)&lt;br&gt;        if (L.data[i]==e) return i+1;&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
&lt;h3 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;br&gt;typedef struct LNode{&lt;br&gt; ElemType data;//数据域&lt;br&gt; struct LNode &lt;em&gt;next;//指针域&lt;br&gt;}LNode,&lt;/em&gt;LinkList;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头插法建立单链表&lt;br&gt;LinkList CreateList1(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; LNode *s;int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; L-&amp;gt;next= NULL;//初始为空链表&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
s-&amp;gt;next=L-&amp;gt;next;
L-&amp;gt;next=s;
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; return L;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尾插法建立单链表&lt;br&gt;LinkList CreateList2(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; LNode &lt;em&gt;s,&lt;/em&gt;r=L;&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
r-&amp;gt;next=s;
r=s;//r指向新的表尾结点
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; r-&amp;gt;next=NUll;&lt;br&gt; return L;&lt;br&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;按序号查找表结点值&lt;br&gt;LNode &lt;em&gt;GetElem(LinkList L,int i){&lt;br&gt; int j=1;&lt;br&gt; LNode &lt;/em&gt;p=L-&amp;gt;next;&lt;br&gt; if(i==0)return L;&lt;br&gt; if (i&amp;lt;1)return NUll;&lt;br&gt; while (p&amp;amp;&amp;amp;j&amp;lt;i) {&lt;pre&gt;&lt;code&gt;p=p-&amp;gt;next;
j++;
&lt;/code&gt;&lt;/pre&gt; }&lt;br&gt; return p;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;双链表&quot;&gt;&lt;a href=&quot;#双链表&quot; class=&quot;headerlink&quot; title=&quot;双链表&quot;&gt;&lt;/a&gt;双链表&lt;/h3&gt;&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;顺序栈 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void InitStack(&amp;amp;S){&lt;br&gt; s.top=-1;//将栈顶指针置为空&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;判断栈空&lt;br&gt;bool empty(S){&lt;br&gt; if (s.top==-1) return true;//栈空&lt;br&gt; else return false;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;进栈&lt;br&gt;bool push(x){&lt;br&gt; if (S.top==MaxSize-1) return false;//栈满，报错&lt;br&gt; S.data[++S.top]=x;//指针先加1，再入栈&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;出栈&lt;br&gt;bool pop(x){&lt;br&gt; if (S.top==-1) return false;//栈空，报错&lt;br&gt; x=S.data[S.top–];//先出栈，指针再减1&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;读栈顶元素&lt;br&gt;void GetTop(x){&lt;br&gt; if (S.top==-1)return false;//栈空，报错&lt;br&gt; x= S.data[S.top];//x记录栈顶元素&lt;br&gt; return false;&lt;br&gt;}&lt;h4 id=&quot;简单计算器（ACM）&quot;&gt;&lt;a href=&quot;#简单计算器（ACM）&quot; class=&quot;headerlink&quot; title=&quot;简单计算器（ACM）&quot;&gt;&lt;/a&gt;简单计算器（ACM）&lt;/h4&gt;读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入&lt;br&gt;测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。&lt;/p&gt;
&lt;p&gt;样例输入&lt;br&gt;30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 &lt;em&gt; 6 + 51 / 29 + 79 &lt;/em&gt; 87 + 57 * 92&lt;br&gt;0&lt;br&gt;样例输出&lt;br&gt;12178.21&lt;br&gt;思路：题目给出的是中缀表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 中缀表达式转后缀表达式 
 1&amp;gt;设立一个操作符栈，存放操作符，设立一个队列，存放后缀表达式
 2&amp;gt;扫描中缀表达式，遇到操作数放入后缀表达式。
 3&amp;gt;遇到操作符op，则将其优先级与操作符栈顶操作符优先级比较; 
 若高于，则压入栈，若低于，则弹出到后缀表达式。
 4&amp;gt;重复直到扫描完，若仍有，放到后缀表达式
- 计算后缀表达式
扫描后缀表达式，若是操作数，就压入栈，若是操作符，就弹出两个操作数，进行计算，计算后的数压入栈。直到扫描完，栈中只有一个数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答案：&lt;a href=&quot;http://blog.csdn.net/ccj2020/article/details/7749450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/ccj2020/article/details/7749450&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &amp;lt;iostream&amp;gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node &amp;#123;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; num;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; op;	&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; flag;&amp;#125;;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;node&amp;gt; s;&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;node&amp;gt; q;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; op;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node temp;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;str.length();)&amp;#123;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			temp.num = str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;			i++;			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;str.length() &amp;amp;&amp;amp; str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;				temp.num = temp.num * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;				i++;			&amp;#125;			q.push(temp);		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;			temp.op = str[i];			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty() &amp;amp;&amp;amp; op[temp.op] &amp;lt;= op[s.top().op])&amp;#123;				q.push(s.top());				s.pop();			&amp;#125;			s.push(temp);			i++;		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty())&amp;#123;		q.push(s.top());		s.pop();	&amp;#125;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node cur,temp;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; temp1,temp2;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&amp;#123;		cur = q.front();		q.pop();		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.flag == &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)			s.push(cur);		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp2 = s.top().num;			s.pop();			temp1 = s.top().num;			s.pop();			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;)				temp.num = temp1 + temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;)				temp.num = temp1 - temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;)				temp.num = temp1 * temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;)				temp.num = temp1 / temp2;			s.push(temp);		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s.top().num;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	op[&lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;	op[&lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;	str = &lt;span class=&quot;string&quot;&gt;&quot;1+1*9-2+1&quot;&lt;/span&gt;;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ni hao&quot;&lt;/span&gt;);	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(getline(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;,str))&amp;#123;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;_______&quot;&lt;/span&gt;);		change();		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,cal());	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;循环队列&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void Initqueue(&amp;amp;Q){&lt;br&gt; Q.rear=Q.front=0;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;判队空&lt;br&gt;bool isEmpty(Q){&lt;br&gt; if (Q.rear==Q.front) return true;&lt;br&gt; else return false;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;入队&lt;br&gt;bool EnQueue(Queue &amp;amp;Q,x){&lt;br&gt; if ((Q.rear+1)%MaxSize==Q.front) return false;//队满&lt;br&gt; Q.data[Q.rear]=x;&lt;br&gt; Q.rear=(Q.rear+1)%MaxSize;//队尾指针加1取模&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;出队&lt;br&gt;bool DeQueue(Queue &amp;amp;Q,&amp;amp;x){&lt;br&gt; if (Q.rear==Q.front)return false;&lt;br&gt; x=Q.data[Q.front];&lt;br&gt; Q.front=(Q.front+1)%MaxSize;&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;树与二叉树&quot;&gt;&lt;a href=&quot;#树与二叉树&quot; class=&quot;headerlink&quot; title=&quot;树与二叉树&quot;&gt;&lt;/a&gt;树与二叉树&lt;/h2&gt;&lt;p&gt;满二叉树和完全二叉树用顺序存储。&lt;br&gt;一般二叉树都用链式存储&lt;br&gt;struct node{&lt;br&gt;    typename data;&lt;br&gt;    node &lt;em&gt;lchild,&lt;/em&gt;rchild;&lt;br&gt;};&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的遍历&lt;br&gt;1.先序遍历&lt;br&gt;2.中序遍历&lt;br&gt;3.后序遍历&lt;br&gt;4.层序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;排序（内排）&quot;&gt;&lt;a href=&quot;#排序（内排）&quot; class=&quot;headerlink&quot; title=&quot;排序（内排）&quot;&gt;&lt;/a&gt;排序（内排）&lt;/h2&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h3&gt;&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h4&gt;&lt;p&gt;思想：表长L[1…..N],有序序列L[1..i-1],L(i),无序序列L[n+1……N],将L(i)插入有序L[1..i-1]。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 找出L(i)插入有序L[1..i-1]的位置k。  
- 将L[k..i-1]中所有元素后移一位  
- 将L(i)复制给L(k)。  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间效率：O（1）&lt;br&gt;时间效率：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InsertSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp=A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j=i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; temp&amp;lt;A[j]; j--) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从后往前查找待插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=A[j];&lt;span class=&quot;comment&quot;&gt;//向后移一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//复制到插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;折半插入排序&quot;&gt;&lt;a href=&quot;#折半插入排序&quot; class=&quot;headerlink&quot; title=&quot;折半插入排序&quot;&gt;&lt;/a&gt;折半插入排序&lt;/h4&gt;&lt;h4 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h4&gt;&lt;h3 id=&quot;交换排序&quot;&gt;&lt;a href=&quot;#交换排序&quot; class=&quot;headerlink&quot; title=&quot;交换排序&quot;&gt;&lt;/a&gt;交换排序&lt;/h3&gt;&lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;思想：表长n，从前往后或（从后往前）两两比较相邻元素的值，逆序则交换，这是第一趟，需要n-1趟。&lt;br&gt;空间效率：O（1）&lt;br&gt;时间效率：平均和最坏都是：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]= &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-i; j++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//第i趟时从a[0]到a[n-i]都与他们的下一个数比较&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123;&lt;span class=&quot;comment&quot;&gt;//如果左边的数更大，则交换a[j]和a[j+1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j] = a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,a[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h4&gt;&lt;p&gt;是所有排序算法中平均时间最好的一种算法，O(nlogn)思想是基于分治法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调整序列中的元素，使得当前序列最左短的元素在调整后满足左侧所以元素均不超过该元素、右侧所有元素均大于该元素。  &lt;/li&gt;
&lt;li&gt;对该元素的左侧和右侧分别递归进行1的调整，直到当前调整区间的长度不超过1.&lt;br&gt;时间复杂度：O(n2)&lt;br&gt;空间复杂度：O(logn)&lt;br&gt;递归实现：&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int temp = &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将表中第一个元素设为枢轴值，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]&amp;gt;temp) &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值小的元素移动到左边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]&amp;lt;=temp) &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值大的元素移动到右边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//枢轴放到最终位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int pos = &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//将[left,right]按A[left]一分为二&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;, pos);&lt;span class=&quot;comment&quot;&gt;//对左子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, pos+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//对右子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;h4 id=&quot;简单选择排序&quot;&gt;&lt;a href=&quot;#简单选择排序&quot; class=&quot;headerlink&quot; title=&quot;简单选择排序&quot;&gt;&lt;/a&gt;简单选择排序&lt;/h4&gt;&lt;p&gt;思想：表长N[1…..N],第i趟排序则从[i……N]中选择关键字最小的元素与i交换，每一趟确定一个元素的最终位置，需要n-1趟。&lt;br&gt;空间效率：O(1)&lt;br&gt;时间效率：平均和最坏都是：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight glsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; selectSort()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = i;&lt;span class=&quot;comment&quot;&gt;//记录最小元素的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=i; j&amp;lt;=n; j++) &lt;span class=&quot;comment&quot;&gt;//从i...n中选择最小元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[j]&amp;lt;A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;]) &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = A[i];&lt;span class=&quot;comment&quot;&gt;//最小元素与A[i]交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[i] = A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;] = A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h4&gt;&lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;含义：将两个或俩个以上的有序表合并成为一个新的有序表。&lt;br&gt;2-路归并排序   递归实现：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将数组A的[L1,R1]与[L2,R2]区间合并为有序区间L2=R1+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L2,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=L1,j=L2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp[maxn],index=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//temp存放合并后的数组，index为其下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1&amp;amp;&amp;amp;j&amp;lt;=R2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=A[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将A[i]加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1)temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将区间[L1,R1]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;=R2)temp[index++]=A[j++];&lt;span class=&quot;comment&quot;&gt;//将区间[L2,R2]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;index; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[L1+i]=temp[i]; &lt;span class=&quot;comment&quot;&gt;//将合并后的序列赋值回数组A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将Array数组当前区间[left,right]进行归并排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (left&amp;lt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, left, mid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        merge(A, left, mid, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;非递归：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;mergeSort(int A[])&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    //step&amp;#20026;&amp;#32452;&amp;#20869;&amp;#20803;&amp;#32032;&amp;#20010;&amp;#25968;&amp;#10;    for (int step= 2; step/2 &amp;#60;= n; step*=2) &amp;#123;&amp;#10;        //&amp;#27599;step&amp;#20010;&amp;#20803;&amp;#32032;&amp;#19968;&amp;#32452;&amp;#65292;&amp;#32452;&amp;#20869;&amp;#36827;&amp;#34892;&amp;#25490;&amp;#24207;&amp;#10;        for (int i =1; i&amp;#60;=n; i+=step) &amp;#123;&amp;#10;            int mid = i +step/2 -1;&amp;#10;            if (mid +1&amp;#60;=n) &amp;#123;&amp;#10;                merge(A,mid,mid+1,min(i+step-1,n));&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者是：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step为组内元素个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; step/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= n; step*=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//每step个元素一组，组内进行排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i+=step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sort(A+i,A+min(i+step,n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h2&gt;&lt;h3 id=&quot;线性结构&quot;&gt;&lt;a href=&quot;#线性结构&quot; class=&quot;headerlink&quot; title=&quot;线性结构&quot;&gt;&lt;/a&gt;线性结构&lt;/h3&gt;&lt;h4 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h4&gt;&lt;h4 id=&quot;折半查找&quot;&gt;&lt;a href=&quot;#折半查找&quot; class=&quot;headerlink&quot; title=&quot;折半查找&quot;&gt;&lt;/a&gt;折半查找&lt;/h4&gt;&lt;p&gt;适用于：有序的顺序表&lt;br&gt;时间复杂度：O(logn)&lt;/p&gt;
&lt;h4 id=&quot;分块查找&quot;&gt;&lt;a href=&quot;#分块查找&quot; class=&quot;headerlink&quot; title=&quot;分块查找&quot;&gt;&lt;/a&gt;分块查找&lt;/h4&gt;&lt;h3 id=&quot;树形结构&quot;&gt;&lt;a href=&quot;#树形结构&quot; class=&quot;headerlink&quot; title=&quot;树形结构&quot;&gt;&lt;/a&gt;树形结构&lt;/h3&gt;&lt;h4 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h4&gt;&lt;h4 id=&quot;二叉平衡数&quot;&gt;&lt;a href=&quot;#二叉平衡数&quot; class=&quot;headerlink&quot; title=&quot;二叉平衡数&quot;&gt;&lt;/a&gt;二叉平衡数&lt;/h4&gt;&lt;h4 id=&quot;B树，B-树&quot;&gt;&lt;a href=&quot;#B树，B-树&quot; class=&quot;headerlink&quot; title=&quot;B树，B+树&quot;&gt;&lt;/a&gt;B树，B+树&lt;/h4&gt;&lt;h3 id=&quot;散列结构&quot;&gt;&lt;a href=&quot;#散列结构&quot; class=&quot;headerlink&quot; title=&quot;散列结构&quot;&gt;&lt;/a&gt;散列结构&lt;/h3&gt;&lt;h4 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://peilinghui.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://peilinghui.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的第三方框架</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的第三方框架/</id>
    <published>2016-03-05T06:08:53.000Z</published>
    <updated>2016-05-04T13:17:03.000Z</updated>
    
    <content type="html">&lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;源代码分析：&lt;a href=&quot;https://github.com/Draveness/iOS-Source-Code-Analyze&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Draveness/iOS-Source-Code-Analyze&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;FMDB&quot;&gt;&lt;a href=&quot;#FMDB&quot; class=&quot;headerlink&quot; title=&quot;FMDB&quot;&gt;&lt;/a&gt;FMDB&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是FMDB：&lt;br&gt;FMDB是iOS平台的SQLite数据库框架；&lt;br&gt;FMDB以OC的方式封装了SQLite的C语言API&lt;/li&gt;
&lt;li&gt;优点&lt;ul&gt;
&lt;li&gt;使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码&lt;/li&gt;
&lt;li&gt;对比苹果自带的Core Data框架，更加轻量级和灵活&lt;/li&gt;
&lt;li&gt;提供了多线程安全的数据库操作方法，有效地防止数据混乱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FMDB的github地址:  &lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ccgus/fmdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;核心类&lt;br&gt;FMDB有三个主要的类&lt;br&gt;（1）FMDatabase&lt;br&gt;一个FMDatabase对象就代表一个单独的SQLite数据库&lt;br&gt;用来执行SQL语句&lt;br&gt;（2）FMResultSet&lt;br&gt;使用FMDatabase执行查询后的结果集&lt;br&gt;（3）FMDatabaseQueue&lt;br&gt;用于在多线程中执行多个查询或更新，它是线程安全的&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Alamofire&quot;&gt;&lt;a href=&quot;#Alamofire&quot; class=&quot;headerlink&quot; title=&quot;Alamofire&quot;&gt;&lt;/a&gt;Alamofire&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Alamofire/Alamofire&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;AlamofireObjectMapper&quot;&gt;&lt;a href=&quot;#AlamofireObjectMapper&quot; class=&quot;headerlink&quot; title=&quot;AlamofireObjectMapper&quot;&gt;&lt;/a&gt;AlamofireObjectMapper&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tristanhimmelman/AlamofireObjectMapper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/tristanhimmelman/AlamofireObjectMapper&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;AFN 与 ASI 有什么区别&lt;br&gt;AFN基于NSURL，ASI基于底层的CFNetwork框架，因此ASI的性能优于AFN&lt;br&gt;AFN采取block的方式处理请求，ASI最初采取delegate的方式处理请求，后面也增加了block的方式。&lt;br&gt;AFN只封装了一些常用功能，满足基本需求，直接忽略了很多扩展功能，比如没有封装同步请求；ASI提供的功能较多，预留了各种接口和工具供开发者自行扩展。AFN直接解析服务器返回的JSON、XML等数据，而ASI比较原始，返回的是NSData二进制数据。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/AFNeting.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;讲解：&lt;br&gt;1&amp;gt;&lt;strong&gt;AFHTTPRequestOperation&lt;/strong&gt;&lt;br&gt;HTTP或HTTPS协议请求的AFURLConnectionOperation的子类。它封装的可接受状态码和内容的类型，判定一个请求结果是成功或失败。&lt;br&gt;实际上对系统的HTTP网络请求增加了几个HTTP需要用到的参数。&lt;br&gt;2&amp;gt;&lt;strong&gt;AFURLConnectionOperation&lt;/strong&gt;&lt;br&gt;可以说是AFN最基础的类。继承自NSOperation类，将网络请求依附到一个operation上。从而让我们能够有效的控制并观察一个网络请求的创建、进行、取消、完成、暂停恢复、异常等问题及状态。&lt;br&gt;①：综述&lt;br&gt;AFURLConnectionOperation 将Operation和URLConnection结合到一起，利用operation可以监听到状态以及可以建立相互之间的依赖关系的特性，实现了对于 一个NSURLConnection对象的完美控制，并将请求的结果通过block友好的返回。&lt;br&gt;②：实现文件.m&lt;br&gt;我们总结下.m中这个类主要有哪些方法。&lt;br&gt;1： 首先我们可以看到它创建了一个单例线程。这个线程将会常驻内存，用来处理AFN发起的所有请求任务。当然，线程也跟随着一个runloop，AFN将这个 runloop的模式设置为NSDefaultRunLoopMode。NSDefaultRunLoopMode是无法检测到connection的状 态的。这说明了，AFN将不会在这该线程处理connection完成后的UI刷新等工作，而是会将数据抛给主线程，让主线程去完成UI的刷新。&lt;br&gt;2：我们可以看到该类通过接受请求的字符串，创建了URLRequest以及NSURLConnection对象。从而去进行请求。&lt;br&gt;3：实现文件多次使用到了锁，可以保证数据的安全。当然他也实现了几个数据的NSCoping协议。&lt;br&gt;4：请求的创建、进行、取消、完成、暂停恢复、异常等问题及状态的控制。这里讲一下暂停和恢复。&lt;br&gt;暂 停实际上将网络请求取消掉了。但是由于实现了nscoping协议，已经下载到数据得以保存下来。下次进行相同请求的时候，我们会将已经下载到的数据的节 点一起发送给服务器，告诉服务器这些部门的数据我们不需要了，服务器根据我发送的返回节点给我返回相应的数据即可。从而实现了暂停和恢复功能，也就是断点 续传。&lt;br&gt;5：operation方法的重写。自行google，这里不赘述。&lt;br&gt;6：状态的各种控制方法的实现以及发送状态改变的通知  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;③：接口文件.h&lt;br&gt;接口文档中的属性方法，基本可以概括为以下几个方法&lt;br&gt;1：只读的数据，让管理者可以接收到。&lt;br&gt;2：设置runloop的modes。不再使用类库默认设置的defaultmodes。&lt;br&gt;3：状态的控制方法&lt;br&gt;4：安全策略的设置&lt;br&gt;总而言之，接口文件.h暴露的接口都是为了让manager可以去完全控制这个operation以及其中的网络请求。&lt;/p&gt;
&lt;p&gt;3&amp;gt;&lt;strong&gt;AFHTTPRequestOperationManager&lt;/strong&gt;&lt;br&gt;这个类是AFN类库的核心类。它封装完成了一种通用的模式，可以帮助我们轻松友好的完成请求的创建、响应的系列化，网络状态的监控以及安全策略以及每一个请求operation的管理（operation的相互依赖或状态改变）。&lt;br&gt;①：综述&lt;br&gt;这个类可以说是整个类库的核心类了。据说AFN2.0之前的时候，所有的网络请求相关的设置都杂糅到一个client中，导致client特别的臃肿。2.0后，AFN将一些设置提取出来，线程了专门的类【AFSecurityPolicy、AFURLRequestSerialization、AFURLResponseSerialization】。现在看来，AFN整体的设计是非常完美的。耦合性变得非常低，一些1.0版本中存在的问题也得到了改善。  &lt;/p&gt;
&lt;p&gt;②：实现文件.m&lt;br&gt;实现文件较为简单，可以看到他创建了一个队列。并将各个operation加入到队列中。在队列中，各个请求就可以设置依赖关系，并发的数量等等。  &lt;/p&gt;
&lt;p&gt;③：接口文件.h&lt;br&gt;接口文件中，我们可以看到。这个类可以设置AFSecurityPolicy、AFURLRequestSerialization、AFURLResponseSerialization 等参数了。这就是综述所说的降低耦合性的方式。基本使用很简单，这里就不再赘述了。  &lt;/p&gt;
&lt;h1 id=&quot;SDWebImage&quot;&gt;&lt;a href=&quot;#SDWebImage&quot; class=&quot;headerlink&quot; title=&quot;SDWebImage&quot;&gt;&lt;/a&gt;SDWebImage&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;网络图片处理框架&lt;br&gt;包含功能：图片下载、图片缓存、下载进度监控&lt;br&gt;用法简单，功能强大，大大提高了网络图片的处理效率&lt;br&gt;&lt;a href=&quot;http://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://github.com/rs/SDWebImage&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;SnapKit&quot;&gt;&lt;a href=&quot;#SnapKit&quot; class=&quot;headerlink&quot; title=&quot;SnapKit&quot;&gt;&lt;/a&gt;SnapKit&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SnapKit/SnapKit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基于swift的autolayout的框架&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;MBProgressHUD&quot;&gt;&lt;a href=&quot;#MBProgressHUD&quot; class=&quot;headerlink&quot; title=&quot;MBProgressHUD&quot;&gt;&lt;/a&gt;MBProgressHUD&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;动态提示框效果。应用显示一个过渡的作用，常用于打开一个联网页面加载过程，防止出现假死现象，如果网速慢则告诉用户已经在很努力很努力的加载中。网页加载、下载等耗时操作中给予用户以提示。&lt;/li&gt;
&lt;li&gt;github 地址：&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/jdg/MBProgressHUD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;讲解：&lt;a href=&quot;http://blog.csdn.net/lanmanck/article/details/38496113&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lanmanck/article/details/38496113&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/duxinfeng2010/article/details/8510894&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/duxinfeng2010/article/details/8510894&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/chenyufeng1991/article/details/50273315&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenyufeng1991/article/details/50273315&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;JSONKit&quot;&gt;&lt;a href=&quot;#JSONKit&quot; class=&quot;headerlink&quot; title=&quot;JSONKit&quot;&gt;&lt;/a&gt;JSONKit&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;JSONKit是用 Objective-C 实现的一个高性能的 JSON 解析和生成库。json正在逐步取代xml，成为网络数据的通用格式。&lt;/li&gt;
&lt;li&gt;讲解：&lt;a href=&quot;http://www.cnblogs.com/jiangyuxuan/archive/2013/03/09/2950984.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/jiangyuxuan/archive/2013/03/09/2950984.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://github.com/johnezang/JSONKit/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/johnezang/JSONKit/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Kingfisher&quot;&gt;&lt;a href=&quot;#Kingfisher&quot; class=&quot;headerlink&quot; title=&quot;Kingfisher&quot;&gt;&lt;/a&gt;Kingfisher&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/onevcat/Kingfisher&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/onevcat/Kingfisher&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Extension&quot;&gt;&lt;a href=&quot;#Extension&quot; class=&quot;headerlink&quot; title=&quot;Extension&quot;&gt;&lt;/a&gt;Extension&lt;/h1&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;h1 id=&quot;MJExtension&quot;&gt;&lt;a href=&quot;#MJExtension&quot; class=&quot;headerlink&quot; title=&quot;MJExtension&quot;&gt;&lt;/a&gt;MJExtension&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;MJExtension是JSON和Model(字典和模型)之间互相转换的超轻量级框架.&lt;/li&gt;
&lt;li&gt;MJExtension能完成的功能&lt;br&gt;字典（JSON） –&amp;gt; 模型（Model）&lt;br&gt;模型（Model） –&amp;gt; 字典（JSON）&lt;br&gt;字典数组（JSON Array） –&amp;gt; 模型数组（Model Array）&lt;br&gt;模型数组（Model Array） –&amp;gt; 字典数组（JSON Array）&lt;/li&gt;
&lt;li&gt;讲解：&lt;a href=&quot;http://www.jianshu.com/p/93c242452b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/93c242452b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub链接：&lt;a href=&quot;https://github.com/CoderMJLee/MJExtension&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/CoderMJLee/MJExtension&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;MJRefresh&quot;&gt;&lt;a href=&quot;#MJRefresh&quot; class=&quot;headerlink&quot; title=&quot;MJRefresh&quot;&gt;&lt;/a&gt;MJRefresh&lt;/h1&gt;&lt;p&gt;主要用于刷新操作，提供了常用的刷新操作，还有刷新动画，用着很好用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;通过不断的学习也接触了不少的第三方框架，就总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://peilinghui.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的数据存储</title>
    <link href="http://peilinghui.com/2016/03/05/iOS%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://peilinghui.com/2016/03/05/iOS中的数据存储/</id>
    <published>2016-03-05T05:59:07.000Z</published>
    <updated>2016-04-16T08:44:37.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS中的数据存储方式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS中的数据存储方式&quot;&gt;&lt;a href=&quot;#iOS中的数据存储方式&quot; class=&quot;headerlink&quot; title=&quot;iOS中的数据存储方式&quot;&gt;&lt;/a&gt;iOS中的数据存储方式&lt;/h1&gt;&lt;h2 id=&quot;Plist（NSArray-NSDictionary）&quot;&gt;&lt;a href=&quot;#Plist（NSArray-NSDictionary）&quot; class=&quot;headerlink&quot; title=&quot;Plist（NSArray\NSDictionary）&quot;&gt;&lt;/a&gt;Plist（NSArray\NSDictionary）&lt;/h2&gt;&lt;p&gt;只能存储数组，字典，但是数组和字典里面不能有自定义对象&lt;/p&gt;
&lt;h2 id=&quot;Preference（偏好设置-NSUserDefaults）&quot;&gt;&lt;a href=&quot;#Preference（偏好设置-NSUserDefaults）&quot; class=&quot;headerlink&quot; title=&quot;Preference（偏好设置\NSUserDefaults）&quot;&gt;&lt;/a&gt;Preference（偏好设置\NSUserDefaults）&lt;/h2&gt;&lt;h2 id=&quot;NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot;&gt;&lt;a href=&quot;#NSCoding（NSKeyedArchiver-NSkeyedUnarchiver归档&quot; class=&quot;headerlink&quot; title=&quot;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&quot;&gt;&lt;/a&gt;NSCoding（NSKeyedArchiver\NSkeyedUnarchiver归档&lt;/h2&gt;&lt;p&gt;存储自定义对象，局限：一次性做读取的存储的操作&lt;/p&gt;
&lt;h2 id=&quot;SQLite3&quot;&gt;&lt;a href=&quot;#SQLite3&quot; class=&quot;headerlink&quot; title=&quot;SQLite3&quot;&gt;&lt;/a&gt;SQLite3&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;什么是SQLite？&lt;br&gt;SQLite是一款轻型的嵌入式数据库;它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了;它的处理速度比Mysql、PostgreSQL这两款著名的数据库都还快  &lt;/li&gt;
&lt;li&gt;怎么解决sqlite锁定的问题？&lt;br&gt;设置数据库锁定的处理函数&lt;br&gt;int sqlite3_busy_handler(sqlite3&lt;em&gt;, int(&lt;/em&gt;)(void&lt;em&gt;,int), void&lt;/em&gt;);&lt;br&gt;设定锁定时的等待时间&lt;br&gt;int sqlite3_busy_timeout(sqlite3*, 60); ：&lt;h2 id=&quot;Core-Data&quot;&gt;&lt;a href=&quot;#Core-Data&quot; class=&quot;headerlink&quot; title=&quot;Core Data&quot;&gt;&lt;/a&gt;Core Data&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;什么是Core Data？&lt;br&gt;Core Data是iOS5以后才出现的一个框架，它提供了对象-关系映射（ORM）关系，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象，不用编写任何SQL语言（类似于Hibernate框架，没有那么强大）&lt;/li&gt;
&lt;li&gt;使用步骤&lt;ul&gt;
&lt;li&gt;创建模型文件，&lt;strong&gt;相当于数据库&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;添加实体，&lt;strong&gt;相对于表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;创建实体类，&lt;strong&gt;相当于模型类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;生成&lt;strong&gt;上下文&lt;/strong&gt; 关联模型文件生成数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四，DDL：数据定义语句&lt;/p&gt;
&lt;p&gt;1、Create&lt;/p&gt;
&lt;p&gt;create table 表名（字段名1，字段类型1，字段名2，字段类型2….）;&lt;/p&gt;
&lt;p&gt;create table if not exists 表名（字段名1，字段类型1，字段名2，字段类型2….）;&lt;/p&gt;
&lt;p&gt;2、Drop&lt;/p&gt;
&lt;p&gt;drop table 表名；&lt;/p&gt;
&lt;p&gt;drop table if not exists 表名；&lt;/p&gt;
&lt;p&gt;五、DML ：数据操作语句&lt;/p&gt;
&lt;p&gt;1、Insert&lt;/p&gt;
&lt;p&gt;2、Update&lt;/p&gt;
&lt;p&gt;3、Delete&lt;/p&gt;
&lt;p&gt;六、DQL：数据查询语句&lt;/p&gt;
&lt;p&gt;1、Where&lt;/p&gt;
&lt;p&gt;2、Select&lt;/p&gt;
&lt;p&gt;3、Group by having&lt;/p&gt;
&lt;p&gt;1&amp;gt; select&lt;/p&gt;
&lt;p&gt;2&amp;gt; 别名,可以不用as,&lt;br&gt;• 给数据库取别名的好处:用别名获取字段,有提示。&lt;/p&gt;
&lt;p&gt;3&amp;gt; 计算查询数量count&lt;br&gt;4&amp;gt; 排序: 有条件语句,需要放在条件语句后。&lt;br&gt;5&amp;gt; limit : limit 0,5 跳过第0个,取5个数据,意味着取前5个数据。这个语 句必须放在查询语句最后面。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的数据存储方式&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://peilinghui.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的多线程网络</title>
    <link href="http://peilinghui.com/2016/03/04/iOS%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BD%91%E7%BB%9C/"/>
    <id>http://peilinghui.com/2016/03/04/iOS中的多线程网络/</id>
    <published>2016-03-04T13:31:31.000Z</published>
    <updated>2016-04-16T09:03:52.000Z</updated>
    
    <content type="html">&lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;多线程网络&quot;&gt;&lt;a href=&quot;#多线程网络&quot; class=&quot;headerlink&quot; title=&quot;多线程网络&quot;&gt;&lt;/a&gt;多线程网络&lt;/h1&gt;&lt;h2 id=&quot;NSthread&quot;&gt;&lt;a href=&quot;#NSthread&quot; class=&quot;headerlink&quot; title=&quot;NSthread&quot;&gt;&lt;/a&gt;NSthread&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建和启动线程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;//创建一个新线程对象，实例方法，返回一个NSThread对象必须调用start方法启动线程 （实例方法）&lt;br&gt;&lt;code&gt;-(id)initWithTarget:(id)target selector:(SEL)selector object:(id)arg:&lt;/code&gt;&lt;br&gt;//创建并启动新线程，不会返回NSThread对象。会直接创建并启动线程(类方法)&lt;br&gt;&lt;code&gt;+(void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)arg:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;target对象的selector方法的方法体代表了线程需要完成的任务，相当于把target对象的selector方法转换为线程执行体. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建多线程对象
NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];
//启动多线程
[thread start];

//创建并启动多线程
[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;线程的状态&lt;br&gt;线程的状态会在运行、就绪状态之间切换。&lt;br&gt;启用线程使用了start方法后，该线程进入就绪状态，系统会为其创建方法调用栈和程序计数器。&lt;strong&gt;当系统调度线程后，线程才会进入运行状态。&lt;/strong&gt;&lt;br&gt;注意：若想要子线程的start方法后子线程立即开始执行，可以调用[NSThread sleepForTimeInterval:0.01];&lt;br&gt;从而让子线程立即获得执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终止子线程&lt;br&gt;1&amp;gt;线程执行体方法执行完成，线程正常结束。&lt;br&gt;2&amp;gt;线程执行过程中出现了错误&lt;br&gt;3&amp;gt;直接调用NSThread类的exit方法来中止当前正在执行的线程。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; ([NSThread currentThread].isCancelled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//中止当前正在执行的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr_selector&quot;&gt;[NSThread exit]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;线程睡眠&lt;br&gt;NSThread的两种类方法：&lt;br&gt;//让当前正在执行的线程暂停到aDate代表的时间，并进入阻塞状态&lt;br&gt;&lt;code&gt;+ (void)sleepUntilDate:(NSDate *)aDate:&lt;/code&gt;&lt;br&gt;//让当前正在执行的线程暂停ti秒，并进入阻塞状态&lt;br&gt;&lt;code&gt;+ (void)sleepForTimeInterval:(NSTimeInterval)ti:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例子：&lt;br&gt;使用线程下载网络图片：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建多线程对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSThread *thread = [[NSThread alloc]&lt;span class=&quot;string&quot;&gt;initWithTarget:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;downloadImageFromURL:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//启动多线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[thread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;downloadImageFromURL:&lt;/span&gt;方法作为线程执行体，当线程启动调用该方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//在主线程中执行updateUI：方法 来更新iv控件显示的图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self &lt;span class=&quot;string&quot;&gt;performSelectorOnMainThread:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;updateUI:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;withObject:&lt;/span&gt;image &lt;span class=&quot;string&quot;&gt;waitUntilDone:&lt;/span&gt;YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iOS规定只能在UI线程中修改UI控件的属性&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;改变优先级&lt;br&gt;NSThread中的实例方法和类方法：&lt;br&gt;+threadPriority&lt;br&gt;-threadPriority&lt;br&gt;+setThreadPriority：(double)priority:&lt;br&gt;-setThreadPriority：(double)priority:&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;线程同步与线程通信&quot;&gt;&lt;a href=&quot;#线程同步与线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程同步与线程通信&quot;&gt;&lt;/a&gt;线程同步与线程通信&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在多线程中引入同步解决线程安全问题&lt;br&gt;使用方法： @synchronized (obj) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//同步代码块
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt;obj是同步监视器&lt;br&gt;任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完毕的后，该线程会释放对同步监视器的锁定。&lt;br&gt;可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全所带来的负面影响，程序可以采用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源的方法进行同步。&lt;/li&gt;
&lt;li&gt;如果可变类有两种运行环境：单线程和多线程环境，则应该为该可变类提供两种版本-单线程环境中使用线程不安全版本以保证性能，多线程环境中使用线程安全版本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;释放对同步监视器的锁定&lt;br&gt;任何线程在进入同步代码块之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前线程的同步代码块执行结束  &lt;/li&gt;
&lt;li&gt;当前代码块在同步代码块中遇到了goto.return终止了该代码块、该方法继续执行时，当前线程会释放同步监视器。&lt;/li&gt;
&lt;li&gt;当线程在同步代码块中出现了错误，导致该代码块异常结束时，将会释放同步监视器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同步锁（NSLock）&lt;br&gt;Foundation提供NSLock，通过显式定义同步锁对象来实现同步。&lt;br&gt;NSlock是控制多个线程对共享资源进行访问的工具，通常锁提供了对共享资源的独占访问。在实现线程安全的控制中，使用NSlock对象可以显示地加锁，释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用NSCondition控制线程通信&lt;br&gt;NSCondition实现了NSLocking协议，因此也可以调用lock，unlock来实现线程同步。也可以让那些已经锁定NSCondition对象却无法继续执行的线程释放NSCondition对象，NSCondition对象也可以唤醒其他处于等待状态的线程。&lt;br&gt;方法：-wait，知道其他线程调用NSCondition的signal方法或broadcast方法来唤醒该线程。&lt;br&gt;-（BOOL）waitUntilDate：(NSDate *)limiteout,&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://blog.csdn.net/totogo2010/article/details/8010231&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/totogo2010/article/details/8010231&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;Grand Central Dispatch “牛逼的中枢调度器”&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;是苹果公司为多核的并行运算提出的解决方案&lt;/li&gt;
&lt;li&gt;GCD会自动利用更多CPU内核&lt;/li&gt;
&lt;li&gt;会自动管理线程的生命周期（创建线程，调度任务，销毁线程）&lt;/li&gt;
&lt;li&gt;程序员只需要告诉GCD该做什么，而不需要写代码&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用2个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定制任务（执行什么操作）&lt;/li&gt;
&lt;li&gt;将任务添加到队列中（GCD会自动将队列中的任务取出，放到对应的线程中执行）（先进先出，后进后出）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建队列&lt;br&gt;队列：把任务放到队列里面，队列先进先出的原则，&lt;br&gt; 串行队列：顺序，一个一个执行(必须一个任务执行完了，才能从队列里面取出下一个任务)&lt;br&gt; 并发队列：同时执行很多个任务（可以同时取出很多个任务，只要有线程去执行）&lt;br&gt;1&amp;gt;获取全局并发队列:&lt;br&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/code&gt;&lt;br&gt;2&amp;gt;获取系统主线程关联的串行队列&lt;br&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_main_queue();&lt;/code&gt;&lt;br&gt;3&amp;gt;创建串行队列&lt;br&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;quot;mmmm.queue&amp;quot;, DISPATCH_QUEUE_SERIAL);&lt;/code&gt;&lt;br&gt;4&amp;gt;创建并发队列&lt;br&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_queue_create(&amp;quot;mmmm.queue&amp;quot;, DISPATCH_QUEUE_CONCURRENT);&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步：dispatch_sync(dispatch_queue_t, dispatch_block_t block);&lt;br&gt;异步：dispatch_async(dispatch_queue_t, dispatch_block_t block);&lt;br&gt;同步和异步的区别：&lt;br&gt;同步：在当前线程中执行,不具备开启新线程的能力&lt;br&gt;异步：在另一条新线程中执行，具备开启新线程的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用GCD下载图片&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;dispatch_async&lt;/span&gt;(dispatch_get_global_queue(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//耗时操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//1.url,确定一个网络上的资源文件路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *url = [&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;http://p18.qhimg.com/t0144d6a0802f22be4f.jpg&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//2.通过URL下载对应的网络资源，网络资源传输的都是二进制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; dataWithContentsOfFile:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//3.把二进制转成图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *image = [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//4.更新UI，在主线程-&amp;gt;直接把主线程添加到主队列，就会在主队列执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;dispatch_async&lt;/span&gt;(dispatch_get_global_queue(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.iconView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.image&lt;/span&gt; = image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多次执行的任务&lt;br&gt;控制的代码块执行了5次。&lt;br&gt;` dispatch_apply(5, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^(size_t time){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLog(@&amp;quot;==执行【%lu次】==%@&amp;quot;,time,[NSThread currentThread]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}`&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只执行一次的任务&lt;br&gt;`static dispatch_once_t oneceToken;&lt;br&gt; dispatch_once(&amp;amp;oneceToken,^{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSLog(@&amp;quot;==执行代码块==&amp;quot;);
//线程暂停3秒
[NSThread sleepForTimeInterval:3];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; });`&lt;br&gt;dispatch_once_t控制函数只执行一次&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;后台运行&quot;&gt;&lt;a href=&quot;#后台运行&quot; class=&quot;headerlink&quot; title=&quot;后台运行&quot;&gt;&lt;/a&gt;后台运行&lt;/h1&gt;&lt;p&gt;进入后台，系统会自动回调系统程序委托的applicationDidEnterBackground：方法。所有应用需要做：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 释放所有可以释放的内存  
- 保存用户数据或状态信息，所有没写入磁盘的文件或信息，在进入后台之前，都应该写入磁盘，因为程序可能在后台被杀死。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;进入后台时释放内存&lt;br&gt;如果应用没有启用ARC机制，程序需要在进入后台是，将那些需要释放的资源的引用计数变为0，从而让系统回收这些资源，当应用转入前台，系统需要重新恢复这些资源。&lt;br&gt;如果应用启用了ARC机制，程序只要在应用进入后台时，将应用那些需要释放的资源的变量赋值为nil即可。当应用转入前台是，系统需要重新恢复这些资源。&lt;/li&gt;
&lt;li&gt;进入后台时保存状态  &lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用NSUserDefault读取系统已经保存的积分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSNumber* scoreNumber;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((scoreNumber = [[NSUserDefaults standardUserDefaults]&lt;span class=&quot;string&quot;&gt;setInteger:&lt;/span&gt;score &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;score&quot;&lt;/span&gt;])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       score = scoreNumber.integerValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;请求更多后台时间&lt;br&gt;为了请求更多后台时间，应该使用如下步骤：&lt;ul&gt;
&lt;li&gt;调用UIApplication对象的beginBackgroundTaskWithExpirationHandler:方法请求获取更多的后台执行时间。&lt;/li&gt;
&lt;li&gt;调用dispatch_async()方法将指定代码块提交给后台执行&lt;/li&gt;
&lt;li&gt;后台任务执行完成是，调用UIApplication对象的endBackgroundTask:方法结束后台任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;使用NSOperation与NSOperationQueue实现多线程&quot;&gt;&lt;a href=&quot;#使用NSOperation与NSOperationQueue实现多线程&quot; class=&quot;headerlink&quot; title=&quot;使用NSOperation与NSOperationQueue实现多线程&quot;&gt;&lt;/a&gt;使用NSOperation与NSOperationQueue实现多线程&lt;/h1&gt;&lt;p&gt;使用步骤：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 创建NSOperationQueue队列，并为该队列设置相关属性。  
- 创建NSOperation子类的对象，并将该对象提交给NSOperationQueue队列，该队列将会按顺序启动每个NSOperation。   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MaxConcurrentOperationCount    设置最大并发线程数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用NSblockOperation下载图片&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//创建NSBlock&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSBlockOperation&lt;/span&gt; *operation = [&lt;span class=&quot;built_in&quot;&gt;NSBlockOperation&lt;/span&gt; blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//从网络获取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [[&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; alloc]initWithContentsOfURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:url]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;//将网络数据初始化为UIImage对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *image = [[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; alloc]initWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(image!= &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//在主线程中updateUI：方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; performSelectorOnMainThread:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(updateUI:)withObject:image waitUntilDone:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;下载图片出现错误&quot;&lt;/span&gt;);           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;定义NSOperation子类&lt;br&gt;创建NSOperation的子类需要重写一个方法：-（void）main，该方法将作为NSOpQueue完成任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是多线程&lt;br&gt;进程：是指在系统中正在运行的一个应用程序。1个进程要想执行任务，必须得有线程。（一个进程至少要有一个线程）特征：独立性，动态性，并发性。&lt;br&gt;线程：是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。当一个程序运行时，内部可能包含了多个顺序执行流，每个顺序执行流就是一个线程的。&lt;br&gt;多线程：在一个进程中可以开启多个线程，每条线程可以并发（同时）执行不同的任务。&lt;br&gt;多线程编程的优点：  &lt;ul&gt;
&lt;li&gt;进程间不能共享内存，但线程之间共享内存非常容易&lt;/li&gt;
&lt;li&gt;系统创建进程需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。&lt;/li&gt;
&lt;li&gt;iOS提供了多种多线程实现方式，从而简化了iOS的多线程编程。&lt;br&gt;参考：&lt;a href=&quot;http://1108038.blog.51cto.com/1098038/420330&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://1108038.blog.51cto.com/1098038/420330&lt;/a&gt;&lt;br&gt;进程间通信—&amp;gt;管道(pipe)、信号(signal)、消息队列、共享内存、信号量、套接字；&lt;br&gt;线程间通信—&amp;gt;信号量、消息、事件event&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;iOS中如何实现多线程&lt;ul&gt;
&lt;li&gt;pthread（一套通用的多线程API，使用难度大 &lt;strong&gt;C语言（底层）&lt;/strong&gt;）程序员管理，几乎不用&lt;br&gt;&lt;code&gt;#include &amp;lt;pthread.h&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;NSThread（面向对象，简单易用，可直接操作多线程对象,&lt;strong&gt;OC&lt;/strong&gt;），偶尔使用&lt;/li&gt;
&lt;li&gt;GCD（旨在替代NSThread等线程技术，充分利用设备的多核，&lt;strong&gt;C语言&lt;/strong&gt;）自动管理，经常使用&lt;/li&gt;
&lt;li&gt;NSOperation（基于GCD，比GCD多了一些简单实用的功能，&lt;strong&gt;OC&lt;/strong&gt;）自动管理，经常使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程间通讯的方法&lt;br&gt;控制器在子线程发送请求给服务器&lt;br&gt;服务器在主线程刷新UI界面到控制器&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;还可以使用GCD，主线程和子线程的通信。&lt;br&gt; &lt;code&gt;dispath_async(dispatch_get_main_queue(),^{
 });&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络图片处理问题中怎么解决一个相同的网络地址重复请求的问题？&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%87%AA%E5%AE%9A%E4%B9%89NSOperation%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;利用字典（图片地址为key，下载操作为value）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多线程安全的几种解决办法及多线程安全怎么控制？&lt;br&gt;线程安全的概念: 就是在多个线程同时执行的时候，能够保证资源信息的准确性.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;苹果约定，&lt;strong&gt;所有程序的更新UI都在主线程进行&lt;/strong&gt;，也就不会出现多个线程同时改变一个资源。在主线程更新UI，有什么好处？只在主线程更新UI，就不会出现多个线程同时改变同一个UI控件;主线程的优先级最高。也就意味UI的更新优先级高。 会让用户感觉很流畅    .&lt;/li&gt;
&lt;li&gt;如果要防止资源抢夺，得用synchronized进行加锁保护.&lt;br&gt;线程同步：多条线程按顺序的执行任务（互斥锁）互斥锁使用格式&lt;br&gt;&lt;code&gt;@synchronized(锁对象){
//需要锁定的代码
}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果异步操作要保证线程安全等问题, 尽量使用GCD(有些函数默认就是安全的)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD内部怎么实现的&lt;br&gt;1&amp;gt; iOS和OS X的核心是XNU内核，GCD是基于XNU内核实现的&lt;br&gt;2&amp;gt; GCD的API全部在libdispatch库中&lt;br&gt;3&amp;gt; GCD的底层实现主要有Dispatch Queue和Dispatch Source&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dispatch Queue ：管理block(操作)&lt;/li&gt;
&lt;li&gt;Dispatch Source ：处理事件(比如线程间的通讯)&lt;br&gt;补充：GCD：Grand Central Dispatch “牛逼的中枢调度器”，自动利用更多CPU内核，自动管理线程的生命周期（创建线程，调度任务，销毁线程).使用2个步骤：  &lt;/li&gt;
&lt;li&gt;定制任务（执行什么操作）用block来封装任务  &lt;/li&gt;
&lt;li&gt;将任务添加到队列中（自动将队列中的任务取出，放到对应的线程中执行）（先进先出，后进后出）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD和NSoperation区别&lt;br&gt;1&amp;gt;GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装&lt;br&gt;2&amp;gt;GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序、设置最大并发数量&lt;br&gt;3&amp;gt;NSOperationQueue可以在轻松在Operation间设置依赖关系，而GCD需要写很多的代码才能实现&lt;br&gt;4&amp;gt;NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）&lt;br&gt;5&amp;gt;GCD的执行速度比NSOperationQueue快&lt;br&gt;任务之间不太互相依赖：GCD&lt;br&gt;任务之间有依赖(或者要监听任务的执行情况)：NSOperationQueue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Socket的实现原理以及Socket是如何实现通信的？&lt;br&gt;Socket：称之为套接字，是一种用于网络传输的“工具”。&lt;br&gt;socket的实现原理：是基于TCP/UDP的（TCP：传输控制协议，是一种面向连接的，安全的，基于IP传输层的协议，三次握手。例如：XMPP等网络聊天）（UDP：传输控制协议，是一种面向连接的，不安全的，基于IP传输层的协议，特点：快，只管发，不管收到没有。例如：游戏,QQ视频，红蜘蛛）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;http协议的实现&lt;br&gt;HTTP：是一种超文本协议，定义了网络传输的格式（短连接）&lt;br&gt;如果利用HTTP做聊天，每次都要重新创建连接，因为HTTP是短连接，一次回话后就断开了，如果利用HTTP做聊天，如果聊天特别频繁，会不断的创建连接，消耗资源，性能不好，服务端不会主动给客户端发送请求。      &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;runloop定时源和输入源?&lt;br&gt;1&amp;gt;你创建的程序不需要显示的创建run loop；每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象, 主线程会自行创建并运行run loop&lt;br&gt;2&amp;gt;Run loop处理的输入事件有两种不同的来源：输入源（input source）（异步）（处理其他线程回到主线程的消息）和定时源（timer source）（同步）（定时检查界面上有没有点击事件，检查主线程的事件）&lt;br&gt;3&amp;gt;输入源传递异步消息，通常来自于其他线程或者程序。定时源则传递同步消息，在特定时间或者一定的时间间隔发生&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runloop.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;NSRunLoop的实现机制,及在多线程中如何使用&lt;br&gt;NSRunLoop是IOS消息机制的处理模式.&lt;blockquote&gt;
&lt;p&gt;1.NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。&lt;br&gt;2.NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)异步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。&lt;br&gt;3.runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;只有在为你的程序创建次线程的时候，才需要运行run loop。对于程序的主线程而言，run loop是关键部分。Cocoa提供了运行主线程run loop的代码同时也会自动运行run loop。IOS程序UIApplication中的run方法在程序正常启动的时候就会启动run loop。如果你使用xcode提供的模板创建的程序，那你永远不需要自己去启动run loop&lt;/li&gt;
&lt;li&gt;在多线程中，你需要判断是否需要run loop。如果需要run loop，那么你要负责配置run loop并启动。你不需要在任何情况下都去启动run loop。比如，你使用线程去处理一个预先定义好的耗时极长的任务时，你就可以毋需启动run loop。Run loop只在你要和线程有交互时才需要&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不论是什么开发，多线程网络始终是学习的重点。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://peilinghui.com/categories/iOS/"/>
    
    
      <category term="多线程" scheme="http://peilinghui.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CocosPods</title>
    <link href="http://peilinghui.com/2016/03/04/CocosPods/"/>
    <id>http://peilinghui.com/2016/03/04/CocosPods/</id>
    <published>2016-03-04T08:54:28.000Z</published>
    <updated>2016-05-04T12:59:37.000Z</updated>
    
    <content type="html">&lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;CocoaPods是什么？&quot;&gt;&lt;a href=&quot;#CocoaPods是什么？&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods是什么？&quot;&gt;&lt;/a&gt;CocoaPods是什么？&lt;/h1&gt;&lt;p&gt;CocoaPods应该是iOS最常用最有名的类库管理工具.开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;a href=&quot;https://blog.cocoapods.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CocoaPod&lt;/a&gt;  &lt;/p&gt;
&lt;h1 id=&quot;Cocoapods原理&quot;&gt;&lt;a href=&quot;#Cocoapods原理&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods原理&quot;&gt;&lt;/a&gt;Cocoapods原理&lt;/h1&gt;&lt;p&gt;Pods项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。&lt;br&gt;对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh的 bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;br&gt;CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;
&lt;h1 id=&quot;安装CocoaPods&quot;&gt;&lt;a href=&quot;#安装CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;安装CocoaPods&quot;&gt;&lt;/a&gt;安装CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;要先确保电脑本地是否有 Ruby环境，因为CocoaPods运行于 Ruby之上，默认情况下，Mac 是自带了 Ruby 环境的，可以通过命令行 ruby -v查看当前Ruby的版本。&lt;br&gt;执行命令：&lt;br&gt; &lt;code&gt;$ ruby -v&lt;/code&gt;&lt;br&gt;已经安装了Ruby开发环境，那么在终端（Terminal）中使用以下命令即可直接安装：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ pod setup&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装过程中可能遇到的问题&lt;br&gt;①执行完install命令半天没反应&lt;br&gt;这有可能是因为Ruby的默认源使用的是cocoapods.org，国内访问这个网址有时候会有问题，网上的一种解决方案是将远替换成淘宝的，替换方式如下：&lt;br&gt; &lt;code&gt;$ gem sources --remove https://rubygems.org/&lt;/code&gt;&lt;br&gt;//等有反应之后再敲入以下命令&lt;br&gt; &lt;code&gt;$ gem sources -a https://ruby.taobao.org/&lt;/code&gt;&lt;br&gt;要想验证是否替换成功了，可以执行：&lt;br&gt; &lt;code&gt;$ gem sources -l&lt;/code&gt;&lt;br&gt;正常的输出是：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%9B%BE1%EF%BC%88%E9%95%9C%E5%83%8F%EF%BC%89.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;②gem版本过老&lt;br&gt;gem是管理Ruby库和程序的标准包，如果它的版本过低也可能导致安装失败，解决方案自然是升级gem，执行下述命令即可：&lt;br&gt;    &lt;code&gt;$ sudo gem update --system&lt;/code&gt;&lt;br&gt;③安装完成后，执行pod setup命令时报错：&lt;br&gt;这就是路径设置的问题，可以通过执行：&lt;br&gt;    &lt;code&gt;$ rvm use ruby-1.9.3-p448&lt;/code&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;升级CocoaPods&lt;br&gt;升级很简单，再次执行安装命令即可：&lt;br&gt; &lt;code&gt;$ sudo gem install cocoapods&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看pod版本输入命令：&lt;br&gt; &lt;code&gt;$ pod --version&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;使用CocoaPods&quot;&gt;&lt;a href=&quot;#使用CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods&quot;&gt;&lt;/a&gt;使用CocoaPods&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;创建一个项目，比如swift或者oc项目，然后在终端下打开文件夹：&lt;br&gt;输入命令：&lt;br&gt; &lt;code&gt;$ touch Podfile&lt;/code&gt;&lt;br&gt; &lt;code&gt;$ vi Podfile&lt;/code&gt;   &lt;/li&gt;
&lt;li&gt;可以输入命令&lt;br&gt; &lt;code&gt;$ pod search ...&lt;/code&gt;来找到所需要的版本  &lt;/li&gt;
&lt;li&gt;在Podfile中输入&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/podfile.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注意：ios小写。一般设置为‘8.0’，这样就可以适配多个版本。&lt;/li&gt;
&lt;li&gt;然后仍旧是在项目根目录下执行如下命令&lt;br&gt; &lt;code&gt;$ pod install&lt;/code&gt;&lt;br&gt;现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。&lt;/li&gt;
&lt;li&gt;每次更改了 Podfile 文件，你需要重新执行一次pod update命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&quot;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cnbin.github.io/blog/2015/05/25/cocoapods-an-zhuang-he-shi-yong/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/index.html&lt;/a&gt;&lt;br&gt;深入理解CocoaPods:&lt;a href=&quot;http://objccn.io/issue-6-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://objccn.io/issue-6-4/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;也在项目中用过一些第三方框架，第三方库，然后就知道了CocoaPods.&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://peilinghui.com/categories/iOS/"/>
    
    
      <category term="CocoaPods，iOS" scheme="http://peilinghui.com/tags/CocoaPods%EF%BC%8CiOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS面试题总结</title>
    <link href="http://peilinghui.com/2016/03/01/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2016/03/01/iOS面试题总结/</id>
    <published>2016-03-01T08:57:25.000Z</published>
    <updated>2016-04-19T02:23:26.000Z</updated>
    
    <content type="html">&lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;a href=&quot;#内存管理（MRC和ARC）&quot; class=&quot;headerlink&quot; title=&quot;内存管理（MRC和ARC）&quot;&gt;&lt;/a&gt;内存管理（MRC和ARC）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;讲解：&lt;a href=&quot;http://www.jianshu.com/p/3129ce12e020&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/3129ce12e020&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？&lt;br&gt;注意：1&amp;gt;block的内存管理 (block的实现是基于指针和函数指针) &lt;ul&gt;
&lt;li&gt;如果没有copy操作，block代码默认放在栈内存（弱引用）。&lt;/li&gt;
&lt;li&gt;如果有copy操作，block升级放在堆内存（强引用）。&lt;br&gt;2&amp;gt;防止循环引用&lt;br&gt; 解决：非ARC（MRC）：&lt;strong&gt;__block&lt;/strong&gt;&lt;br&gt;ARC：&lt;strong&gt;__weak&lt;/strong&gt;或者&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;补充：&lt;strong&gt;__block&lt;/strong&gt; 和 &lt;strong&gt;__weak&lt;/strong&gt;修饰符的区别&lt;br&gt;&lt;strong&gt;__block&lt;/strong&gt; 不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。&lt;br&gt;&lt;strong&gt;__weak&lt;/strong&gt;只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。&lt;br&gt;&lt;strong&gt;__block&lt;/strong&gt; 对象可以在block中被重新赋值，&lt;strong&gt;__weak&lt;/strong&gt;不可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动释放池底层怎么实现&lt;br&gt;自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.&lt;/li&gt;
&lt;li&gt;怎么保证多人开发进行内存泄露的检查.&lt;br&gt;1&amp;gt;使用Product-&amp;gt;Analyze进行代码的静态分析&lt;br&gt;2&amp;gt;为避免不必要的麻烦, 多人开发时尽量使用ARC&lt;/li&gt;
&lt;li&gt;什么情况下会发生内存泄漏和内存溢出？&lt;br&gt;内存泄露：不再需要的对象没有释放，导致内存泄露，内存泄露会导致应用闪退。循环引用造成内存不可回收。&lt;br&gt;1&amp;gt;block中使用strong self，如果不注意很容易造成内存泄露&lt;br&gt;2&amp;gt;delegate如果设置为strong也很大可能造成内存泄露，不过具体还要看有没有循环引用.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;引用计数：&quot;&gt;&lt;a href=&quot;#引用计数：&quot; class=&quot;headerlink&quot; title=&quot;引用计数：&quot;&gt;&lt;/a&gt;&lt;strong&gt;引用计数&lt;/strong&gt;：&lt;/h3&gt;&lt;p&gt;OC在内存管理上采用了引用计数（retain count），在对象内部保存一个数字，用来表示被引用的次数。init、new和copy都会让retain count加1。当销毁对象的时候，系统不会直接调用dealloc方法，而是先调用release，让retain count 减1，当retain count等于0的时候，系统才会调用dealloc方法来销毁对象。&lt;br&gt;在指针赋值的时候，retain count是不会自动增加的，为了避免上面所说的错误，我们需要在赋值的时候手动retain一次，让retain count增加1。&lt;br&gt;ClassA &lt;em&gt;a = [[ClassA alloc] init]; // retain count = 1&lt;br&gt;ClassA &lt;/em&gt;b = a;&lt;br&gt;[b retain]; // retain count = 2&lt;br&gt;[a dealloc];&lt;br&gt;这样在执行到第四行的时候，对象的retain count只是减了1，并没有被销毁，指针b仍然有效。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄露&lt;/strong&gt;：&lt;br&gt;就如上面列子所示，当生成ClassA对象时，指针a拥有对该对象的访问权。如果失去了对一个对象的访问权，而又没有将retain count减至0，就会造成内存泄露。也就是说，分配出去的内存无法回收。&lt;br&gt;ClassA *a = [[ClassA alloc] init];&lt;br&gt;a = nil; &lt;/p&gt;
&lt;h3 id=&quot;Autorelease-Pool&quot;&gt;&lt;a href=&quot;#Autorelease-Pool&quot; class=&quot;headerlink&quot; title=&quot;Autorelease Pool&quot;&gt;&lt;/a&gt;&lt;strong&gt;Autorelease Pool&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;一般地，在新建一个iphone 项目的时候，xcode会自动地为你创建一个autorelease pool，这个pool就写在Main函数里面。&lt;br&gt;在NSAutoreleasePool中包含了一个可变数组，用来存储被声明为autorelease的对象。当NSAutoreleasePool自身被销毁的时候，它会遍历这个数组，release数组中的每一个成员（注意，这里只是release，并没有直接销毁对象）。若成员的retain count 大于1，那么对象没有被销毁，造成内存泄露。&lt;br&gt;默认的NSAutoreleasePool只有一个，你可以在你的程序中创建NSAutoreleasePool，被标记为autorelease的对象会跟最近的 NSAutoreleasePool匹配。&lt;br&gt; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];&lt;br&gt;//Create some objects&lt;br&gt;//do something…&lt;br&gt;[pool  release];&lt;br&gt;你也可以嵌套使用NSAutoreleasePool ，就像你嵌套使用for一样。&lt;br&gt;即使NSAutoreleasePool 看起来没有手动release那么繁琐，但是使用NSAutoreleasePool 来管理内存的方法还是不推荐的。因为在一个NSAutoreleasePool 里面，如果有大量对象被标记为autorelease，在程序运行的时候，内存会剧增，直到NSAutoreleasePool 被销毁的时候才会释放。如果其中的对象足够的多，在运行过程中你可能会收到系统的低内存警告，或者直接crash。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Autorelease Pool 扩展&lt;/strong&gt;：&lt;br&gt; 如果你极具好奇心，把Main函数中的NSAutoreleasePool代码删除掉，然后再自己的代码中把对象声明为autorelease，你会 发现系统并不会给你发出错误信息或者警告。用内存检测工具去检测内存的话，你可能会惊奇的发现你的对象仍然被销毁了。&lt;br&gt;其实在新生成一个Run Loop的时候，系统会自动的创建一个NSAutoreleasePool ，这个NSAutoreleasePool 无法被删除。&lt;br&gt;在做内存测试的时候，请不要用NSString。OC对字符串作了特殊处理&lt;br&gt;NSString *str =[[NSString alloc] stringWithString:@”123”];&lt;br&gt;在输出str的retain count 的时候，你会发现retain count 大于1。  &lt;/p&gt;
&lt;h3 id=&quot;手动管理内存&quot;&gt;&lt;a href=&quot;#手动管理内存&quot; class=&quot;headerlink&quot; title=&quot;手动管理内存&quot;&gt;&lt;/a&gt;&lt;strong&gt;手动管理内存&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;使用alloc、new、copy创建一个对象，该对象的retain count都等于1，需要用release来释放该对象。谁创建，谁去释放。在这3钟方法以外的方法创建的对象，都被系统默认的声明为autorelease。&lt;br&gt;ClassA &lt;em&gt;a = [[ClassA alloc] init];//对象的retain count等于1&lt;br&gt;ClassA &lt;/em&gt;b = a;//把一个指针赋值给另外一个指针的时候，a 指针所指向的对象的引用次数并没有增加，也就是说，对象的retain count依然等于1。&lt;br&gt;[b retain];//retain了之后，retain count加1&lt;br&gt;[a release];//a指针放弃了对对象的访问权，对象的retain count 减1，对象没有被销毁。&lt;br&gt;[b release];//只有当b也执行了release方法之后，才会将对象销毁掉。因此，谁retain了，谁就要release。&lt;br&gt;b = nil;//对象被销毁之后，指针依然是存在的。所以在release了之后，最好把指针赋为空，防止无头指针的出现&lt;br&gt;顺便一说，release一个空指针是合法的，但是不会发生任何事情。&lt;br&gt;如果你在一个函数中创建并返回一个对象，那么你需要把这个对象声明为autorelease.&lt;br&gt;(ClassA  &lt;em&gt;)Function(){&lt;br&gt;ClassA &lt;/em&gt;a = [[[ClassA alloc] init] autorelease];&lt;br&gt;return a;}&lt;br&gt;不这样做的话，会造成内存泄露。&lt;/p&gt;
&lt;h3 id=&quot;属性与内存管理&quot;&gt;&lt;a href=&quot;#属性与内存管理&quot; class=&quot;headerlink&quot; title=&quot;属性与内存管理&quot;&gt;&lt;/a&gt;&lt;strong&gt;属性与内存管理&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;@property实际上是getter和setter，@synthesize是合成这2个方法.&lt;br&gt;@property()，如果你里面什么都不写，那么系统会默认的把你的属性设置为：&lt;br&gt;@property(atomic, assign)….  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于nonatomic&lt;/strong&gt;&lt;br&gt;指定 nonatomic特性，编译器合成访问器的时候不会去考虑线程安全问题。&lt;br&gt;如果你的多个线程在同一时间会访问到这个变量的话，可以将特性声明为 atomic(通过省略关键字nonatomic)。在这种特性的状态下，编辑器在合成访问器的时候就会在访问器里面加一个锁 （@synchronized），在同一时间只能有一个线程访问该变量。&lt;br&gt;但是使用锁是需要付出代价的，一个声明为atomic的属性，在设置和获取这个变量的时候都要比声明为nonatomic的慢。所以如果你不打算编写多线程代码，最好把变量的属性特性声明为nonatomic。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于assign、retain和copy&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign：适用基本数据类型，（不适用于对象）简单赋值，不更改索引计数（因为assign对于在引用计数下的对象特性，只创建了一个弱引用（也就是平时说的浅复制）。这样使用变量会很危险。当你release了前一个对象的时候，被赋值的对象指针就成了无头指针了。因此在为对象类型的变量声明属性的时候，尽量不要使用assign。）&lt;br&gt;retain：适用于普通对象。释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1。&lt;br&gt;copy：适用于NSString与block。建立一个索引计数为1的对象，然后释放旧对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;weak和strong的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;weak和strong不同的是 当一个对象不再有strong类型的指针指向它的时候 它会被释放 ，即使还有weak型指针指向它。一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;copy与retain的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;copy其实是建立了一个相同的对象，而retain不是；&lt;br&gt;copy是内容拷贝，retain是指针拷贝；&lt;br&gt;copy是内容的拷贝 ,对于像NSString,的确是这样，如果拷贝的是NSArray这时只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;assign和weak的区别；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；而weak一旦不进行使用后，永远不会使用了，就不会产生野指针！ 用weak避免循环引用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;单例设计模式-Singleton&quot;&gt;&lt;a href=&quot;#单例设计模式-Singleton&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式(Singleton)&quot;&gt;&lt;/a&gt;单例设计模式(Singleton)&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;定义：它可以保证某个类创建出来的对象永远只有1个。&lt;/li&gt;
&lt;li&gt;作用：节省内存资源，一个应用就一个对象  例如：工具类(音频Sound)&lt;/li&gt;
&lt;li&gt;实现：MRC和ARC&lt;/li&gt;
&lt;li&gt;单例模式实现代码：（MRC）&lt;br&gt; &lt;code&gt;static MJSoundTool *_soundTool = nil;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8D%95%E4%BE%8B%E6%8A%BD%E5%87%BA%E5%AE%8F.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;若是ARC：&lt;br&gt;在build加标记-fobjc-arc&lt;br&gt;与MRC类似，只是没有了release，retain。&lt;br&gt;在宏中用&lt;code&gt;if__has_feature(objc_arc)&lt;/code&gt;判断&lt;br&gt;创建单例设计模式的基本步骤：&lt;ul&gt;
&lt;li&gt;声明一个单件对象的静态实例,并初始化为nil。 &lt;/li&gt;
&lt;li&gt;创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类的实例&lt;/li&gt;
&lt;li&gt;实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和初始化对象时,不会产 生另一个对象。&lt;br&gt;&lt;code&gt;@interface MJSoundTool : NSObject&amp;lt;NSCopying&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;覆盖release、autorelease、retain、retainCount方法, 以此确保单例的状态。 &lt;/li&gt;
&lt;li&gt;在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实例被正确的创建和初始化。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;&lt;p&gt;作用：间接通过字符串类型的key取出对应的属性值&lt;br&gt;字典中key必须和模型的属性名称一模一样&lt;br&gt;    &lt;code&gt;self.answer = dic[@&amp;quot;answer&amp;quot;];&lt;/code&gt;等价于：&lt;br&gt;    &lt;code&gt;[self setValue:dict[@&amp;quot;answer&amp;quot;] forKeyPath:@&amp;quot;answer&amp;quot;];&lt;/code&gt;&lt;br&gt;一句话：&lt;br&gt;    &lt;code&gt;[self setValuesForKeysWithDictionary:dict];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;keyPath包含了key的功能&lt;br&gt;key：只能访问当前对象的属性&lt;br&gt;keyPath：能利用运算符一层一层往内部访问属性  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;键值编码（key-value coding）是一种间接更改对象状态的方式。通过传入的字符串（key）查找要更改的对象的状态。查找的规则是，先查找以字符串（key）命名的getter和setter方法。如果没有找到对应的方法，再查找key和_key的实例变量。KVC 是字典转模型，模型转字典的神器  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KVC中基本调用的两个方法：&lt;br&gt;valueForKey:&lt;br&gt; &lt;code&gt;NSString *name = [self.studentModel valueForKey:@&amp;quot;name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKey:&lt;br&gt; &lt;code&gt;[self.studentModel setValue:@&amp;quot;李四&amp;quot; forKey:@&amp;quot;name&amp;quot;];&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于标量值，会自动进行装箱和拆箱。&lt;br&gt;使用键路径：&lt;br&gt;valueForKeyPath:&lt;br&gt; &lt;code&gt;NSString *phone = [self.schoolModel valueForKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;setValue:forKeyPath:&lt;br&gt; &lt;code&gt;[self.schoolModel setValue:@&amp;quot;初三五班&amp;quot; forKeyPath:@&amp;quot;classModel.name&amp;quot;];&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVC%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;p&gt;作用：属性监听&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/KVO.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;strong&gt;讲解&lt;/strong&gt;：&lt;a href=&quot;http://www.jianshu.com/p/0492b841b500&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/0492b841b500&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/8f83f592a354#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/8f83f592a354#&lt;/a&gt;&lt;br&gt;内部实现原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KVO是基于runtime机制实现的&lt;/li&gt;
&lt;li&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。&lt;br&gt;派生类在被重写的 setter 方法实现真正的通知机制（Person-&amp;gt;NSKVONotifying_Person）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;Foundation&quot;&gt;&lt;a href=&quot;#Foundation&quot; class=&quot;headerlink&quot; title=&quot;Foundation&quot;&gt;&lt;/a&gt;Foundation&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否可以把比较耗时的操作放在NSNotificationCenter中&lt;br&gt;如果在异步线程发的通知，那么可以执行比较耗时的操作；&lt;br&gt;如果在主线程发的通知，那么就不可以执行比较耗时的操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Foundation对象与Core Foundation对象有什么区别  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Foundation对象是OC的，Core Foundation对象是C对象&lt;/li&gt;
&lt;li&gt;数据类型之间的转换&lt;br&gt;ARC:&lt;strong&gt;__bridge_retained&lt;/strong&gt;,&lt;strong&gt;__bridge_transfer&lt;/strong&gt;&lt;br&gt;非ARC:&lt;strong&gt;__bridge&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不用中间变量,用两种方法交换A和B的值&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B7%A7%E4%BA%A4%E6%8D%A2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;或者使用&lt;strong&gt;位运算符&lt;/strong&gt;异或&lt;br&gt;A = A^B;&lt;br&gt;B = A^B;&lt;br&gt;A = A^B;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否使用Core Text（核心文本（富文本））或者Core Image等？如果使用过，请谈谈你使用Core Text或者Core Image的体验。&lt;br&gt;Core Text：随意修改文本的样式，图文混排(纯C语言)第三方框架:Niumb（国外）&lt;br&gt;Core Image(滤镜处理框架)： 能调节图片的各种属性(对比度, 色温, 色差等)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;controllers间怎么进行通信。&lt;br&gt;在IOS应用不断的出现三种模式来实现这种通信：（可以做到监听）&lt;ul&gt;
&lt;li&gt;委托delegation代理；（一个controller定义了一个协议（一对一）监听scroll的滚动，使用安全，比较规范，但是代码多，先用协议-&amp;gt;代理属性-&amp;gt;设置代理-&amp;gt;实现代理方法）&lt;/li&gt;
&lt;li&gt;通知中心Notification Center；(通知比较灵活(1个通知能被多个对象接收, 1个对象能接收多个通知(多对多)，监听键盘弹出)&lt;/li&gt;
&lt;li&gt;键值观察key value observing，KVO(KVO性能不好(底层会动态产生新的类)，只能监听某个对象属性的改变, 不推荐使用(1个对象的属性能被多个对象监听(一对多)监听对象属性的改变)&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/dqjyong/article/details/7685933&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/dqjyong/article/details/7685933&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是runtime？&lt;br&gt;1&amp;gt; runtime是一套比较底层的纯C语言API, 属于1个C语言库&lt;br&gt;2&amp;gt; 平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者&lt;br&gt;3&amp;gt; 举例:&lt;br&gt;OC：&lt;code&gt;[[Person alloc] init]&lt;/code&gt;&lt;br&gt;runtime: &lt;code&gt;objc_msgSend(objc_msgSend(&amp;quot;Person&amp;quot; , &amp;quot;alloc&amp;quot;), &amp;quot;init&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有什么用？&lt;br&gt;runtime是属于OC的底层, 可以进行一些非常底层的操作。&lt;br&gt;1&amp;gt; 在程序运行过程中，动态创建一个类（比如KVO的底层实现）&lt;br&gt;2&amp;gt; 在程序运行过程中，动态的为某个类添加属性\方法，修改属性\方法.&lt;br&gt;3&amp;gt; 遍历一个类的所有的成员变量(属性)\方法  &lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的头文件：&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt; : 成员变量、类、方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/message.h&amp;gt;: 消息机制&lt;/code&gt;&lt;br&gt; 常见的方法：&lt;br&gt; &lt;code&gt;Ivar class_copyIvarList : 获得某个类内部的所有成员变量&lt;/code&gt;（Ivar是成员变量）&lt;br&gt; &lt;code&gt;Method * class_copyMethodList : 获得某个类内部的所有方法&lt;/code&gt; （Method是成员方法）&lt;br&gt; &lt;code&gt;Method class_getInstanceMethod: 获得某个实例方法（对象方法，减号-开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getClassMethod : 获得某个类方法（加号+开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;method_exchangeImplementations : 交换2个方法的具体实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;objc_msgSend(....)：给对象发送消息&lt;/code&gt;&lt;br&gt;相关应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSCoding(利用runtime遍历模型对象的所有属性来归档和解档）&lt;/li&gt;
&lt;li&gt;字典–&amp;gt;模型（利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）&lt;/li&gt;
&lt;li&gt;KVO（利用runtime动态产生一个类）&lt;ul&gt;
&lt;li&gt;用于封装框架（想怎么改就怎么改）&lt;br&gt;示例第一种应用：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;h1 id=&quot;UI&quot;&gt;&lt;a href=&quot;#UI&quot; class=&quot;headerlink&quot; title=&quot;UI&quot;&gt;&lt;/a&gt;UI&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍一下isa指针,怎么用？&lt;br&gt;每一个对象内部都有一个ISA指针，对象的ISA指针就指向它的真实类型它所属的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;控制器的生命周期&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%89%AF%E6%9C%AC.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;怎么解决缓存池满的问题(cell)&lt;br&gt;ios中不存在缓存池满的情况，因为通常我们ios中开发，对象都是在需要的时候才会创建，有种常用的说话叫做懒加载，还有在UITableView中一般只会创建刚开始出现在屏幕中的cell，之后都是从缓存池里取，不会再创建新对象。缓存池里最多也就一两个对象（缓存池满的这种情况一般在开发java中比较常见，java中一般把最近最少使用的对象先释放）&lt;/li&gt;
&lt;li&gt;如何渲染自定义格式字符串的UILabel?&lt;br&gt;通过NSAttributedString类&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UILabel.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;显示效果如下：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/label%E6%98%BE%E7%A4%BA.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;应用程序&quot;&gt;&lt;a href=&quot;#应用程序&quot; class=&quot;headerlink&quot; title=&quot;应用程序&quot;&gt;&lt;/a&gt;应用程序&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;IOS7之前,后台执行内容有几种形式,都是什么？&lt;br&gt;一般的应用在进入后台的时候可以获取一定时间来运行相关任务，也就是说可以在后台运行一小段时间(10S左右)。&lt;ul&gt;
&lt;li&gt;后台播放音乐&lt;/li&gt;
&lt;li&gt;后台GPS跟踪&lt;/li&gt;
&lt;li&gt;后台voip支持（网络电话）&lt;/li&gt;
&lt;li&gt;7以后查看，在Support Interface orientations中添加Requried background modes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;APP的启动过程,从main文件开始说起&lt;br&gt;程序启动分为两类:&lt;br&gt;1&amp;gt;有storyboard&lt;ul&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain(创建UIApplication对象,创建UIApplication的delegate对象)&lt;/li&gt;
&lt;li&gt;根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(创建UIWindow,创建和设置UIWindow的rootViewController,显示窗口)&lt;br&gt;2&amp;gt;没有storyboard情况下:&lt;/li&gt;
&lt;li&gt;main函数&lt;/li&gt;
&lt;li&gt;UIApplicationMain（创建UIApplication对象，创建UIApplication的delegate对象）&lt;/li&gt;
&lt;li&gt;delegate对象开始处理(监听)系统事件(没有storyboard)&lt;br&gt;程序启动完毕的时候, 就会调用代理的&lt;br&gt;&lt;code&gt;application:didFinishLaunchingWithOptions:方法&lt;/code&gt;&lt;br&gt;&lt;code&gt;在application:didFinishLaunchingWithOptions:中创建UIWindow&lt;/code&gt;&lt;br&gt;创建和设置UIWindow的rootViewController&lt;br&gt;显示窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把程序自己关掉和程序进入后台,远程推送的区别&lt;br&gt;1&amp;gt;关掉后不执行任何代码, 不能处理事件&lt;br&gt;2&amp;gt;应用程序进入&lt;strong&gt;后台状态&lt;/strong&gt;不久后转入&lt;strong&gt;挂起状态&lt;/strong&gt;。在这种状态下，应用程序不执行任何代码，并有可能在任意时候从内存中删除。只有当用户再次运行此应用，应用才会从挂起状态唤醒，代码得以继续执行&lt;br&gt;3&amp;gt;或者进入后台时开启多任务状态，保留在内存中，这样就可以&lt;br&gt;执行系统允许的动作&lt;br&gt;4&amp;gt;远程推送是由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序,当应用程序收到推送的消息会自动调用特定的方法执行事先写好的代码&lt;/li&gt;
&lt;li&gt;本地通知和远程推送通知对基本概念和用法？&lt;br&gt;本地通知和远程推送通知的基本目的都是让应用程序能够通知用户某些事情, 而且不需要应用程序在前台运行.&lt;br&gt;本地通知由本应用负责调用,只能从当前设备上的iOS发出&lt;br&gt;远程通知由远程服务器上的程序发送到APNS,再由APNS把消息推送至设备上的程序&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5.png&quot; alt=&quot;&quot;&gt;&lt;h1 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;客户端安全性处理方式？&lt;ul&gt;
&lt;li&gt;网络数据传输(敏感数据[账号\密码\消费数据\银行卡账号], 不能明文发送)&lt;/li&gt;
&lt;li&gt;协议的问题(自定义协议, 游戏代练)&lt;/li&gt;
&lt;li&gt;本地文件存储(游戏的存档)&lt;/li&gt;
&lt;li&gt;源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sip是什么？&lt;br&gt;SIP（Session Initiation Protocol），会话发起协议&lt;br&gt;SIP是建立VOIP连接的 IETF 标准，IETF是全球互联网最具权威的技术标准化组织.&lt;br&gt;所谓VOIP，就是网络电话，直接用互联网打电话，不用耗手机话费.&lt;/li&gt;
&lt;li&gt;有些图片加载的比较慢怎么处理?你是怎么优化程序的性能的?&lt;br&gt;图片下载放在异步线程;&lt;br&gt;图片下载过程中使用占位图片;&lt;br&gt;如果图片较大，可以考虑多线程断点下载.&lt;/li&gt;
&lt;li&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;ul&gt;
&lt;li&gt;提供给外界的接口功能是否实用、够用&lt;/li&gt;
&lt;li&gt;别人使用我的框架时，能不能根据类名、方法名就猜出接口的具体作用&lt;/li&gt;
&lt;li&gt;别人调用接口时，提供的参数是否够用、调用起来是否简单&lt;/li&gt;
&lt;li&gt;别人使用我的框架时，要不要再导入依赖其他的框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;App需要加载超大量的数据，给服务器发送请求，但是服务器卡住了如何解决？  &lt;ul&gt;
&lt;li&gt;设置请求超时&lt;/li&gt;
&lt;li&gt;给用户提示请求超时&lt;/li&gt;
&lt;li&gt;根据用户操作再次请求数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;json解析的具体实现&lt;br&gt;SBJson&lt;br&gt;JSONKit&lt;br&gt;NSJSONSerialization&lt;/li&gt;
&lt;li&gt;如果在网络数据处理过程中,发现一处比较卡,一般怎么解决？&lt;br&gt;检查网络请求操作是否被放在主线程了&lt;br&gt;看看异步请求的数量是否太多了（子线程数量）&lt;br&gt;数据量是否太大？如果太大，先清除一些不必要的对象（看不见的数据、图片）&lt;br&gt;手机CPU使用率和内存问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;OC的对象类型&quot;&gt;&lt;a href=&quot;#OC的对象类型&quot; class=&quot;headerlink&quot; title=&quot;OC的对象类型&quot;&gt;&lt;/a&gt;OC的对象类型&lt;/h1&gt;&lt;p&gt;objective-C中对象的本质是&lt;strong&gt;isa指针&lt;/strong&gt;.&lt;br&gt;Objective-C对象模型主要包含的内容有：&lt;br&gt; 类对象&lt;br&gt; 元类&lt;br&gt; 对象类型&lt;/p&gt;
&lt;h3 id=&quot;类对象&quot;&gt;&lt;a href=&quot;#类对象&quot; class=&quot;headerlink&quot; title=&quot;类对象&quot;&gt;&lt;/a&gt;类对象&lt;/h3&gt;&lt;h4 id=&quot;id&quot;&gt;&lt;a href=&quot;#id&quot; class=&quot;headerlink&quot; title=&quot;id&quot;&gt;&lt;/a&gt;id&lt;/h4&gt;&lt;p&gt;Objective-C中所有的对象都可以用id类型来表示。而id究竟又是什么呢？在XCode中按Shift + Command + O，并键入objc.h搜索，可以打开objc.h文件。我们可以看到objc.h中对id的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// A pointer to an&lt;span class=&quot;instruction&quot;&gt; instance &lt;/span&gt;of a class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_object *id;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;id是是结构体指针，所以我们在使用id定义对象类型的时候不需要在前面加*.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;id是类实例的指针。但是我们看到的是一个objc_object类型的指针。  &lt;strong&gt;objc_object结构体是什么呢？&lt;/strong&gt;&lt;br&gt;在objc.h中objc_object有如下定义：&lt;br&gt;&lt;figure class=&quot;highlight smali&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Represents an&lt;span class=&quot;instruction&quot;&gt; instance &lt;/span&gt;of a class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAI&lt;span class=&quot;class&quot;&gt;LABILITY;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们在这里看到了&lt;strong&gt;isa指针&lt;/strong&gt;。由此看出Objective-C对象被转化成了C结构体，而这个结构体中含有一个isa实例，isa指针的类型为&lt;strong&gt;Class&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;Class&lt;/strong&gt;定义：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// An opaque type that represents an Objective-C class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;```  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;它也是一个结构体的指针类型.    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**objc_class**定义：  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                           OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size           OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists  OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols  OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Use `Class` instead of `struct objc_class *` */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;该结构体中包含版本的兼容，根据结构体中各变量名我们能大体猜测出各自的作用。这里比较迷惑是又出现了Class类型的isa指针，它与objc_object中也定义的Class类型的isa指针是什么呢？下一节揭晓。&lt;br&gt;&lt;a href=&quot;http://www.wtoutiao.com/p/E17pme.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.wtoutiao.com/p/E17pme.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.devtang.com/2013/10/15/objective-c-object-model/#u7C7B_u7684_u6210_u5458_u53D8_u91CF&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2013/10/15/objective-c-object-model/#u7C7B_u7684_u6210_u5458_u53D8_u91CF&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://foredoomed.org/blog/2014/02/24/object-modeling-of-objective-c/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://foredoomed.org/blog/2014/02/24/object-modeling-of-objective-c/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;快找实习了，近几天要总结一下iOS中重要的知识点。以备面试之用。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://peilinghui.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="OC" scheme="http://peilinghui.com/tags/OC/"/>
    
      <category term="iOS面试" scheme="http://peilinghui.com/tags/iOS%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于iOS中的autolayout</title>
    <link href="http://peilinghui.com/2016/02/28/%E5%85%B3%E4%BA%8EiOS%E4%B8%AD%E7%9A%84autolayout/"/>
    <id>http://peilinghui.com/2016/02/28/关于iOS中的autolayout/</id>
    <published>2016-02-28T14:04:07.000Z</published>
    <updated>2016-03-28T07:51:44.000Z</updated>
    
    <content type="html">&lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;a href=&quot;#autolayout在Storyboard中的使用&quot; class=&quot;headerlink&quot; title=&quot;autolayout在Storyboard中的使用&quot;&gt;&lt;/a&gt;autolayout在Storyboard中的使用&lt;/h2&gt;&lt;h3 id=&quot;三个练习：&quot;&gt;&lt;a href=&quot;#三个练习：&quot; class=&quot;headerlink&quot; title=&quot;三个练习：&quot;&gt;&lt;/a&gt;三个练习：&lt;/h3&gt;&lt;h4 id=&quot;1-练习1&quot;&gt;&lt;a href=&quot;#1-练习1&quot; class=&quot;headerlink&quot; title=&quot;1.练习1&quot;&gt;&lt;/a&gt;1.练习1&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在控制器view底部添加2个view，1个蓝色，1个红色
2个view宽度、高度永远相等
距离父控件左边、右边、下边间距和2个view之间的间距相等  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A01%E7%AD%94%E6%A1%88.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;就是设置蓝色View的左边和下边和右边(相对于红色view)，设置红色view的右边和下边，选中俩个，再设置equal width和height，或者是设置顶部对齐和底部对齐。     &lt;/p&gt;
&lt;h4 id=&quot;练习2&quot;&gt;&lt;a href=&quot;#练习2&quot; class=&quot;headerlink&quot; title=&quot;练习2&quot;&gt;&lt;/a&gt;练习2&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在控制器view顶部添加2个view，1个蓝色，1个红色
2个view高度永远相等,等于50
红色view和蓝色view右边对齐
蓝色view距离父控件左边、右边、上边间距相等,等于30
蓝色view距离红色view间距固定,等于30
红色view的左边和父控件的中点对齐
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E9%A2%98%E7%9B%AE.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%AD%94%E6%A1%882.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A02%E7%AD%94%E6%A1%88.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;练习3&quot;&gt;&lt;a href=&quot;#练习3&quot; class=&quot;headerlink&quot; title=&quot;练习3&quot;&gt;&lt;/a&gt;练习3&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E7%BB%83%E4%B9%A03%E7%9A%84.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;理解垂直居中和水平居中，还有左对齐，右对齐，底部顶部对齐，利用公式：Superview.center Y = Button center Y * 1 -constant &lt;/p&gt;
&lt;h2 id=&quot;代码实现Autolayout&quot;&gt;&lt;a href=&quot;#代码实现Autolayout&quot; class=&quot;headerlink&quot; title=&quot;代码实现Autolayout&quot;&gt;&lt;/a&gt;代码实现Autolayout&lt;/h2&gt;&lt;h3 id=&quot;代码实现Autolayout的步骤&quot;&gt;&lt;a href=&quot;#代码实现Autolayout的步骤&quot; class=&quot;headerlink&quot; title=&quot;代码实现Autolayout的步骤&quot;&gt;&lt;/a&gt;代码实现Autolayout的步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;利用NSLayoutConstraint类创建具体的约束对象&lt;br&gt;一个NSLayoutConstraint对象就代表一个约束&lt;br&gt;创建约束对象的常用方法&lt;br&gt;&lt;code&gt;+(id)constraintWithItem:(id)view1 attribute:(NSLayoutAttribute)attr1 relatedBy:(NSLayoutRelation)relation toItem:(id)view2 attribute:(NSLayoutAttribute)attr2 multiplier:(CGFloat)multiplier constant:(CGFloat)c;&lt;/code&gt;&lt;br&gt; view1 ：要约束的控件&lt;br&gt; attr1 ：约束的类型（做怎样的约束）&lt;br&gt; relation ：与参照控件之间的关系&lt;br&gt; view2 ：参照的控件&lt;br&gt; attr2 ：约束的类型（做怎样的约束）&lt;br&gt; multiplier ：乘数&lt;br&gt; c ：常量&lt;br&gt; 自动布局有个核心公式&lt;br&gt;obj1.property1 =（obj2.property2 * multiplier）+ constant value&lt;/li&gt;
&lt;li&gt;添加约束对象到相应的view上&lt;br&gt;&lt;code&gt;- (void)addConstraint:(NSLayoutConstraint *)constraint;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)addConstraints:(NSArray *)constraints;&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;VFL语言实现layout&quot;&gt;&lt;a href=&quot;#VFL语言实现layout&quot; class=&quot;headerlink&quot; title=&quot;VFL语言实现layout&quot;&gt;&lt;/a&gt;VFL语言实现layout&lt;/h2&gt;&lt;p&gt;1.VFL全称是Visual Format Language，翻译过来是“可视化格式语言”&lt;br&gt;VFL是苹果公司为了简化Autolayout的编码而推出的抽象语言。&lt;/p&gt;
&lt;p&gt;2.使用VFL来创建约束数组&lt;br&gt;&lt;code&gt;+ (NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;&lt;/code&gt;&lt;br&gt;format ：VFL语句&lt;br&gt;opts ：约束类型&lt;br&gt;metrics ：VFL语句中用到的具体数值&lt;br&gt;views ：VFL语句中用到的控件&lt;br&gt;VFL示例：&lt;br&gt;H:[cancelButton(72)]-12-[acceptButton(50)]&lt;br&gt;canelButton宽72，acceptButton宽50，它们之间间距12 &lt;/p&gt;
&lt;p&gt;3.创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义&lt;br&gt;NSDictionaryOfVariableBindings(…)  &lt;/p&gt;
&lt;h2 id=&quot;Masonry&quot;&gt;&lt;a href=&quot;#Masonry&quot; class=&quot;headerlink&quot; title=&quot;Masonry&quot;&gt;&lt;/a&gt;Masonry&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt; Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。  &lt;/p&gt;
&lt;h3 id=&quot;框架下载地址：&quot;&gt;&lt;a href=&quot;#框架下载地址：&quot; class=&quot;headerlink&quot; title=&quot;框架下载地址：&quot;&gt;&lt;/a&gt;框架下载地址：&lt;/h3&gt;&lt;p&gt;   &lt;a href=&quot;https://github.com/Masonry/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Masonry/Masonry&lt;/a&gt;  &lt;/p&gt;
&lt;h3 id=&quot;Masonry介绍与使用实践-快速上手Autolayout&quot;&gt;&lt;a href=&quot;#Masonry介绍与使用实践-快速上手Autolayout&quot; class=&quot;headerlink&quot; title=&quot;Masonry介绍与使用实践(快速上手Autolayout)&quot;&gt;&lt;/a&gt;Masonry介绍与使用实践(快速上手Autolayout)&lt;/h3&gt;&lt;p&gt;  &lt;a href=&quot;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://adad184.com/2014/09/28/use-masonry-to-quick-solve-autolayout/&lt;/a&gt;   &lt;/p&gt;
&lt;h3 id=&quot;案例讲解：&quot;&gt;&lt;a href=&quot;#案例讲解：&quot; class=&quot;headerlink&quot; title=&quot;案例讲解：&quot;&gt;&lt;/a&gt;案例讲解：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.brighttj.com/ios/ios-masonry-demo.html#comment-353&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用方法：&quot;&gt;&lt;a href=&quot;#使用方法：&quot; class=&quot;headerlink&quot; title=&quot;使用方法：&quot;&gt;&lt;/a&gt;使用方法：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.ios122.com/2015/09/masonry/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ios122.com/2015/09/masonry/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用方法：&quot;&gt;&lt;a href=&quot;#常用方法：&quot; class=&quot;headerlink&quot; title=&quot;常用方法：&quot;&gt;&lt;/a&gt;常用方法：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.三个添加约束方法区别
mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错
mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况
mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束
三种函数善加利用 就可以应对各种情况了

2、两个赋值方法区别（equalTo 和 mas_equalTo）
#define equalTo(...)  mas_equalTo(__VA_ARGS__)
#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) 
mas_equalTo对其参数进行了一个自动装箱操作， 除了支持NSNumber数值类型之外还支持CGPoint CGSize UIEdgeInsets
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;基于Autolayout的动画&quot;&gt;&lt;a href=&quot;#基于Autolayout的动画&quot; class=&quot;headerlink&quot; title=&quot;基于Autolayout的动画&quot;&gt;&lt;/a&gt;基于Autolayout的动画&lt;/h2&gt;&lt;p&gt;在修改了约束之后，只要执行下面代码，就能做动画效果&lt;br&gt;&lt;code&gt;[UIView animateWithDuration:1.0 animations:^{
    添加了约束的view layoutIfNeeded];
}];&lt;/code&gt;&lt;br&gt;参考学习：&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何在scrollView中使用Autolayout&quot;&gt;&lt;a href=&quot;#如何在scrollView中使用Autolayout&quot; class=&quot;headerlink&quot; title=&quot;如何在scrollView中使用Autolayout&quot;&gt;&lt;/a&gt;如何在scrollView中使用Autolayout&lt;/h2&gt;&lt;p&gt;scrollView比较特殊，因为它有个contentSize的属性。那么在遇到scrollView时，怎么使用Autolayout呢。其实关键点就一点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ScrollView的contentSize的大小是由其subview的constraints来决定的。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;知道这一点其实就够了，那么基于这个特性，在应用的时候要注意哪些呢？&lt;/p&gt;
&lt;p&gt;   完全依赖scrollView来计算subview的坐标的Constraints设法不行了，计算条件互相依赖的，常见的如left+right+top+bottom不行了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;要保证contentSize可以通过subview的constraints能够计算出来。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;举个栗子：&lt;br&gt;[childView mas_makeConstraints:^(MASConstraintMaker *make) {&lt;br&gt;    make.width.mas_equalTo(scrollView.mas_width);&lt;br&gt;  make.height.mas_equalTo(scrollView.mas_height);&lt;br&gt;  make.leading.mas_equalTo(scrollView.mas_leading);&lt;br&gt;  make.top.mas_equalTo(scrollView.mas_top);&lt;br&gt;  make.bottom.mas_equalTo(scrollView.mas_bottom);&lt;br&gt;  make.trailing.mas_equalTo(scrollView.mas_trailing).multipliedBy(1./4.);&lt;br&gt;}];&lt;/p&gt;
&lt;p&gt;例子中如果scrollView的size是(100x100), 那么contentSize即为(400x100)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Autolayout是一种“自动布局”技术，专门用来布局UI界面做屏幕适配的。相当于安卓中的相对布局。一个控件以另一个为参照进行布局，那么即使屏幕变化，布局也会随着进行微调，以达到良好的视觉效果并且保持了代码的可扩展性。&lt;br&gt; Autolayout的2个核心概念：1.参照 2.约束&lt;br&gt; 花了俩天的时间学习了一下iOS中的autolayout, 总结一下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://peilinghui.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>git学习笔记</title>
    <link href="http://peilinghui.com/2016/02/25/git%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/02/25/git学习/</id>
    <published>2016-02-25T04:21:14.000Z</published>
    <updated>2016-04-12T06:48:21.000Z</updated>
    
    <content type="html">&lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;mac自带git。&lt;/p&gt;
&lt;h1 id=&quot;本地&quot;&gt;&lt;a href=&quot;#本地&quot; class=&quot;headerlink&quot; title=&quot;本地&quot;&gt;&lt;/a&gt;本地&lt;/h1&gt;&lt;h2 id=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;a href=&quot;#git的配置，邮箱地址和用户名&quot; class=&quot;headerlink&quot; title=&quot;git的配置，邮箱地址和用户名&quot;&gt;&lt;/a&gt;git的配置，邮箱地址和用户名&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置邮箱&lt;/strong&gt;&lt;br&gt;$ git config –global user.email “799745776@qq.com”  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;配置用户名&lt;/strong&gt;&lt;br&gt;$ git config –global user.name “plh”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看当前的配置&lt;/strong&gt;&lt;br&gt;$ cat .git/config&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;git命令&quot;&gt;&lt;a href=&quot;#git命令&quot; class=&quot;headerlink&quot; title=&quot;git命令&quot;&gt;&lt;/a&gt;git命令&lt;/h2&gt;&lt;h3 id=&quot;下载代码&quot;&gt;&lt;a href=&quot;#下载代码&quot; class=&quot;headerlink&quot; title=&quot;下载代码&quot;&gt;&lt;/a&gt;下载代码&lt;/h3&gt;&lt;p&gt;$ git clone git@github.com:…….&lt;/p&gt;
&lt;h3 id=&quot;添加文件到Git仓库&quot;&gt;&lt;a href=&quot;#添加文件到Git仓库&quot; class=&quot;headerlink&quot; title=&quot;添加文件到Git仓库&quot;&gt;&lt;/a&gt;添加文件到Git仓库&lt;/h3&gt;&lt;p&gt;先打开指定的文件夹。用cd.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;放在暂缓区的命令&lt;/strong&gt;&lt;br&gt;$ git add Read.md&lt;br&gt;$ git add .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;本地提交仓库&lt;/strong&gt;&lt;br&gt;$ git commit -m “提交代码”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;将提交推送到服务器&lt;/strong&gt;&lt;br&gt;$ git push origin master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;&lt;br&gt;$ git staus&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;更新本地代码&lt;/strong&gt;&lt;br&gt;$ git pull&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;p&gt;先在分支上进行操作，再合并到主干上。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查看所有本地分支&lt;br&gt;$ git branch  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列出所有远程分支&lt;br&gt;$ git branch -r&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;创建分支&lt;/strong&gt;&lt;br&gt;$ git branch V2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;将分支提交到服务器&lt;/strong&gt;&lt;br&gt;$ git push origin V2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;切换分支&lt;/strong&gt;&lt;br&gt;$ git checkout V2&lt;br&gt;修改V2分支上的文件，再提交本地修改，将提交推送到服务器上。分支内容修改，主干不变。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;合并分支到主干&lt;/strong&gt;&lt;br&gt;切换到主干上再合并&lt;br&gt;$ git checkout master&lt;br&gt;$ git merge V2&lt;br&gt;$ git push &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除分支&lt;/strong&gt;&lt;br&gt;$ git branch -d name&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;删除远程分支&lt;/strong&gt;&lt;br&gt;$ git push origin –delete name&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$ git branch -dr [remote/branch]&lt;/p&gt;
&lt;h4 id=&quot;版本还原&quot;&gt;&lt;a href=&quot;#版本还原&quot; class=&quot;headerlink&quot; title=&quot;版本还原&quot;&gt;&lt;/a&gt;版本还原&lt;/h4&gt;&lt;p&gt;$ git checkout V2&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将本地代码还原最近一次提交的修改&lt;br&gt;$ git revert HEAD&lt;br&gt;填写描述信息。保存退出。查看本地文件内容是否修改。&lt;br&gt;git push origin V2&lt;/li&gt;
&lt;li&gt;还原到指定版本&lt;br&gt;$ git revert fxxxx&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示当前分支的版本历史&lt;/strong&gt;&lt;br&gt;$ git log&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前一个版本&lt;/strong&gt;&lt;br&gt;git reset –hard HEAD^  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前两个版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD^^ &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复前 N 版本&lt;/strong&gt;&lt;br&gt;$ git reset –hard HEAD~N  &lt;/p&gt;
&lt;!--N 是数字--&gt; 
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;恢复指定版本&lt;/strong&gt;&lt;br&gt;$ (git lg) git reset –hard 版本号 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;查看指令使用历史，确定要回到未来的哪个版本&lt;/strong&gt;&lt;br&gt;$ git reflog&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git rm 文件名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;远程&quot;&gt;&lt;a href=&quot;#远程&quot; class=&quot;headerlink&quot; title=&quot;远程&quot;&gt;&lt;/a&gt;远程&lt;/h2&gt;&lt;h3 id=&quot;创建SSH-Key&quot;&gt;&lt;a href=&quot;#创建SSH-Key&quot; class=&quot;headerlink&quot; title=&quot;创建SSH Key&quot;&gt;&lt;/a&gt;创建SSH Key&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ssh-keygen -t rsa -C &lt;span class=&quot;string&quot;&gt;&quot;youremail@example.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;远程同步&quot;&gt;&lt;a href=&quot;#远程同步&quot; class=&quot;headerlink&quot; title=&quot;远程同步&quot;&gt;&lt;/a&gt;远程同步&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;下载远程仓库的所有变动&lt;/strong&gt;&lt;br&gt;$ git fetch [remote] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示所有远程仓库&lt;/strong&gt;&lt;br&gt;$ git remote -v&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;显示某个远程仓库的信息&lt;/strong&gt;&lt;br&gt;$ git remote show [remote]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;增加一个新的远程仓库，并命名&lt;/strong&gt;&lt;br&gt;$ git remote add [shortname] [url]  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;取回远程仓库的变化，并与本地分支合并&lt;/strong&gt;&lt;br&gt;$ git pull [remote] [branch] &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;上传本地指定分支到远程仓库&lt;/strong&gt;&lt;br&gt;$  git push [remote] [branch]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;强行推送当前分支到远程仓库，即使有冲突&lt;/strong&gt;&lt;br&gt;$ git push [remote] –force&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;推送所有分支到远程仓库&lt;/strong&gt;&lt;br&gt;$ git push [remote] –all &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h2&gt;&lt;h3 id=&quot;显示本地git库：&quot;&gt;&lt;a href=&quot;#显示本地git库：&quot; class=&quot;headerlink&quot; title=&quot;显示本地git库：&quot;&gt;&lt;/a&gt;显示本地git库：&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;隐藏本地git库&quot;&gt;&lt;a href=&quot;#隐藏本地git库&quot; class=&quot;headerlink&quot; title=&quot;隐藏本地git库&quot;&gt;&lt;/a&gt;隐藏本地git库&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ defaults  write  com.apple.finder AppleShowAllFiles -bool &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ KillAll Finder&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/git.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习git也有一段时间了，准备系统整理一下&lt;br&gt;参考请到此处&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/929606dd18361248578c67b8067c8c017b000&quot;&gt;廖雪峰的官网&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Git" scheme="http://peilinghui.com/categories/Git/"/>
    
    
      <category term="git" scheme="http://peilinghui.com/tags/git/"/>
    
  </entry>
  
</feed>
