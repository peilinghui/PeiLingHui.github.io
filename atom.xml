<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <icon>https://www.gravatar.com/avatar/f1a75c66faf43f3b1652aef0eb09037e</icon>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2019-09-20T10:12:26.885Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Axios源码分析</title>
    <link href="http://peilinghui.com/2019/09/20/Axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://peilinghui.com/2019/09/20/Axios源码分析/</id>
    <published>2019-09-20T06:50:58.000Z</published>
    <updated>2019-09-20T10:12:26.885Z</updated>
    
    <content type="html"><![CDATA[<p>Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><a id="more"></a><p>Axios 的主要特性包括：</p><pre><code>基于 Promise支持浏览器和 node.js可添加拦截器和转换请求和响应数据请求可以取消自动转换 JSON 数据客户端支持防范 XSRF支持各主流浏览器及 IE8+</code></pre><p>Axios的使用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/get?name=xmz'</span>)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response'</span>, response)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error'</span>, error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当业务请求代码发起时，具体执行的是lib/core/Axios.js中的request方法。</p><pre><code>├── /dist/                     # 项目输出目录├── /lib/                      # 项目源码目录│ ├── /cancel/                 # 定义取消功能│ ├── /core/                   # 一些核心功能│ │ ├── Axios.js               # axios的核心主类---------------------------这是其最核心部分│ │ ├── dispatchRequest.js     # 用来调用http请求适配器方法发送请求         |│ │ ├── InterceptorManager.js  # 拦截器构造函数                            |│ │ └── settle.js              # 根据http响应状态，改变Promise的状态--------│ ├── /helpers/                # 一些辅助方法│ ├── /adapters/               # 定义请求的适配器 xhr、http----这个文件夹封装了ajax的请求│ │ ├── http.js                # 实现http适配器│ │ └── xhr.js                 # 实现xhr适配器│ ├── axios.js                 # 对外暴露接口│ ├── defaults.js              # 默认配置 │ └── utils.js                 # 公用工具├── package.json               # 项目信息├── index.d.ts                 # 配置TypeScript的声明文件└── index.js                   # 入口文件</code></pre><h2 id="工厂函数createInstance"><a href="#工厂函数createInstance" class="headerlink" title="工厂函数createInstance"></a>工厂函数createInstance</h2><p>在找到axios/lib/axios.js里面有这个对象，<code>var axios = createInstance(defaults);</code>创建axios这样一个实例函数</p><p>axios/lib/defaults.js是默认配置，默认导出一个对象</p><p>配置：</p><ul><li>全局配置：提供配置参考，实例化的时候可以使用。</li><li>实例配置：一个应用可能需要实例化多个不同的对象（针对不同的接口）所以每个实例化对象都会有自己的配置，可以通过全局配置进行初始化，或合并一个新的配置项</li><li>请求配置：请求的时候需要传入配置与实例配置进行合并。不要影响(赋值引用)</li></ul><p>深度克隆-deepcopy函数，深度克隆对象</p><p>配置合并-configMerge函数，有的是覆盖，有的是合并</p><h2 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h2><p>在 Axios 中，大概是这样添加拦截器：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Add a request interceptor</span><br><span class="line">axios.interceptors.request.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(config) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">config</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">// Add a response interceptor</span><br><span class="line">axios.interceptors.response.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(response) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">response</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>interceptors.request -&gt; request -&gt; interceptors.response -&gt; response<br>而 Axios 内部，很巧妙地实现了上面所说的管道式流程，首先看 lib/core/Axios.js。interceptors.request可以注册函数，在发送请求之前执行，interceptors.response在发送请求并得到数据后执行，then之前执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatchRequest = <span class="built_in">require</span>(<span class="string">'./dispatchRequest'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 省略部分代码...</span></span><br></pre></td></tr></table></figure><p>先看到 Axios 类的定义里面有 interceptors，并且带有 request 和 response 属性，而这 2 个属性都是指向 InterceptorManager 类的实例。这个等下再说，先看 request 方法里 interceptors 的实现。</p><p>我们留意 chain 这个变量，经过 2 次 forEach 操作后，最后的值会变成：(这个 forEach 方法在 InterceptorManager 中定义)</p><h3 id="InterceptorManager管理拦截器"><a href="#InterceptorManager管理拦截器" class="headerlink" title="InterceptorManager管理拦截器"></a>InterceptorManager管理拦截器</h3><p>use()方法接收到两个参数，一个是fulfilled，一个是rejected</p><h2 id="适配器adapters"><a href="#适配器adapters" class="headerlink" title="适配器adapters"></a>适配器adapters</h2><p>通过适配器，把不同的接口进行适配。在adapter的处理逻辑中，axios没有把http和xhr两个模块（一个用于Node.js发送请求，另一个则用于浏览器端发送请求）当成自身的模块直接在dispatchRequest中直接饮用，而是通过配置的方法在default.js文件中进行默认引入。这样既保证了两个模块间的低耦合性，同时又能够为今后用户需要自定义请求发送模块保留了余地。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/axios/axios&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="http://peilinghui.com/2019/09/17/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2019/09/17/JavaScript面试题/</id>
    <published>2019-09-17T06:53:56.000Z</published>
    <updated>2019-09-17T11:37:29.746Z</updated>
    
    <content type="html"><![CDATA[<p>相关面试题</p><a id="more"></a><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。<br>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：666666</p><p>改变：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; (<span class="function"><span class="keyword">function</span><span class="params">(j)</span> &#123;</span></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123; <span class="title">console</span>.<span class="title">log</span><span class="params">( j )</span>;</span></span><br><span class="line">             &#125;, <span class="built_in">j</span>*<span class="number">1000</span> );</span><br><span class="line">         &#125;)( <span class="built_in">i</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：123456</p><p>块作用域和闭包联手便可天下无敌。把var改成let<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><p><code>`</code></p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相关面试题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React新特性Hooks</title>
    <link href="http://peilinghui.com/2019/09/16/React%E6%96%B0%E7%89%B9%E6%80%A7Hooks/"/>
    <id>http://peilinghui.com/2019/09/16/React新特性Hooks/</id>
    <published>2019-09-16T07:25:56.000Z</published>
    <updated>2019-09-18T05:39:59.765Z</updated>
    
    <content type="html"><![CDATA[<p>React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-reference.html</a><br>中文：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-intro.html</a><br><a id="more"></a><br>React 的核心是组件,组件的标准写法是类（class), 组件的最佳写法应该是函数，而不是类。但是函数组件必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p><p>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。就是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来</p><p>总结一下要解决的痛点问题就是：</p><ol><li>在组件之间复用状态逻辑很难</li></ol><ul><li>之前的解决方案是：render props 和高阶组件</li><li>缺点是难理解、存在过多的嵌套形成“嵌套地狱”  </li></ul><ol start="2"><li>复杂组件变得难以理解</li></ol><ul><li>生命周期函数中充斥着各种状态逻辑和副作用</li><li>这些副作用难以复用，且很零散</li></ul><ol start="3"><li>难以理解的Class</li></ol><ul><li>this指针问题</li><li>组件预编译技术（组件折叠）会在class中遇到优化失效的case</li><li>class不能很好的压缩</li><li>class在热重载时会出现不稳定的情况</li></ul><p>React 默认提供的基础Hook。</p><pre><code>useState()useEffect()useContext()</code></pre><p>额外的 Hook</p><pre><code>useReducer()useReduceruseCallbackuseMemouseRefuseImperativeHandleuseLayoutEffectuseDebugValue</code></pre><h2 id="useState-：状态钩子"><a href="#useState-：状态钩子" class="headerlink" title="useState()：状态钩子"></a>useState()：状态钩子</h2><p><code>const [state, setState] = useState(initialState);</code></p><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><p> class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setState(prevState =&gt; &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;.<span class="built_in">..prevState</span>, .<span class="built_in">..updatedValues</span>&#125;<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h2><p><code>const value = useContext(MyContext);</code></p><h2 id="useReducer-：action-钩子"><a href="#useReducer-：action-钩子" class="headerlink" title="useReducer()：action 钩子"></a>useReducer()：action 钩子</h2><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。</p><p>useReducers()钩子用来引入 Reducer 功能。</p><pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre><p>上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。</p><p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p><h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。</p><p>useEffect()的用法如下。</p><pre><code>useEffect(()  =&gt;  {  // Async Action}, [dependencies])</code></pre><p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：&lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://reactjs.org/docs/hooks-reference.html&lt;/a&gt;&lt;br&gt;中文：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-hans.reactjs.org/docs/hooks-intro.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RN第三方组件</title>
    <link href="http://peilinghui.com/2019/09/09/RN%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2019/09/09/RN第三方组件/</id>
    <published>2019-09-09T06:56:21.000Z</published>
    <updated>2019-09-19T09:59:00.156Z</updated>
    
    <content type="html"><![CDATA[<p>用过的一些组件。  </p><a id="more"></a><h1 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h1><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p>react-native-simple-router</p><p>react-native-scrollable-tab-view</p><p>react-native-router-flux</p><p>react-native-router-redux</p><p>react-native-tabbar-navigator(IOS only)</p><p>react-native-navigation</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p><a href="https://github.com/tradle/react-native-crypto" target="_blank" rel="noopener">react-native-crypto</a>此类库支持在 React Native 中使用 node 的 crypto 模块</p><p><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="noopener">https://www.npmjs.com/package/crypto-js</a></p><h1 id="整体框架布局–轮播"><a href="#整体框架布局–轮播" class="headerlink" title="整体框架布局–轮播"></a>整体框架布局–轮播</h1><p>react-native-side-menu 侧栏</p><p>react-native-scrollable-tab-view 可滑动的底部或上部导航栏框架</p><h1 id="轮播视图"><a href="#轮播视图" class="headerlink" title="轮播视图"></a>轮播视图</h1><p><a href="https://github.com/race604/react-native-viewpager" target="_blank" rel="noopener">react-native-viewpager</a> 分页浏览 </p><p><a href="https://github.com/FuYaoDe/react-native-app-intro" target="_blank" rel="noopener">https://github.com/FuYaoDe/react-native-app-intro</a> </p><p><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">https://github.com/appintheair/react-native-looped-carousel react-native-swiper</a> 轮播</p><p><a href="https://github.com/root-two/react-native-drawer" target="_blank" rel="noopener">react-native-drawer</a> 抽屉效果 </p><p><a href="https://github.com/react-native-fellowship/react-native-side-menu" target="_blank" rel="noopener">react-native-side-menu</a></p><p><a href="https://github.com/react-navigation/material-bottom-tabs" target="_blank" rel="noopener">react-navigation-material-bottom-tabs</a>底部tab</p><p>react-native-swiper</p><p>react-native-carousel</p><p>react-native-looped-carousel</p><p>react-native-carousel-control</p><p>react-native-spring-carousel</p><p>react-native-image-carousell</p><h1 id="键盘遮挡"><a href="#键盘遮挡" class="headerlink" title="键盘遮挡"></a>键盘遮挡</h1><p><a href="https://github.com/wix/react-native-keyboard-aware-scrollview" target="_blank" rel="noopener">react-native-keyboard-aware-scrollview</a><br><a href="https://github.com/reactnativecn/react-native-inputscrollview" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-inputscrollview</a> </p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>react-native-icons 图标 </p><p><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener">react-native-vector-icons</a>头像库 矢量</p><h2 id="初始化应用时启动轮播图"><a href="#初始化应用时启动轮播图" class="headerlink" title="初始化应用时启动轮播图"></a>初始化应用时启动轮播图</h2><p><a href="https://github.com/phil-r/react-native-looped-carousel" target="_blank" rel="noopener">react-native-looped-carousel</a></p><p><a href="https://www.npmjs.com/package/react-native-auto-height-image" target="_blank" rel="noopener">react-native-auto-height-image</a>自动调节图片高度</p><p>react-native-image-picker 图片选择器</p><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><p><a href="https://github.com/DylanVann/react-native-fast-image" target="_blank" rel="noopener">react-native-fast-image</a>图片缓存以及预加载</p><p>react-native-rn-cacheimage缓存</p><p><a href>react-native-cache-image</a></p><p><a href>react-native-image-zoom-viewer</a>图片轮播、放大、手势捏合</p><p>react-native-image-pan-zoom</p><p>react-native-image-resizer图片压缩</p><h2 id="图片放大查看"><a href="#图片放大查看" class="headerlink" title="图片放大查看"></a>图片放大查看</h2><p><a href="https://github.com/oblador/react-native-lightbox" target="_blank" rel="noopener">react-native-lightbox</a></p><p><a href="https://github.com/ldn0x7dc/react-native-transformable-image" target="_blank" rel="noopener">react-native-transformable-image</a></p><h2 id="照片选择"><a href="#照片选择" class="headerlink" title="照片选择"></a>照片选择</h2><p><a href="https://github.com/marcshilling/react-native-image-picker" target="_blank" rel="noopener">react-native-image-picker</a></p><p><a href>react-native-camera-roll-picker</a></p><p><a href="https://github.com/ivpusic/react-native-image-crop-picker" target="_blank" rel="noopener">react-native-image-crop-picker</a>图像选择器，可支持摄像头，可配置压缩，可多选图像和可对图像进行裁剪的。</p><p>图片加载进度条 <a href="https://github.com/oblador/react-native-image-progress" target="_blank" rel="noopener">https://github.com/oblador/react-native-image-progress</a></p><h1 id="通知栏"><a href="#通知栏" class="headerlink" title="通知栏"></a>通知栏</h1><p>Noticebar与Snackbar的区别：<a href="http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html" target="_blank" rel="noopener">http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html</a></p><h2 id="noticebar"><a href="#noticebar" class="headerlink" title="noticebar"></a>noticebar</h2><p><a href="https://github.com/seymoe/react-native-noticebar" target="_blank" rel="noopener">react-native-noticebar</a>上下滚动的通知栏</p><p><a href="https://rn.mobile.ant.design/components/notice-bar-cn/#components-notice-bar-demo-basic" target="_blank" rel="noopener">Ant Design Mobile NoticeBar 通告栏</a>滚动播放的noticebar</p><p><a href="https://github.com/peilinghui/BokeDemo/tree/master/React-Native%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%AD%97%E4%BD%93%E8%B7%91%E9%A9%AC%E7%81%AFmarquee" target="_blank" rel="noopener">纯JS跑马灯的text</a></p><p><a href="https://github.com/remobile/react-native-marquee-label" target="_blank" rel="noopener">链接原生Text跑马灯效果</a></p><h2 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h2><p><a href>rn-snackbar</a></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="https://github.com/itinance/react-native-fs" target="_blank" rel="noopener">react-native-fs</a>文件下载、文本存储</p><p>先下载<a href="https://github.com/wkh237/react-native-fetch-blob" target="_blank" rel="noopener">https://github.com/wkh237/react-native-fetch-blob</a><br>或者rn-fetch-blob</p><p>react-native-fileupload 文件上传</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p>react-native-video 视频播放</p><h1 id="滚动列表"><a href="#滚动列表" class="headerlink" title="滚动列表"></a>滚动列表</h1><p><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="noopener">react-native-refreshable-listview</a> 可刷新列表</p><p>react-native-sortable-listview 分类ListView</p><p>单选多选ListView <a href="https://github.com/hinet/react-native-checkboxlist" target="_blank" rel="noopener">https://github.com/hinet/react-native-checkboxlist</a></p><p><a href>react-native-invertible-scroll-view</a> 翻转listview</p><p>recyclerlistview”: “^2.0.0-beta.4”,</p><p>recyclerlistview-gridlayoutprovider”: “^1.0.1”,</p><p><a href="https://github.com/jaysoo/react-native-parallax-scroll-view" target="_blank" rel="noopener">react-native-parallax-scroll-view</a>拉伸最上方图片刷新，类似微信朋友圈刷新</p><p>react-native-lazyload</p><p><a href="https://github.com/sghiassy/react-native-sglistview" target="_blank" rel="noopener">react-native-sglistview</a>ListView的优化 </p><p>react-native-refreshable-listview</p><h1 id="WebView网页"><a href="#WebView网页" class="headerlink" title="WebView网页"></a>WebView网页</h1><p>react-native-htmlview 将 HTML 目录作为本地视图的控件，其风格可以定制 </p><p>react-native-webview-invoke React Native和WebView中的函数可以互相调用</p><p>react-native-easy-toast 一款简单易用的 Toast 组件，支持 Android&amp;iOS.</p><p>WebView相关 <a href="https://github.com/alinz/react-native-webview-bridge" target="_blank" rel="noopener">https://github.com/alinz/react-native-webview-bridge</a></p><p>选项卡 <a href="https://github.com/exponentjs/react-native-tab-navigator" target="_blank" rel="noopener">https://github.com/exponentjs/react-native-tab-navigator</a></p><p>material组件库（各种漂亮的小组件）<a href="https://github.com/xinthink/react-native-material-kit" target="_blank" rel="noopener">https://github.com/xinthink/react-native-material-kit</a></p><p>base组件库（各种封装不错的小组件）<a href="http://nativebase.io/docs/v0.4.6/components#anatomy" target="_blank" rel="noopener">http://nativebase.io/docs/v0.4.6/components#anatomy</a> <a href="https://github.com/GeekyAnts/NativeBase" target="_blank" rel="noopener">https://github.com/GeekyAnts/NativeBase</a></p><p>不错的按钮 <a href="https://github.com/mastermoo/react-native-action-button" target="_blank" rel="noopener">https://github.com/mastermoo/react-native-action-button</a> <a href="https://github.com/ide/react-native-button" target="_blank" rel="noopener">https://github.com/ide/react-native-button</a></p><p>输入框表单验证 <a href="https://github.com/gcanti/tcomb-form-native" target="_blank" rel="noopener">https://github.com/gcanti/tcomb-form-native</a> <a href="https://github.com/FaridSafi/react-native-gifted-form" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-form</a> <a href="https://github.com/bartonhammond/snowflake" target="_blank" rel="noopener">https://github.com/bartonhammond/snowflake</a></p><p>炫酷效果的 TextInput <a href="https://github.com/halilb/react-native-textinput-effects" target="_blank" rel="noopener">https://github.com/halilb/react-native-textinput-effects</a> <a href="https://github.com/zbtang/React-Native-TextInputLayout" target="_blank" rel="noopener">https://github.com/zbtang/React-Native-TextInputLayout</a></p><p>聊天 <a href="https://github.com/FaridSafi/react-native-gifted-chat" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-chat</a></p><p>地图 <a href="https://github.com/lelandrichardson/react-native-maps" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-maps</a></p><p>侧滑按钮 <a href="https://github.com/dancormier/react-native-swipeout" target="_blank" rel="noopener">https://github.com/dancormier/react-native-swipeout</a> <a href="https://github.com/jemise111/react-native-swipe-list-view" target="_blank" rel="noopener">https://github.com/jemise111/react-native-swipe-list-view</a></p><p>图表 <a href="https://github.com/tomauty/react-native-chart" target="_blank" rel="noopener">https://github.com/tomauty/react-native-chart</a></p><p>下拉放大 <a href="https://github.com/lelandrichardson/react-native-parallax-view" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-parallax-view</a></p><p>日历组件 <a href="https://github.com/cqm1994617/react-native-myCalendar" target="_blank" rel="noopener">https://github.com/cqm1994617/react-native-myCalendar</a> <a href="https://github.com/vczero/react-native-calendar" target="_blank" rel="noopener">https://github.com/vczero/react-native-calendar</a></p><p>语言转化和一些常用格式转换 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a><br>选择按钮 <a href="https://github.com/sconxu/react-native-checkbox" target="_blank" rel="noopener">https://github.com/sconxu/react-native-checkbox</a></p><p>制作本地库 <a href="https://github.com/frostney/react-native-create-library" target="_blank" rel="noopener">https://github.com/frostney/react-native-create-library</a></p><p>影音相关 <a href="https://github.com/MisterAlex95/react-native-record-sound" target="_blank" rel="noopener">https://github.com/MisterAlex95/react-native-record-sound</a></p><p>安卓录音 <a href="https://github.com/bosung90/react-native-audio-android" target="_blank" rel="noopener">https://github.com/bosung90/react-native-audio-android</a></p><p>提示消息的Bar <a href="https://github.com/KBLNY/react-native-message-bar" target="_blank" rel="noopener">https://github.com/KBLNY/react-native-message-bar</a></p><p>iOS原生TableView <a href="https://github.com/aksonov/react-native-tableview" target="_blank" rel="noopener">https://github.com/aksonov/react-native-tableview</a></p><p>点击弹出视图 <a href="https://github.com/jeanregisser/react-native-popover" target="_blank" rel="noopener">https://github.com/jeanregisser/react-native-popover</a> <a href="https://github.com/instea/react-native-popup-menu" target="_blank" rel="noopener">https://github.com/instea/react-native-popup-menu</a></p><p>3D Touch <a href="https://github.com/madriska/react-native-quick-actions" target="_blank" rel="noopener">https://github.com/madriska/react-native-quick-actions</a></p><p>照片墙 <a href="https://github.com/ldn0x7dc/react-native-gallery" target="_blank" rel="noopener">https://github.com/ldn0x7dc/react-native-gallery</a></p><p>本地存储 <a href="https://github.com/sunnylqm/react-native-storage" target="_blank" rel="noopener">https://github.com/sunnylqm/react-native-storage</a></p><p>星星 <a href="https://github.com/djchie/react-native-star-rating" target="_blank" rel="noopener">https://github.com/djchie/react-native-star-rating</a></p><p>国际化 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a></p><p>通讯录 <a href="https://github.com/rt2zz/react-native-contacts" target="_blank" rel="noopener">https://github.com/rt2zz/react-native-contacts</a></p><p>缓存管理 <a href="https://github.com/reactnativecn/react-native-http-cache" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-http-cache</a></p><p>图片和base64互转 <a href="https://github.com/xfumihiro/react-native-image-to-base64" target="_blank" rel="noopener">https://github.com/xfumihiro/react-native-image-to-base64</a></p><p>安卓 iOS 白屏解决 <a href="https://github.com/mehcode/rn-splash-screen" target="_blank" rel="noopener">https://github.com/mehcode/rn-splash-screen</a></p><p>清除按钮的输入框 <a href="https://github.com/beefe/react-native-textinput" target="_blank" rel="noopener">https://github.com/beefe/react-native-textinput</a></p><p>PDF <a href="https://github.com/cnjon/react-native-pdf-view" target="_blank" rel="noopener">https://github.com/cnjon/react-native-pdf-view</a></p><h1 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h1><p><a href="https://github.com/rebeccahughes/react-native-device-info" target="_blank" rel="noopener">react-native-device-info</a></p><p>下拉-上拉-刷新 <a href="https://github.com/FaridSafi/react-native-gifted-listview" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-listview</a> </p><p><a href="https://github.com/greatbsky/react-native-pull/wiki" target="_blank" rel="noopener">https://github.com/greatbsky/react-native-pull/wiki</a></p><p>下拉选择 <a href="https://github.com/alinz/react-native-dropdown" target="_blank" rel="noopener">https://github.com/alinz/react-native-dropdown</a></p><h1 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h1><p><a href>react-native-alphabetlistview</a>类似iPhone通讯录样式</p><h1 id="toast提示"><a href="#toast提示" class="headerlink" title="toast提示"></a>toast提示</h1><p><a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">react-native-root-toast</a>浮动提示</p><h1 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h1><p><a href="https://github.com/react-native-fellowship/react-native-blur" target="_blank" rel="noopener">react-native-blur</a></p><p>滑动选项卡 <a href="https://github.com/skv-headless/react-native-scrollable-tab-view" target="_blank" rel="noopener">https://github.com/skv-headless/react-native-scrollable-tab-view</a></p><h1 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h1><p><a href>react-native-progress</a></p><h1 id="第三方授权登录"><a href="#第三方授权登录" class="headerlink" title="第三方授权登录"></a>第三方授权登录</h1><p><a href="https://github.com/yoaicom/react-native-social-kit" target="_blank" rel="noopener">https://github.com/yoaicom/react-native-social-kit</a> <a href="https://github.com/mozillo/react-native-open-share" target="_blank" rel="noopener">https://github.com/mozillo/react-native-open-share</a> <a href="https://github.com/zuoyoulian/React-Native-iOS-OpenShare" target="_blank" rel="noopener">https://github.com/zuoyoulian/React-Native-iOS-OpenShare</a></p><p>react-native-dialog-input弹框的输入框</p><p>react-native-countdown 倒计时</p><p>react-native-device-info 设备信息</p><p><a href="https://github.com/beefe/react-native-actionsheet" target="_blank" rel="noopener">react-native-actionsheet</a>双平台兼容的ActionSheet弹框</p><h1 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h1><p><a href>react-native-camera</a></p><p><a href="https://github.com/wix/react-native-camera-kit" target="_blank" rel="noopener">react-native-camera-kit</a>相机组件</p><p>react-native-keychain iOS KeyChain管理</p><p>react-native-picker滚轮选择器</p><p>react-native-picker-Android Android 滚轮选择器</p><h1 id="表情选择"><a href="#表情选择" class="headerlink" title="表情选择"></a>表情选择</h1><p><a href="https://github.com/arronhunt/react-native-emoji-selector" target="_blank" rel="noopener">react-native-emoji-selector</a></p><p><a href="https://github.com/yonahforst/react-native-emoji-picker" target="_blank" rel="noopener">react-native-emoji-picker</a></p><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p><a href="https://github.com/master-atul/react-native-exception-handler" target="_blank" rel="noopener">react-native-exception-handler</a></p><h1 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h1><p><a href="https://github.com/Sunhat/react-native-extra-dimensions-android" target="_blank" rel="noopener">react-native-extra-dimensions-android</a></p><p>React Native目前存在一个错误，Dimensions.get(‘window’).height有时会返回错误的值。</p><h1 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h1><p><a href>react-native-gesture-handler</a><br><a href>react-native-gesture-password</a>手势解锁</p><p>手势放大缩小移动 <a href="https://github.com/kiddkai/react-native-gestures" target="_blank" rel="noopener">https://github.com/kiddkai/react-native-gestures</a> </p><p><a href="https://github.com/johanneslumpe/react-native-gesture-recognizers" target="_blank" rel="noopener">https://github.com/johanneslumpe/react-native-gesture-recognizers</a></p><p>react-native-linear-gradient渐变</p><h1 id="Model模态视图"><a href="#Model模态视图" class="headerlink" title="Model模态视图"></a>Model模态视图</h1><p><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="noopener">react-native-modal</a><br><a href="https://github.com/maxs15/react-native-modalbox" target="_blank" rel="noopener">react-native-modalbox</a><br><a href="https://github.com/bodyflex/react-native-simple-modal" target="_blank" rel="noopener">react-native-simple-modal</a></p><h1 id="横竖屏"><a href="#横竖屏" class="headerlink" title="横竖屏"></a>横竖屏</h1><p><a href="https://github.com/yamill/react-native-orientation" target="_blank" rel="noopener">react-native-orientation</a>判断横竖屏 </p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>react-native-qrcode-svg</p><p><a href="https://github.com/lazaronixon/react-native-qrcode-reader" target="_blank" rel="noopener">react-native-qrcode-reader</a>扫描二维码 </p><p><a href="https://github.com/ideacreation/react-native-barcodescanner" target="_blank" rel="noopener">react-native-barcodescanner</a></p><h1 id="网页链接"><a href="#网页链接" class="headerlink" title="网页链接"></a>网页链接</h1><p><a href="https://github.com/obipawan/react-native-hyperlink" target="_blank" rel="noopener">react-native-hyperlink</a>超链接变可点击的</p><p>react-native-tab-navigator 底部或上部导航框架(不可滑动)</p><p>react-native-check-box CheckBox</p><p>react-native-splash-screen 启动白屏问题</p><p>react-native-simple-router 简易路由跳转框架</p><p>react-native-storage 持久化存储<br>    “react-native-global-props”: “^1.1.5”,<br>    “react-native-iphone-x-helper”: “^1.2.0”,<br>    “react-native-paper”: “^2.15.2”,<br>    “react-native-plugin-zhugeio”: “^1.1.1”,<br>    “react-native-randombytes”: “^3.5.3”,<br>    “react-native-shadow”: “^1.2.2”,<br>    “react-native-svg”: “^9.4.0”,<br>    “react-native-tab-view”: “^1.3.2”,<br>    “react-native-text-size”: “^3.0.0”,<br>    “react-native-update-app”: “^1.1.11”,<br>    “react-native-view-shot”: “^2.5.0”,   </p><h1 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h1><p>react-native-wechat “git+<a href="https://github.com/AegoYu/react-native-wechat.git&quot;" target="_blank" rel="noopener">https://github.com/AegoYu/react-native-wechat.git&quot;</a> </p><p>react-navigation</p><p>react-navigation-redux-helpers<br>react-navigation-transitions<br>react-redux<br>redux-immutable<br>redux-persist</p><p>socket.io-client<br>teaset<br>react-native-menu<br>react-timer-mixin<br>redux<br>redux-actions<br>redux-form<br>redux-thunk<br>remote-redux-devtools<br>rmc-date-picker<br>rmc-tabs<br>semver<br>react-native-networkplugin</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><a href="https://github.com/oblador/react-native-collapsible" target="_blank" rel="noopener">react-native-collapsible</a>制作动画可折叠组件—手风琴</p><p>React-native-animatable 动画</p><p>动画 <a href="https://github.com/oblador/react-native-animatable" target="_blank" rel="noopener">https://github.com/oblador/react-native-animatable</a></p><p>加载动画 <a href="https://github.com/maxs15/react-native-spinkit" target="_blank" rel="noopener">https://github.com/maxs15/react-native-spinkit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过的一些组件。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux中间件与异步</title>
    <link href="http://peilinghui.com/2019/08/21/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://peilinghui.com/2019/08/21/Redux中间件与异步/</id>
    <published>2019-08-21T02:40:48.000Z</published>
    <updated>2019-08-21T02:40:48.761Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://peilinghui.com/2019/07/19/TypeScript/"/>
    <id>http://peilinghui.com/2019/07/19/TypeScript/</id>
    <published>2019-07-19T07:21:29.000Z</published>
    <updated>2019-08-23T09:07:26.168Z</updated>
    
    <content type="html"><![CDATA[<p>学习TS。是JS的超集。TS类Class。接口Interface。<br><a id="more"></a></p><p>安装：npm install -g typescript</p><p>官网：<a href="https://typescript.bootcss.com/" target="_blank" rel="noopener">https://typescript.bootcss.com/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>TS强于JS：可以声明数据类型。<br>Boolean<br>Number<br>String<br>Array<br>Enum<br>Any<br>Void</p><p>访问修饰符：public和private</p><p>封装的实现：方法里面写get和set方法<br>类：<br>认识类Class：有构造方法的话必须传参数<br>类的继承：在子类的constructor构造函数中调用super<br>static和使用：</p><p>函数类型：命名函数和匿名函数<br>重载：</p><p>Lambads和this关键字的使用：</p><p>TypeScript的接口：Class类型</p><p>interface CLockInterface{<br>} </p><p>class Clock implements CLockInterface{</p><p>}</p><p>了解接口：规范传入参数的类型<br>可选属性：自定义接口属性<br>函数类型：<br>数组类型：<br>Class类型：<br>继承接口与混合类型：</p><p>混合类型</p><p>泛型：<br>class HelloNumber<t>{<br> Ten:T<br> add:(x:T,y:T)=&gt;T;<br>}<br>var myHelloNumber = new </t></p><p>Module模式：<br>1.模块化、可重用<br>2.封装变量和函数</p><p>//闭包<br>(function(){<br>    //内部代码<br>}());</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习TS。是JS的超集。TS类Class。接口Interface。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js</title>
    <link href="http://peilinghui.com/2019/07/18/%E5%AD%A6%E4%B9%A0Node.js/"/>
    <id>http://peilinghui.com/2019/07/18/学习Node.js/</id>
    <published>2019-07-18T10:14:32.000Z</published>
    <updated>2019-09-17T01:54:42.712Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下Node.js。</p><a id="more"></a><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p><p><strong>Nodejs的特点是：</strong></p><ul><li>JavaScript运行环境，相当于js在服务端的一个宿主环境</li><li>依赖于Chrome V8引擎进行代码解释，V8引擎执行Javascript的速度非常快，性能非常好。</li><li>事件驱动</li><li>非阻塞I/O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li><li>Node提供核心功能模块，使得JavaScript语言可以实现文件的读写、进程管理以及网络通信等功能，在这个意义上，Node又是JavaScript的工具库</li></ul><p><strong>Node.js的应用领域</strong></p><ul><li>项目管理：npm,grunt, gulp,bower, yeoman</li><li>桌面应用: node-webkit</li><li>Web开发：express,ejs,hexo, socket.io, restify, cleaver, stylus, browserify,cheerio</li><li>工具包 underscore,moment,connet,later,log4js,passport,passport(oAuth),domain,require,reap,commander,retry,PDFkit</li><li>数据库：mysql,mongoose,redis,memcached</li><li>异步：async,wind,eventProxy,bluebird</li><li>部署：forever,pm2,nodemon</li><li>测试：jasmine,karma,protractor</li><li>跨平台：rio,tty</li><li>内核：cluster,http,request</li><li>模板: jade</li><li>博客: ghost,hexo</li><li>微信: weui</li><li>硬件控制: NoduinoWeb</li><li>操作系统: NodeOS</li></ul><p><strong>Node.js的优点缺点</strong><br><strong>优点：</strong></p><ul><li>解决并发连接的问题</li></ul><blockquote><p>更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。</p></blockquote><ul><li>解决I/O阻塞的问题<br>业务场景：需要从多个数据源拉取数据，然后进行处理，处理的方式有：</li></ul><ol><li>串行获取数据，这是我们一般的解决方案</li><li>NodeJS非阻塞I/O，是通过发射/监听事件来控制执行过程<br>NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行，事件代理接收到线程后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。</li></ol><p><strong>缺点：</strong><br>匿名函数，使得抛出的异常不易阅读。try/catch使得异常捕获较为复杂。单线程的可靠性。不适合CPU密集型的场景。</p><p><strong>总结：</strong>  </p><ul><li>Nodejs具有处理高并发的能力（最重要的优点）</li><li>Nodejs适合I/O密集型应用</li><li>Nodejs不适合CPU密集型应用；<br>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；<br>解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；或者使用第三方模块，让Node也可以创建多进程。</li></ul><p>Node.js的特点：<br>1.部署简单方便<br>2.事件驱动：根据当前出现的事件，调用资源进行相关的处理。<br>3.异步编程：回调函数，事件监听，发布/订阅模式，<br>4.高效与性能：<br>5.单线程与多线程<br>6.可以解析JS代码，提供系统级别的API：文件的读写，线程的管理，网络通信</p><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><ul><li>express的安装：npm install express –save<br>expressjs的基础<br>expressjs的初始化配置<br>expressjs的路由<br>expressjs的返回响应</li><li>从Request—中间件—URL—-response<br>中间件MiddleWare：app.use  app.get  app.post<br>request:req.params  req.query  req.body<br>response: res.send() next()</li></ul><ol><li><p>使用express返回HTML内容</p><ul><li>Content-Type：text/html</li><li>fs.createReadStream(‘xxx.html’).pipe(res)</li><li>res.render()</li></ul></li><li><p>模板引擎：–复用HTML组件，简化开发流程</p><ul><li>app.set(‘view’, ‘ejs’)</li><li>res.render(‘home.ejs’, {title: ‘ejs template’}) </li></ul></li><li><p>使用app.set来设置express实例所使用的模板引擎</p></li><li>前后端共用模板</li></ol><h2 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h2><ol><li>简介<br><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">https://github.com/koajs/koa</a><br>Express的扩展。更小，更健壮的Web框架。组合不同的generator可以免除重复繁琐的回调函数的嵌套。提供了轻量优雅的函数库。<br>教程：<a href="https://chenshenhai.github.io/koa2-note/note/start/async.html" target="_blank" rel="noopener">https://chenshenhai.github.io/koa2-note/note/start/async.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960</a></li><li>应用</li></ol><ol start="3"><li>Request和Response</li><li>Content上下文</li></ol><h2 id="Mac下升级Node-js"><a href="#Mac下升级Node-js" class="headerlink" title="Mac下升级Node.js"></a>Mac下升级Node.js</h2><p>node有一个专门管理node.js版本的包叫作：n(没错，就是一个字母n)，mac下升级步骤如下：</p><ul><li>查看当前 node版本：</li></ul><p><code>$ node -v</code></p><ul><li>清除node缓存：</li></ul><p><code>$ sudo npm cache clean -f</code></p><ul><li>安装n工具包：</li></ul><p><code>$ sudo npm i -g n</code></p><ul><li>安装最新版node.js</li></ul><p><code>$ sudo n stable</code></p><ul><li>也可以到安装指定版本：(例如升级到10.8.0)</li></ul><p><code>$ sudo n v10.8.0</code></p><ul><li>再次查看本机node版本</li></ul><p><code>$ node -v</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下Node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://peilinghui.com/categories/NodeJS/"/>
    
    
  </entry>
  
  <entry>
    <title>RN性能优化总结</title>
    <link href="http://peilinghui.com/2019/05/22/RN%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2019/05/22/RN性能优化总结/</id>
    <published>2019-05-22T13:53:04.000Z</published>
    <updated>2019-05-22T14:02:23.724Z</updated>
    
    <content type="html"><![CDATA[<p>RN的性能优化<br><a id="more"></a></p><h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p>更新阶段的生命周期</p><pre><code>componentWillReceiveProps(object nextProps)：当挂载的组件接收到新的props时被调用。此方法应该被用于比较this.props 和 nextProps以用于使用this.setState()执行状态转换。（组件内部数据有变化，使用state，但是在更新阶段又要在props改变的时候改变state，则在这个生命周期里面）shouldComponentUpdate(object nextProps, object nextState)： -boolean 当组件决定任何改变是否要更新到DOM时被调用。作为一个优化实现比较this.props 和 nextProps 、this.state 和 nextState ，如果React应该跳过更新，返回false。componentWillUpdate(object nextProps, object nextState)：在更新发生前被立即调用。你不能在此调用this.setState()。componentDidUpdate(object prevProps, object prevState)： 在更新发生后被立即调用。（可以在DOM更新完之后，做一些收尾的工作）</code></pre><blockquote><p>  Tips: React的优化是基于shouldComponentUpdate的，该生命周期默认返回true，所以一旦prop或state有任何变化，都会引起重新render。</p></blockquote><h2 id="React官方的解决方案"><a href="#React官方的解决方案" class="headerlink" title="React官方的解决方案"></a>React官方的解决方案</h2><p>PureRenderMixin(es5)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Shallow Compare (es6)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCompare = require(<span class="symbol">'react</span>-addons-shallow-compare');</span><br><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;foo&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es7装饰器的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pureRender <span class="keyword">from</span> <span class="string">"pure-render-decorator"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@pureRender</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我re-render了"</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123;name,age&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;span&gt;姓名:<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">          &lt;span&gt;&#123;name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span&gt; age:&lt;/</span>span&gt;</span><br><span class="line">          &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>immutable.js</p><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>【在react中使用immutable】改变shouldComponentUpdate的重新渲染规则（1）防止每次setState或传递props，即使state和props的值没有发生改变也重新渲染组件，带来无谓的性能消耗（2）防止浅比较带来的比较误差问题，以及深比较带来的性能消耗问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RN的性能优化&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习Dva</title>
    <link href="http://peilinghui.com/2019/04/11/%E5%AD%A6%E4%B9%A0Dva/"/>
    <id>http://peilinghui.com/2019/04/11/学习Dva/</id>
    <published>2019-04-11T02:11:03.000Z</published>
    <updated>2019-04-11T02:53:52.840Z</updated>
    
    <content type="html"><![CDATA[<p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。</p><a id="more"></a><h1 id="Dva-概念"><a href="#Dva-概念" class="headerlink" title="Dva 概念"></a>Dva 概念</h1><p>dva = React-Router + Redux + Redux-saga</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line">const App = <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Hello dva&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 创建应用</span><br><span class="line">const app = dva();</span><br><span class="line"><span class="regexp">//</span> 注册视图</span><br><span class="line">app.router(<span class="function"><span class="params">()</span> =&gt;</span> &lt;App /&gt;);</span><br><span class="line"><span class="regexp">//</span> 启动应用</span><br><span class="line">app.start(<span class="string">'#root'</span>);</span><br></pre></td></tr></table></figure><ul><li>State：一个对象，保存整个应用状态</li><li>View：React 组件构成的视图层</li><li>Action：一个对象，描述事件</li><li>connect 方法：一个函数，绑定 State 到 View</li><li>dispatch 方法：一个函数，发送 Action 到 State</li></ul><p>改变数据的时候可以通过 dispatch 发起一个 action,<br>同步行为:直接通过 Reducers 改变 State ，异步行为:会先触发 Effects 然后流向 Reducers 最终改变 State.</p><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><h3 id="State-是储存数据的地方，收到-Action-以后，会更新数据。"><a href="#State-是储存数据的地方，收到-Action-以后，会更新数据。" class="headerlink" title="State : 是储存数据的地方，收到 Action 以后，会更新数据。"></a>State : 是储存数据的地方，收到 Action 以后，会更新数据。</h3><p><code>type State = any</code><br>表示 Model 的状态数据</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>type AsyncAction = any</code></p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'add'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="connect-绑定-State-到-View"><a href="#connect-绑定-State-到-View" class="headerlink" title="connect:绑定 State 到 View"></a>connect:绑定 State 到 View</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; <span class="keyword">from</span> 'dva';</span><br><span class="line"></span><br><span class="line">function mapStateToProps(<span class="keyword">state</span>) &#123;</span><br><span class="line">  return &#123; todos: <span class="keyword">state</span>.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line">connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure><p>mapStateToProps 函数会返回一个对象，用于建立 State 到 Props 的映射关系。</p><h3 id="dispatch-函数：用来将-Action-发送给-State。"><a href="#dispatch-函数：用来将-Action-发送给-State。" class="headerlink" title="dispatch 函数：用来将 Action 发送给 State。"></a>dispatch 函数：用来将 Action 发送给 State。</h3><p><code>type dispatch = (a: Action) =&gt; Action</code></p><p>dispatching function 是一个用于触发 action 的函数，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'user/add'</span>, <span class="comment">// 如果在 model 外调用，需要添加 namespace</span></span><br><span class="line">  <span class="attribute">payload</span>: &#123;&#125;, <span class="comment">// 需要传递的信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S</p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。计算以外的操作都属于 Effect，典型的就是 I/O 操作、数据库读写。Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。<br>dva 提供多个 effect 函数内部的处理函数，比较常用的是 call 和 put。</p><ul><li>call：执行异步函数</li><li>put：发出一个 Action，类似于 dispatch</li></ul><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><h1 id="通信：组件之间如何通信？"><a href="#通信：组件之间如何通信？" class="headerlink" title="通信：组件之间如何通信？"></a>通信：组件之间如何通信？</h1><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><h1 id="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"><a href="#数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等" class="headerlink" title="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"></a>数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等</h1><p>目前流行的数据流方案有：</p><ul><li>Flux，单向数据流方案，以 Redux 为代表</li><li>Reactive，响应式数据流方案，以 Mobx 为代表</li><li>其他，比如 rxjs 等</li><li>最流行的社区 React 应用架构方案如下。</li></ul><p>路由： React-Router<br>架构： Redux<br>异步操作： Redux-saga</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于RN的热更新</title>
    <link href="http://peilinghui.com/2019/03/07/%E5%85%B3%E4%BA%8ERN%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://peilinghui.com/2019/03/07/关于RN的热更新/</id>
    <published>2019-03-07T09:46:13.000Z</published>
    <updated>2019-08-21T03:09:33.408Z</updated>
    
    <content type="html"><![CDATA[<p>写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题</p><a id="more"></a><p>在APPDelegate中加载RN，一般的加载方式是：<br><code>RCTRootView *rootView= [[RCTRootView alloc] initWithBundleURL:jsCodeLocation                                                   moduleName:@&quot;authen_native&quot;                                            initialProperties:nil                                               launchOptions:nil];</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(instancetype)</span>initWithBundleURL:<span class="params">(NSURL *)</span>bundleURL</span><br><span class="line">                       moduleName:<span class="params">(NSString *)</span>moduleName</span><br><span class="line">                initialProperties:<span class="params">(NSDictionary *)</span>initialProperties</span><br><span class="line">                    launchOptions:<span class="params">(NSDictionary *)</span>launchOptions;</span><br></pre></td></tr></table></figure><p>但在调试中发现两个现象：<br>1.重复进入react-native页面、退出react-native页面的操作，RCTBridge对象会被重复创建、销毁。有时候RCTBridge对象未能及时创建还会crash<br>2.在原生页面和react-native页面相互跳转是RCTBridge也会被重复创建，造成很大的内存开销</p><p>阅读RCTRootView.h发现一些细节:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Convenience initializer -</span></span><br><span class="line"><span class="comment"> * A bridge will be created internally.</span></span><br><span class="line"><span class="comment"> * This initializer is intended to be used when the app has a single RCTRootView,</span></span><br><span class="line"><span class="comment"> * otherwise create an `RCTBridge` and pass it in via `initWithBridge:moduleName:`</span></span><br><span class="line"><span class="comment"> * to all the instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBundleURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">bundleURL</span></span><br><span class="line">                       <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">                <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span></span><br><span class="line">                    <span class="selector-tag">launchOptions</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">launchOptions</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Designated initializer -</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBridge</span><span class="selector-pseudo">:(RCTBridge</span> *)<span class="selector-tag">bridge</span></span><br><span class="line">                    <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">             <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span> <span class="selector-tag">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><h2 id="initWithBundleURL与initWithBridge的区别"><a href="#initWithBundleURL与initWithBridge的区别" class="headerlink" title="initWithBundleURL与initWithBridge的区别"></a>initWithBundleURL与initWithBridge的区别</h2><p>对于项目中只有一个RCTRootView的时候建议initWithBundleURL的方法，这个方法内部创建了一个RCTBridge.</p><p>而有多个RCTRootView的情况，建议initWithBridge的方法.开发者直接创建RCTBridge，多个RCTRootView可共用一个RCTBridge。</p><h1 id="RN版本升级更新"><a href="#RN版本升级更新" class="headerlink" title="RN版本升级更新"></a>RN版本升级更新</h1><p>项目中使用多个RCTRootView，推荐使用以下方法initWithBridge初始化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">_bridge</span> <span class="string">=</span> <span class="string">[[RCTBridge</span> <span class="string">alloc]</span> <span class="attr">initWithBundleURL:[SDRrectFileOption</span> <span class="attr">SetFileWithOption:self.luanchOption]</span></span><br><span class="line"><span class="attr">                                  moduleProvider:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                                   launchOptions:</span><span class="string">self.luanchOption];</span></span><br><span class="line"><span class="string">RCTRootView</span> <span class="meta">*rootView</span> <span class="string">=</span> <span class="string">[[RCTRootView</span> <span class="string">alloc]</span> <span class="attr">initWithBridge:_bridge</span></span><br><span class="line"><span class="attr">                                                   moduleName:</span><span class="string">@"authen_native"</span></span><br><span class="line"><span class="attr">                                            initialProperties:</span><span class="string">nil];</span></span><br></pre></td></tr></table></figure><p>在SDRrectFileOption中返回的是jsbundle的地址。在这个文件中可以使用NSFileManager来把jsbundle缓存到本地。但是如果是新版本的RN比如0.57要替换老版本的比如0.54的APP覆盖更新的话，记得要对比版本号，然后把缓存里面的jsbundle清除掉再返回新的jsbundle地址。不然会导致crash。</p><h1 id="RN的热更新"><a href="#RN的热更新" class="headerlink" title="RN的热更新"></a>RN的热更新</h1><p>在APPdelegate的didFinishLaunchingWithOptions方法中来判断是否需要Update。在Update方法中如果需要强制更新的话就就把RCTBridge调用reload方法进行热更新—和初始化使用的是同一个bridge。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>checkUpdate &#123;</span><br><span class="line">  <span class="keyword">patch</span>Class *<span class="keyword">patch</span> = [<span class="keyword">patch</span>Class sharedInstance];</span><br><span class="line">  [<span class="keyword">patch</span> checkUpdate];</span><br><span class="line">  <span class="keyword">patch</span>.IS_COERCIVE = ^<span class="params">(NSURL *newPath)</span> &#123;</span><br><span class="line">    <span class="string">//</span>是强制更新的话，就把RCTBridge调用<span class="keyword">reload</span>方法进行热更新</span><br><span class="line">    [_bridge <span class="keyword">reload</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在patchClass中使用的是单例，在这个里面通过接口判断是否需要热更还是强制更新，是只更新jsbundle还是整包更新，下载文件，把下载的压缩文件解压缩，如果缓存里面有文件先删除旧的jsbundle再保存，</p><h1 id="解决白屏问题"><a href="#解决白屏问题" class="headerlink" title="解决白屏问题"></a>解决白屏问题</h1><p>使用单例初始化一个bridge对象解决上述问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeManager</span>: <span class="title">RCTBridge</span></span></span><br><span class="line"></span><br><span class="line">+ (BridgeManager*)shareInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeHandle</span> : <span class="title">NSObject</span>&lt;<span class="title">RCTBridgeDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line">implementation MallBridgeHandle</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)sourceURLForBridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"index.ios"</span> withExtension:<span class="string">@"jsbundle"</span>];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BridgeManager</span></span></span><br><span class="line"><span class="keyword">static</span> BridgeManager * manager = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">+ (BridgeManager*)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        manager = [BridgeManager alloc] initWithDelegate:[[BridgeHandle alloc] init] launchOptions:<span class="literal">nil</span>]; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>单例在程序启动时初始化。<br>测试验证可以发现：内存得到优化，白屏问题得到解决。</p><h1 id="桥接原生模块"><a href="#桥接原生模块" class="headerlink" title="桥接原生模块"></a>桥接原生模块</h1><p>首先我们需要创建一个类，然后导入头文件 #import &lt;RCTBridgeModule.h&gt; ,这个类需要实现 RCTBridgeModule 协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RNTestManager</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>模块名字</strong></p><p>在类的实现部分，需要包含 RCT_EXPORT_MODULE() 宏，这个宏也可以添加一个参数用来指定在 JS 中访问这个模块的名字。如果你不指定，默认就会使用这个 OC 类的名字。</p><p><strong><em>导出方法</em></strong></p><p>RCT_EXPORT_METHOD()，导出到 JS 的方法名是 OC 的方法名的第一个部分，桥接到 JS 的方法返回值类型必须是 void。<strong>RN 的桥接操作是异步的</strong>，所以如果要返回结果给 JS，你必须通过回调或者触发事件来进行。传入的参数类型有以下几种：</p><p>string (NSString)<br>number (NSInteger, float, double, CGFloat, NSNumber)<br>boolean (BOOL, NSNumber)<br>array (NSArray) 包含本列表中任意类型<br>object (NSDictionary) 包含string类型的键和本列表中任意类型的值<br>function (RCTResponseSenderBlock)</p><p><strong>回调函数</strong><br>RCT_EXPORT_METHOD(RNInvokeOCPromise:(NSDictionary *)dictionary resolver:(RCTPromiseResolveBlock)resolve<br>                  rejecter:(RCTPromiseRejectBlock)reject){<br>}<br>桥接原生方法的最后两个参数是RCTPromiseResolveBlock 和RCTPromiseRejectBlock的话，则对应的JS方法就会返回一个Promise对象。</p><p><strong>设置原生模块执行操作的线程</strong><br>如果你在原生模块中需要更改 UI 或者必须在主线程的话，可以实现 </p><p><code>- (dispatch_queue_t)methodQueue 方法</code></p><p><code>- (dispatch_queue_t)methodQueue {    return dispatch_get_main_queue();}</code></p><h2 id="RN使用原生的View"><a href="#RN使用原生的View" class="headerlink" title="RN使用原生的View"></a>RN使用原生的View</h2><p>import入UIView+React.h文件，，原生视图都需要被一个RCTViewManager的子类来创建和管理。这些管理器在功能上有些类似“视图控制器”，但它们本质上都是单例 —— React Native只会为每个管理器创建一个实例。步骤：</p><ol><li>创建一个子类</li><li>添加 RCT_EXPORT_MODULE()标记宏</li><li>实现 -(UIView *)view 方法</li></ol><h3 id="创建一个子类"><a href="#创建一个子类" class="headerlink" title="创建一个子类"></a>创建一个子类</h3><p>该组件有回调需要处理，这里即必须用到 RCTDirectEventBlock 或者 RCTBubblingEventBlock，而且命名的时候要特别注意，需要已 on 开头，熟悉 JS 的朋友应该会反应过来，这很像 JS 的事件命名规范。</p><p><code>@property (nonatomic, copy) RCTBubblingEventBlock onValueChange;</code><br><code>@property (nonatomic, copy) RCTBubblingEventBlock onSlidingComplete;</code></p><h3 id="在自定义ViewManager中"><a href="#在自定义ViewManager中" class="headerlink" title="在自定义ViewManager中"></a>在自定义ViewManager中</h3><ol><li>初始化子View</li><li>添加 RCT_EXPORT_MODULE()标记宏<br>添加TYRCBarChartViewManager 来管理TYRCBarChartView。这个TYRCBarChartViewManager : 继承自RCTViewManager。 RCTViewManager 实现 RCTBridgeModule 协议。</li><li>自定义属性RCT_CUSTOM_VIEW_PROPERTY</li><li>自定义方法RCT_EXPORT_METHOD(refresh){<br> [_barView refreshData];<br>}<br>RCT_CUSTOM_VIEW_PROPERTY(name, type, viewClass)，完整的属性定义为</li></ol><h3 id="给JS发送事件使用-eventDispatcher"><a href="#给JS发送事件使用-eventDispatcher" class="headerlink" title="给JS发送事件使用 eventDispatcher"></a>给JS发送事件使用 eventDispatcher</h3><p>   [self.rootView.bridge.eventDispatcher sendAppEventWithName:@”deviceLocalStateChange”<br>                                                          body:@{@”state”:state}];</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ios2.1大礼包被拒经验分享<a href="https://zhuanlan.zhihu.com/p/54042709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54042709</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题&lt;/p&gt;
    
    </summary>
    
      <category term="RN" scheme="http://peilinghui.com/categories/RN/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac获取ipa方法</title>
    <link href="http://peilinghui.com/2019/02/02/Mac%E8%8E%B7%E5%8F%96ipa%E6%96%B9%E6%B3%95/"/>
    <id>http://peilinghui.com/2019/02/02/Mac获取ipa方法/</id>
    <published>2019-02-02T05:46:05.000Z</published>
    <updated>2019-02-02T05:53:34.025Z</updated>
    
    <content type="html"><![CDATA[<p>从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。<br>新的方法。</p><a id="more"></a><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p> Apple Configurator 2   Mac appstore下载即可<br>登录appleId</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><ol><li>在Appstore下载相关App（以XX为例）到iPhone或iPad上;</li><li>打开 Apple Configurator 2</li><li>选中连接Mac的移动设备后，点击 Apple Configurator 2 工具菜单 ”添加“ –&gt; 应用；</li><li>搜索app-xx，选中，点击右下角添加，等待添加完成(如下图)；</li><li>不要操作  Apple Configurator 2,切换到桌面;</li><li>快捷键：command + shift + G 或者在Finder 中前往文件夹…</li><li>输入路径：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</li><li>拷贝出 上述路径中的ipa文件，之后在 Apple Configurator 2 工具的弹框中点击停止，即可；<br>zhifubao<br>done</li></ol></blockquote><h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><ol><li>修改上述获取的ipa文件，修改后缀名 ipa –&gt;zip;</li><li>解压zip文件，在完成的文件夹中打开Payload 文件夹，即可看到应用xx宝应用程序；</li><li>选中该应用程序，右键显示包内容即可查看图片资源等；</li></ol><h3 id="获取图片资源"><a href="#获取图片资源" class="headerlink" title="获取图片资源"></a>获取图片资源</h3><ol><li>找到包内容中的 Assets.car 文件；</li><li>打开 “Assets提取工具”，导入 Assets.car 文件，添加到处文件夹，点击提取即可获取；</li></ol><p>参考资料:</p><ol><li>Mac获取ipa和相关资源</li><li>Assets提取工具<a href="https://github.com/pcjbird/AssetsExtractor" target="_blank" rel="noopener">https://github.com/pcjbird/AssetsExtractor</a></li></ol><p>微信分享二维码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。&lt;br&gt;新的方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS逆向</title>
    <link href="http://peilinghui.com/2019/02/01/%E5%AD%A6%E4%B9%A0iOS%E9%80%86%E5%90%91/"/>
    <id>http://peilinghui.com/2019/02/01/学习iOS逆向/</id>
    <published>2019-02-01T02:26:24.000Z</published>
    <updated>2019-07-19T03:48:10.635Z</updated>
    
    <content type="html"><![CDATA[<p>从现有APP实现细节的过程.</p><a id="more"></a><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>壳是应用程序加密保护的一种方式，在APP Store上的应用程序都是有加密保护的。<br>查看是否加壳：<br><code>otool -l 可执行文件 | grep cryptid</code><br>例如：<code>localhost:ivwen.app peilinghui$ otool -l ivwen | grep cryptid        cryptid 1</code><br>    如果是1表示是加密的.0表示脱壳的。<br>查看架构：<br><code>lipo -info WeChat</code><br><code>Non-fat file: WeChat is architecture: arm64</code></p><h3 id="1-砸壳工具"><a href="#1-砸壳工具" class="headerlink" title="1. 砸壳工具"></a>1. 砸壳工具</h3><h4 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a>dumpdecrypted</h4><p><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted</a><br>去 Github 下载 dumpdecrypted 源码, 源码就一个 C 源文件.下载 zip 包之后, 解压.在当前目录, 执行 make 即可完成编译,编译成功后生成 dumpdecrypted.dylib 文件.<br>iOS 逆向: dumpdecrypted 砸壳记<a href="http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/" target="_blank" rel="noopener">http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/</a></p><h4 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a>Clutch</h4><p><a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch/releases</a></p><h3 id="2-监控工具"><a href="#2-监控工具" class="headerlink" title="2.监控工具"></a>2.监控工具</h3><p>通过监控，可以获取界面的变化，文件的读取，网络的传输。</p><h4 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h4><p>对于去壳的应用可以得到所有类的头文件<br><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">https://github.com/nygard/class-dump</a></p><h4 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h4><p><a href="https://revealapp.com/" target="_blank" rel="noopener">https://revealapp.com/</a><br>得到界面UI，得到响应事件。</p><h4 id="Snoop-it"><a href="#Snoop-it" class="headerlink" title="Snoop-it"></a>Snoop-it</h4><p><a href="https://code.google.com/archive/p/snoop-it/" target="_blank" rel="noopener">https://code.google.com/archive/p/snoop-it/</a></p><h4 id="introspy"><a href="#introspy" class="headerlink" title="introspy"></a>introspy</h4><p><a href="https://github.com/iSECPartners/Introspy-iOS" target="_blank" rel="noopener">https://github.com/iSECPartners/Introspy-iOS</a></p><h3 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h3><p>通过分析二进制文件，生成汇编代码，进而转换成高级语言。</p><h4 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h4><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><h3 id="调试跟踪工具"><a href="#调试跟踪工具" class="headerlink" title="调试跟踪工具"></a>调试跟踪工具</h3><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><h4 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h4><h2 id="程序功能具体实现"><a href="#程序功能具体实现" class="headerlink" title="程序功能具体实现"></a>程序功能具体实现</h2><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="应用代码框架构成"><a href="#应用代码框架构成" class="headerlink" title="应用代码框架构成"></a>应用代码框架构成</h2><h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><h2 id="执行流程参数传递"><a href="#执行流程参数传递" class="headerlink" title="执行流程参数传递"></a>执行流程参数传递</h2><p><code>class-dump -s -S -H WeChat.decrypted -o /Users/lecoding/Desktop/test/WeChatDemo/Headers</code></p><blockquote><p>WeChat.decrypted ： 砸壳后的Mach-o文件路径<br>/Users/lecoding/Desktop/test/WeChatDemo/Headers： 存储头文件目录<br>-s             sort classes and categories by name<br>-S             sort methods by name<br>-H            generate header files in current directory, or directory specified with -o<br>-o            output directory used for -H</p></blockquote><h1 id="iOS系统安全机制"><a href="#iOS系统安全机制" class="headerlink" title="iOS系统安全机制"></a>iOS系统安全机制</h1><p><code>image list -o -f</code>打印出iOS中二进制文件，库文件，动态链接文件，栈和堆内存地址的位置全部都是随机的。</p><h1 id="iOS越狱"><a href="#iOS越狱" class="headerlink" title="iOS越狱"></a>iOS越狱</h1><p>通过一系列iOS系统的漏洞，对系统安全权限进行破解，获取系统Root的权限。<br>引导式越狱，不完美越狱，完美越狱。</p><h2 id="越狱环境的配置"><a href="#越狱环境的配置" class="headerlink" title="越狱环境的配置"></a>越狱环境的配置</h2><h1 id="iOS底层的知识储备"><a href="#iOS底层的知识储备" class="headerlink" title="iOS底层的知识储备"></a>iOS底层的知识储备</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h2 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h2><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h2 id="UI控件的背后代码执行"><a href="#UI控件的背后代码执行" class="headerlink" title="UI控件的背后代码执行"></a>UI控件的背后代码执行</h2><h2 id="整个APP的结构以及构建的过程"><a href="#整个APP的结构以及构建的过程" class="headerlink" title="整个APP的结构以及构建的过程"></a>整个APP的结构以及构建的过程</h2><h3 id="手动打包APP模拟Xcode自动打包的过程"><a href="#手动打包APP模拟Xcode自动打包的过程" class="headerlink" title="手动打包APP模拟Xcode自动打包的过程"></a>手动打包APP模拟Xcode自动打包的过程</h3><h1 id="Hook的原理"><a href="#Hook的原理" class="headerlink" title="Hook的原理"></a>Hook的原理</h1><h2 id="Hook的几种方式"><a href="#Hook的几种方式" class="headerlink" title="Hook的几种方式"></a>Hook的几种方式</h2><h3 id="1-Method-Swizzle—OC"><a href="#1-Method-Swizzle—OC" class="headerlink" title="1.Method Swizzle—OC"></a>1.Method Swizzle—OC</h3><p>通过OC的Runtime机制，改变函数的地址来交换方法实现</p><h3 id="2-fishHook—–C"><a href="#2-fishHook—–C" class="headerlink" title="2.fishHook—–C"></a>2.fishHook—–C</h3><p>通过修改懒加载和非懒加载的表，通过修改表的指针来达到Hook的效果，作用于C函数</p><h3 id="3-Cydia-Substrate（框架）"><a href="#3-Cydia-Substrate（框架）" class="headerlink" title="3.Cydia Substrate（框架）"></a>3.Cydia Substrate（框架）</h3><p>针对OC，C函数，或者是函数地址来做Hook操作</p><h1 id="Theos"><a href="#Theos" class="headerlink" title="Theos"></a>Theos</h1><p><a href="http://codershmily.github.io/2017/04/03/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8BTheos/" target="_blank" rel="noopener">iOS逆向之Theos基础到实战</a></p><h1 id="iOSOpenDev"><a href="#iOSOpenDev" class="headerlink" title="iOSOpenDev"></a>iOSOpenDev</h1><p>基于Xcode创建模板和编译打包<br><a href="http://iosopendev.com/download/" target="_blank" rel="noopener">http://iosopendev.com/download/</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一条命令完成砸壳<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/" target="_blank" rel="noopener">http://www.alonemonkey.com/2018/01/30/frida-ios-dump/</a><br>书籍：&lt;iOS逆向&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从现有APP实现细节的过程.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode10遇到的问题</title>
    <link href="http://peilinghui.com/2018/11/03/%E5%8D%87%E7%BA%A7Xcode10%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2018/11/03/升级Xcode10遇到的问题/</id>
    <published>2018-11-03T07:59:27.000Z</published>
    <updated>2019-08-21T03:46:11.287Z</updated>
    
    <content type="html"><![CDATA[<p>升级Xcode10遇到的问题以及最近解决的问题。</p><a id="more"></a><p>项目升级到Xcode10 以后报错：</p><h3 id="React-Native-‘config-h’-file-not-found"><a href="#React-Native-‘config-h’-file-not-found" class="headerlink" title="React-Native ‘config.h’ file not found"></a>React-Native ‘config.h’ file not found</h3><p>解决方法：</p><p>cd node_modules/react-native/third-party/glog-0.3.4<br>../../scripts/ios-configure-glog.sh</p><h3 id="Xcode-10-libfishhook-a-cannot-be-found"><a href="#Xcode-10-libfishhook-a-cannot-be-found" class="headerlink" title="Xcode 10 libfishhook.a cannot be found"></a>Xcode 10 libfishhook.a cannot be found</h3><p>解决方法：</p><p>在LIbrary下面的RCTWebSocket中的Target中的Build Phases中的Link Binary With Libraries 中的libfishhook.a文件删了重新导入就好了。</p><h3 id="Multiple-commands-produce"><a href="#Multiple-commands-produce" class="headerlink" title="Multiple commands produce"></a>Multiple commands produce</h3><p>Showing Recent Messages</p><p>2) Target ‘YAORecordProject’ (project ‘YAORecordProject’) has process command with output ‘/Users/peilinghui/Library/Developer/Xcode/DerivedData/YAORecordProject-frlkqcmjttdqtdandttwzrmfhjnt/Build/Products/Debug-iphonesimulator/YAORecordProject.app/Info.plist’</p><p>解决方法：</p><p>This issue might occur just because of multiple Plist/other files within App-<br>Solution -&gt; Open target -&gt; Build phases &gt; Copy Bundle Resources and remove info.plist from there.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级Xcode10遇到的问题以及最近解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://peilinghui.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>RN与iOS的混合开发</title>
    <link href="http://peilinghui.com/2018/10/29/RN%E4%B8%8EiOS%E7%9A%84%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://peilinghui.com/2018/10/29/RN与iOS的混合开发/</id>
    <published>2018-10-29T09:16:37.000Z</published>
    <updated>2018-10-29T10:00:52.152Z</updated>
    
    <content type="html"><![CDATA[<p>以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。</p><a id="more"></a><h2 id="纯RN的APP"><a href="#纯RN的APP" class="headerlink" title="纯RN的APP"></a>纯RN的APP</h2><p>就是通过React-Native init一个项目以后，代码写好以后把代码打包成bundle文件，然后导入到Xcode里面然后打包成ipa来发布，其中在APPdelegate里面是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSURL</span> *jsCodeLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index.ios" fallbackResource:nil];</span></span><br><span class="line">  jsCodeLocation = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"main"</span> withExtension:<span class="string">@"jsbundle"</span>];</span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                      moduleName:<span class="string">@"CompassRN"</span></span><br><span class="line">                                               initialProperties:<span class="literal">nil</span></span><br><span class="line">                                                   launchOptions:launchOptions];</span><br><span class="line">  rootView.backgroundColor = [[<span class="built_in">UIColor</span> alloc] initWithRed:<span class="number">1.0</span>f green:<span class="number">1.0</span>f blue:<span class="number">1.0</span>f alpha:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最重要的连接就是RCTRootView，的方法加载bundle文件，参数initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。</p><p>具体解析请看：<a href="https://www.jianshu.com/p/9d7dbf17daa5" target="_blank" rel="noopener">https://www.jianshu.com/p/9d7dbf17daa5</a><br>RCTBridge桥接，moduleName是CompassRN，同样在RN中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CompassRN <span class="keyword">from</span> <span class="string">'./component/Appmain'</span>;</span><br><span class="line">AppRegistry.registerComponent(<span class="string">'CompassRN'</span>, <span class="function"><span class="params">()</span> =&gt;</span> CompassRN);</span><br></pre></td></tr></table></figure><p>在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。</p><h2 id="RN和iOS混合开发"><a href="#RN和iOS混合开发" class="headerlink" title="RN和iOS混合开发"></a>RN和iOS混合开发</h2><p>需要在iOS工程中：</p><p>iOS是如何下载bundle文件，并且保证bundle文件的安全？</p><ol><li><p>TYRCTPanelViewController 的viewDidLoad中加载面板 loadDevicePanel,<br>通过TYPanelService来下载面板，<br>如果是debug模式的话，加载路径是：</p><pre><code>panelPath = [NSString stringWithFormat:@&quot;http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true&amp;gwId=%@&quot;,ip, self.devId];其中IP是本机电脑的IP，</code></pre></li></ol><p>否则release模式的话：  [self loadWebView:panelPath]通过panelPath的网络请求路径来加载面板</p><p>_rootView = [[RCTRootView alloc] initWithBundleURL:[NSURL URLWithString:panelPath] moduleName:@”TYRCTApp” initialProperties:@{@”devInfo”:devInfo} launchOptions:nil];<br>_rootView.frame = self.view.bounds;<br>如果设备变更，数据，网络，蓝牙等变化的话，通过<br>[self.rootView.bridge.eventDispatcher sendAppEventWithName:@”networkStateChange”<br>                        body:@{@”state”:[NSNumber numberWithBool:state]}];<br>来通知rootView</p><ol start="2"><li><p>列表中用 TYPanelViewControllerFactory来处理具体进入到哪个面板。 isEnableDebug模式下进入 TYCommonPanelViewController,</p></li><li><p>TYPanelService.拉取面板主要是 TYPanelService 这个方法， 使用NSURLSessionDownload来下载面板，<br>如果沙盒 TPSandBox里面通过 NSFileManager来管理，如果里面存在有面板，直接加载，<br>不存在的话就去下载main.jsbundle（通过 RunLoop里面的这个方法cancelPreviousPerformRequestsWithTarget可以取消先前的请求任务）<br>下载以后的面板通过JSON解析以后放到 TYUIPanel（Model）中，删除先前的tar.gz压缩包，取消先前的任务，</p></li></ol><p>3.对于每一个panel文件，Model对象里面有 uiId， version， content， fileMd5，<br>其中 fileMd5来保证包的安全性，包解析用的工具是 TPEncryptUtils，先把 tarPath的文件转化成NSData，然后通过 DCTar来解压文件，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在APP中IM使用融云</title>
    <link href="http://peilinghui.com/2018/09/21/%E5%9C%A8APP%E4%B8%ADIM%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91/"/>
    <id>http://peilinghui.com/2018/09/21/在APP中IM使用融云/</id>
    <published>2018-09-21T04:43:28.000Z</published>
    <updated>2018-09-29T09:21:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。<br><a id="more"></a></p><p>首先可以参照官网：<a href="https://www.rongcloud.cn/docs/ios.html#prepare" target="_blank" rel="noopener">https://www.rongcloud.cn/docs/ios.html#prepare</a>来进行基本的融云包的导入和集成到工程中。<br>通过在控制台中API的调用<a href="https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=" target="_blank" rel="noopener">https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=</a>来模拟接口调用的过程。<br>集成融云，就是能用好他所提供的API，就能完成大部分的工作，用好IMKit和IMLib。IMKit主要就是页面，可以在它的基础上进行我们自己页面的自定义，IMLib就是通讯的API，通过使用它暴露的方法来实现及时通讯，单聊，群聊，以及自定义消息的发送。</p><h1 id="导入融云，连接融云"><a href="#导入融云，连接融云" class="headerlink" title="导入融云，连接融云"></a>导入融云，连接融云</h1><p>在APPDelegate中注册自定义的消息类型和做消息推送相关的内容。<br>最好是在登录APP的时候，让服务端返回userId和rongcloudToken，获取到Token以后，登录融云的服务器。可以写一个单例的工具类，来处理融云的登录，断开连接，和&lt;RCIMUserInfoDataSource, RCIMReceiveMessageDelegate,RCIMConnectionStatusDelegate&gt;用户数据源的一些方法的实现。</p><h1 id="用户信息和群组信息的数据源"><a href="#用户信息和群组信息的数据源" class="headerlink" title="用户信息和群组信息的数据源"></a>用户信息和群组信息的数据源</h1><p>因为融云已经做好了基本的聊天通讯的功能，我们要做的就是处理用户昵称，头像和群组的一些信息的处理，设置</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置用户信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.userInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群组信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群成员数据源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupMemberDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息需要通过实现RCIMUserInfoDataSource的方法"><a href="#用户信息需要通过实现RCIMUserInfoDataSource的方法" class="headerlink" title="用户信息需要通过实现RCIMUserInfoDataSource的方法"></a>用户信息需要通过实现RCIMUserInfoDataSource的方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getUserInfoWithUserId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">userId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCUserInfo *userInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>我们需要在这个方法里面调用自己的接口来获取用户的相关信息，就是头像和昵称，然后把获取到的数据放到RCUserInfo对象的userId，name，和portraitUri中，也把这个数据存到FMDB数据库中。这样在聊天列表展示聊天cell的时候，可以通过<br><code>RCUserInfo *user = [[RCIM sharedRCIM] getUserInfoCache:model.targetId];</code>这个方法，如果User存在的话，直接赋值，如果不存在的话，再次调用getUserInfoWithUserId这个来获取用户的信息，获取到以后刷新用户信息，并存到数据库中。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">RCIM</span> sharedRCIM] refreshUserInfoCache:user withUserId:user.userId]<span class="comment">; </span></span><br><span class="line">[[<span class="name">JRDataBaseManager</span>  shareInstance]insertUserToDB:userInfo]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="群组信息实现RCIMGroupInfoDataSource方法"><a href="#群组信息实现RCIMGroupInfoDataSource方法" class="headerlink" title="群组信息实现RCIMGroupInfoDataSource方法"></a>群组信息实现RCIMGroupInfoDataSource方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getGroupInfoWithGroupId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">groupId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCGroup *groupInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>融云自带的群组的信息类是RCGroup，只包含groupId，groupName和portraitUri，我们如果需要更多的信息存储，只需要继承自RCGroup,<br>如果我们需要在群组名称中携带很多信息的话，只需要把相关的信息放到一个字典中然后后转化成json字符串赋值给groupName</p><h3 id="群组成员实现"><a href="#群组成员实现" class="headerlink" title="群组成员实现"></a>群组成员实现</h3><p>我们可以写个单例来实现这三个方法。在方法实现中通过调用自己的接口获取到相关的数据，然后调用融云的接口refreshGroupInfoCache存储起来。</p><h1 id="消息列表"><a href="#消息列表" class="headerlink" title="消息列表"></a>消息列表</h1><p>消息列表需要继承自RCConversationListViewController，只要继承了这个，然后通过其暴露的属性和方法来设置基本列表的样式，当有消息的时候就能展示出来融云自带的聊天cell。如果我们要自定义的消息列表的cell。主要实现的方法：</p><h3 id="重写方法：插入自定义会话model"><a href="#重写方法：插入自定义会话model" class="headerlink" title="重写方法：插入自定义会话model"></a>重写方法：插入自定义会话model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSMutableArray</span> *)willReloadTableData:(<span class="built_in">NSMutableArray</span> *)dataSource&#123;</span><br><span class="line"> [dataSource enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        RCConversationModel *model = (RCConversationModel *)obj;</span><br><span class="line">        <span class="comment">//筛选请求添加好友的系统消息，用于生成自定义会话类型的cell</span></span><br><span class="line">       <span class="keyword">if</span> (model.conversationType == ConversationType_GROUP) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (model.conversationType == ConversationType_PRIVATE) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">     <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在该方法内筛选数据源dataSource中具体的会话类型及消息的model，将model 类型必须修改为 model.conversationModelType=RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION</p><p>如果需要插入类似微博消息列表中的点赞、评论，关注和系统消息的自定义cell，需要在这个方法中自定义Model，并且拼接到DataSource中。</p><p>代码如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_isShowServiceSystem == <span class="keyword">NO</span>) &#123;</span><br><span class="line">        RCConversationModel *<span class="keyword">model</span> = [[RCConversationModel alloc] init];</span><br><span class="line">        <span class="keyword">model</span>.targetId = JR_Service_System_ID;</span><br><span class="line">        <span class="keyword">model</span>.conversationType = ConversationType_SYSTEM;</span><br><span class="line">        <span class="keyword">model</span>.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        [dataSource addObject:<span class="keyword">model</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重写返回-cell-高度的方法"><a href="#重写返回-cell-高度的方法" class="headerlink" title="重写返回 cell 高度的方法"></a>重写返回 cell 高度的方法</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGFloat)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView heightForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath;</span><br></pre></td></tr></table></figure><p>如果需要显示不同高度测自定义的cell，只需要在这个方法中，根据判断的类型返回高度值。</p><h3 id="自定义会话Cell显示时的回调"><a href="#自定义会话Cell显示时的回调" class="headerlink" title="自定义会话Cell显示时的回调"></a>自定义会话Cell显示时的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(RCConversationBaseCell *)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView cellForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>或者是即将显示cell的时候把用户信息和群组信息放到cell里面</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>willDisplayConversationTableCell:<span class="params">(RCConversationBaseCell *)</span>cell atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>如果使用的都是自定义的cell的话，要设置在model.conversationModelType == RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION)先区分数据模型是自定义的，再区分是单聊还是群聊conversationType。对于每一种会话类型，自定义我们需要的cell的样式，然后通过取出对应index的Model。<br>  <code>RCConversationModel *model = self.conversationListDataSource[indexPath.row];</code><br>来把Model中的头像、昵称、最近消息、时间、未读数、一些信息放到cell对应的位置。</p><h3 id="点击事件-–点击cell的回调"><a href="#点击事件-–点击cell的回调" class="headerlink" title="点击事件 –点击cell的回调"></a>点击事件 –点击cell的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>onSelectedTableRow:<span class="params">(RCConversationModelType)</span>conversationModelType</span><br><span class="line">         conversationModel:<span class="params">(RCConversationModel *)</span>model</span><br><span class="line">               atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>在点击事件中，根据你自定义cell类型的不同，跳转到不同的页面，如果是单聊，群聊跳转到聊天会话页面，如果是系统消息：评论回复、点赞、关注、系统消息，跳转到自己写的页面，融云提供了这种系统消息的通知的接口，我们可以通过它的接口就可以实现通知的推送，不需要接入第三方极光等来进行推送。只需要把这些通知调用发送接口，作为消息发送给用户。</p><p>例如：评论和回复页面：继承自RCConversationViewController，隐藏下面的输入栏<code>self.chatSessionInputBarControl.hidden = YES;</code><br>注册自定义的消息和数据模型：<code>[self registerClass:[JRServiceCommentCell class] forMessageClass:[JRServiceCommentModel class]];</code><br>通过接收到通知以后，在会话页面插入一条消息并展示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在会话页面中插入一条消息并展示</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(updateForSharedMessageInsertSuccess:)</span><br><span class="line">                                                 name:<span class="string">@"RCDSharedMessageInsertSuccess"</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">                                               </span><br><span class="line">-(<span class="keyword">void</span>)updateForSharedMessageInsertSuccess:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    RCMessage *message = notification.object;</span><br><span class="line">    <span class="keyword">if</span> (message.conversationType == <span class="keyword">self</span>.conversationType &amp;&amp; [message.targetId isEqualToString:<span class="keyword">self</span>.targetId]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> appendAndDisplayMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论和回复的cell继承自RCMessageBaseCell。可以自己写这个cell的样式。再说一下这个cell的数据源，也是自己自定义的CommentModel继承自RCMessageContent，就和自定义消息类型一样的，需要把消息内容编码成JSON，然后将JSON解码成消息内容，定义消息的类型名（与融云消息不要名字一样），类似我们平时用网络请求后的JSON数据解析，把NSData的data消息解码成字典，<code>NSDictionary *dictionary = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error];</code>然后把字典中的dictionary[@”content”]取出来，判断是字典还是字符串类型，如果是字典的话就用YYModel解析到一个Model中来使用。如果是字符串的话就用方法把JSON字符串转化为字典，</p><h1 id="消息会话"><a href="#消息会话" class="headerlink" title="消息会话"></a>消息会话</h1><h1 id="消息会话展示"><a href="#消息会话展示" class="headerlink" title="消息会话展示"></a>消息会话展示</h1><ol><li>单聊不显示对方名称：RCMessageModel的model.isDisplayNickname来设置<br>2.群聊显示身份的名称：获取到群成员数组以后，遍历数组，把身份和成员的昵称存到RCUserInfo的name中，并保存到SDK中，再把  [self.conversationMessageCollectionView reloadData];</li></ol><p>重要的方法:<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sendMessage:<span class="params">(RCMessageContent *)</span>messageContent pushContent:<span class="params">(NSString *)</span>pushContent;</span><br></pre></td></tr></table></figure></p><p>在发送自定义消息和通知的时候使用，当我在发送一个邀请好友进入聊天室的自定义cell的时候，使用</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JRInviteMessage *inviteMsg = [JRInviteMessage messageWithGroupId:<span class="literal">self</span>.<span class="keyword">group</span>Id</span><br><span class="line">                                                             WithGroupHeader:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img).length==<span class="number">0</span>?  <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>ImgAll :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img</span><br><span class="line">                                                               WithGroupName:[<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name containsString:@<span class="string">"、"</span>] ? <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>NameAll : <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name</span><br><span class="line">                                                            WithGroupProflie:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct).length==<span class="number">0</span>?  @<span class="string">"暂无简介"</span> :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct];</span><br><span class="line">           </span><br><span class="line">[[RCIM sharedRCIM]sendMessage:ConversationType_PRIVATE</span><br><span class="line">                                 targetId:selectArray[j]</span><br><span class="line">                                  content:inviteMsg</span><br><span class="line">                              pushContent:nil</span><br><span class="line">                                 pushData:nil</span><br><span class="line">                                  success:^(long messageId) &#123;&#125;</span><br><span class="line">                                    error:^(RCErrorCode nErrorCode, long messageId)&#123;&#125;]</span><br></pre></td></tr></table></figure><p>对于文字，图片和自定义的消息的cell都可以重写，文字继承自RCTextMessageCell，语音继承自RCVoiceMessageCell，图片继承自RCImageMessageCell，其他自定义邀请好友进入群聊的cell继承自RCMessageCell或者是它的父类RCMessageBaseCell，在方法中实现<br><code>- (void)setDataModel:(RCMessageModel *)model</code>来设置自己想要的属性的样式.</p><h3 id="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"><a href="#进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库" class="headerlink" title="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"></a>进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库</h3><p>这样做的目的就是：用户换了头像或者是昵称以后，在会话页面可以更新用户的数据，</p><h3 id="自定义Cell的点击"><a href="#自定义Cell的点击" class="headerlink" title="自定义Cell的点击"></a>自定义Cell的点击</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>didTapMessageCell:<span class="params">(RCMessageModel *)</span>model</span><br></pre></td></tr></table></figure><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><p>就像上面的会话列表里面的评论和回复一样，只要在这个的地方，调用自己服务端在融云基础上开发的接口，就能把Model传过去，把需要发送的数据放在一个字典里面，然后jsonStringWithObject把字典转换成JSON字符串</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>1.修改聊天气泡以及一些图标<br>直接把要替换的图片替换RongCloud.bundle文件中的图片即可。</p><p>2.当融云SDK和BlocksKit被引入到同一工程，通过融云的聊天UI界面去选择照片、拍摄照片并发送时，无法正常选择和发送。<br>问题的本质：</p><p>UIImagePickerController代理中的方法冲突了，导致融云SDK中选择并发送照片的功能失效。</p><p>解决方法：</p><p>BlocksKit是开源方法，直接编辑UIImagePickerController+BlocksKit.m文件，注释红框部分，问题便可解决。<img src="http://rongcloud-web.qiniudn.com/39ef2374b74fb20691d28a5b6b9824d1" alt></p><p>3.//点击消息发送失败红点的回调<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">didTapmessageFailedStatusViewForResend:(RCMessageModel </span>*)model&#123;</span><br><span class="line">     RCMessageContent *resendContent = (RCMessageContent *)model.content<span class="comment">;</span></span><br><span class="line">    AlertShowMoreButtons(@[@<span class="string">"重新发送"</span>], ^(NSString *title, NSInteger moreButtonIndex) &#123;</span><br><span class="line">        if (<span class="keyword">BoolEqualToString(title, </span>@<span class="string">"重新发送"</span>)) &#123;</span><br><span class="line">            [self resendMessage:resendContent]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>独立开发一个APP</title>
    <link href="http://peilinghui.com/2018/08/04/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAPP/"/>
    <id>http://peilinghui.com/2018/08/04/独立开发一个APP/</id>
    <published>2018-08-04T07:22:24.000Z</published>
    <updated>2018-10-11T04:02:17.141Z</updated>
    
    <content type="html"><![CDATA[<p>独立开发一个社群APP，类似微博，知识星球，简书这一类的。</p><a id="more"></a><p>首先是整个项目的框架的搭建。</p><h1 id="中间层的路由跳转方案"><a href="#中间层的路由跳转方案" class="headerlink" title="中间层的路由跳转方案"></a>中间层的路由跳转方案</h1><p>抽象出一个中间层来对纷乱的引用关系进行统一的跳转。模块只和中间层耦合，模块间解耦；中间层使用runtime的形式调用模块的业务组件，不依赖具体的模块代码.两种主流方案:</p><ol><li>以<a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="noopener">JLRoutes</a>为代表的URLRoute方案:以URL为key，以待执行的block为value，保存在一个全局map中，在内存中常驻;</li><li>Mediator中间人方案:把所有的调用都集合在一起，使用一个中间人管理。所有调用方都通过中间人调取另外一个模块;</li></ol><ul><li>创建Target-Action。Target对象暴露整个模块对外提供的所有服务，此外，因为Mediator和Target是通过Runtime交互的，Target暴露的方法中接收的参数是一个字典，但在方法实现中负责将传过来的字典还原成各个参数，并调用该模块具体的类和方法。</li><li>创建 CTMediator 的Category. 受限于runtime只能以字典形式传一系列参数，Mediator分类的职责就在于对外提供参数友好型的一系列方法，但在方法实现中包装成字典形式。这里涉及到key的定义必须和Target中还原时的key定义一致，因此划分给相同的开发维护。<br><a href="https://github.com/yehot/YT_TargetAction" target="_blank" rel="noopener">使用方法</a></li></ul><ol start="3"><li><a href="https://github.com/xuzhenhao/ZHMediator" target="_blank" rel="noopener">结合URLRoute和Mediator的跳转方案</a></li></ol><h1 id="整体导航条Navigation"><a href="#整体导航条Navigation" class="headerlink" title="整体导航条Navigation"></a>整体导航条Navigation</h1><p>写自定义的navigationController，主要用于处理问题：</p><ul><li>手势返回的支持和不支持。</li><li>导航栏的显示和隐藏。</li><li>底部tabBar的显示和隐藏。</li></ul><p>在一些页面对于statusBar的处理，设置statusBar的背景颜色和样式</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>在AFN上面封装，包装AFNManager，创建一个单例的HTTPClient继承自AFHTTPSessionManager，在单例中设置securityPolicy、requestSerializer、responseSerializer、和请求头，以及Content-type相关的参数，包装GET、post请求<br>没有判断网络的情况，是WIFI还是4G还是3G，还是无网络的状态</p><h1 id="tableView自适应"><a href="#tableView自适应" class="headerlink" title="tableView自适应"></a>tableView自适应</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>Sunny写的<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a><br>UITableView+FDTemplateLayoutCell</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><a href="https://github.com/peilinghui/SDAutoLayout" target="_blank" rel="noopener">SDAutoLayout</a><br>不仅可以实现tableview和cell高度自适应，还可以实现普通view的自动布局，比用masonry代码更少，</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>在每个元素的模型model中添加一个height属性，实现它的get方法，在get方法中计算需要多行显示文字的高度，然后再加上其他乱七八糟的高度并返回，然后在tableview的 </p><ul><li>(CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath中获取到每行对应的model，取出其中的model.height属性的值返回，还要在cell中确定cell中label的高度。。。总之就是很麻烦，而且还不一定总能算的很正确，甚是受此困扰。</li></ul><p>只要你懂一定的Autolayout知识的话，原来实现这种的cell高度自适应，其实是灰常灰常简单的：<br>首先，第一步，现在自定义的cell中将高度随着内容动态改变的label的布局使用autolayout布局完成，这里有个注意点就是label和cell边界的距离要确定好，不能固定死label的高度，然后设置label的numberOfLines=0，行数设置为0即意味着label可以有任意行。<br>其次，实现以下两个tableview的delegate中的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，只要实现这两个方法，然后运行你的项目，你会惊讶的发现，哇塞，高度完美自适应…<br>这里有几个关键点：<br>关键点1：必须重写estimatedHeightForRowAtIndexPath方法<br>这个方法是iOS7.0之后才出现的，如果不重写此方法，仅重写heightForRowAtIndexPath，那么大家会发现，cell并不会根据label的内容，自适应高度。因为系统是先获取cell的高度，再获取cell的view。也就是先调用heightForRowAtIndexPath，再调用cellForRowAtIndexPath。在cellForRowAtIndexPath被调用之前，你的label是没有被设置文本内容的，因此它获取到的高度，并不是你想要的。那么我们必须想办法让系统在获取了cell之后，再获取cell的高度。方法就是，重写estimatedHeightForRowAtIndexPath，顾名思义，它会返回一个估计高度，有了这个方法后，tableview会先调用它获取估计高度，然后获取cell，最后获取真实高度。estimatedHeightForRowAtIndexPath的返回值可以随意，返回多少都可以，只是给tableview一个安慰而已，让它延迟获取真实的高度。<br>关键点2：真实高度返回值为<br>UITableViewAutomaticDimension<br>关键点3：cell中的元素，必须相对于cell的顶部和底部布局，这样在元素中的内容动态变化的时候，才能撑开cell</p><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>ASDK：AsyncDisplayKit.相关连接：<br><a href="https://draveness.me/asdk-rendering" target="_blank" rel="noopener">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></p><p><a href="https://www.cnblogs.com/ludashi/p/5895725.html" target="_blank" rel="noopener">iOS开发之多种Cell高度自适应实现方案的UI流畅度分析</a></p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><p>YYKit的</p><h1 id="整体的方法"><a href="#整体的方法" class="headerlink" title="整体的方法"></a>整体的方法</h1><p>页面布局：masonry自动布局<br>页面的网络解析：YYModel<br>页面的网络请求：</p><p>各个模块需要注意的问题：</p><h1 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h1><p>第一次登录和再次登录</p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>图片压缩</p><h1 id="弹框处理"><a href="#弹框处理" class="headerlink" title="弹框处理"></a>弹框处理</h1><h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h1 id="下拉刷新和上拉加载更多"><a href="#下拉刷新和上拉加载更多" class="headerlink" title="下拉刷新和上拉加载更多"></a>下拉刷新和上拉加载更多</h1><h1 id="第三方登录和第三方分享"><a href="#第三方登录和第三方分享" class="headerlink" title="第三方登录和第三方分享"></a>第三方登录和第三方分享</h1><p>第三方分享：</p><ol><li>申请微信APPKey和申请友盟APPkey</li><li>cocospod:    pod ‘UMengUShare/Social/WeChat’</li><li>在APPdelegate中设置APPkey</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAppkey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//友盟</span></span><br><span class="line">    [WXApi <span class="string">registerApp:</span>WXAPPID];</span><br><span class="line">    <span class="comment">//设置友盟appkey</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setUmSocialAppkey:</span>UMKey];</span><br><span class="line">    <span class="comment">//分享到微信</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setPlaform:</span>UMSocialPlatformType_WechatSession <span class="string">appKey:</span>APPKEY <span class="string">appSecret:</span>APPSECRET <span class="string">redirectURL:</span>@<span class="string">"www.com"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)<span class="string">application:</span>(UIApplication *)application <span class="string">openURL:</span>(NSURL *)url <span class="string">sourceApplication:</span>(NSString *)sourceApplication <span class="string">annotation:</span>(id)annotation</span><br><span class="line">&#123;</span><br><span class="line">    BOOL result = [UMSocialSnsService <span class="string">handleOpenURL:</span>url];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置Plis跳转的URL。URL Schemes列为白名单</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>LSApplicationQueriesSchemes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>weixin<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>创建分享信息</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建分享消息对象</span></span><br><span class="line"> UMSocialMessageObject *messageObject = [UMSocialMessageObject messageObject];</span><br><span class="line"><span class="built_in">NSString</span> *title = <span class="keyword">self</span>.shareTitle;</span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="keyword">self</span>.originUrl;</span><br><span class="line"><span class="built_in">NSString</span> *text = <span class="keyword">self</span>.shareText;</span><br><span class="line"><span class="built_in">NSString</span> *imgUrl = <span class="keyword">self</span>.shareImage;</span><br><span class="line">UMShareWebpageObject *shareObject = [UMShareWebpageObject shareObjectWithTitle:title descr:text thumImage:imgUrl];</span><br><span class="line">[shareObject setWebpageUrl:url];</span><br><span class="line">messageObject.shareObject = shareObject;</span><br><span class="line">[[UMSocialManager defaultManager] shareToPlatform:UMSocialPlatformType_WechatSession</span><br><span class="line">           messageObject:messageObject</span><br><span class="line">currentViewController:<span class="literal">nil</span></span><br><span class="line">completion:^(<span class="keyword">id</span> data, <span class="built_in">NSError</span> *error) &#123;    </span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">UMSocialLogInfo(<span class="string">@"************Share fail with error %@*********"</span>,error);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;         </span><br><span class="line"><span class="keyword">if</span> ([data isKindOfClass:[UMSocialShareResponse <span class="keyword">class</span>]]) &#123;          </span><br><span class="line">  UMSocialShareResponse *resp = data; UMSocialLogInfo(<span class="string">@"response message is %@"</span>,resp.message);   UMSocialLogInfo(<span class="string">@"response originalResponse data is %@"</span>,resp.originalResponse);&#125;<span class="keyword">else</span>&#123; UMSocialLogInfo(<span class="string">@"response data is %@"</span>,data); &#125;&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="系统问题"><a href="#系统问题" class="headerlink" title="系统问题"></a>系统问题</h1><p>启动图</p><p>横屏</p><p>推送</p><p>3Dtouch</p><p>屏幕适配</p><h1 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h1><p>1。手动打包</p><p>2。自动化打包</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>tableView的流畅：没有网络请求结束的时候先加载占位图，然后<br><a href="https://www.jianshu.com/p/d1e6ae279dd2" target="_blank" rel="noopener">UITableView的优化策略</a><br><a href="https://didee.cn/2018/01/29/iOS-ASDK/" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a><br>UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定 contentSize及Cell的位置,然后才会调用tableView:cellForRowAtIndexPath:,从而来显示在 当前屏幕的Cell。</li></ol><p>UITableView的滚动优化主要在于以下两个方面：</p><p>减少cellForRowAtIndexPath代理中的计算量（cell的内容计算）<br>减少heightForRowAtIndexPath代理中的计算量（cell的高度计算）</p><h3 id="减少cellForRowAtIndexPath代理中的计算量"><a href="#减少cellForRowAtIndexPath代理中的计算量" class="headerlink" title="减少cellForRowAtIndexPath代理中的计算量"></a>减少cellForRowAtIndexPath代理中的计算量</h3><p>首先要提前计算每个cell中需要的一些基本数据，代理调用的时候直接取出；<br>图片要异步加载，加载完成后再根据cell内部UIImageView的引用设置图片；<br>图片数量多时，图片的尺寸要跟据需要提前经过transform矩阵变换压缩好（直接设置图片的contentMode让其自行压缩仍然会影响滚动效率），必要的时候要准备好预览图和高清图，需要时再加载高清图。<br>图片的‘懒加载’方法，即延迟加载，当滚动速度很快时避免频繁请求服务器数据。<br>尽量手动Drawing视图提升流畅性，而不是直接子类化UITableViewCell，然后覆盖drawRect方法，因为cell中不是只有一个contentview。绘制cell不建议使用UIView，建议使用CALayer。原因要参考UIView和CALayer的区别和联系。</p><h3 id="减少heightForRowAtIndexPath代理中的计算量"><a href="#减少heightForRowAtIndexPath代理中的计算量" class="headerlink" title="减少heightForRowAtIndexPath代理中的计算量"></a>减少heightForRowAtIndexPath代理中的计算量</h3><p>由于每次TableView进行update更新都会对每一个cell调用heightForRowAtIndexPath代理取得最新的height，会大大增加计算时间。如果表格的所有cell高度都是固定的，那么去掉heightForRowAtIndexPath代理，直接设置TableView的rowHeight属性为固定的高度；<br>如果高度不固定，应尽量将cell的高度数据计算好并储存起来，代理调用的时候直接取，即将height的计算时间复杂度降到O(1)。例如：在异步请求服务器数据时，提前将cell高度计算好并作为dataSource的一个数据存到数据库供随时取用。</p><h1 id="数据刷新"><a href="#数据刷新" class="headerlink" title="数据刷新"></a>数据刷新</h1><h2 id="tableView的数据刷新"><a href="#tableView的数据刷新" class="headerlink" title="tableView的数据刷新"></a>tableView的数据刷新</h2><p>那就在每个元素的model里面加上一个高度字段，显示的时候如果高度非0，直接拿过来使用，如果是0就自适应计算一下</p><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p><h1 id="把模块拆分成Pod"><a href="#把模块拆分成Pod" class="headerlink" title="把模块拆分成Pod"></a>把模块拆分成Pod</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="UIScrollView的左右滑动与侧滑返回并存"><a href="#UIScrollView的左右滑动与侧滑返回并存" class="headerlink" title="UIScrollView的左右滑动与侧滑返回并存"></a>UIScrollView的左右滑动与侧滑返回并存</h2><p>侧滑返回效果的触发需要满足：(1) 滑动位置在屏幕左边缘;（2）向右滑动;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 侧滑返回和控件手势冲突的解决方法</span></span><br><span class="line"><span class="comment">//是否支持多手势触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥.</span></span><br><span class="line"><span class="comment">//是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播</span></span><br><span class="line"><span class="comment">//一句话总结就是此方法返回YES时，手势事件会一直往下传递，不论当前层次是否对该事件进行响应。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//location_X可自己定义,其代表的是滑动返回距左边的有效长度</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)panBack:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是滑动返回距左边的有效长度</span></span><br><span class="line">    <span class="keyword">int</span> location_X =<span class="number">0.15</span>*IPHONE_W;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gestureRecognizer ==<span class="keyword">self</span>.panGestureRecognizer) &#123;</span><br><span class="line">        <span class="built_in">UIPanGestureRecognizer</span> *pan = (<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer;</span><br><span class="line">        <span class="built_in">CGPoint</span> point = [pan translationInView:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">UIGestureRecognizerState</span> state = gestureRecognizer.state;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIGestureRecognizerStateBegan</span> == state ||<span class="built_in">UIGestureRecognizerStatePossible</span> == state) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> location = [gestureRecognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这是允许每张图片都可实现滑动返回</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = location.x;</span><br><span class="line">            <span class="keyword">int</span> temp2 =IPHONE_W;</span><br><span class="line">            <span class="built_in">NSInteger</span> XX = temp1 % temp2;</span><br><span class="line">            <span class="keyword">if</span> (point.x &gt;<span class="number">0</span> &amp;&amp; XX &lt; location_X) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取系统的UIPanGestureRecognizer的<br>(3) 侧滑手势优先，侧滑手势失效时，才触发UISrcollView的滑动</p><p><a href="https://www.jianshu.com/p/8170fea174da" target="_blank" rel="noopener">https://www.jianshu.com/p/8170fea174da</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;独立开发一个社群APP，类似微博，知识星球，简书这一类的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS底层实现</title>
    <link href="http://peilinghui.com/2018/06/25/iOS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://peilinghui.com/2018/06/25/iOS底层实现/</id>
    <published>2018-06-25T07:07:36.000Z</published>
    <updated>2018-10-14T06:49:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>源于一个面试题。</p><a id="more"></a><p><img src="https://wx3.sinaimg.cn/mw690/51530583ly1fsatleo2zmj213u10caiu.jpg" alt><br>我们知道在Runtime中的swizzling:通过selector来找IMP，可以利用Runtime来实现交换原方法和目标方法的IMP，以完全代替原方法的实现，或为原实现前后相当于加一段额外的代码。</p><p>就是在分类的load方法中，通过class_getClassMethodclass_getInstanceMethod获取类方法和实例方法，然后method_exchangeImplementations(),交换方法实现，或者是其他class_addMethods、class_addIvar、class_addProtocol、class_addProperty来动态的添加方法或者成员变量。还有class_copyIvarList、class_copyMethodList获得某个类所有的成员变量和所有方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span>: <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodA;</span><br><span class="line">+ (<span class="keyword">void</span>)methodB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(methodA));</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(swizzled_methodA));</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_methodA &#123;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span> swizzled_methodA];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AOP的库Aspects 支持多次hook同一个方法，支持从hook返回的id<aspecttoken>对象删除对应的hook，IMP即函数指针。<br>Aspects 的大致原理：替换原方法的IMP为 消息转发函数指针 _objc_msgForward或_objc_msgForward_stret，把原方法IMP添加并对应到SEL aspects_originalSelector，将forwardInvocation:的IMP替换为参数对齐的C函数<strong>ASPECTS_ARE_BEING_CALLED</strong>(NSObject <em>self, SEL selector, NSInvocation </em>invocation)的指针。在<strong>ASPECTS_ARE_BEING_CALLED</strong>函数中，替换invocation的selector为aspects_originalSelector，相当于要发送调用原始方法实现的消息。对于插入位置在前面，替换，后面的多个block，构建新的blockInvocation，从invocation中提取参数，最后通过invokeWithTarget:block来完成依次调用。</aspecttoken></p><h1 id="libffi-简介"><a href="#libffi-简介" class="headerlink" title="libffi 简介"></a>libffi 简介</h1><p>    libffi 可以认为是实现了C语言上的runtime，简单来说，libffi 可根据 参数类型(ffi_type)，参数个数 生成一个 模板(ffi_cif)；可以输入 模板、函数指针 和 参数地址 来直接完成 函数调用(ffi_call)； 模板 也可以生成一个所谓的 闭包(ffi_closure)，并得到指针，当执行到这个地址时，会执行到自定义的void function(ffi_cif <em>cif, void </em>ret, void <strong>args, void <em>userdata)函数，在这里，我们可以获得所有参数的地址(包括返回值)，以及自定义数据userdata。当然，在这个函数里我们可以做一些额外的操作。<br>    <br>    <br>如何hook ObjC方法和实现AOP，思路：我们可以将ffi_closure关联的指针替换原方法的IMP，当对象收到该方法的消息时objc_msgSend(id self, SEL sel, …)，将最终执行自定义函数void ffi_function(ffi_cif </em>cif, void *ret, void </strong>args, void *userdata)。而实现这一切的主要工作是：设计可行的结构，存储类的多个hook信息；根据包含不同参数的方法和切面block，生成包含匹配ffi_type的cif；替换类某个方法的实现为ffi_closure关联的imp，记录hook；在ffi_function里，根据获得的参数，动态调用原始imp和block。</p><h2 id="动态调用C函数"><a href="#动态调用C函数" class="headerlink" title="动态调用C函数"></a>动态调用C函数</h2><p>使用libffi提供接口动态调用流程如下：</p><ol><li>准备好参数数据及其对应ffi_type数组、返回值内存指针、函数指针</li><li>创建与函数特征相匹配的函数原型：ffi_cif对象</li><li>使用“ffi_call”来完成函数调用<br>使用ffi，只要有函数原型cif对象，函数实现指针，返回值内存指针和函数参数数组，我们就可以实现在运行时动态调用任意C函数。</li></ol><p>所以如果想实现其他语言(譬如JS)，执行过程中动态调用C函数，只需在调用过程中加一层转换，将参数及返回值类型转换成libffi对应类型，并封装成函数原型cif对象，准备好参数数据，找到对应函数指针，然后调用即可。</p><h2 id="动态定义C函数"><a href="#动态定义C函数" class="headerlink" title="动态定义C函数"></a>动态定义C函数</h2><p>libffi还有一个特别强大的函数，通过它我们可以将任意参数和返回值类型的函数指针，绑定到一个函数实体上。那么这样我们就可以很方便的实现动态定义一个C函数了！同时这个函数在编写解释器或提供任意函数的包装器(通用block)时非常有用，此函数是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffi_status ffi_prep_closure_loc (ffi_closure *closure,  <span class="comment">//闭包，一个ffi_closure对象</span></span><br><span class="line">       ffi_cif *cif,  <span class="comment">//函数原型</span></span><br><span class="line">       <span class="keyword">void</span> (*fun) (ffi_cif *cif, <span class="keyword">void</span> *ret, <span class="keyword">void</span> **args, <span class="keyword">void</span>*user_data), <span class="comment">//函数实体</span></span><br><span class="line">       <span class="keyword">void</span> *user_data, <span class="comment">//函数上下文，函数实体实参</span></span><br><span class="line">       <span class="keyword">void</span> *codeloc)   <span class="comment">//函数指针，指向函数实体</span></span><br></pre></td></tr></table></figure><p>通过一个简单的例子，看下如何将一个函数指针绑定到一个函数实体上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acts like puts with the file given at time of enclosure. */</span></span><br><span class="line"><span class="comment">// 函数实体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts_binding</span><span class="params">(ffi_cif *cif, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ret, <span class="keyword">void</span>* args[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ret = <span class="built_in">fputs</span>(*(<span class="keyword">char</span> **)args[<span class="number">0</span>], stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ffi_cif cif;</span><br><span class="line">    ffi_type *args[<span class="number">1</span>];</span><br><span class="line">    ffi_closure *closure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*bound_puts)(<span class="keyword">char</span> *);  <span class="comment">//声明一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate closure and bound_puts */</span>  <span class="comment">//创建closure</span></span><br><span class="line">    closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), &amp;bound_puts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closure)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Initialize the argument info vectors */</span></span><br><span class="line">        args[<span class="number">0</span>] = &amp;ffi_type_pointer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Initialize the cif */</span>  <span class="comment">//生成函数原型</span></span><br><span class="line">        <span class="keyword">if</span> (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, <span class="number">1</span>,</span><br><span class="line">                         &amp;ffi_type_uint, args) == FFI_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Initialize the closure, setting stream to stdout */</span></span><br><span class="line">            <span class="comment">// 通过 ffi_closure 把 函数原型_cifPtr / 函数实体JPBlockInterpreter / 上下文对象self / 函数指针blockImp 关联起来</span></span><br><span class="line">            <span class="keyword">if</span> (ffi_prep_closure_loc(closure, &amp;cif, puts_binding,</span><br><span class="line">                                     <span class="built_in">stdout</span>, bound_puts) == FFI_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                rc = bound_puts(<span class="string">"Hello World!"</span>);</span><br><span class="line">                <span class="comment">/* rc now holds the result of the call to fputs */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deallocate both closure, and bound_puts */</span></span><br><span class="line">    ffi_closure_free(closure);   <span class="comment">//释放闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述步骤大致分为：</p><ol><li>准备一个函数实体</li><li>声明一个函数指针</li><li>根据函数参数个数/参数及返回值类型生成一个函数原型</li><li>创建一个ffi_closure对象，并用其将函数原型、函数实体、函数上下文、函数指针关联起来</li><li>释放closure</li></ol><p>通过以上这5步，我们就可以在执行过程中将一个函数指针，绑定到一个函数实体上，从而轻而易举的实现动态定义一个C函数。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.assuner.com/%E5%BC%80%E6%BA%90/2018/01/16/Stinger.html" target="_blank" rel="noopener">Hook方法的新姿势–(使用libffi实现AOP )</a></p><p><a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="noopener">如何动态调用 C 函数</a></p><p><a href="http://blog.cnbang.net/tech/3332/" target="_blank" rel="noopener">如何动态创建 block – JPBlock 扩展原理详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源于一个面试题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective JavaScript</title>
    <link href="http://peilinghui.com/2018/04/19/Effective-JavaScript/"/>
    <id>http://peilinghui.com/2018/04/19/Effective-JavaScript/</id>
    <published>2018-04-19T00:08:23.000Z</published>
    <updated>2018-07-19T15:05:44.675Z</updated>
    
    <content type="html"><![CDATA[<p>Effective JavaScript</p><a id="more"></a><h1 id="Accustoming-Yourself-to-JavaScript让自己习惯JS"><a href="#Accustoming-Yourself-to-JavaScript让自己习惯JS" class="headerlink" title="Accustoming Yourself to JavaScript让自己习惯JS"></a>Accustoming Yourself to JavaScript让自己习惯JS</h1><h2 id="1-知道你正在使用的JavaScript模式"><a href="#1-知道你正在使用的JavaScript模式" class="headerlink" title="1.知道你正在使用的JavaScript模式"></a>1.知道你正在使用的JavaScript模式</h2><p>是否使用严格模式？只可选择其一或者将其自身包裹在立即调用的函数表达式（IIFE）中连接多个文件。<br>获得最大兼容性： 在严格模式下，并且显式地将代码内容包裹在严格函数中。</p><h2 id="2-注意JavaScript的浮点数"><a href="#2-注意JavaScript的浮点数" class="headerlink" title="2.注意JavaScript的浮点数"></a>2.注意JavaScript的浮点数</h2><p>avaScript的数字都是双精度的浮点数。<br>JavaScript中的整数只是双精度浮点数的一个子集,而不是一个单独的数据类型。<br>位运算符把数字当做32位的有符号整数来处理。<br>注意JavaScript中浮点数的精度陷阱。</p><h2 id="3-当心隐式的强制转换"><a href="#3-当心隐式的强制转换" class="headerlink" title="3.当心隐式的强制转换"></a>3.当心隐式的强制转换</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Effective JavaScript&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React技术栈</title>
    <link href="http://peilinghui.com/2018/02/22/React%E7%9F%A5%E8%AF%86/"/>
    <id>http://peilinghui.com/2018/02/22/React知识/</id>
    <published>2018-02-22T06:26:54.000Z</published>
    <updated>2019-08-13T12:28:07.980Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对阅读深入React技术栈的总结和实践。</p><a id="more"></a><p><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">官网</a><br><a href="https://github.com/facebook/react" target="_blank" rel="noopener">github地址</a></p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>React基于Viral DOM实现了一个Synthetic（合成事件）层，使用stopPropagation()和preventDefault()来中断它。<br>所有事件都自动绑定到最外层，如果要访问原生事件对象，可以使用nativeEvent属性。</p><p>一、 合成事件的实现机制</p><ol><li>事件委派：把所有事件绑定到结构最外层，使用同一的事件监听器–映射所有组件内部的事件监听和处理函数。</li><li>自动绑定：手动绑定this为当前组件的方法：<ul><li>bind方法：使用::this.handleClick等同于this.handleClick.bind(this)</li><li>构造器内绑定声明，在constructor中完成</li><li>箭头函数</li></ul></li></ol><p>二、 使用原生事件<br>在ComponentDidMount中<br>this.refs.button.addEventListener(‘click’,e=&gt;{<br>    hanldeCliick(e);<br>});<br>在ComponentWillUnMount中移除<br>this.refs.button.removeEventListener(‘click’);</p><p>三、 合成事件和原生事件混用<br>比如在web页面添加移动设备扫描二维码的功能。</p><ol><li>不要把合成事件和原生事件混用</li><li>通过e.target判断来避免</li></ol><p>四、 对比React合成事件和JS的原生事件</p><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>一、 父组件向子组件通信<br>通过props</p><p>二、 子组件向父组件通信</p><ol><li>利用回调函数：this.props的function的回调</li><li>利用自定义事件机制，触发事件。</li></ol><p>三、 跨级组件通信<br>子组件跨级访问信息，使用context实现跨级父子组件间的通信。<br>在父组件中定义了ChildContext，在子组件中使用this.context从而调用。<br>一般只有在全局比如：界面主题、用户信息才会使用。总体原则：使用它，可以写成高阶组件。</p><p>四、 没有嵌套关系的组件通信<br>通过一个单例的EventEmitter，然后把这个实例输出到各组件中使用。</p><p>import {EventEmitter} from ‘event’;<br>export default new EventEmitter();</p><p>import emitter from ‘./events’;</p><p>在APP的类中的ComponentDidMount中emmit</p><h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><p>mixin和高阶组件<br>mixin:创造一种类似多重继承的效果，组合。</p><h1 id="Flux架构"><a href="#Flux架构" class="headerlink" title="Flux架构"></a>Flux架构</h1><p>不是MVC的架构，Flux三大部分组成：1. dispatcher、store、view。dispatcher负责分发事件，store负责保存数据、view负责订阅store中的数据，并使用这些数据渲染相应的页面。</p><p><strong>与MVC的主要区别：</strong><br>没有职责明确的Controller，存在一个Controller-view的角色，将view和store进行绑定，并没有Controller需要承担的复杂的逻辑。</p><ol><li><strong>dispatcher与action</strong><br>dispatcher的实现就是下面两个API:</li></ol><blockquote><p>.register(callback)方法用来注册一个监听器。<br>.dispatch(action)用来分发一个action。</p></blockquote><p>action是一个普通的JavaScript对象，一般包含type、payload字段，用于描述一个事件以及需要改变的相关数据。</p><ol start="2"><li><p><strong>store</strong><br>负责保存数据，并且修改数据的逻辑，调用dispatcher的register(callback)方法将自己注册为一个监听器。<br>当.dispatch(action)用来分发一个action时，store注册的监听器就会被调用，同时得到这个action作为参数。store之暴露getter不暴露setter，只能读取不能修改。</p></li><li><p><strong>Controller-view</strong><br>最顶层view，主要进行store与React组件(view层)之间的数据的绑定，定义数据更新以及传递的方式。会调用store保留的getter获取存储其中的数据并设置为自己的state，在render时以props的形式传给自己的子组件。</p></li><li><p><strong>view</strong><br>React组件扮演。结合Angular、Vue来发挥Flux的能力。<br>一条特殊的约定：<strong>Flux的view不能直接修改数据，如果页面操作需要修改数据，则必须使用dispatcher分发一个action。</strong></p></li></ol><ol start="5"><li><strong>actionCreator</strong><br>用来创造action的。为什么需要？因为在分发action的时候代码是冗余的。</li></ol><h1 id="Redux架构"><a href="#Redux架构" class="headerlink" title="Redux架构"></a>Redux架构</h1><h2 id="Redux简介"><a href="#Redux简介" class="headerlink" title="Redux简介"></a>Redux简介</h2><p>Redux的核心代码是一个库，类似Flux的架构思想，</p><h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><ol><li><p>单一数据源<br>一个应用永远只有唯一的一个数据源，整个应用状态都保存在一个对象中。</p></li><li><p>状态是只读的</p></li></ol><p>Flux中store没有setter只有getter，而Redux中没有store，只有reducer，根据当前触发的action对当前应用state进行迭代。</p><ol start="3"><li>状态修改均由纯函数完成</li></ol><p>Redux与Flux最大的不同。<br>在Flux中，我们在actionCreator里调用APPDispatcher.dispatch方法来触发action，直接修改了store中数据.</p><p>用户通过 View 发出 Action； store.dispatch(action);<br>然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State<br>State 一旦有变化，Store 就会调用监听函数。 store.subscribe(listener);<br>listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p><p>面试题：</p><ol><li><p>React中key的作用？怎样设置key值?</p><blockquote><p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:<br>用key值来标识哪些元素是改变的，新增的，或者移除的。</p></blockquote></li></ol><ul><li>使用数据项中的ID</li><li>生成唯一标识字符串</li><li>使用index数组下标；</li></ul><ol start="2"><li>SetState发生了什么？</li></ol><p>将传入参数对象与当前状态合并，触发reconciliation调和，构建新的元素树。自动计算新的树和老树的差异，按需渲染。不是全部重新渲染。</p><p>setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。<br>多次调用会合并为一次，只有当更新结束后 state 才会改变。所以setState是异步的，<br>两种方法解决： </p><ul><li>1.利用setState的第二个参数设置回调函数，setState调用后会触发执行这个callback函数；</li><li>2.利用setTimeout</li></ul><p>setTimeout(() =&gt; {console.log(this.state.counter)}, 0)</p><ol start="3"><li>props和state的区别？</li></ol><ul><li>props用于定义外部接口，使用state来存储控制当前页面逻辑的数据；</li><li>props的赋值是在父级组件，state赋值在当前组件内部；</li><li>props是不可变的，而state是可变的；</li><li>使用props比state会有更好的性能；</li></ul><ol start="4"><li>react 生命周期函数</li></ol><p>初始化阶段：<br>getDefaultProps:获取实例的默认属性<br>getInitialState:获取每个实例的初始化状态<br>componentWillMount：组件即将被装载、渲染到页面上<br>render:组件在这里生成虚拟的 DOM 节点<br>componentDidMount:组件真正在被装载之后  </p><p>运行中状态：<br>componentWillReceiveProps:组件将要接收到属性的时候调用<br>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）<br>componentWillUpdate:组件即将更新不能修改属性和状态<br>render:组件重新描绘<br>componentDidUpdate:组件已经更新  </p><p>销毁阶段：<br>componentWillUnmount:组件即将销毁</p><ol start="5"><li>Virtual DOM算法</li></ol><p>Virtual DOM 算法主要的实现就是三个步骤：</p><ul><li>用JS对象模拟DOM树element，</li><li>比较两棵虚拟DOM树的差异diff，</li><li>把差异应用到真正的DOM树上patch</li></ul><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是对阅读深入React技术栈的总结和实践。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative中使用Redux</title>
    <link href="http://peilinghui.com/2017/12/12/ReactNative%E4%B8%AD%E4%BD%BF%E7%94%A8Redux/"/>
    <id>http://peilinghui.com/2017/12/12/ReactNative中使用Redux/</id>
    <published>2017-12-12T15:14:35.000Z</published>
    <updated>2017-12-13T14:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Redux也有一段时间了。总结一下。</p><a id="more"></a><p>为什么要使用Redux?<br>背景：</p><ol><li>RN的state（可变，子组件不可见）和props（不可变，子组件可见）的设计，在面对大型项目时候，容易因为不经意修改state造成状态混乱，组件渲染错误</li><li>RN使用了Virtual DOM，不需要Target绑定-&gt;Action修改UI属性，只要当状态变化，render新状态下的组件，数据单向传递，而MVC的设计模式存在双向数据流。</li><li>RN不易进行测试，Redux提供了非常方便的mock测试方式。</li></ol><h1 id="Redux开发"><a href="#Redux开发" class="headerlink" title="Redux开发"></a>Redux开发</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>安装Redux：  ‘npm install –save redux’<br>安装React Native和Redux绑定库：npm install –save react-redux<br>安装Redux Thunk异步Action中间件：npm install –save redux-thunk</p><h2 id="三个原则"><a href="#三个原则" class="headerlink" title="三个原则"></a>三个原则</h2><ul><li>单一数据源<br>  整个应用的 state 被储存在一个对象树中，对象树存在于唯一的 store 中。store中的 state 绑定到组件</li><li>State 是只读的<br>  惟一改变 state 的方法就是触发 action。action 是一个含有 type 属性的普通JS对象，type 可以用常量表示事件。</li><li>使用纯函数来执行修改<br>  编写 reducers 来描述对应action如何修改 state 。一般可以用 switch(action.type) 来处理，无副作用<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>react-redux提供了connect和Provider。</li></ul><ol><li>Provider是顶层的分发点，属性就是Store，将State分发给所有被connect的组件<br>2.connect：接受两个参数：一个是mapStateToProps或者mapDispatchToProps，一个是要绑定的组件本身。</li></ol><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 就是把 Reducer 和 action 联系到一起的对象。Store 有以下职责：  </p><ul><li>维持应用的 state–类似数据库，存储应用的所有state。</li><li>提供 getState() 方法。获取 所有的当前state；</li><li>提供 dispatch(action) 方法更新 state，相当于存入数据库，存入action来改变state。</li><li>通过 subscribe(listener) 注册监听器。<br>Store本质上是一个对象，它以树的形式保存了整个应用的State。并提供了一些方法。例如getState( ) 和 dispatch( )。<br>Redux应用只有惟一一个Store。<br>Store通过createStore方法来创建，根据整个应用的根Reducer的初始State。<br>代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;<span class="comment">//异步</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">const</span> Store = applyMiddleware(thunk)(createStore)(reducers);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Store;</span><br></pre></td></tr></table></figure><h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h3><p>Action只是描述了有事情发生了这一事实，并没有指明应用如何更新state。这是reducer要做的事情。  </p><ol><li>Reducer的本质是一个函数，并且是一个纯函数。没有任何副作用。简单来讲Reducer只负责做一件事，就是根据接收到的action和state来修改Store中的state：</li></ol><p>(state, action) =&gt; newState  </p><ol start="2"><li>一般实现的时候，通过switch(action.type) 来判断不同的Action，default为旧state。同时可以定义初始状态。</li><li>代码：</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; <span class="keyword">from</span> 'redux';</span><br><span class="line">const newState = (<span class="keyword">state</span> = &#123;&#125;, action = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case ActionTypes.CSTATE:</span><br><span class="line">      return &#123; ...<span class="keyword">state</span>, ...action.<span class="keyword">state</span> &#125;;</span><br><span class="line">    case '_DPDATACHANGE_':</span><br><span class="line">      return &#123;...<span class="keyword">state</span>, ...action.dpState&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//Reducer 合并</span><br><span class="line">export <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  newState,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意:返回的是新state，如果需要保留部分旧state值，使用…state（ES7的对象展开语法，对对象会浅拷贝对应属性，这里等价于Object.assign({}, state, newState)），而如果合并state的话只会合并一层，对复杂state需要手动合并。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是一个普通JS对象，至少包括一个type属性代表事件，其他属性可以用来传递数据。实践上对一个流程定义一个函数，流程可以包括网络请求，最后返回Action，这个函数叫Action Creator。<br>代码：Store可以dispatch这个Action，action的type表示标识符，state是它携带的数据。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const newState = <span class="keyword">state</span> =&gt; &#123;</span><br><span class="line">  Store.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.CSTATE,</span><br><span class="line">    <span class="keyword">state</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>当触发action时根据其reducer key恢复数据，然后只需要在应用启动时分发action，这也很容易抽象成可配置的拓展服务，实际上三方库redux-persist已经为我们做好了这一切。<br>在Action中可以代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStorage = <span class="keyword">async</span> (key) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">await</span> AsyncStorage.getItem(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(d);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setStorage = <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">  AsyncStorage.setItem(key, <span class="built_in">JSON</span>.stringify(value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>通过- 提供 getState() 方法。获取 所有的当前state<br>通过connect，绑定需要的state以及Action Creator到你的组件的props上，这样组件就可以通过props来调用Action Creator，或者根据不同props来render()不同的组件。<br>代码：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mapStateToProps(&#123; newState &#125;) &#123;</span><br><span class="line">            const <span class="keyword">value</span> = newState[<span class="keyword">name</span>];//<span class="keyword">name</span>: newState.<span class="keyword">name</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="keyword">name</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://dreampiggy.com/2016/10/26/react-nativezhi-reduxjia-gou-ru-men/" target="_blank" rel="noopener">Redux架构入门</a><br><a href="http://blog.codingplayboy.com/2017/10/31/react-native-app/comment-page-1/#Redux" target="_blank" rel="noopener">React Native App应用架构设计</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Redux也有一段时间了。总结一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
