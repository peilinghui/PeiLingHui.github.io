<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <icon>https://www.gravatar.com/avatar/f1a75c66faf43f3b1652aef0eb09037e</icon>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2020-02-13T08:24:08.494Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native转web方案：react-native-web</title>
    <link href="http://peilinghui.com/2020/02/10/React-Native%E8%BD%ACweb%E6%96%B9%E6%A1%88%EF%BC%9Areact-native-web/"/>
    <id>http://peilinghui.com/2020/02/10/React-Native转web方案：react-native-web/</id>
    <published>2020-02-10T03:21:03.000Z</published>
    <updated>2020-02-13T08:24:08.494Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/necolas/react-native-web" target="_blank" rel="noopener">react-native-web</a></p><a id="more"></a><p>说一下，最新版的RN-web的版本是0.12.0，适用于RN是0.60以上版本的。<br>以前的RN-web版本0.11.5的时候有example，这个版本有例子可以直接运行起来，而最新的0.12.0没有example。<br>本文所用的RN的版本：0.59.10。RN-Web的版本0.11.5。node的版本v13.8.0<br>相关开发文档：<a href="http://necolas.github.io/react-native-web/docs/?path=/docs/overview-getting-started--page" target="_blank" rel="noopener">http://necolas.github.io/react-native-web/docs/?path=/docs/overview-getting-started--page</a></p><h1 id="新建Demo使用RN-web"><a href="#新建Demo使用RN-web" class="headerlink" title="新建Demo使用RN-web"></a>新建Demo使用RN-web</h1><ol><li><p>首先使用react-native-cli初始化一个项目。<br><code>sudo npm i -g react-native-cli</code><br><code>react-native init rnweb</code><br>初始化RN指定版本<code>react-native init demo --version 0.59.10</code></p></li><li><p>在iOS或者安卓模拟器或真机上运行出来<br><code>react-native run-ios</code><br><code>react-native run-android</code></p></li><li><p>安装react-native-web<br>修改 根目录/package.json，分别在后面加上，保存：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"myApp"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"node node_modules/react-native/local-cli/cli.js start"</span>,</span><br><span class="line">     <span class="attr">"web"</span>: <span class="string">"webpack-dev-server --config ./web/webpack.config.js --content-base ./web --inline"</span>,</span><br><span class="line">     <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"16.8.3"</span>,</span><br><span class="line">    <span class="attr">"react-native"</span>: <span class="string">"0.59.10"</span>,</span><br><span class="line">    <span class="attr">"react-art"</span>: <span class="string">"^16.8.3"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.8.3"</span>,</span><br><span class="line">    <span class="attr">"react-native-web"</span>: <span class="string">"^0.11.5"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"@babel/core"</span>: <span class="string">"^7.8.4"</span>,</span><br><span class="line">    <span class="attr">"@babel/runtime"</span>: <span class="string">"^7.8.4"</span>,</span><br><span class="line">    <span class="attr">"babel-jest"</span>: <span class="string">"^25.1.0"</span>,</span><br><span class="line">    <span class="attr">"jest"</span>: <span class="string">"^25.1.0"</span>,</span><br><span class="line">    <span class="attr">"metro-react-native-babel-preset"</span>: <span class="string">"^0.58.0"</span>,</span><br><span class="line">    <span class="attr">"react-test-renderer"</span>: <span class="string">"16.8.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^8.0.5"</span>,</span><br><span class="line">    <span class="attr">"file-loader"</span>: <span class="string">"^3.0.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.29.6"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.2.3"</span>,</span><br><span class="line">    <span class="attr">"webpack-dev-server"</span>: <span class="string">"^3.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-html-plugin"</span>: <span class="string">"^0.1.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"jest"</span>: &#123;</span><br><span class="line">    <span class="attr">"preset"</span>: <span class="string">"react-native"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>根目录新建web文件夹</li><li>web文件夹下，新建webpack.config.js的webpack配置文件:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">path</span> <span class="string">=</span> <span class="string">require('path');</span></span><br><span class="line"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    entry:</span> <span class="string">path.resolve(__dirname,</span> <span class="string">'../index.web'</span><span class="string">),</span> <span class="string">//</span> <span class="string">入口文件</span></span><br><span class="line"><span class="attr">    output:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">path.resolve(__dirname,</span> <span class="string">'dist'</span><span class="string">),</span> <span class="string">//</span> <span class="string">输出的路径</span></span><br><span class="line"><span class="attr">        filename:</span> <span class="string">'bundle.js'</span>  <span class="string">//</span> <span class="string">打包后文件</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    resolve:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        alias:</span> <span class="string">&#123;</span></span><br><span class="line">          <span class="string">'react-native$'</span><span class="string">:</span> <span class="string">'react-native-web'</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    module:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        rules:</span> <span class="string">[</span></span><br><span class="line">            <span class="string">&#123;</span></span><br><span class="line"><span class="attr">                test:</span> <span class="string">/\.(js|jsx)$/,</span></span><br><span class="line"><span class="attr">                use:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">                    loader:</span> <span class="string">'babel-loader'</span><span class="string">,</span></span><br><span class="line"><span class="attr">                    options:</span> <span class="string">&#123;</span></span><br><span class="line">                    <span class="string">&#125;</span></span><br><span class="line">                <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">                exclude:</span> <span class="string">/node_modules/</span></span><br><span class="line">            <span class="string">&#125;,</span></span><br><span class="line">            <span class="string">&#123;</span></span><br><span class="line"><span class="attr">                test:</span> <span class="string">/\.(png|jpe?g|gif|svg)$/,</span></span><br><span class="line"><span class="attr">                use:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">                    loader:</span> <span class="string">'file-loader'</span><span class="string">,</span></span><br><span class="line"><span class="attr">                    options:</span> <span class="string">&#123;</span></span><br><span class="line">                        <span class="string">//</span> <span class="attr">name:</span> <span class="string">'images/[name].[ext]'</span></span><br><span class="line">                    <span class="string">&#125;</span></span><br><span class="line">                <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">                exclude:</span> <span class="string">/node_modules/</span></span><br><span class="line">            <span class="string">&#125;</span></span><br><span class="line">        <span class="string">]</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    devServer:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">9090</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>web文件夹下，新建index.html，复制保存</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1, width=device-width, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"react-app"</span> <span class="attr">style</span>=<span class="string">"height: 100vh; display: flex;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>写一个针对 Web 平台启动入口文件,在根目录下 index.web.js<br>新增配置之后，如下：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register the app</span></span><br><span class="line">AppRegistry.registerComponent(<span class="string">"App"</span>, <span class="function"><span class="params">()</span> =&gt;</span> App);</span><br><span class="line"></span><br><span class="line"><span class="comment">// web enterance</span></span><br><span class="line">AppRegistry.runApplication(<span class="string">"App"</span>, &#123;</span><br><span class="line">  initialProps: &#123;&#125;,</span><br><span class="line">  rootTag: <span class="built_in">document</span>.getElementById(<span class="string">"react-app"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>7.运行npm install或者是yarn install，然后运行 npm run web 或者是yarn web。</p><p>在浏览器中打开 <a href="http://localhost:9090/index.html你就可以看到" target="_blank" rel="noopener">http://localhost:9090/index.html你就可以看到</a> React Native 转出的 Web 网页了。</p><p><img src="https://pei-1300205956.cos.ap-beijing.myqcloud.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-02-13%20%E4%B8%8B%E5%8D%884.02.58.png" alt></p><h3 id="适配自定义的-Native-Modules"><a href="#适配自定义的-Native-Modules" class="headerlink" title="适配自定义的 Native Modules"></a>适配自定义的 Native Modules</h3><p>React Native 开发的 App 中经常会出现 React Native 官方提供的 Native Modules</p><p>够用的情况，这时你会在项目中开发自己的 Native Modules，然后在 JavaScript 中去调用自己的 Native Modules。这在 ReactNative 环境下运行没有问题，但转成 Web 后执行时会报错说 Native Modules 上找不到对应的模块，这时因为在浏览器环境下是不存在这些自定义的 Native Modules。为了让页面能正常在浏览器中运行，需要为 Web 平台也实现一份自定义的 Native Modules，实现方法可以在 Web 平台的执行入口的最开头注入以下 polyfill，内容NativeModules polyfill.js</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> MyModule <span class="keyword">from</span> <span class="string">'./MyModule'</span>; <span class="comment">// 实现自定义 Native Modules 的地方</span></span><br><span class="line"> </span><br><span class="line">NativeModules.MyModule = MyModule; <span class="comment">// 挂载 MyModule</span></span><br></pre></td></tr></table></figure><p>这段代码的作用是把针对 Web 平台编写的自定义原生模块挂载到 Native Modules 对象上成为其属性，以让 JavaScript 代码在访问自定义 Native Modules 时访问到针对 Web 平台编写模块。</p><p>编写特定平台的代码<br>为了让 React Native 三端同构能正常的运行，在有些情况下你不得不编写平台特定的代码，因为有些代码只能在特定平台下才能运行，编写特定的 Web 平台代码有以下三种方法：</p><p>ReactNative.Platform.OS：所有端的代码都在一个文件中，通过以下代码来写 Web 平台专属代码:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Platform &#125; from <span class="string">'react-native'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">if</span>(Platform.OS===<span class="string">'web'</span>)&#123;</span><br><span class="line">  <span class="comment">// web 平台专属代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">process</span>.env.platform：通过 webpack 注入的环境变量来区分:</span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">process</span>.env.platform === <span class="string">'web'</span>) &#123;</span><br><span class="line">  <span class="comment">// web 平台专属代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只会在 Web 平台下被打包进去，这和 ReactNative.Platform 的区别是：后者的代码会打包进所有的平台。</p><p>要使用这种方法需要你在 webpack.config.js 文件中注入环境变量：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">plugins</span>: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">        <span class="string">'process.env'</span>: &#123;</span><br><span class="line">            <span class="attribute">platform</span>: JSON.stringify(platform),</span><br><span class="line">            <span class="attribute">__DEV__</span>: mode === <span class="string">'development'</span></span><br><span class="line">    &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>.web.js: 在 Web 模式下会优先加载 .web.js 文件，当 .web.js 文件不存在时才使用 .js 文件。<br>总结<br>React Native 三端同构在理论上虽然可行，并且有现成的方案，但实践是还是会遇到一些问题，例如：</p><p>在 Web 平台运行出的样式和 React Native 平台不一致，针对这种情况一般是 react-native-web 库的适配问题，可以在 Github 上提 issue 或 Pull Request。<br>有些 React Native 提供的 API 在 Web 平台不可能实现适配，例如调摄像头、振动等，对于这种问题可以在 Web 平台裁剪掉这些功能或使用其他交互方式替代。<br>React Native 三端同构虽然无法实现 100% 和 React Native 环境运行一致，但能快速简单的转换大多数场景，以低成本的方式为你的项目带来收益。</p><p><a href="http://npm.taobao.org/package/babel-plugin-react-native-web" target="_blank" rel="noopener">babel-plugin-react-native-web</a></p><h1 id="创建React项目"><a href="#创建React项目" class="headerlink" title="创建React项目"></a>创建React项目</h1><p>构建React项目的几种方式：</p><pre><code>构建：create-react-app 快速脚手架构建：generator-react-webpack构建：webpack一步一步构建</code></pre><h2 id="构建：create-react-app-快速脚手架"><a href="#构建：create-react-app-快速脚手架" class="headerlink" title="构建：create-react-app 快速脚手架"></a>构建：create-react-app 快速脚手架</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npx </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">npm </span><span class="string">install </span><span class="string">react-native-</span><span class="string">web</span></span><br><span class="line"><span class="string">npm </span><span class="string">start</span></span><br></pre></td></tr></table></figure><p>参考资源<br><a href="https://juejin.im/post/5b79397be51d45389153b060#heading-2" target="_blank" rel="noopener">React Native转web方案：react-native-web</a></p><p><a href="https://github.com/HuJiaoHJ/blog/issues/9" target="_blank" rel="noopener">链接</a><br><a href="https://codesandbox.io/s/q4qymyp2l6" target="_blank" rel="noopener">示范代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/necolas/react-native-web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;react-native-web&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>适配iOS13</title>
    <link href="http://peilinghui.com/2019/11/21/%E9%80%82%E9%85%8DiOS13/"/>
    <id>http://peilinghui.com/2019/11/21/适配iOS13/</id>
    <published>2019-11-21T02:46:37.000Z</published>
    <updated>2019-12-02T06:51:07.554Z</updated>
    
    <content type="html"><![CDATA[<p>适配iOS13中遇到的问题：</p><a id="more"></a><ol><li>/Users/peilinghui/Dog/Dog/ViewController/HomeViewController/PSTCollectionView.m:1624:47: Multiple methods named ‘numberOfItemsInSection:’ found with mismatched result, parameter type or attributes</li></ol><p>解决方法：<br>原来是： NSInteger numberOfBeforeSection = [_update[@”oldModel”] numberOfItemsInSection:updateItem.indexPathBeforeUpdate.section];<br>改成： NSInteger numberOfBeforeSection = [(UICollectionView *)_update[@”oldModel”] numberOfItemsInSection:updateItem.indexPathBeforeUpdate.section];</p><ol start="2"><li>library not found for -lstdc++.6<br>解决方法：直接到GitHUB上。<a href="https://github.com/devdawei/libstdc-" target="_blank" rel="noopener">https://github.com/devdawei/libstdc-</a>下载，然后只能sh命令就能直接解决</li></ol><ol start="3"><li>-[UIView setGrowingHook_textChangeNumber:]: unrecognized selector sent to instance 0x7fba1242cfb0</li></ol><ol start="4"><li>模态</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要改回原来模态视图样式，我们只需要把<span class="built_in">UIModalPresentationStyle</span>设置为<span class="built_in">UIModalPresentationFullScreen</span>即可。</span><br><span class="line"></span><br><span class="line">ViewController *vc = [[ViewController alloc] init];</span><br><span class="line">vc.title = <span class="string">@"presentVC"</span>;</span><br><span class="line"><span class="built_in">UINavigationController</span> *nav = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:vc];</span><br><span class="line">nav.modalPresentationStyle = <span class="built_in">UIModalPresentationFullScreen</span>;</span><br><span class="line">[<span class="keyword">self</span>.window.rootViewController presentViewController:nav animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><ol start="5"><li>iOS13碰到设置tabbar字体为选中状态颜色，正常切换没有问题，push后再返回，选中颜色变化系统蓝色<br>目前碰到这种状况有两种方法<br>这个是子视图影响所以用tintColor试试<br>tintColor有寻找和传递<br>1、寻找也就是通过get方法获取属性的值。<br>2、传递也就是当主动改变tintColor时</li></ol><p>方法1<br>self.tabBar.tintColor = [UIColor blackColor];</p><p>方法2<br>if (@available(iOS 10.0, *)) {<br>self.tabBar.unselectedItemTintColor = [UIColor blackColor];<br>} else {<br>// Fallback on earlier versions<br>}</p><p>上面亲测没有用</p><p>用下面的：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UITabBar appearance] <span class="string">setUnselectedItemTintColor:</span> [UIColor <span class="string">colorWithRed:</span><span class="number">127</span><span class="regexp">/255.0 green:127/</span><span class="number">255.0</span> <span class="string">blue:</span><span class="number">127</span>/<span class="number">255.0</span> <span class="string">alpha:</span><span class="number">1</span>]];</span><br></pre></td></tr></table></figure><ol start="6"><li>适配暗黑模式</li></ol><ol start="7"><li>把UIWebView替换成WKWebView</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适配iOS13中遇到的问题：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative错误异常收集和处理</title>
    <link href="http://peilinghui.com/2019/11/05/ReactNative%E9%94%99%E8%AF%AF%E5%BC%82%E5%B8%B8%E6%94%B6%E9%9B%86%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>http://peilinghui.com/2019/11/05/ReactNative错误异常收集和处理/</id>
    <published>2019-11-05T06:07:43.000Z</published>
    <updated>2019-12-05T02:35:39.917Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative</p><a id="more"></a><p>在生产环境下，因RN页面异常导致整个APP白屏,闪退，或者是卡顿，用户体验并不好，所以应该对异常进行捕获并处理，提高用户体验。</p><p>需求：</p><blockquote><p>对于闪退，白屏，卡死等APP异常表象，在日志中必须能够详细输出：报错时间，错误位置（所在代码文件和出错行），错误描述，相关堆栈，如果是rn框架和组件报错，应能通过堆栈看到具体调用顺序，相关出错的一系列文件及代码行</p></blockquote><p>解决方法：</p><h1 id="1-React-Error-Boundaries-异常边界组件"><a href="#1-React-Error-Boundaries-异常边界组件" class="headerlink" title="1. React Error Boundaries (异常边界组件)"></a>1. React Error Boundaries (异常边界组件)</h1><p>React官方文档：<a href="https://react.docschina.org/docs/error-boundaries.html" target="_blank" rel="noopener">https://react.docschina.org/docs/error-boundaries.html</a><br>React 16 引入了一个新的概念 —— 错误边界。</p><p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p><blockquote><p>注意：</p></blockquote><pre><code>错误边界无法捕获以下场景中产生的错误：事件处理（了解更多）异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）服务端渲染它自身抛出来的错误（并非它的子组件）</code></pre><p>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; hasError: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; hasError: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> &lt;h1&gt;<span class="type">Something</span> went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可行性：我们的React版本&gt;16。所以可以使用。<br>总结：主要是捕获render过程中的一些错误，就是写componentDidCatch方法，然后捕获生命周期中的异常，</p><h1 id="2-React-Native自带的-ErrorUtils-模块"><a href="#2-React-Native自带的-ErrorUtils-模块" class="headerlink" title="2. React Native自带的 ErrorUtils 模块"></a>2. React Native自带的 ErrorUtils 模块</h1><p>使用 React Native ErrorUtils 模块对错误边界无法捕获的场景中对这些异常进行捕获并处理。<br>React Native ErrorUtils 是负责对RN页面中异常进行管理的模块，功能很类似Web页面中的 window.onerror</p><p>首先我们看看怎么利用 React Native ErrorUtils 进行异步捕获和处理，存在javascriptCore，所以官方提供了方法：global.ErrorUtils.setGlobalHandler来监听全局的错误，直接上代码：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span>.ErrorUtils.setGlobalHandler(<span class="keyword">error</span> =&gt; &#123;</span><br><span class="line">  console.<span class="keyword">log</span>(<span class="string">'ErrorUtils发现了语法错误，避免了崩溃，具体报错信息：'</span>);</span><br><span class="line">  console.<span class="keyword">log</span>(<span class="keyword">error</span>.name, <span class="keyword">error</span>.message, [&#123; <span class="keyword">text</span>: <span class="string">'OK'</span> &#125;]);</span><br><span class="line">&#125;, true);</span><br></pre></td></tr></table></figure><p>错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p><p>注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p><p>项目中已经集成了。</p><h1 id="3-逻辑崩溃处理react-native-exception-handler也可以统一处理报错，另外它也可以处理Native端的报错。"><a href="#3-逻辑崩溃处理react-native-exception-handler也可以统一处理报错，另外它也可以处理Native端的报错。" class="headerlink" title="3. 逻辑崩溃处理react-native-exception-handler也可以统一处理报错，另外它也可以处理Native端的报错。"></a>3. 逻辑崩溃处理react-native-exception-handler也可以统一处理报错，另外它也可以处理Native端的报错。</h1><p><a href="https://github.com/master-atul/react-native-exception-handler" target="_blank" rel="noopener">https://github.com/master-atul/react-native-exception-handler</a></p><p>使用：</p><h1 id="4-redux-logger-使用"><a href="#4-redux-logger-使用" class="headerlink" title="4. redux-logger 使用"></a>4. redux-logger 使用</h1><p>安装<br><code>npm install redux-logger --save-dev</code></p><pre><code>redux-logger 仅且在开发模式下使用，所以只需增加参数--save-dev.--save-dev 开发模式下使用的插件--save 生成环境下使用的插件</code></pre><p>-g 将插件安装成全局插件，该电脑的所有项目都可以使用。无-g参数时，仅且该项目可以使用改插件。<br>使用<br>API定义：createLogger(options?:Object)=&gt;LoggerMiddleware;<br>JS新语法说明：<br>options?:Object 是类型定义，表明options参数的类型是Object类型。<br>“？”号表示非必须参数。<br>options包含的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="comment">//日志等级，可以是以下字符串，也可以是返回以下字符串的function.</span></span><br><span class="line">     level = <span class="string">'log'</span>: <span class="string">'log'</span> | <span class="string">'console'</span> | <span class="string">'warn'</span> | <span class="string">'error'</span> | <span class="string">'info'</span>, <span class="comment">// console's level</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行持续时间 </span></span><br><span class="line">     duration = <span class="literal">false</span>: <span class="built_in">Boolean</span>, <span class="comment">// Print the duration of each action?</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//执行时间</span></span><br><span class="line">    timestamp = <span class="literal">true</span>: <span class="built_in">Boolean</span>, <span class="comment">// Print the timestamp with each action?</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//日志颜色</span></span><br><span class="line">    colors: ColorsObject, <span class="comment">// Object with color getters. See the ColorsObject interface.</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//自定义一个日志输出函数，相当于再次封装console类</span></span><br><span class="line">    logger = <span class="built_in">console</span>: LoggerObject, <span class="comment">// Implementation of the `console` API.</span></span><br><span class="line"></span><br><span class="line">    logErrors = <span class="literal">true</span>: <span class="built_in">Boolean</span>, <span class="comment">// Should the logger catch, log, and re-throw errors?</span></span><br><span class="line">  </span><br><span class="line">    collapsed, <span class="comment">// Takes a boolean or optionally a function that receives `getState` function for accessing current store state and `action` object as parameters. Returns `true` if the log group should be collapsed, `false` otherwise.</span></span><br><span class="line">  </span><br><span class="line">    predicate, <span class="comment">// If specified this function will be called before each action is processed with this middleware.</span></span><br><span class="line">  </span><br><span class="line">    stateTransformer, <span class="comment">// Transform state before print. Eg. convert Immutable object to plain JSON.</span></span><br><span class="line">  </span><br><span class="line">    actionTransformer, <span class="comment">// Transform state before print. Eg. convert Immutable object to plain JSON.</span></span><br><span class="line">  </span><br><span class="line">    errorTransformer <span class="comment">// Transform state before print. Eg. convert Immutable object to plain JSON.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项<br>logger 中间件必须放在所有中间件的最后，不然会出现部分action无法打印日志的情况。 使用如下：</p><p>var logger = createLogger({ predicate: (getState, action) =&gt; isDebuggingInChrome, collapsed: true, duration: true, });</p><p>var createF8Store = applyMiddleware(thunk, promise, array, analytics, logger)(createStore);</p><p>相关资料：</p><p>React Native 异常处理 ：<a href="https://github.com/HuJiaoHJ/blog/issues/13" target="_blank" rel="noopener">https://github.com/HuJiaoHJ/blog/issues/13</a></p><p>RN-逻辑崩溃处理：react-native-exception-handler：<a href="https://www.jianshu.com/p/c46e06b4b73e" target="_blank" rel="noopener">https://www.jianshu.com/p/c46e06b4b73e</a></p><p>总结：<br>以上可以一起使用，通过异常边界组件监控每个组件的生命周期，通过ErrorUtils 模块来监控事件处理等其他全局异常，并把报错发送给原生端处理。并有错误的显示页面，类似404 的那种，防止APP直接crash，或者白屏。</p><h1 id="5-打印出错的行号和文件"><a href="#5-打印出错的行号和文件" class="headerlink" title="5.打印出错的行号和文件"></a>5.打印出错的行号和文件</h1><p>我们知道在开发者模式下的时候，会出现红屏，那个红屏会闪一下，然后出现报错信息和报错的行号和方法。<br>可以在RN源码看到：<br>文件夹位置<br>/node_modules/react-native/Libraries/Core/InitializeCore.js中可以看到：</p><p>打印错误日记的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up console</span></span><br><span class="line"><span class="keyword">const</span> ExceptionsManager = <span class="built_in">require</span>(<span class="string">'ExceptionsManager'</span>);</span><br><span class="line">ExceptionsManager.installConsoleErrorReporter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up error handler</span></span><br><span class="line"><span class="keyword">if</span> (!global.__fbDisableExceptionsManager) &#123;</span><br><span class="line">  <span class="keyword">const</span> handleError = <span class="function">(<span class="params">e, isFatal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ExceptionsManager.handleException(e, isFatal);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ee) &#123;</span><br><span class="line">      <span class="comment">/* eslint-disable no-console */</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Failed to print error: '</span>, ee.message);</span><br><span class="line">      <span class="comment">/* eslint-enable no-console */</span></span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ErrorUtils = <span class="built_in">require</span>(<span class="string">'ErrorUtils'</span>);</span><br><span class="line">  ErrorUtils.setGlobalHandler(handleError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在/node_modules/react-native/Libraries/Core/ExceptionsManager.js中：这这个方法中可以看到，在开发者模式下，它会解析那个错误栈，然后追溯那个错误栈，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reportException</span>(<span class="params">e: ExtendedError, isFatal: bool</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;ExceptionsManager&#125; = <span class="built_in">require</span>(<span class="string">'NativeModules'</span>);</span><br><span class="line">  <span class="keyword">if</span> (ExceptionsManager) &#123;</span><br><span class="line">    <span class="keyword">const</span> parseErrorStack = <span class="built_in">require</span>(<span class="string">'parseErrorStack'</span>);</span><br><span class="line">    <span class="keyword">const</span> stack = parseErrorStack(e);</span><br><span class="line">    <span class="keyword">const</span> currentExceptionID = ++exceptionID;</span><br><span class="line">    <span class="keyword">if</span> (isFatal) &#123;</span><br><span class="line">      ExceptionsManager.reportFatalException(e.message, stack, currentExceptionID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ExceptionsManager.reportSoftException(e.message, stack, currentExceptionID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">const</span> symbolicateStackTrace = <span class="built_in">require</span>(<span class="string">'symbolicateStackTrace'</span>);</span><br><span class="line">      symbolicateStackTrace(stack).then(</span><br><span class="line">        (prettyStack) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (prettyStack) &#123;</span><br><span class="line">            ExceptionsManager.updateExceptionMessage(e.message, prettyStack, currentExceptionID);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The stack is null'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ).catch(</span><br><span class="line">        (error) =&gt; <span class="built_in">console</span>.warn(<span class="string">'Unable to symbolicate stack trace: '</span> + error.message)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以借鉴这个源码的方案来写一下这个打印出行号和文件名还有方法的一个方法，写在index.js或者是index.android.js或者是index.ios.js</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ErrorUtils.setGlobalHandler(<span class="function"><span class="params">(e)</span> =&gt;</span> &#123;　</span><br><span class="line">    const parseErrorStack = <span class="built_in">require</span>(<span class="string">'parseErrorStack'</span>);</span><br><span class="line">    const stack = parseErrorStack(e);</span><br><span class="line">    const symbolicateStackTrace = <span class="built_in">require</span>(<span class="string">'symbolicateStackTrace'</span>);</span><br><span class="line">    symbolicateStackTrace(stack).<span class="keyword">then</span>(</span><br><span class="line">        (prettyStack) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (prettyStack) &#123;</span><br><span class="line">            const errorString = <span class="string">'\nfile:'</span>+prettyStack[<span class="number">0</span>].file + <span class="string">'\nmethodName:'</span>+prettyStack[<span class="number">0</span>].methodName+<span class="string">'\nlineNumber:'</span>+prettyStack[<span class="number">0</span>].lineNumber+<span class="string">'\nerrorInfo:'</span>+e.toString();</span><br><span class="line">            WebSDK.recordJsLog(&#123;</span><br><span class="line">             jsLog: errorString,</span><br><span class="line">        logMode:<span class="string">'ERROR'</span>&#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'The stack is null'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ).<span class="keyword">catch</span>(</span><br><span class="line">        (error) =&gt; <span class="built_in">console</span>.warn(<span class="string">'Unable to symbolicate stack trace: '</span> + error.message)</span><br><span class="line">    );  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在捕获了异常以后，就可以把这个错误信息报给原生，或者服务端。</p><p>在iOS下的RN源码也可以看到类似的信息：</p><h3 id="RCTRedBox"><a href="#RCTRedBox" class="headerlink" title="RCTRedBox"></a>RCTRedBox</h3><h3 id="RCTErrorInfo"><a href="#RCTErrorInfo" class="headerlink" title="RCTErrorInfo"></a>RCTErrorInfo</h3><h3 id="RCTJSStackFrame"><a href="#RCTJSStackFrame" class="headerlink" title="RCTJSStackFrame"></a>RCTJSStackFrame</h3><h1 id="Release状态下统计日志"><a href="#Release状态下统计日志" class="headerlink" title="Release状态下统计日志"></a>Release状态下统计日志</h1><p>Bugly是腾讯提供的专业Crash、Android ANR、ios卡顿解决方案，24小时实时监控和告警，可以及时发现异常问题。</p><ol><li>ReactNative 不同的编译模式，使用的 JS 来源不同。Debug 模式来自 Packager Server，而 Release 模式，来自 Apk 的 assets 目录。</li><li>Debug 模式下的崩溃，会触发红屏，而 Release 模式下的崩溃，会直接导致 App 崩溃。</li><li>Debug 模式，之所以可以显示崩溃栈的基本信息，是因为编译的 JS 文件中，包含了对应的源文件和代码行号。而这些在 Release 模式下的 JS 是没有的。</li><li>Release 模式的崩溃栈是被混淆后的，可以通过崩溃栈显示的行号和列号，来定位代码，但是无法定位具体源文件。</li><li>通过 react-native 命名，增加 –sourcemap-output参数，指定输出需要的混淆 Mapping 文件，它其内包含了混淆的信息。</li><li>解读 ReactNative Mapping 文件，可以使用 source-map 这个 NodeJs 库来进行解析，可以精准定位到行号和源文件名。</li></ol><p>打包的同时打出map的包：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-<span class="keyword">native</span> bundle --platform android --dev <span class="keyword">false</span> --entry-<span class="keyword">file</span> index.js --bundle-output android<span class="regexp">/app/</span>src<span class="regexp">/main/</span>assets<span class="regexp">/index.android.bundle --assets-dest android/</span>app<span class="regexp">/src/m</span>ain<span class="regexp">/res/</span> --sourcemap-output android-release.bundle.map</span><br></pre></td></tr></table></figure><p>在release模式下，通过集成bugly，在bugly平台上收集错误信息，定位到某行某列。然后运行下面的map.JS文件。替换console.log里面的行和列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sourceMap = <span class="built_in">require</span>(<span class="string">'source-map'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"> </span><br><span class="line">fs.readFile(<span class="string">'../android-release.bundle.map'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> smc = <span class="keyword">new</span> sourceMap.SourceMapConsumer(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(smc.originalPositionFor(&#123;</span><br><span class="line">        line: <span class="number">344</span>, <span class="comment">//报错的行</span></span><br><span class="line">        column: <span class="number">868</span> <span class="comment">//报错的列</span></span><br><span class="line">    &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在终端执行：<code>node map.js</code><br>即可看到打印：文件名，行号等信息</p><p><a href="https://bugly.qq.com/docs/introduction/bugly-introduction/?v=20180709165613" target="_blank" rel="noopener">https://bugly.qq.com/docs/introduction/bugly-introduction/?v=20180709165613</a></p><p>缺点：使用的是node的sourceMap来解析文件，只能做到手动来统计错误日志，不能做到自动化来统计日志并且把错误上报到自己的服务器上。</p><p>其实不集成bugly也可以<br>参考：</p><p>关于App异常监控那点事：<a href="https://www.jianshu.com/p/9aba5572ddcb" target="_blank" rel="noopener">https://www.jianshu.com/p/9aba5572ddcb</a></p><p><a href="https://blog.csdn.net/luolin2611/article/details/81110718" target="_blank" rel="noopener">https://blog.csdn.net/luolin2611/article/details/81110718</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bundle的拆包</title>
    <link href="http://peilinghui.com/2019/10/28/bundle%E7%9A%84%E6%8B%86%E5%8C%85/"/>
    <id>http://peilinghui.com/2019/10/28/bundle的拆包/</id>
    <published>2019-10-28T06:19:39.000Z</published>
    <updated>2020-01-16T10:25:09.128Z</updated>
    
    <content type="html"><![CDATA[<p>RN的默认机制是加载一个bundle，并且在初始化就加载。不利于我们的业务维护，所以要拆包。</p><a id="more"></a><p>主要是拆分成基础包CommonBundle + N个业务包。</p><p>初始化ReactContext—-&gt;ReactManager</p><p>达到的目标：</p><ol><li>ReactNative的动态加载与卸载。</li><li>bundle的拆分与加载。包名+类名<br>使用metro-bundle.js类来</li></ol><h2 id="主流方案"><a href="#主流方案" class="headerlink" title="主流方案"></a>主流方案</h2><p>在网上查了相关的资料，主流的方案基本都是把Main.jsbundl拆分成基础包common.jsbundle+业务包bundle，和上面拆包目标基本一样，不赘述。</p><p>具体的拆分思路就很不一样了：</p><h3 id="1-QQ音乐"><a href="#1-QQ音乐" class="headerlink" title="1. QQ音乐"></a>1. QQ音乐</h3><p><a href="https://cloud.tencent.com/developer/article/1032279" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1032279</a></p><p>侵入RN代码，修改打包流程，使得打出来的包就是基础+业务包，如QQ音乐</p><p><a href="https://cloud.tencent.com/developer/article/1005415" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1005415</a></p><h3 id="2-在RN打包的基础上，实现新的打包方案，如携程-moles-Packer"><a href="#2-在RN打包的基础上，实现新的打包方案，如携程-moles-Packer" class="headerlink" title="2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer"></a>2. 在RN打包的基础上，实现新的打包方案，如携程 moles-Packer</h3><p>简介：携程大厂推出，稳定可靠，针对react native0.44时代的版本</p><p>优点：重写了react native自带的打包工具，重写就是为了分包，为分包而生的项目，肯定可靠</p><p>缺点：2 years ago，只适合rn老版本用户了，现在都9012了，0.5以上的rn版本全部扑街</p><h3 id="3-Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包"><a href="#3-Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包" class="headerlink" title="3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包"></a>3. Patch方案，打包流程不变，生成基础包后，根据diff来生成每个业务不同的patch包</h3><p>简介：大致的做法就是先打个正常的完整的jsbundle，然后再打个只包含了基础引用(react和第三方module)的基础包，比对一下patch，得出业务包，这样基础包和业务包都有了</p><p>优点：简单暴力，如果只是想简单做下分包的可以尝试下</p><p>缺点：1、不利于维护，由于module后面都是rn生成数字，依赖变了数字也变，导致基础包变了所有包都需要变2、图片没法分包，有的第三方库是有图片的，这个方法只处理jsbundle不处理图片</p><h2 id="metro-bundle"><a href="#metro-bundle" class="headerlink" title="metro bundle"></a>metro bundle</h2><p>上官网：<a href="https://facebook.github.io/metro/" target="_blank" rel="noopener">https://facebook.github.io/metro/</a></p><p>这个就是现在rn版本使用的打包工具，是由之前的rn打包代码中抽取出来成为一个单独的项目，metro更新迅速，一个月一个样，现在我觉得已经比较完善了，可以拿出来溜溜</p><p>全新的做法</p><p>其实react native在0.5时代就已经引入了metro bundle，但由于其还是在不断完善，无法完成分包大任，现在0.57已经可以完全支持分包了</p><p>其实react native打包是支持配置的：<a href="https://facebook.github.io/metro/docs/en/configuration" target="_blank" rel="noopener">https://facebook.github.io/metro/docs/en/configuration</a></p><p>配置是不是眼花缭乱，分包只要用到两个配置：createModuleIdFactory和processModuleFilter</p><p>createModuleIdFactory函数传入的是你要打包的module文件的绝对路径返回的是这个module的id</p><p>processModuleFilter函数传入的是module信息，返回是boolean值，如果是false就过滤不打包</p><p>做法就很清晰了，配置createModuleIdFactory让其每次打包都module们使用固定的id(路径相关)，</p><p>配置processModuleFilter过滤基础包打出业务包</p><p>具体的配置看我的github吧<br>加载多bundle</p><p>现在网上流传的一些方法都还是demo级别的方法，我的做法是尽量与react native兼容</p><p>android是直接重写ReactActivity，只在运行module前加载了业务包文件，这样可以让代码有完整的生命周期</p><p>iOS监听基础包加载成功的消息，基础包加载后再加载业务包，顺序和时机都是完美</p><p><a href="https://github.com/smallnew/react-native-multibundler" target="_blank" rel="noopener">react-native-multibundler</a></p><p>下载下来</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RN的默认机制是加载一个bundle，并且在初始化就加载。不利于我们的业务维护，所以要拆包。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter学习</title>
    <link href="http://peilinghui.com/2019/10/22/Flutter%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2019/10/22/Flutter学习/</id>
    <published>2019-10-22T11:48:43.000Z</published>
    <updated>2020-01-06T11:31:08.862Z</updated>
    
    <content type="html"><![CDATA[<p>简单学习一下flutter。</p><a id="more"></a><h1 id="Dart语言基础"><a href="#Dart语言基础" class="headerlink" title="Dart语言基础"></a>Dart语言基础</h1><p>Dart不单独安装，随框架安装，可通过DartPad在线编写和运行代码。</p><p>基础概念：</p><ul><li>一切变量都是对象，包括数字、函数和null</li><li>对象是类的实例，所有类都继承于object</li><li>强类型但支持类型推断</li><li>如果不想指定具体类型可以使用dynamic</li><li>支持泛型，比如List<int>或List<dynamic></dynamic></int></li><li>支持顶层函数、类方法、实例变量和嵌套函数</li><li>支持顶层变量、类变量、实例变量和局部变量</li></ul><p>变量</p><ul><li>变量类型可以自动推断，或者显示</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单学习一下flutter。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="http://peilinghui.com/2019/10/15/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2019/10/15/webpack学习/</id>
    <published>2019-10-15T01:45:13.000Z</published>
    <updated>2020-02-12T12:14:20.015Z</updated>
    
    <content type="html"><![CDATA[<p>webpack是现代前端开发中最火的模块打包工具。<br>官网：<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>WebPack可以看做是模块打包机：</p><p>它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h3 id="WebPack和Grunt以及Gulp相比有什么特性"><a href="#WebPack和Grunt以及Gulp相比有什么特性" class="headerlink" title="WebPack和Grunt以及Gulp相比有什么特性"></a>WebPack和Grunt以及Gulp相比有什么特性</h3><p>其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack在很多场景下可以替代Gulp/Grunt类的工具。</p><p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，工具之后可以自动替你完成这些任务。<br>Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。</p><h2 id="webpack源码"><a href="#webpack源码" class="headerlink" title="webpack源码"></a>webpack源码</h2><ol><li>把所有模块的代码放入到函数中，用一个数组保存起来</li><li>根据require时传入的数组索引，能知道需要哪一段代码</li><li>从数组中，根据索引取出包含我们代码的函数</li><li>执行该函数，传入一个对象Module.exports</li><li>我们的代码，按照约定，正好是用module.exports=’xxx’进行赋值</li><li>调用函数结束后，module.exports从原来的空对象，就有值了</li><li>最终return module.exports作为require函数的返回值</li></ol><p><code>npm install webpack babel-loader --save-dev</code><br>配置webpack.config.js<br>配置package.json 中的scripts<br>运行npm start</p><h2 id="webpack-config-js文件配置："><a href="#webpack-config-js文件配置：" class="headerlink" title="webpack.config.js文件配置："></a>webpack.config.js文件配置：</h2><ol><li>Entry：指定webpack开始构建的入口模块，从该模块开始构建并计算出直接或间接依赖的模块或者库</li><li>Output：告诉webpack如何命名输出的文件以及输出的目录</li><li><p>Module模块（对象）（loaders:[]）存在一些loader{test:正则，loader：’style-loader!css-loader’}<br>webpack中，loader的配置主要在module.rules中进行，这是一个数组，每一个rule做了两件事</p><p> 识别文件类型，来确定具体处理该数据的loader(Rule.test属性)<br> 使用相关的loader对文件进行相关的操作转换(Rule.use属性）   </p><blockquote><p>常用的loader：</p></blockquote><pre><code>　　转换编译：script-loader, babel-loader,ts-loader,coffee-loader　　处理样式：style-loader,css-loader,less-loader,sass-loader,postcss-loader　　处理文件：raw--loader,url-loader,file-loader　　处理数据：csv-loader,xml-loader　　处理模板语言：html-loader,pug-loader,jade-loader,markdown-loader　　清理和测试：mocha-loader,eslint-loader　　此外还有许多loader，可以到loader文档里查询处理CSS：require(./xxx.css)</code></pre></li></ol><p>处理less:loader：’style-loader!css-loader!less-loader’</p><p>Loaders：由于webpack只能处理javascript，所以我们需要对一些非js文件处理成webpack能够处理的模块，比如sass文件</p><p>处理ES6：babel-loader+babel-preset-env(se2015/2016/2017)</p><p>处理文件+base64：<br>url-loader可以将文件生成为base64编码。到build.js中<br>文件在base64加密后会比原来大三分之一<br>应用场景是比较小的图片 4kb以内的图片</p><p>Plugins： Loaders将各类型的文件处理成webpack能够处理的模块， plugins有着很强的能力。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。但也是最复杂的一个。比如对js文件进行压缩优化的 UglifyJsPlugin插件。一种插件就是一种函数，通过传入不同的参数，可以实现不同的功能，webpack让人觉得难学的地方之一是哟啊自己封装plugins，对于我们大多数人来说，需要掌握的plugins并不是那么多，用的时候再查就可以</p><p>Chunk：coding split的产物，我们可以对一些代码打包成一个单独的chunk，比如某些公共模块，去重，更好的利用缓存。或者按需加载某些功能模块，优化加载时间。在webpack3及以前我们都利用 CommonsChunkPlugin将一些公共代码分割成一个chunk，实现单独加载。在webpack4 中 CommonsChunkPlugin被废弃，使用 SplitChunksPlugin</p><p>5、一些辅助开发的相关属性</p><p>　　devtool:打包后的代码和原始代码存在较大的差异，此选项控制是否生成以及如何生成sourcemap</p><p>　　devserver：通过配置devserver选项，可以开启一个本地服务器</p><p>　　watch：启用watch模式后，webpack将持续监听热河已经解析文件的更改，开发是开启会很方便</p><p>　　watchoption：用来定制watch模式的选项</p><p>　　performance：打包后命令行如何展示性能提示，如果超过某个大小是警告还是报错　　</p><h3 id="字符串内使用的内置变量"><a href="#字符串内使用的内置变量" class="headerlink" title="字符串内使用的内置变量"></a>字符串内使用的内置变量</h3><p>name:[name].[ext]<br>name是获取原文件名，ext是获取原文件名的后缀<br>output:{path:’绝对路径’//设置产出的资源目录 filename:’build.js’}</p><h3 id="使用webpack构建本地服务器webpack-dev-server"><a href="#使用webpack构建本地服务器webpack-dev-server" class="headerlink" title="使用webpack构建本地服务器webpack-dev-server"></a>使用webpack构建本地服务器webpack-dev-server</h3><p>让你的浏览器监听你的代码的修改，并自动刷新显示修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p><ol><li><p>安装webpack-dev-server</p><p>   npm i webpack-dev-server</p></li><li><p>安装cross-env</p><p> npm i cross-env </p></li><li><p>安装HTML支持文件</p><p> npm i html-webpack-plugin<br> 下载，引入，在plugin里面配置，给其Options设置template(参照物)</p></li><li><p>配置pack.json文件</p><p> “scripts”: {</p><pre><code>    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.config.js&quot;</code></pre><p>   },</p></li></ol><p>命令：</p><ul><li>open 自动打开浏览器</li><li>hot 热替换，不再刷新的情况下替换</li><li>inline 自动刷新</li><li>port 9999 指定端口</li><li>process 显示编译进度</li></ul><h4 id="包的分类管理和分类恢复"><a href="#包的分类管理和分类恢复" class="headerlink" title="包的分类管理和分类恢复"></a>包的分类管理和分类恢复</h4><ol><li><p>安装包的时候，做一个分类的管理</p><pre><code>- 开发依赖devDependencies（打包相关webpack） npm i 包名 -D   - 生产依赖dependencies（不包含webpack打包依赖） npm i 包名 -S </code></pre></li><li><p>恢复依赖</p><ul><li>开发恢复依赖： npm i</li><li>生产恢复： npm i –production</li></ul></li></ol><p>webpack.config.js<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">        entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">        output:&#123;</span><br><span class="line">            filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">            path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">module</span>:&#123;</span><br><span class="line">            rules:[<span class="comment">// 配置模块loaders，解析规则</span></span><br><span class="line">                &#123;</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    use:[</span><br><span class="line">                        <span class="string">'style-loader'</span>,</span><br><span class="line">                        <span class="string">'css-loader'</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    test:<span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                    use:[</span><br><span class="line">                        <span class="string">'file-loader'</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool:<span class="string">"source-map"</span>,<span class="comment">// enum</span></span><br><span class="line"><span class="comment">// 为浏览器开发者工具添加元数据增强调试</span></span><br><span class="line">plugins:[</span><br><span class="line"> <span class="comment">// 附加插件列表 ,插件的执行顺序与元素的索引有关</span></span><br><span class="line">],</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</p><pre><code>让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；</code></pre><h3 id="Babel的安装与配置"><a href="#Babel的安装与配置" class="headerlink" title="Babel的安装与配置"></a>Babel的安装与配置</h3><p>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><pre><code>// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</code></pre><h4 id="Babel的配置"><a href="#Babel的配置" class="headerlink" title="Babel的配置"></a>Babel的配置</h4><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol><li>什么是webpack?</li></ol><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><p>在 webpack里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。webpack专注于构建模块化项目。</p><ol><li><p>Webpack 打包原理是怎样的？<br>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><pre><code>1. 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数2. 开始编译 用上一步得到的参数初始Compiler对象，加载所有配置的插件，通过执行对象的run方法开始执行编译3. 确定入口 根据配置中的 Entry 找出所有入口文件4. 编译模块 从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理5. 完成模块编译 在经过第4步使用 Loader 翻译完所有模块后， 得到了每个模块被编译后的最终内容及它们之间的依赖关系6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk,再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。</code></pre></li><li><p>什么是 loader，Webpack Loader 的开发及调试过程?</p></li></ol><p>Loader 就像一个翻译员，能将源文件经过转化后输出新的结果，并且一个文件还可以链式地经过多个翻译员翻译。</p><p>一个Loader 的职责是单一的，只需要完成一种转换<br>一个Loader 其实就是一个Node.js 模块，这个模块需要导出一个函数 </p><p>开发调试：</p><pre><code>1. 确保正在开发的本地 Loader 模块的 package.json 已经配置好(最主要的main字段的入口文件指向要正确)2. 在本地的 Npm 模块根目录下执行 npm link，将本地模块注册到全局3. 在项目根目录下执行 npm link loader-name ，将第 2 步注册到全局的本地 Npm 模块链接到项目的 node moduels 下，其中的 loader-name 是指在第 1 步的package.json 文件中配置的模块名称</code></pre><ol start="3"><li>了解 Webpack Plugin 的实现机制？</li></ol><p>Plugin ： 专注处理 webpack 在编译过程中的某个特定的任务的功能模块，可以称为插件。</p><ul><li>是一个独立的模块</li><li>模块对外暴露一个 js 函数</li><li>函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法</li><li>apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback</li><li>完成自定义子编译流程并处理 compilation  对象的内部数据</li><li>如果异步编译插件的话，数据处理完成后执行 callback 回调。</li></ul><ol start="4"><li>HMR热更新原理是怎样的？</li></ol><p>Hot Module Replacement（HMR）是 webpack 发展至今引入的最令人兴奋的特性之一 ，当你对代码进行修改并保存后，webpack 将对代码重新打包，并将新的模块发送到浏览器端，浏览器通过新的模块替换老的模块，这样在不刷新浏览器的前提下就能够对应用进行更新。</p><ol start="4"><li>知道哪些 Webpack 性能优化的方法？</li></ol><ul><li>优化 Loader 配置</li><li>优化 resolve.modules 配置</li><li>优化 resolve.mainFields 配置</li><li>优化 resolve.alias 配置</li><li>优化 resolve.extensions 配置</li><li>优化 module.noParse 配置</li><li>使用 DllPlugin</li><li>使用 HappyPack</li><li>使用 ParallelUglifyPlugin</li><li>优化文件监听的性能</li><li>Webpack 实现 CDN 的接入</li><li>使用 Tree Shaking</li><li>提取公共代码</li><li>分割代码以按需加载</li></ul><p><a href="https://mp.weixin.qq.com/s/dy1u2g9TeCoq2WOdPLqAXw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dy1u2g9TeCoq2WOdPLqAXw</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;webpack是现代前端开发中最火的模块打包工具。&lt;br&gt;官网：&lt;a href=&quot;https://www.webpackjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.webpackjs.com/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React面试题</title>
    <link href="http://peilinghui.com/2019/09/24/React%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2019/09/24/React面试题/</id>
    <published>2019-09-24T06:36:32.000Z</published>
    <updated>2019-10-23T02:06:41.713Z</updated>
    
    <content type="html"><![CDATA[<p>React高频面试题</p><a id="more"></a><ol><li><p>React生命周期有哪些，16版本生命周期发生了哪些变化？</p><p> <strong>15版本的生命周期：</strong></p><blockquote><p>初始化阶段</p></blockquote><pre><code> constructor 构造函数getDefaultProps props默认值getInitialState state默认值</code></pre><blockquote><p>挂载阶段  </p></blockquote><pre><code>componentWillMount 组件初始化渲染前调用render 组件渲染componentDidMount组件挂载到 DOM后调用</code></pre><blockquote><p>更新阶段</p></blockquote><pre><code>componentWillReceiveProps 组件将要接收新 props前调用shouldComponentUpdate 组件是否需要更新componentWillUpdate 组件更新前调用render 组件渲染componentDidUpdate 组件更新后调用</code></pre><blockquote><p>卸载阶段</p></blockquote><pre><code>componentWillUnmount 组件卸载前调用</code></pre><p> <strong>16生命周期</strong></p><blockquote><p>初始化阶段</p></blockquote><pre><code>constructor 构造函数getDefaultProps props默认值getInitialState state默认值</code></pre><blockquote><p>挂载阶段</p></blockquote><pre><code>static getDerivedStateFromProps(props,state)rendercomponentDidMount</code></pre><p> 补充：getDerivedStateFromProps：组件每次被 rerender的时候，包括在组件构建之后(虚拟 dom之后，实际 dom挂载之前)，每次获取新的 props或 state之后；每次接收新的props之后都会返回一个对象作为新的 state，返回null则说明不需要更新 state；配合 componentDidUpdate，可以覆盖 componentWillReceiveProps的所有用法</p><blockquote><p>更新阶段</p></blockquote><pre><code>static getDerivedStateFromProps(props,state)shouldComponentUpdaterendergetSnapshotBeforeUpdate(prevProps,prevState)componentDidUpdate</code></pre><p> 补充：getSnapshotBeforeUpdate：触发时间: update发生的时候，在 render之后，在组件 dom渲染之前；返回一个值，作为 componentDidUpdate的第三个参数；配合 componentDidUpdate, 可以覆盖 componentWillUpdate的所有用法</p><blockquote><p>卸载阶段</p></blockquote><pre><code>componentWillUnmount</code></pre><blockquote><p>错误处理</p></blockquote><pre><code>componentDidCatch</code></pre></li></ol><p>React16新的生命周期弃用了 componentWillMount、componentWillReceivePorps，componentWillUpdate新增了 getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数。</p><p>React16并没有删除这三个钩子函数，但是不能和新增的钩子函数混用， React17将会删除这三个钩子函数，新增了对错误的处理（ componentDidCatch）</p><ol start="2"><li>setState是同步的还是异步的？</li></ol><blockquote><p>生命周期和合成事件中</p></blockquote><p>在 React的生命周期和合成事件中， React仍然处于他的更新机制中，这时无论调用多少次 setState，都会不会立即执行更新，而是将要更新的·存入 _pendingStateQueue，将要更新的组件存入 dirtyComponent。</p><p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 didmount后会将批处理标志设置为 false。这时将取出 dirtyComponent中的组件以及 _pendingStateQueue中的 state进行更新。这样就可以确保组件不会被重新渲染多次</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是0</p><p>所以，如上面的代码，当我们在执行 setState后立即去获取 state，这时是获取不到更新后的 state的，因为处于 React的批处理机制中， state被暂存起来，待批处理机制完成之后，统一进行更新。</p><p>所以。setState本身并不是异步的，而是 React的批处理机制给人一种异步的假象。</p><blockquote><p>异步代码和原生事件中</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> <span class="built_in">set</span>Timeout(() =&gt; &#123;</span><br><span class="line">      console.<span class="keyword">log</span>(<span class="string">"调用setState"</span>);</span><br><span class="line">      this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;);</span><br><span class="line">      console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是1</p><p>根据 JavaScript的异步机制，会将异步代码先暂存，等所有同步代码执行完毕后在执行，这时 React的批处理机制已经走完，处理标志设被设置为 false，这时再调用 setState即可立即执行更新，拿到更新后的结果。</p><p>在原生事件中调用 setState并不会出发 React的批处理机制，所以立即能拿到最新结果。</p><blockquote><p>最佳实践</p></blockquote><p>setState的第二个参数接收一个函数，该函数会在 React的批处理机制完成之后调用，所以你想在调用 setState后立即获取更新后的值，请在该回调函数中获取。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constructor里面设置this.state.index是0，输出是1</p><ol start="3"><li>为什么有时连续多次 setState只有一次生效？</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"> this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;);</span><br><span class="line">   this.<span class="built_in">set</span>State(&#123;</span><br><span class="line">        index: this.<span class="keyword">state</span>.index + <span class="number">1</span></span><br><span class="line">      &#125;,() =&gt; &#123;</span><br><span class="line">        console.<span class="keyword">log</span>(<span class="string">"state"</span>, this.<span class="keyword">state</span>.index);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次打印出的结果是相同的,都为1。</p><p>原因就是 React会批处理机制中存储的多个 setState进行合并，来看下 React源码中的 _assign函数，类似于 Object的 assign：</p><p>React会对多次连续的 setState进行合并，如果你想立即使用上次 setState后的结果进行下一次 setState，可以让 setState 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。</p><ol start="4"><li>React如何实现自己的事件机制？</li></ol><p>React事件并没有绑定在真实的 Dom节点上，而是通过事件代理，在最外层的 document上对事件进行统一分发。</p><ol start="5"><li>为何 React事件要自己绑定 this？<br>React在 document上进行统一的事件分发， dispatchEvent通过循环调用所有层级的事件来模拟事件冒泡和捕获。</li></ol><p>在 React源码中，当具体到某一事件处理函数将要调用时，将调用 invokeGuardedCallback方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function invokeGuardedCallback(name,<span class="function"><span class="keyword">func</span>,<span class="title">a</span>)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(a)</span></span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(x)&#123;</span><br><span class="line"><span class="keyword">if</span>(caughtError === null)&#123;</span><br><span class="line">caughtError = x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this是不准确的，所以我们需要手动将当前组件绑定到 this上。</p><ol start="6"><li><p>原生事件和 React事件的区别？</p><ul><li>React 事件使用驼峰命名，而不是全部小写。<ul><li>通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。</li><li>在 React 中你不能通过返回 false 来阻止默认行为。必须明确调用 preventDefault。</li></ul></li></ul></li></ol><p>由上面执行机制我们可以得出： React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。</p><ol start="7"><li><p>React事件和原生事件的执行顺序</p><pre><code>react的所有事件都挂载在 document中当真实dom触发后冒泡到 document后才会对 react事件进行处理所以原生的事件会先执行然后执行 react合成事件最后执行真正在 document上挂载的事件</code></pre></li></ol><ol start="8"><li>React的合成事件是什么？<br>React 根据 W3C 规范定义了每个事件处理函数的参数，即合成事件。</li></ol><p>事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。它具有与浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()，在所有浏览器中他们工作方式都相同。</p><p>React合成的 SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。</p><p>另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。</p><ol start="9"><li>React和原生事件的执行顺序是什么？可以混用吗？</li></ol><p>React的所有事件都通过 document进行统一分发。当真实 Dom触发事件后冒泡到 document后才会对 React事件进行处理。</p><p>所以原生的事件会先执行，然后执行 React合成事件，最后执行真正在 document上挂载的事件</p><p>React事件和原生事件最好不要混用。原生事件中如果执行了 stopPropagation方法，则会导致其他 React事件失效。因为所有元素的事件将无法冒泡到 document上，导致所有的 React事件都将无法被触发。。</p><ol start="10"><li>虚拟Dom是什么？</li></ol><p>在原生的 JavaScript程序中，我们直接对 DOM进行创建和更改，而 DOM元素通过我们监听的事件和我们的应用程序进行通讯。</p><p>而 React会先将你的代码转换成一个 JavaScript对象，然后这个 JavaScript对象再转换成真实 DOM。这个 JavaScript对象就是所谓的虚拟 DOM。</p><p>当我们需要创建或更新元素时， React首先会让这个 VitrualDom对象进行创建和更改，然后再将 VitrualDom对象渲染成真实DOM。</p><p>当我们需要对 DOM进行事件监听时，首先对 VitrualDom进行事件监听， VitrualDom会代理原生的 DOM事件从而做出响应。</p><ol start="11"><li>虚拟Dom比 普通Dom更快吗？</li></ol><p>很多文章说 VitrualDom可以提升性能，这一说法实际上是很片面的。</p><p>直接操作 DOM是非常耗费性能的，这一点毋庸置疑。但是 React使用 VitrualDom也是无法避免操作 DOM的。<br>如果是首次渲染， VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。</p><p>VitrualDom的优势在于 React的 Diff算法和批处理策略， React在页面更新之前，提前计算好了如何进行更新和渲染 DOM。实际上，这个计算过程我们在直接操作 DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如 React好的。所以，在这个过程中 React帮助我们”提升了性能”。</p><p>所以，我更倾向于说， VitrualDom帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比 DOM操作更快。</p><ol start="12"><li><p>虚拟Dom中的 $$typeof属性的作用是什么？</p></li><li><p>React组件的渲染流程是什么？</p></li><li><p>为什么代码中一定要引入 React？<br>JSX只是为 React.createElement(component,props,…children)方法提供的语法糖。<br>所有的 JSX代码最后都会转换成 React.createElement(…)， Babel帮助我们完成了这个转换的过程。<br>所以使用了 JSX的代码都必须引入 React。</p></li><li><p>为什么 React组件首字母必须大写？<br>babel在编译时会判断 JSX中组件的首字母，当首字母为小写时，其被认定为原生 DOM标签， createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件， createElement的第一个变量被编译为对象；</p></li><li><p>React在渲染 真实Dom时做了哪些性能优化？<br>在 IE（8-11）和 Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。</p></li></ol><p>React通过 lazyTree，在 IE（8-11）和 Edge中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的 DOM结构构建好，然后再整体插入容器。</p><p>并且，在单独渲染节点时， React还考虑了 fragment等特殊节点，这些节点则不会一个一个插入渲染。</p><ol start="17"><li>什么是高阶组件？如何实现？<br>高阶组件可以看作 React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</li></ol><blockquote><p>高阶组件（ HOC）是 React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是 ReactAPI。它只是一种模式，这种模式是由 React自身的组合性质必然产生的。</p></blockquote><p>我们可以通过以下两种方式实现高阶组件：</p><ol><li><strong>属性代理</strong></li></ol><p>函数返回一个我们自己定义的组件，然后在 render中返回要包裹的组件，这样我们就可以代理所有传入的 props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数 visible就是一个 HOC属性代理的实现方式。<br>对比原生组件增强的项：</p><pre><code>可操作所有传入的 props可操作组件的生命周期可操作组件的 static方法获取 ref</code></pre><ol start="2"><li><strong>反向继承</strong></li></ol><p>返回一个组件，继承原组件，在 render中调用原组件的 render。由于继承了原组件，能通过this访问到原组件的 生命周期、props、state、render等，相比属性代理它能操作更多的属性。</p><p>对比原生组件增强的项：</p><pre><code>可操作所有传入的 props可操作组件的生命周期可操作组件的 static方法获取 refs可操作 state可以渲染劫持</code></pre><ol start="18"><li><p>HOC在业务场景中有哪些实际应用场景？<br>HOC可以实现的功能：</p><pre><code>组合渲染条件渲染操作 props获取 refs状态管理操作 state渲染劫持</code></pre></li></ol><p>HOC在业务中的实际应用场景：</p><pre><code>日志打点权限控制双向绑定表单校验</code></pre><ol start="19"><li><p>高阶组件( HOC)和 Mixin的异同点是什么？<br>Mixin和 HOC都可以用来解决 React的代码复用问题。</p><ul><li>Mixin 可能会相互依赖，相互耦合，不利于代码维护</li><li>不同的 Mixin中的方法可能会相互冲突</li><li>Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li></ul><p>而 HOC的出现可以解决这些问题：</p><ul><li>高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</li><li>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为</li><li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</li></ul></li><li><p>Hook有哪些优势？</p><ul><li>减少状态逻辑复用的风险</li></ul><p>Hook和 Mixin在用法上有一定的相似之处，但是 Mixin引入的逻辑和状态是可以相互覆盖的，而多个 Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。在不遵守约定的情况下使用 HOC也有可能带来一定冲突，比如 props覆盖等等，使用 Hook则可以避免这些问题。</p><ul><li>避免地狱式嵌套</li></ul><p>大量使用 HOC的情况下让我们的代码变得嵌套层级非常深，使用 HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。</p><ul><li>让组件更容易理解</li></ul><p>在使用 class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用 Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。</p><ul><li>使用函数代替class</li></ul><p>相比函数，编写一个 class可能需要掌握更多的知识，需要注意的点也越多，比如 this指向、绑定事件等等。另外，计算机理解一个 class比理解一个函数更快。Hooks让你可以在 classes之外使用更多 React的新特性。</p></li><li><p>ReactDiff算法的策略是什么？</p></li><li><p>React中 key的作用是什么？</p></li><li><p>ReactFiber是什么？为什么要引入？</p></li><li><p>为什么推荐在 componentDidMount中发起网络请求？</p></li><li><p>React代码优化？</p></li><li><p>React组件设计要掌握哪些原则？</p></li><li><p>Redux的核心原理是什么？</p></li><li><p>什么是 Redux中间件？</p></li><li><p>Reduxconnect函数的实现策略？</p></li><li><p>Mox的核心原理是什么？</p></li><li><p>Redux和 Mobx的异同点，如何选择？</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React高频面试题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Axios源码分析</title>
    <link href="http://peilinghui.com/2019/09/20/Axios%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://peilinghui.com/2019/09/20/Axios源码分析/</id>
    <published>2019-09-20T06:50:58.000Z</published>
    <updated>2019-10-10T09:59:57.111Z</updated>
    
    <content type="html"><![CDATA[<p>Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：<a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><a id="more"></a><p>Axios 的主要特性包括：</p><pre><code>基于 Promise支持浏览器和 node.js可添加拦截器和转换请求和响应数据请求可以取消自动转换 JSON 数据客户端支持防范 XSRF支持各主流浏览器及 IE8+</code></pre><p>Axios的使用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/get?name=xmz'</span>)</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(response)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response'</span>, response)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(<span class="function"><span class="params">(error)</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'error'</span>, error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当业务请求代码发起时，具体执行的是lib/core/Axios.js中的request方法。</p><pre><code>├── /dist/                     # 项目输出目录├── /lib/                      # 项目源码目录│ ├── /cancel/                 # 定义取消功能│ ├── /core/                   # 一些核心功能│ │ ├── Axios.js               # axios的核心主类---------------------------这是其最核心部分│ │ ├── dispatchRequest.js     # 用来调用http请求适配器方法发送请求         |│ │ ├── InterceptorManager.js  # 拦截器构造函数                            |│ │ └── settle.js              # 根据http响应状态，改变Promise的状态--------│ ├── /helpers/                # 一些辅助方法│ ├── /adapters/               # 定义请求的适配器 xhr、http----这个文件夹封装了ajax的请求│ │ ├── http.js                # 实现http适配器│ │ └── xhr.js                 # 实现xhr适配器│ ├── axios.js                 # 对外暴露接口│ ├── defaults.js              # 默认配置 │ └── utils.js                 # 公用工具├── package.json               # 项目信息├── index.d.ts                 # 配置TypeScript的声明文件└── index.js                   # 入口文件</code></pre><h2 id="工厂函数createInstance"><a href="#工厂函数createInstance" class="headerlink" title="工厂函数createInstance"></a>工厂函数createInstance</h2><p>在找到axios/lib/axios.js里面有这个对象，<code>var axios = createInstance(defaults);</code>创建axios这样一个实例函数</p><p>axios/lib/defaults.js是默认配置，默认导出一个对象</p><p>配置：</p><ul><li>全局配置：提供配置参考，实例化的时候可以使用。</li><li>实例配置：一个应用可能需要实例化多个不同的对象（针对不同的接口）所以每个实例化对象都会有自己的配置，可以通过全局配置进行初始化，或合并一个新的配置项</li><li>请求配置：请求的时候需要传入配置与实例配置进行合并。不要影响(赋值引用)</li></ul><p>深度克隆-deepcopy函数，深度克隆对象</p><p>配置合并-configMerge函数，有的是覆盖，有的是合并</p><h2 id="拦截器Interceptor"><a href="#拦截器Interceptor" class="headerlink" title="拦截器Interceptor"></a>拦截器Interceptor</h2><p>在 Axios 中，大概是这样添加拦截器：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Add a request interceptor</span><br><span class="line">axios.interceptors.request.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(config) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">config</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">// Add a response interceptor</span><br><span class="line">axios.interceptors.response.<span class="keyword">use</span>(<span class="keyword">function</span> <span class="title"></span>(response) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">response</span>;</span><br><span class="line">  &#125;, <span class="keyword">function</span> <span class="title"></span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise.reject(error)</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>interceptors.request -&gt; request -&gt; interceptors.response -&gt; response<br>而 Axios 内部，很巧妙地实现了上面所说的管道式流程，首先看 lib/core/Axios.js。interceptors.request可以注册函数，在发送请求之前执行，interceptors.response在发送请求并得到数据后执行，then之前执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatchRequest = <span class="built_in">require</span>(<span class="string">'./dispatchRequest'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = &#123;</span><br><span class="line">    request: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    response: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略部分代码...</span></span><br><span class="line">    <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">        chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">        promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 省略部分代码...</span></span><br></pre></td></tr></table></figure><p>先看到 Axios 类的定义里面有 interceptors，并且带有 request 和 response 属性，而这 2 个属性都是指向 InterceptorManager 类的实例。这个等下再说，先看 request 方法里 interceptors 的实现。</p><p>我们留意 chain 这个变量，经过 2 次 forEach 操作后，最后的值会变成：(这个 forEach 方法在 InterceptorManager 中定义)</p><ul><li>单请求配置Options:axios.post(url,data,options)</li><li>全局配置Defaults:this.$axios.defaults</li><li>config：请求拦截器中的参数</li><li>response.config:响应拦截器中的参数</li><li><p>Options:</p><pre><code>-  baseURL 基础URL路径-  params 查询字符串对象-  transformRequest 转换请求体数据-  transformResponse 转换响应体数据-  headers:头信息-  data：请求体数据-  timeout：请求超时。 </code></pre><h3 id="InterceptorManager管理拦截器"><a href="#InterceptorManager管理拦截器" class="headerlink" title="InterceptorManager管理拦截器"></a>InterceptorManager管理拦截器</h3></li></ul><p>use()方法接收到两个参数，一个是fulfilled，一个是rejected</p><h2 id="适配器adapters"><a href="#适配器adapters" class="headerlink" title="适配器adapters"></a>适配器adapters</h2><p>通过适配器，把不同的接口进行适配。在adapter的处理逻辑中，axios没有把http和xhr两个模块（一个用于Node.js发送请求，另一个则用于浏览器端发送请求）当成自身的模块直接在dispatchRequest中直接饮用，而是通过配置的方法在default.js文件中进行默认引入。这样既保证了两个模块间的低耦合性，同时又能够为今后用户需要自定义请求发送模块保留了余地。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Axios主要就是在package.json里面配置然后安装就能在node_modules里面找到源码。git地址：&lt;a href=&quot;https://github.com/axios/axios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/axios/axios&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript面试题</title>
    <link href="http://peilinghui.com/2019/09/17/JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2019/09/17/JavaScript面试题/</id>
    <published>2019-09-17T06:53:56.000Z</published>
    <updated>2020-01-09T12:09:33.522Z</updated>
    
    <content type="html"><![CDATA[<p>相关面试题</p><a id="more"></a><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>JavaScript 中有两个机制可以“欺骗”词法作用域:eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在 运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。<br>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认 为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>原型：在JavaScript中原型是一个prototype对象，用于表示类型之间的关系。</p><p>原型链：JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：666666</p><p>改变：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; (<span class="function"><span class="keyword">function</span><span class="params">(j)</span> &#123;</span></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123; <span class="title">console</span>.<span class="title">log</span><span class="params">( j )</span>;</span></span><br><span class="line">             &#125;, <span class="built_in">j</span>*<span class="number">1000</span> );</span><br><span class="line">         &#125;)( <span class="built_in">i</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：123456</p><p>块作用域和闭包联手便可天下无敌。把var改成let<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span>&lt;=<span class="number">5</span>; <span class="built_in">i</span>++) &#123; setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">             console.<span class="built_in">log</span>( <span class="built_in">i</span> );</span><br><span class="line">         &#125;, <span class="built_in">i</span>*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ol><li>数组常用遍历的方法</li></ol><p>forEach、map、filter、find、every、some、reduce，它们有个共同点：不会改变原始数组。</p><ul><li>forEach：遍历数组</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [1,2,3,4,5];</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">sum</span> = 0;</span><br><span class="line">numbers.<span class="keyword">forEach</span>(number=&gt;<span class="keyword">sum</span>+=number)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">sum</span>)<span class="comment">//15</span></span><br></pre></td></tr></table></figure><ul><li>map：将数组映射成另一个数组(map通过指定函数处理数组的每个元素，并返回处理后新的数组，map 不会改变原始数组。forEach和map的区别在于，forEach没有返回值。)</li></ul><p>map需要返回值，如果不给return，默认返回undefined</p><ul><li>filter：从数组中找出所有符合指定条件的元素</li><li>find：返回通过测试（函数内判断）的数组的第一个元素的值</li><li><p>every&amp;some<br>every：数组中是否每个元素都满足指定的条件<br>some:数组中是否有元素满足指定的条件<br>Some: 一真即真；Every: 一假即假</p></li><li><p>reduce：将数组合成一个值(reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。)</p></li></ul><ol start="2"><li>浅拷贝与深拷贝</li></ol><p>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。<br>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p><p>浅拷贝的实现方式：</p><ul><li>Object.assign()拷贝的是对象的属性的引用，而不是对象本身。当object只有一层的时候，是深拷贝</li><li>Array.prototype.concat()</li><li>Array.prototype.slice()</li></ul><p>Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p><p>深拷贝的实现方式</p><ul><li>JSON.parse(JSON.stringify())这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</li><li>函数库lodash提供_.cloneDeep用来做 Deep Copy</li><li>手写递归方法<br>递归方法实现深度克隆原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>ES6模块化如何使用，开发环境如何打包？<br>模块化的基本语法：export语法，import语法<br>开发环境配置：babel编译ES6语法  <code>npm init</code><br><code>npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest</code></li></ol><p>创建.babelrc文件<br><code>npm install --global babel-cli</code><br><code>babel --version</code><br>JS众多模块化标准：<br>AMD成为标准，require.js（也有CMD）<br>前端打包工具，nodejs模块化可以被使用<br>模块化可以使用webpack和rollup</p><ol start="2"><li><p>Class和普通构造函数有何区别？<br>JS构造函数：<br>Class的基本语法：<br>语法糖：<br>继承：</p></li><li><p>Promise的基本使用和原理</p></li><li>ES6的常用功能？</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相关面试题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React新特性Hooks</title>
    <link href="http://peilinghui.com/2019/09/16/React%E6%96%B0%E7%89%B9%E6%80%A7Hooks/"/>
    <id>http://peilinghui.com/2019/09/16/React新特性Hooks/</id>
    <published>2019-09-16T07:25:56.000Z</published>
    <updated>2019-09-18T05:39:59.765Z</updated>
    
    <content type="html"><![CDATA[<p>React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：<a href="https://reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">https://reactjs.org/docs/hooks-reference.html</a><br>中文：<a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-intro.html</a><br><a id="more"></a><br>React 的核心是组件,组件的标准写法是类（class), 组件的最佳写法应该是函数，而不是类。但是函数组件必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。</p><p>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。就是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来</p><p>总结一下要解决的痛点问题就是：</p><ol><li>在组件之间复用状态逻辑很难</li></ol><ul><li>之前的解决方案是：render props 和高阶组件</li><li>缺点是难理解、存在过多的嵌套形成“嵌套地狱”  </li></ul><ol start="2"><li>复杂组件变得难以理解</li></ol><ul><li>生命周期函数中充斥着各种状态逻辑和副作用</li><li>这些副作用难以复用，且很零散</li></ul><ol start="3"><li>难以理解的Class</li></ol><ul><li>this指针问题</li><li>组件预编译技术（组件折叠）会在class中遇到优化失效的case</li><li>class不能很好的压缩</li><li>class在热重载时会出现不稳定的情况</li></ul><p>React 默认提供的基础Hook。</p><pre><code>useState()useEffect()useContext()</code></pre><p>额外的 Hook</p><pre><code>useReducer()useReduceruseCallbackuseMemouseRefuseImperativeHandleuseLayoutEffectuseDebugValue</code></pre><h2 id="useState-：状态钩子"><a href="#useState-：状态钩子" class="headerlink" title="useState()：状态钩子"></a>useState()：状态钩子</h2><p><code>const [state, setState] = useState(initialState);</code></p><p>useState()用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p><p> class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setState(prevState =&gt; &#123;</span><br><span class="line">  <span class="comment">// 也可以使用 Object.assign</span></span><br><span class="line">  <span class="keyword">return</span> &#123;.<span class="built_in">..prevState</span>, .<span class="built_in">..updatedValues</span>&#125;<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>useReducer 是另一种可选方案，它更适合用于管理包含多个子值的 state 对象。</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h2><p><code>const value = useContext(MyContext);</code></p><h2 id="useReducer-：action-钩子"><a href="#useReducer-：action-钩子" class="headerlink" title="useReducer()：action 钩子"></a>useReducer()：action 钩子</h2><p>Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) =&gt; newState。</p><p>useReducers()钩子用来引入 Reducer 功能。</p><pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre><p>上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。</p><p>由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。</p><h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在componentDidMount里面的代码，现在可以放在useEffect()。</p><p>useEffect()的用法如下。</p><pre><code>useEffect(()  =&gt;  {  // Async Action}, [dependencies])</code></pre><p>上面用法中，useEffect()接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，useEffect()就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行useEffect()。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React 是主流的前端框架，v16.8 版本引入了全新的 API，叫做 React Hooks.作用：让在不写Class的情况下也能使用state和其他的React特性。API地址：&lt;a href=&quot;https://reactjs.org/docs/hooks-reference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://reactjs.org/docs/hooks-reference.html&lt;/a&gt;&lt;br&gt;中文：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zh-hans.reactjs.org/docs/hooks-intro.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RN第三方组件</title>
    <link href="http://peilinghui.com/2019/09/09/RN%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2019/09/09/RN第三方组件/</id>
    <published>2019-09-09T06:56:21.000Z</published>
    <updated>2020-01-10T08:51:54.027Z</updated>
    
    <content type="html"><![CDATA[<p>用过的一些组件。  </p><a id="more"></a><h1 id="react-native"><a href="#react-native" class="headerlink" title="react-native"></a>react-native</h1><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p>react-native-simple-router</p><p>react-native-scrollable-tab-view</p><p>react-native-router-flux</p><p>react-native-router-redux</p><p>react-native-tabbar-navigator(IOS only)</p><p>react-native-navigation</p><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p><a href="https://github.com/tradle/react-native-crypto" target="_blank" rel="noopener">react-native-crypto</a>此类库支持在 React Native 中使用 node 的 crypto 模块</p><p><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="noopener">https://www.npmjs.com/package/crypto-js</a></p><h1 id="整体框架布局–轮播"><a href="#整体框架布局–轮播" class="headerlink" title="整体框架布局–轮播"></a>整体框架布局–轮播</h1><p>react-native-side-menu 侧栏</p><p>react-native-scrollable-tab-view 可滑动的底部或上部导航栏框架</p><h1 id="轮播视图"><a href="#轮播视图" class="headerlink" title="轮播视图"></a>轮播视图</h1><p><a href="https://github.com/race604/react-native-viewpager" target="_blank" rel="noopener">react-native-viewpager</a> 分页浏览 </p><p><a href="https://github.com/FuYaoDe/react-native-app-intro" target="_blank" rel="noopener">https://github.com/FuYaoDe/react-native-app-intro</a> </p><p><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">react-native-swiper</a> 轮播</p><p><a href="https://github.com/root-two/react-native-drawer" target="_blank" rel="noopener">react-native-drawer</a> 抽屉效果 </p><p><a href="https://github.com/react-native-fellowship/react-native-side-menu" target="_blank" rel="noopener">react-native-side-menu</a></p><p><a href="https://github.com/react-navigation/material-bottom-tabs" target="_blank" rel="noopener">react-navigation-material-bottom-tabs</a>底部tab</p><p>react-native-carousel</p><p>react-native-looped-carousel</p><p>react-native-carousel-control</p><p>react-native-spring-carousel</p><p>react-native-image-carousell</p><h1 id="键盘遮挡"><a href="#键盘遮挡" class="headerlink" title="键盘遮挡"></a>键盘遮挡</h1><p><a href="https://github.com/wix/react-native-keyboard-aware-scrollview" target="_blank" rel="noopener">react-native-keyboard-aware-scrollview</a><br><a href="https://github.com/reactnativecn/react-native-inputscrollview" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-inputscrollview</a> </p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p>react-native-icons 图标 </p><p><a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener">react-native-vector-icons</a>头像库 矢量</p><h2 id="初始化应用时启动轮播图"><a href="#初始化应用时启动轮播图" class="headerlink" title="初始化应用时启动轮播图"></a>初始化应用时启动轮播图</h2><p><a href="https://github.com/phil-r/react-native-looped-carousel" target="_blank" rel="noopener">react-native-looped-carousel</a></p><p><a href="https://www.npmjs.com/package/react-native-auto-height-image" target="_blank" rel="noopener">react-native-auto-height-image</a>自动调节图片高度</p><p>react-native-image-picker 图片选择器</p><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><p><a href="https://github.com/DylanVann/react-native-fast-image" target="_blank" rel="noopener">react-native-fast-image</a>图片缓存以及预加载</p><p>react-native-fast-image这是一个native库，在iOS上是包装的 SDWebImage，Android上是包装的Glide (Android)，这两个都是原生上万星星的库。因为是native库，所以安装后也需要链接，具体方法跟上面一样。这是一个使用例子：</p><p><a href="https://github.com/quenice/react-native-cacheimage" target="_blank" rel="noopener">react-native-cache-image</a>，react-native-rn-cacheimage纯JS实现，所以兼容性很好。首先安装rn-fecth-blob。<br> Image 组件在 iOS 端实现了缓存，而android 端仍未实现，而且，就算实现了 iOS端 ，可能有些需求仍然比较难实现，比如一般APP都有一个 清除缓存 的功能，如果我们使用默认的 Image 的缓存实现，我们能难定位图片到底缓存在本地文件系统的哪个目录。 react-native-rn-cacheimage 的实现方式是，把所有的缓存图片都放在一个指定的文件夹下，并提供了一个方法 CacheHelper.clearCache() 方法能够轻松清除缓存。</p><p>相关文章：<a href="https://www.jianshu.com/p/19ef9f32c332" target="_blank" rel="noopener">https://www.jianshu.com/p/19ef9f32c332</a><br><a href="https://github.com/magicwing/react-native-image-zoom-viewer" target="_blank" rel="noopener">react-native-image-zoom-viewer</a>图片轮播、放大、手势捏合</p><p>react-native-image-resizer图片压缩</p><p><a href="https://github.com/ascoders/react-native-image-viewer" target="_blank" rel="noopener">react-native-image-viewer</a>实现大图预览</p><h2 id="图片放大查看"><a href="#图片放大查看" class="headerlink" title="图片放大查看"></a>图片放大查看</h2><p><a href="https://github.com/oblador/react-native-lightbox" target="_blank" rel="noopener">react-native-lightbox</a></p><p><a href="https://github.com/ldn0x7dc/react-native-transformable-image" target="_blank" rel="noopener">react-native-transformable-image</a></p><h2 id="照片选择"><a href="#照片选择" class="headerlink" title="照片选择"></a>照片选择</h2><p><a href="https://github.com/marcshilling/react-native-image-picker" target="_blank" rel="noopener">react-native-image-picker</a></p><p><a href>react-native-camera-roll-picker</a></p><p><a href="https://github.com/ivpusic/react-native-image-crop-picker" target="_blank" rel="noopener">react-native-image-crop-picker</a>图像选择器，可支持摄像头，可配置压缩，可多选图像和可对图像进行裁剪的。</p><p>图片加载进度条 <a href="https://github.com/oblador/react-native-image-progress" target="_blank" rel="noopener">https://github.com/oblador/react-native-image-progress</a></p><h2 id="图片保存到本地"><a href="#图片保存到本地" class="headerlink" title="图片保存到本地"></a>图片保存到本地</h2><h1 id="通知栏"><a href="#通知栏" class="headerlink" title="通知栏"></a>通知栏</h1><p>Noticebar与Snackbar的区别：<a href="http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html" target="_blank" rel="noopener">http://www.xueui.cn/design-theory/style-guide/noticebar-snack-bar.html</a></p><h2 id="noticebar"><a href="#noticebar" class="headerlink" title="noticebar"></a>noticebar</h2><p><a href="https://github.com/seymoe/react-native-noticebar" target="_blank" rel="noopener">react-native-noticebar</a>上下滚动的通知栏</p><p><a href="https://rn.mobile.ant.design/components/notice-bar-cn/#components-notice-bar-demo-basic" target="_blank" rel="noopener">Ant Design Mobile NoticeBar 通告栏</a>滚动播放的noticebar</p><p><a href="https://github.com/peilinghui/BokeDemo/tree/master/React-Native%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81/%E5%AD%97%E4%BD%93%E8%B7%91%E9%A9%AC%E7%81%AFmarquee" target="_blank" rel="noopener">纯JS跑马灯的text</a></p><p><a href="https://github.com/remobile/react-native-marquee-label" target="_blank" rel="noopener">链接原生Text跑马灯效果</a></p><h2 id="Snackbar"><a href="#Snackbar" class="headerlink" title="Snackbar"></a>Snackbar</h2><p><a href>rn-snackbar</a></p><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><a href="https://github.com/itinance/react-native-fs" target="_blank" rel="noopener">react-native-fs</a>文件下载、文本存储</p><p>先下载<a href="https://github.com/wkh237/react-native-fetch-blob" target="_blank" rel="noopener">https://github.com/wkh237/react-native-fetch-blob</a><br>或者rn-fetch-blob</p><p>react-native-fileupload 文件上传</p><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><p><a href="https://github.com/react-native-community/react-native-video" target="_blank" rel="noopener">react-native-video</a> 视频播放</p><h1 id="滚动列表"><a href="#滚动列表" class="headerlink" title="滚动列表"></a>滚动列表</h1><p><a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="noopener">react-native-refreshable-listview</a> 可刷新列表</p><p>react-native-sortable-listview 分类ListView</p><p>单选多选ListView <a href="https://github.com/hinet/react-native-checkboxlist" target="_blank" rel="noopener">https://github.com/hinet/react-native-checkboxlist</a></p><p><a href>react-native-invertible-scroll-view</a> 翻转listview</p><p>recyclerlistview”: “^2.0.0-beta.4”,</p><p>recyclerlistview-gridlayoutprovider”: “^1.0.1”,</p><p><a href="https://github.com/jaysoo/react-native-parallax-scroll-view" target="_blank" rel="noopener">react-native-parallax-scroll-view</a>拉伸最上方图片刷新，类似微信朋友圈刷新</p><p>react-native-lazyload</p><p><a href="https://github.com/sghiassy/react-native-sglistview" target="_blank" rel="noopener">react-native-sglistview</a>ListView的优化 </p><p>react-native-refreshable-listview</p><h1 id="WebView网页"><a href="#WebView网页" class="headerlink" title="WebView网页"></a>WebView网页</h1><p>react-native-htmlview 将 HTML 目录作为本地视图的控件，其风格可以定制 </p><p>react-native-webview-invoke React Native和WebView中的函数可以互相调用</p><p>react-native-easy-toast 一款简单易用的 Toast 组件，支持 Android&amp;iOS.</p><p>WebView相关 <a href="https://github.com/alinz/react-native-webview-bridge" target="_blank" rel="noopener">https://github.com/alinz/react-native-webview-bridge</a></p><p>选项卡 <a href="https://github.com/exponentjs/react-native-tab-navigator" target="_blank" rel="noopener">https://github.com/exponentjs/react-native-tab-navigator</a></p><p>material组件库（各种漂亮的小组件）<a href="https://github.com/xinthink/react-native-material-kit" target="_blank" rel="noopener">https://github.com/xinthink/react-native-material-kit</a></p><p>base组件库（各种封装不错的小组件）<a href="http://nativebase.io/docs/v0.4.6/components#anatomy" target="_blank" rel="noopener">http://nativebase.io/docs/v0.4.6/components#anatomy</a> <a href="https://github.com/GeekyAnts/NativeBase" target="_blank" rel="noopener">https://github.com/GeekyAnts/NativeBase</a></p><p>不错的按钮 <a href="https://github.com/mastermoo/react-native-action-button" target="_blank" rel="noopener">https://github.com/mastermoo/react-native-action-button</a> <a href="https://github.com/ide/react-native-button" target="_blank" rel="noopener">https://github.com/ide/react-native-button</a></p><p>输入框表单验证 <a href="https://github.com/gcanti/tcomb-form-native" target="_blank" rel="noopener">https://github.com/gcanti/tcomb-form-native</a> <a href="https://github.com/FaridSafi/react-native-gifted-form" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-form</a> <a href="https://github.com/bartonhammond/snowflake" target="_blank" rel="noopener">https://github.com/bartonhammond/snowflake</a></p><p>炫酷效果的 TextInput <a href="https://github.com/halilb/react-native-textinput-effects" target="_blank" rel="noopener">https://github.com/halilb/react-native-textinput-effects</a> <a href="https://github.com/zbtang/React-Native-TextInputLayout" target="_blank" rel="noopener">https://github.com/zbtang/React-Native-TextInputLayout</a></p><p>聊天 <a href="https://github.com/FaridSafi/react-native-gifted-chat" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-chat</a></p><p>地图 <a href="https://github.com/lelandrichardson/react-native-maps" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-maps</a></p><p>侧滑按钮 <a href="https://github.com/dancormier/react-native-swipeout" target="_blank" rel="noopener">https://github.com/dancormier/react-native-swipeout</a> <a href="https://github.com/jemise111/react-native-swipe-list-view" target="_blank" rel="noopener">https://github.com/jemise111/react-native-swipe-list-view</a></p><p>图表 <a href="https://github.com/tomauty/react-native-chart" target="_blank" rel="noopener">https://github.com/tomauty/react-native-chart</a></p><p>下拉放大 <a href="https://github.com/lelandrichardson/react-native-parallax-view" target="_blank" rel="noopener">https://github.com/lelandrichardson/react-native-parallax-view</a></p><p>日历组件 <a href="https://github.com/cqm1994617/react-native-myCalendar" target="_blank" rel="noopener">https://github.com/cqm1994617/react-native-myCalendar</a> <a href="https://github.com/vczero/react-native-calendar" target="_blank" rel="noopener">https://github.com/vczero/react-native-calendar</a></p><p>语言转化和一些常用格式转换 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a><br>选择按钮 <a href="https://github.com/sconxu/react-native-checkbox" target="_blank" rel="noopener">https://github.com/sconxu/react-native-checkbox</a></p><p>制作本地库 <a href="https://github.com/frostney/react-native-create-library" target="_blank" rel="noopener">https://github.com/frostney/react-native-create-library</a></p><p>影音相关 <a href="https://github.com/MisterAlex95/react-native-record-sound" target="_blank" rel="noopener">https://github.com/MisterAlex95/react-native-record-sound</a></p><p>安卓录音 <a href="https://github.com/bosung90/react-native-audio-android" target="_blank" rel="noopener">https://github.com/bosung90/react-native-audio-android</a></p><p>提示消息的Bar <a href="https://github.com/KBLNY/react-native-message-bar" target="_blank" rel="noopener">https://github.com/KBLNY/react-native-message-bar</a></p><p>iOS原生TableView <a href="https://github.com/aksonov/react-native-tableview" target="_blank" rel="noopener">https://github.com/aksonov/react-native-tableview</a></p><p>点击弹出视图 <a href="https://github.com/jeanregisser/react-native-popover" target="_blank" rel="noopener">https://github.com/jeanregisser/react-native-popover</a> <a href="https://github.com/instea/react-native-popup-menu" target="_blank" rel="noopener">https://github.com/instea/react-native-popup-menu</a></p><p>3D Touch <a href="https://github.com/madriska/react-native-quick-actions" target="_blank" rel="noopener">https://github.com/madriska/react-native-quick-actions</a></p><p>照片墙 <a href="https://github.com/ldn0x7dc/react-native-gallery" target="_blank" rel="noopener">https://github.com/ldn0x7dc/react-native-gallery</a></p><p>本地存储 <a href="https://github.com/sunnylqm/react-native-storage" target="_blank" rel="noopener">https://github.com/sunnylqm/react-native-storage</a></p><p>星星 <a href="https://github.com/djchie/react-native-star-rating" target="_blank" rel="noopener">https://github.com/djchie/react-native-star-rating</a></p><p>国际化 <a href="https://github.com/joshswan/react-native-globalize" target="_blank" rel="noopener">https://github.com/joshswan/react-native-globalize</a></p><p>通讯录 <a href="https://github.com/rt2zz/react-native-contacts" target="_blank" rel="noopener">https://github.com/rt2zz/react-native-contacts</a></p><p>缓存管理 <a href="https://github.com/reactnativecn/react-native-http-cache" target="_blank" rel="noopener">https://github.com/reactnativecn/react-native-http-cache</a></p><p>图片和base64互转 <a href="https://github.com/xfumihiro/react-native-image-to-base64" target="_blank" rel="noopener">https://github.com/xfumihiro/react-native-image-to-base64</a></p><p>安卓 iOS 白屏解决 <a href="https://github.com/mehcode/rn-splash-screen" target="_blank" rel="noopener">https://github.com/mehcode/rn-splash-screen</a></p><p>清除按钮的输入框 <a href="https://github.com/beefe/react-native-textinput" target="_blank" rel="noopener">https://github.com/beefe/react-native-textinput</a></p><p>PDF <a href="https://github.com/cnjon/react-native-pdf-view" target="_blank" rel="noopener">https://github.com/cnjon/react-native-pdf-view</a></p><h1 id="获取设备信息"><a href="#获取设备信息" class="headerlink" title="获取设备信息"></a>获取设备信息</h1><p><a href="https://github.com/rebeccahughes/react-native-device-info" target="_blank" rel="noopener">react-native-device-info</a></p><p>下拉-上拉-刷新 <a href="https://github.com/FaridSafi/react-native-gifted-listview" target="_blank" rel="noopener">https://github.com/FaridSafi/react-native-gifted-listview</a> </p><p><a href="https://github.com/greatbsky/react-native-pull/wiki" target="_blank" rel="noopener">https://github.com/greatbsky/react-native-pull/wiki</a></p><p>下拉选择 <a href="https://github.com/alinz/react-native-dropdown" target="_blank" rel="noopener">https://github.com/alinz/react-native-dropdown</a></p><h1 id="通讯录"><a href="#通讯录" class="headerlink" title="通讯录"></a>通讯录</h1><p><a href>react-native-alphabetlistview</a>类似iPhone通讯录样式</p><h1 id="toast提示"><a href="#toast提示" class="headerlink" title="toast提示"></a>toast提示</h1><p><a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">react-native-root-toast</a>浮动提示</p><h1 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h1><p><a href="https://github.com/react-native-fellowship/react-native-blur" target="_blank" rel="noopener">react-native-blur</a></p><p>滑动选项卡 <a href="https://github.com/skv-headless/react-native-scrollable-tab-view" target="_blank" rel="noopener">https://github.com/skv-headless/react-native-scrollable-tab-view</a></p><h1 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h1><p><a href>react-native-progress</a></p><h1 id="第三方授权登录"><a href="#第三方授权登录" class="headerlink" title="第三方授权登录"></a>第三方授权登录</h1><p><a href="https://github.com/yoaicom/react-native-social-kit" target="_blank" rel="noopener">https://github.com/yoaicom/react-native-social-kit</a> <a href="https://github.com/mozillo/react-native-open-share" target="_blank" rel="noopener">https://github.com/mozillo/react-native-open-share</a> <a href="https://github.com/zuoyoulian/React-Native-iOS-OpenShare" target="_blank" rel="noopener">https://github.com/zuoyoulian/React-Native-iOS-OpenShare</a></p><p>react-native-dialog-input弹框的输入框</p><p>react-native-countdown 倒计时</p><p>react-native-device-info 设备信息</p><p><a href="https://github.com/beefe/react-native-actionsheet" target="_blank" rel="noopener">react-native-actionsheet</a>双平台兼容的ActionSheet弹框</p><h1 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h1><p><a href>react-native-camera</a></p><p><a href="https://github.com/wix/react-native-camera-kit" target="_blank" rel="noopener">react-native-camera-kit</a>相机组件</p><p>react-native-keychain iOS KeyChain管理</p><p>react-native-picker滚轮选择器</p><p>react-native-picker-Android Android 滚轮选择器</p><h1 id="表情选择"><a href="#表情选择" class="headerlink" title="表情选择"></a>表情选择</h1><p><a href="https://github.com/arronhunt/react-native-emoji-selector" target="_blank" rel="noopener">react-native-emoji-selector</a></p><p><a href="https://github.com/yonahforst/react-native-emoji-picker" target="_blank" rel="noopener">react-native-emoji-picker</a></p><h1 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h1><p><a href="https://github.com/master-atul/react-native-exception-handler" target="_blank" rel="noopener">react-native-exception-handler</a></p><h1 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h1><p><a href="https://github.com/Sunhat/react-native-extra-dimensions-android" target="_blank" rel="noopener">react-native-extra-dimensions-android</a></p><p>React Native目前存在一个错误，Dimensions.get(‘window’).height有时会返回错误的值。</p><h1 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h1><p><a href>react-native-gesture-handler</a><br><a href>react-native-gesture-password</a>手势解锁</p><p>手势放大缩小移动 <a href="https://github.com/kiddkai/react-native-gestures" target="_blank" rel="noopener">https://github.com/kiddkai/react-native-gestures</a> </p><p><a href="https://github.com/johanneslumpe/react-native-gesture-recognizers" target="_blank" rel="noopener">https://github.com/johanneslumpe/react-native-gesture-recognizers</a></p><p>react-native-linear-gradient渐变</p><h1 id="Model模态视图"><a href="#Model模态视图" class="headerlink" title="Model模态视图"></a>Model模态视图</h1><p><a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="noopener">react-native-modal</a><br><a href="https://github.com/maxs15/react-native-modalbox" target="_blank" rel="noopener">react-native-modalbox</a><br><a href="https://github.com/bodyflex/react-native-simple-modal" target="_blank" rel="noopener">react-native-simple-modal</a></p><h1 id="横竖屏"><a href="#横竖屏" class="headerlink" title="横竖屏"></a>横竖屏</h1><p><a href="https://github.com/yamill/react-native-orientation" target="_blank" rel="noopener">react-native-orientation</a>判断横竖屏 </p><h1 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h1><p>react-native-qrcode-svg</p><p><a href="https://github.com/lazaronixon/react-native-qrcode-reader" target="_blank" rel="noopener">react-native-qrcode-reader</a>扫描二维码 </p><p><a href="https://github.com/ideacreation/react-native-barcodescanner" target="_blank" rel="noopener">react-native-barcodescanner</a></p><h1 id="网页链接"><a href="#网页链接" class="headerlink" title="网页链接"></a>网页链接</h1><p><a href="https://github.com/obipawan/react-native-hyperlink" target="_blank" rel="noopener">react-native-hyperlink</a>超链接变可点击的</p><p>react-native-tab-navigator 底部或上部导航框架(不可滑动)</p><p>react-native-check-box CheckBox</p><p>react-native-splash-screen 启动白屏问题</p><p>react-native-simple-router 简易路由跳转框架</p><p>react-native-storage 持久化存储<br>    “react-native-global-props”: “^1.1.5”,<br>    “react-native-iphone-x-helper”: “^1.2.0”,<br>    “react-native-paper”: “^2.15.2”,<br>    “react-native-plugin-zhugeio”: “^1.1.1”,<br>    “react-native-randombytes”: “^3.5.3”,<br>    “react-native-shadow”: “^1.2.2”,<br>    “react-native-svg”: “^9.4.0”,<br>    “react-native-tab-view”: “^1.3.2”,<br>    “react-native-text-size”: “^3.0.0”,<br>    “react-native-update-app”: “^1.1.11”,<br>    “react-native-view-shot”: “^2.5.0”,   </p><h1 id="微信"><a href="#微信" class="headerlink" title="微信"></a>微信</h1><p>react-native-wechat “git+<a href="https://github.com/AegoYu/react-native-wechat.git&quot;" target="_blank" rel="noopener">https://github.com/AegoYu/react-native-wechat.git&quot;</a> </p><p>react-navigation</p><p>react-navigation-redux-helpers<br>react-navigation-transitions<br>react-redux<br>redux-immutable<br>redux-persist</p><p>socket.io-client<br>teaset<br>react-native-menu<br>react-timer-mixin<br>redux<br>redux-actions<br>redux-form<br>redux-thunk<br>remote-redux-devtools<br>rmc-date-picker<br>rmc-tabs<br>semver<br>react-native-networkplugin</p><h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><p><a href="https://github.com/oblador/react-native-collapsible" target="_blank" rel="noopener">react-native-collapsible</a>制作动画可折叠组件—手风琴</p><p>React-native-animatable 动画</p><p>动画 <a href="https://github.com/oblador/react-native-animatable" target="_blank" rel="noopener">https://github.com/oblador/react-native-animatable</a></p><p>加载动画 <a href="https://github.com/maxs15/react-native-spinkit" target="_blank" rel="noopener">https://github.com/maxs15/react-native-spinkit</a></p><h1 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h1><p><a href="https://www.jianshu.com/p/e3ee0ab1eb82" target="_blank" rel="noopener">react native第三方组件（持续更新…）</a></p><p><a href="https://github.com/Geek-ch/react-native-thirdparty" target="_blank" rel="noopener">https://github.com/Geek-ch/react-native-thirdparty</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用过的一些组件。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redux中间件与异步</title>
    <link href="http://peilinghui.com/2019/08/21/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
    <id>http://peilinghui.com/2019/08/21/Redux中间件与异步/</id>
    <published>2019-08-21T02:40:48.000Z</published>
    <updated>2020-01-15T02:07:39.210Z</updated>
    
    <content type="html"><![CDATA[<p>了解中间件，并会使用，再到自己手动实现一个中间件。</p><a id="more"></a><h1 id="中间件是什么？"><a href="#中间件是什么？" class="headerlink" title="中间件是什么？"></a>中间件是什么？</h1><p>redux中管理数据的流程是单向的，就是说，从派发动作一直到发布订阅触发渲染是一条路走到头，那么如果想要在中间添加或是更改某个逻辑就需要找到action或是reducer来修改，有没有更方便的做法呢？<br>redux的流程：<br>button -触发事件-&gt; dispath -派发动作-&gt; reducer -发布订阅-&gt; view<br>而中间件（middleware）就是一个可插拔的机制，如果想找扩展某个功能，比如添加日志，在更新前后打印出state状态，只需要将日志中间件装到redux上即可，于是便有了日志功能，当不想使用时可再拿掉，非常方便。</p><h1 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h1><h2 id="redux-logger日志中间件"><a href="#redux-logger日志中间件" class="headerlink" title="redux-logger日志中间件"></a>redux-logger日志中间件</h2><p>redux提供了好多个现成的中间件，比如上面提到的日志中间件，安装它即可使用：<br>npm i –save redux-logger<br>复制代码redux包提供了一个方法可以装载中间件：applyMiddleware<br>在创建store对象的时候，可以传入第二个参数，它就是中间件：<br>import { createStore, applyMiddleware } from “redux”;<br>import { reducer } from “./reducer”;<br>import ReduxLogger from “redux-logger”;<br>//使用applyMiddleware加载中间件<br>let store = createStore(reducer, applyMiddleware(ReduxLogger));<br>复制代码这样在每一次更新state，会在控制台打印更新日志：</p><h2 id="redux-thunk"><a href="#redux-thunk" class="headerlink" title="redux-thunk"></a><a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener">redux-thunk</a></h2><p>redux-thunk中间件可以支持异步action。<br>加载中间件：<br>import reduxThunk from “redux-thunk”;<br>let store = createStore(reducer, applyMiddleware(reduxThunk));<br>复制代码当加载了redux-thunk中间件，action函数可以支持返回一个函数，将异步操作封装在里面：<br>function add(payload) {<br>    return function(dispatch, getState) {<br>      setTimeout(() =&gt; {<br>        dispatch({ type: ADD, payload });<br>      }, 2000); //延时2秒执行<br>    };<br>}<br>复制代码可以看到action又返回一个函数，其中的参数dispatch和getState就是redux提供的方法，它将这两个函数的使用权交给了我们，让我们等待异步操作完成 时再调用，完成异步action编写。</p><h2 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h2><p>有了redux-thunk中间件我们可以编写异步action，但我们想更进一步，让异步action支持Promise，那么redux-promise中间件可派上用场。<br>还是安装redux-promise然后加载它：<br>import reduxPromise from “redux-promise”;<br>let store = createStore(<br>  reducer,<br>  applyMiddleware(reduxPromise)<br>);<br>复制代码redux-promise中间件可以支持action返回的对象payload为一个Promise：<br>let action = {<br>  add: function(payload) {<br>    return {<br>      type: ADD,<br>      //payload是一个Promise对象，异步操作封装到里面<br>      payload: new Promise((resolve, reject) =&gt; {<br>        setTimeout(() =&gt; {<br>          resolve(payload); //执行成功，将参数传到reducer<br>        }, 1000);<br>      })<br>    };<br>  },<br>  minus: function(payload) {<br>    return {<br>      type: MINUS,<br>      payload: new Promise((resolve, reject) =&gt; {<br>        setTimeout(() =&gt; {<br>          reject(payload); //执行失败，将参数传到reducer<br>        }, 1000);<br>      })<br>    };<br>  }<br>};<br>复制代码可以看到，payload不再是直接返回参数，而是改为一个Promise对象，这样就可以把异步代码封装到里面。<br>注意！如果你使用redux-promise中间件，payload参数名是固定的，不可随意改名<br>比如：<br>{<br>  type: MINUS,<br>  num: new Promise((resolve, reject) =&gt; {<br>    //…<br>  })<br>};//此处参数名是num，redux-promise不能正确识别，若使用redux-promise必须叫payload</p><h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解中间件，并会使用，再到自己手动实现一个中间件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TypeScript</title>
    <link href="http://peilinghui.com/2019/07/19/TypeScript/"/>
    <id>http://peilinghui.com/2019/07/19/TypeScript/</id>
    <published>2019-07-19T07:21:29.000Z</published>
    <updated>2019-08-23T09:07:26.168Z</updated>
    
    <content type="html"><![CDATA[<p>学习TS。是JS的超集。TS类Class。接口Interface。<br><a id="more"></a></p><p>安装：npm install -g typescript</p><p>官网：<a href="https://typescript.bootcss.com/" target="_blank" rel="noopener">https://typescript.bootcss.com/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。<br>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。<br>TS强于JS：可以声明数据类型。<br>Boolean<br>Number<br>String<br>Array<br>Enum<br>Any<br>Void</p><p>访问修饰符：public和private</p><p>封装的实现：方法里面写get和set方法<br>类：<br>认识类Class：有构造方法的话必须传参数<br>类的继承：在子类的constructor构造函数中调用super<br>static和使用：</p><p>函数类型：命名函数和匿名函数<br>重载：</p><p>Lambads和this关键字的使用：</p><p>TypeScript的接口：Class类型</p><p>interface CLockInterface{<br>} </p><p>class Clock implements CLockInterface{</p><p>}</p><p>了解接口：规范传入参数的类型<br>可选属性：自定义接口属性<br>函数类型：<br>数组类型：<br>Class类型：<br>继承接口与混合类型：</p><p>混合类型</p><p>泛型：<br>class HelloNumber<t>{<br> Ten:T<br> add:(x:T,y:T)=&gt;T;<br>}<br>var myHelloNumber = new </t></p><p>Module模式：<br>1.模块化、可重用<br>2.封装变量和函数</p><p>//闭包<br>(function(){<br>    //内部代码<br>}());</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习TS。是JS的超集。TS类Class。接口Interface。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js</title>
    <link href="http://peilinghui.com/2019/07/18/%E5%AD%A6%E4%B9%A0Node.js/"/>
    <id>http://peilinghui.com/2019/07/18/学习Node.js/</id>
    <published>2019-07-18T10:14:32.000Z</published>
    <updated>2020-02-11T07:36:43.334Z</updated>
    
    <content type="html"><![CDATA[<p>学习一下Node.js。</p><a id="more"></a><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p><p><strong>Nodejs的特点是：</strong></p><ul><li>JavaScript运行环境，相当于js在服务端的一个宿主环境</li><li>依赖于Chrome V8引擎进行代码解释，V8引擎执行Javascript的速度非常快，性能非常好。</li><li>事件驱动</li><li>非阻塞I/O</li><li>轻量、可伸缩，适于实时数据交互应用</li><li>单进程，单线程</li><li>Node提供核心功能模块，使得JavaScript语言可以实现文件的读写、进程管理以及网络通信等功能，在这个意义上，Node又是JavaScript的工具库</li></ul><p><strong>Node.js的应用领域</strong></p><ul><li>项目管理：npm,grunt, gulp,bower, yeoman</li><li>桌面应用: node-webkit</li><li>Web开发：express,ejs,hexo, socket.io, restify, cleaver, stylus, browserify,cheerio</li><li>工具包 underscore,moment,connet,later,log4js,passport,passport(oAuth),domain,require,reap,commander,retry,PDFkit</li><li>数据库：mysql,mongoose,redis,memcached</li><li>异步：async,wind,eventProxy,bluebird</li><li>部署：forever,pm2,nodemon</li><li>测试：jasmine,karma,protractor</li><li>跨平台：rio,tty</li><li>内核：cluster,http,request</li><li>模板: jade</li><li>博客: ghost,hexo</li><li>微信: weui</li><li>硬件控制: NoduinoWeb</li><li>操作系统: NodeOS</li></ul><p><strong>Node.js的优点缺点</strong><br><strong>优点：</strong></p><ul><li>解决并发连接的问题</li></ul><blockquote><p>更改连接到服务器的方式，每个连接发射（emit）一个在NodeJS引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的OS线程（并为其分配一些配套内存）。</p></blockquote><ul><li>解决I/O阻塞的问题<br>业务场景：需要从多个数据源拉取数据，然后进行处理，处理的方式有：</li></ul><ol><li>串行获取数据，这是我们一般的解决方案</li><li>NodeJS非阻塞I/O，是通过发射/监听事件来控制执行过程<br>NodeJS遇到I/O事件会创建一个线程去执行，然后主线程会继续往下执行，事件代理接收到线程后继续往下执行后面的逻辑，这就是NodeJS非阻塞I/O的特点。</li></ol><p><strong>缺点：</strong><br>匿名函数，使得抛出的异常不易阅读。try/catch使得异常捕获较为复杂。单线程的可靠性。不适合CPU密集型的场景。</p><p><strong>总结：</strong>  </p><ul><li>Nodejs具有处理高并发的能力（最重要的优点）</li><li>Nodejs适合I/O密集型应用</li><li>Nodejs不适合CPU密集型应用；<br>CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起；<br>解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；或者使用第三方模块，让Node也可以创建多进程。</li></ul><p>Node.js的特点：<br>1.部署简单方便<br>2.事件驱动：根据当前出现的事件，调用资源进行相关的处理。<br>3.异步编程：回调函数，事件监听，发布/订阅模式，<br>4.高效与性能：<br>5.单线程与多线程<br>6.可以解析JS代码，提供系统级别的API：文件的读写，线程的管理，网络通信</p><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><ul><li>express的安装：npm install express –save<br>expressjs的基础<br>expressjs的初始化配置<br>expressjs的路由<br>expressjs的返回响应</li><li>从Request—中间件—URL—-response<br>中间件MiddleWare：app.use  app.get  app.post<br>request:req.params  req.query  req.body<br>response: res.send() next()</li></ul><ol><li><p>使用express返回HTML内容</p><ul><li>Content-Type：text/html</li><li>fs.createReadStream(‘xxx.html’).pipe(res)</li><li>res.render()</li></ul></li><li><p>模板引擎：–复用HTML组件，简化开发流程</p><ul><li>app.set(‘view’, ‘ejs’)</li><li>res.render(‘home.ejs’, {title: ‘ejs template’}) </li></ul></li><li><p>使用app.set来设置express实例所使用的模板引擎</p></li><li>前后端共用模板</li></ol><h2 id="KOA"><a href="#KOA" class="headerlink" title="KOA"></a>KOA</h2><ol><li>简介<br><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">https://github.com/koajs/koa</a><br>Express的扩展。更小，更健壮的Web框架。组合不同的generator可以免除重复繁琐的回调函数的嵌套。提供了轻量优雅的函数库。<br>教程：<a href="https://chenshenhai.github.io/koa2-note/note/start/async.html" target="_blank" rel="noopener">https://chenshenhai.github.io/koa2-note/note/start/async.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023025933764960</a></li><li>应用</li></ol><ol start="3"><li>Request和Response</li><li>Content上下文</li></ol><h2 id="Mac下升级Node-js"><a href="#Mac下升级Node-js" class="headerlink" title="Mac下升级Node.js"></a>Mac下升级Node.js</h2><p>node有一个专门管理node.js版本的包叫作：n(没错，就是一个字母n)，mac下升级步骤如下：</p><ul><li>查看当前 node版本：</li></ul><p><code>$ node -v</code></p><ul><li>清除node缓存：</li></ul><p><code>$ sudo npm cache clean -f</code></p><ul><li>安装n工具包：</li></ul><p><code>$ sudo npm i -g n</code></p><ul><li>安装最新版node.js</li></ul><p><code>$ sudo n stable</code></p><ul><li>也可以到安装指定版本：(例如升级到10.8.0)</li></ul><p><code>$ sudo n v10.8.0</code></p><ul><li>再次查看本机node版本</li></ul><p><code>$ node -v</code></p><h1 id="Node-js-多进程"><a href="#Node-js-多进程" class="headerlink" title="Node.js 多进程"></a>Node.js 多进程</h1><p>是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p><p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p><p>Node 提供了 child_process 模块来创建子进程，方法有：</p><pre><code>exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。spawn - child_process.spawn 使用指定的命令行参数创建新进程。fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(&apos;./son.js&apos;) 相当于 spawn(&apos;node&apos;, [&apos;./son.js&apos;]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</code></pre><h1 id="node连接mongodb"><a href="#node连接mongodb" class="headerlink" title="node连接mongodb"></a>node连接mongodb</h1><p>cnpm install mongodb</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><ol><li>Express Command not found<br> 最初操作：<code>npm install -g express</code>,安装好了，<code>express --help</code>或者<code>express Demo</code>就出现上面的原因了。<br> 解决方法：在安装一个包<code>npm install -g express-generator</code><br> 原因：express3+已经把创建一个APP的功能分离出来为express-generator，没它你创建不了应用程序</li></ol><p>总结：<br>其实简单入门式用express ejs模板步骤如下</p><pre><code>npm install -g express &amp;&amp; npm install -g express-generatorexpress -e microblogcd microblog &amp; make installnpm start浏览器访问localhost:3000</code></pre><h1 id="Node-的版本问题"><a href="#Node-的版本问题" class="headerlink" title="Node 的版本问题"></a>Node 的版本问题</h1><p>目前主流的node版本管理工具有两种，nvm和n。两者差异挺大的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>brew install nvm</code></p><h3 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h3><pre><code>nvm install &lt;version&gt; ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4nvm uninstall &lt;version&gt; ## 删除已安装的指定版本，语法与install类似nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm ls ## 列出所有安装的版本nvm ls-remote ## 列出所以远程服务器的版本（官方node version list）nvm current ## 显示当前的版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包</code></pre><h3 id="安装路径"><a href="#安装路径" class="headerlink" title="安装路径"></a>安装路径</h3><p>从官网或者自己系统安装路径：/usr/local/bin/node<br>通过nvm安装的路径/Users/peilinghui/.nvm/versions/node/v8.3.0/bin/n</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习一下Node.js。&lt;/p&gt;
    
    </summary>
    
      <category term="NodeJS" scheme="http://peilinghui.com/categories/NodeJS/"/>
    
    
  </entry>
  
  <entry>
    <title>RN性能优化总结</title>
    <link href="http://peilinghui.com/2019/05/22/RN%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2019/05/22/RN性能优化总结/</id>
    <published>2019-05-22T13:53:04.000Z</published>
    <updated>2019-12-02T08:02:36.414Z</updated>
    
    <content type="html"><![CDATA[<p>RN的性能优化<br><a id="more"></a></p><p>RN开发，遇到的问题：</p><blockquote><ol><li>打包出来的JSBundle过大；</li><li>首次进入RN页面加载缓慢；</li><li>稳定性不够，有大量因为RN导致的crash；</li><li>大数据量时候listview加载卡顿；</li></ol></blockquote><p> 对于1，可以进行bundle拆包。</p><h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><p>更新阶段的生命周期</p><pre><code>componentWillReceiveProps(object nextProps)：当挂载的组件接收到新的props时被调用。此方法应该被用于比较this.props 和 nextProps以用于使用this.setState()执行状态转换。（组件内部数据有变化，使用state，但是在更新阶段又要在props改变的时候改变state，则在这个生命周期里面）shouldComponentUpdate(object nextProps, object nextState)： -boolean 当组件决定任何改变是否要更新到DOM时被调用。作为一个优化实现比较this.props 和 nextProps 、this.state 和 nextState ，如果React应该跳过更新，返回false。componentWillUpdate(object nextProps, object nextState)：在更新发生前被立即调用。你不能在此调用this.setState()。componentDidUpdate(object prevProps, object prevState)： 在更新发生后被立即调用。（可以在DOM更新完之后，做一些收尾的工作）</code></pre><blockquote><p>  Tips: React的优化是基于shouldComponentUpdate的，该生命周期默认返回true，所以一旦prop或state有任何变化，都会引起重新render。</p></blockquote><h2 id="React官方的解决方案"><a href="#React官方的解决方案" class="headerlink" title="React官方的解决方案"></a>React官方的解决方案</h2><p>PureRenderMixin(es5)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">'react-addons-pure-render-mixin'</span>);</span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin],</span><br><span class="line"></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;this.props.className&#125;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Shallow Compare (es6)</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shallowCompare = require(<span class="symbol">'react</span>-addons-shallow-compare');</span><br><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">SampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    <span class="keyword">return</span> shallowCompare(<span class="keyword">this</span>, nextProps, nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;<span class="keyword">this</span>.props.className&#125;&gt;foo&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es7装饰器的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pureRender <span class="keyword">from</span> <span class="string">"pure-render-decorator"</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@pureRender</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>  <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"我re-render了"</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123;name,age&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;span&gt;姓名:<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">          &lt;span&gt;&#123;name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;span&gt; age:&lt;/</span>span&gt;</span><br><span class="line">          &lt;span&gt;&#123;age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>immutable.js</p><p>Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p><p>【在react中使用immutable】改变shouldComponentUpdate的重新渲染规则（1）防止每次setState或传递props，即使state和props的值没有发生改变也重新渲染组件，带来无谓的性能消耗（2）防止浅比较带来的比较误差问题，以及深比较带来的性能消耗问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RN的性能优化&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习Dva</title>
    <link href="http://peilinghui.com/2019/04/11/%E5%AD%A6%E4%B9%A0Dva/"/>
    <id>http://peilinghui.com/2019/04/11/学习Dva/</id>
    <published>2019-04-11T02:11:03.000Z</published>
    <updated>2019-04-11T02:53:52.840Z</updated>
    
    <content type="html"><![CDATA[<p>dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。</p><a id="more"></a><h1 id="Dva-概念"><a href="#Dva-概念" class="headerlink" title="Dva 概念"></a>Dva 概念</h1><p>dva = React-Router + Redux + Redux-saga</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dva <span class="keyword">from</span> <span class="string">'dva'</span>;</span><br><span class="line">const App = <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Hello dva&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 创建应用</span><br><span class="line">const app = dva();</span><br><span class="line"><span class="regexp">//</span> 注册视图</span><br><span class="line">app.router(<span class="function"><span class="params">()</span> =&gt;</span> &lt;App /&gt;);</span><br><span class="line"><span class="regexp">//</span> 启动应用</span><br><span class="line">app.start(<span class="string">'#root'</span>);</span><br></pre></td></tr></table></figure><ul><li>State：一个对象，保存整个应用状态</li><li>View：React 组件构成的视图层</li><li>Action：一个对象，描述事件</li><li>connect 方法：一个函数，绑定 State 到 View</li><li>dispatch 方法：一个函数，发送 Action 到 State</li></ul><p>改变数据的时候可以通过 dispatch 发起一个 action,<br>同步行为:直接通过 Reducers 改变 State ，异步行为:会先触发 Effects 然后流向 Reducers 最终改变 State.</p><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><h3 id="State-是储存数据的地方，收到-Action-以后，会更新数据。"><a href="#State-是储存数据的地方，收到-Action-以后，会更新数据。" class="headerlink" title="State : 是储存数据的地方，收到 Action 以后，会更新数据。"></a>State : 是储存数据的地方，收到 Action 以后，会更新数据。</h3><p><code>type State = any</code><br>表示 Model 的状态数据</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>type AsyncAction = any</code></p><p>Action 是一个普通 javascript 对象，它是改变 State 的唯一途径。无论是从 UI 事件、网络回调，还是 WebSocket 等数据源所获得的数据，最终都会通过 dispatch 函数调用一个 action，从而改变对应的数据。action 必须带有 type 属性指明具体的行为，其它字段可以自定义，如果要发起一个 action 需要使用 dispatch 函数；需要注意的是 dispatch 是在组件 connect Models以后，通过 props 传入的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'add'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="connect-绑定-State-到-View"><a href="#connect-绑定-State-到-View" class="headerlink" title="connect:绑定 State 到 View"></a>connect:绑定 State 到 View</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; connect &#125; <span class="keyword">from</span> 'dva';</span><br><span class="line"></span><br><span class="line">function mapStateToProps(<span class="keyword">state</span>) &#123;</span><br><span class="line">  return &#123; todos: <span class="keyword">state</span>.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line">connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure><p>mapStateToProps 函数会返回一个对象，用于建立 State 到 Props 的映射关系。</p><h3 id="dispatch-函数：用来将-Action-发送给-State。"><a href="#dispatch-函数：用来将-Action-发送给-State。" class="headerlink" title="dispatch 函数：用来将 Action 发送给 State。"></a>dispatch 函数：用来将 Action 发送给 State。</h3><p><code>type dispatch = (a: Action) =&gt; Action</code></p><p>dispatching function 是一个用于触发 action 的函数，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">dispatch</span>(&#123;</span><br><span class="line">  <span class="attribute">type</span>: <span class="string">'user/add'</span>, <span class="comment">// 如果在 model 外调用，需要添加 namespace</span></span><br><span class="line">  <span class="attribute">payload</span>: &#123;&#125;, <span class="comment">// 需要传递的信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S</p><p>Reducer（也称为 reducing function）函数接受两个参数：之前已经累积运算的结果和当前要被累积的值，返回的是一个新的累积结果。该函数把一个集合归并成一个单值。</p><h3 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h3><p>Effect 被称为副作用，在我们的应用中，最常见的就是异步操作。它来自于函数编程的概念，之所以叫副作用是因为它使得我们的函数变得不纯，同样的输入不一定获得同样的输出。计算以外的操作都属于 Effect，典型的就是 I/O 操作、数据库读写。Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。<br>dva 提供多个 effect 函数内部的处理函数，比较常用的是 call 和 put。</p><ul><li>call：执行异步函数</li><li>put：发出一个 Action，类似于 dispatch</li></ul><p>dva 为了控制副作用的操作，底层引入了redux-sagas做异步流程控制，由于采用了generator的相关概念，所以将异步转成同步写法，从而将effects转为纯函数。至于为什么我们这么纠结于 纯函数，如果你想了解更多可以阅读Mostly adequate guide to FP，或者它的中文译本JS函数式编程指南。</p><h3 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h3><p>Subscriptions 是一种从 源 获取数据的方法，它来自于 elm。</p><p>Subscription 语义是订阅，用于订阅一个数据源，然后根据条件 dispatch 需要的 action。数据源可以是当前的时间、服务器的 websocket 连接、keyboard 输入、geolocation 变化、history 路由变化等等。</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>这里的路由通常指的是前端路由，由于我们的应用现在通常是单页应用，所以需要前端代码来控制路由逻辑，通过浏览器提供的 History API 可以监听浏览器url的变化，从而控制路由相关操作。</p><p>dva 实例提供了 router 方法来控制路由，使用的是react-router。</p><h1 id="通信：组件之间如何通信？"><a href="#通信：组件之间如何通信？" class="headerlink" title="通信：组件之间如何通信？"></a>通信：组件之间如何通信？</h1><ul><li>向子组件发消息</li><li>向父组件发消息</li><li>向其他组件发消息</li></ul><h1 id="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"><a href="#数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等" class="headerlink" title="数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等"></a>数据流：数据如何和视图串联起来？路由和数据如何绑定？如何编写异步逻辑？等等</h1><p>目前流行的数据流方案有：</p><ul><li>Flux，单向数据流方案，以 Redux 为代表</li><li>Reactive，响应式数据流方案，以 Mobx 为代表</li><li>其他，比如 rxjs 等</li><li>最流行的社区 React 应用架构方案如下。</li></ul><p>路由： React-Router<br>架构： Redux<br>异步操作： Redux-saga</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于RN的热更新</title>
    <link href="http://peilinghui.com/2019/03/07/%E5%85%B3%E4%BA%8ERN%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://peilinghui.com/2019/03/07/关于RN的热更新/</id>
    <published>2019-03-07T09:46:13.000Z</published>
    <updated>2019-08-21T03:09:33.408Z</updated>
    
    <content type="html"><![CDATA[<p>写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题</p><a id="more"></a><p>在APPDelegate中加载RN，一般的加载方式是：<br><code>RCTRootView *rootView= [[RCTRootView alloc] initWithBundleURL:jsCodeLocation                                                   moduleName:@&quot;authen_native&quot;                                            initialProperties:nil                                               launchOptions:nil];</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(instancetype)</span>initWithBundleURL:<span class="params">(NSURL *)</span>bundleURL</span><br><span class="line">                       moduleName:<span class="params">(NSString *)</span>moduleName</span><br><span class="line">                initialProperties:<span class="params">(NSDictionary *)</span>initialProperties</span><br><span class="line">                    launchOptions:<span class="params">(NSDictionary *)</span>launchOptions;</span><br></pre></td></tr></table></figure><p>但在调试中发现两个现象：<br>1.重复进入react-native页面、退出react-native页面的操作，RCTBridge对象会被重复创建、销毁。有时候RCTBridge对象未能及时创建还会crash<br>2.在原生页面和react-native页面相互跳转是RCTBridge也会被重复创建，造成很大的内存开销</p><p>阅读RCTRootView.h发现一些细节:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Convenience initializer -</span></span><br><span class="line"><span class="comment"> * A bridge will be created internally.</span></span><br><span class="line"><span class="comment"> * This initializer is intended to be used when the app has a single RCTRootView,</span></span><br><span class="line"><span class="comment"> * otherwise create an `RCTBridge` and pass it in via `initWithBridge:moduleName:`</span></span><br><span class="line"><span class="comment"> * to all the instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBundleURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">bundleURL</span></span><br><span class="line">                       <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">                <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span></span><br><span class="line">                    <span class="selector-tag">launchOptions</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">launchOptions</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Designated initializer -</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBridge</span><span class="selector-pseudo">:(RCTBridge</span> *)<span class="selector-tag">bridge</span></span><br><span class="line">                    <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">             <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span> <span class="selector-tag">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><h2 id="initWithBundleURL与initWithBridge的区别"><a href="#initWithBundleURL与initWithBridge的区别" class="headerlink" title="initWithBundleURL与initWithBridge的区别"></a>initWithBundleURL与initWithBridge的区别</h2><p>对于项目中只有一个RCTRootView的时候建议initWithBundleURL的方法，这个方法内部创建了一个RCTBridge.</p><p>而有多个RCTRootView的情况，建议initWithBridge的方法.开发者直接创建RCTBridge，多个RCTRootView可共用一个RCTBridge。</p><h1 id="RN版本升级更新"><a href="#RN版本升级更新" class="headerlink" title="RN版本升级更新"></a>RN版本升级更新</h1><p>项目中使用多个RCTRootView，推荐使用以下方法initWithBridge初始化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">_bridge</span> <span class="string">=</span> <span class="string">[[RCTBridge</span> <span class="string">alloc]</span> <span class="attr">initWithBundleURL:[SDRrectFileOption</span> <span class="attr">SetFileWithOption:self.luanchOption]</span></span><br><span class="line"><span class="attr">                                  moduleProvider:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                                   launchOptions:</span><span class="string">self.luanchOption];</span></span><br><span class="line"><span class="string">RCTRootView</span> <span class="meta">*rootView</span> <span class="string">=</span> <span class="string">[[RCTRootView</span> <span class="string">alloc]</span> <span class="attr">initWithBridge:_bridge</span></span><br><span class="line"><span class="attr">                                                   moduleName:</span><span class="string">@"authen_native"</span></span><br><span class="line"><span class="attr">                                            initialProperties:</span><span class="string">nil];</span></span><br></pre></td></tr></table></figure><p>在SDRrectFileOption中返回的是jsbundle的地址。在这个文件中可以使用NSFileManager来把jsbundle缓存到本地。但是如果是新版本的RN比如0.57要替换老版本的比如0.54的APP覆盖更新的话，记得要对比版本号，然后把缓存里面的jsbundle清除掉再返回新的jsbundle地址。不然会导致crash。</p><h1 id="RN的热更新"><a href="#RN的热更新" class="headerlink" title="RN的热更新"></a>RN的热更新</h1><p>在APPdelegate的didFinishLaunchingWithOptions方法中来判断是否需要Update。在Update方法中如果需要强制更新的话就就把RCTBridge调用reload方法进行热更新—和初始化使用的是同一个bridge。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>checkUpdate &#123;</span><br><span class="line">  <span class="keyword">patch</span>Class *<span class="keyword">patch</span> = [<span class="keyword">patch</span>Class sharedInstance];</span><br><span class="line">  [<span class="keyword">patch</span> checkUpdate];</span><br><span class="line">  <span class="keyword">patch</span>.IS_COERCIVE = ^<span class="params">(NSURL *newPath)</span> &#123;</span><br><span class="line">    <span class="string">//</span>是强制更新的话，就把RCTBridge调用<span class="keyword">reload</span>方法进行热更新</span><br><span class="line">    [_bridge <span class="keyword">reload</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在patchClass中使用的是单例，在这个里面通过接口判断是否需要热更还是强制更新，是只更新jsbundle还是整包更新，下载文件，把下载的压缩文件解压缩，如果缓存里面有文件先删除旧的jsbundle再保存，</p><h1 id="解决白屏问题"><a href="#解决白屏问题" class="headerlink" title="解决白屏问题"></a>解决白屏问题</h1><p>使用单例初始化一个bridge对象解决上述问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeManager</span>: <span class="title">RCTBridge</span></span></span><br><span class="line"></span><br><span class="line">+ (BridgeManager*)shareInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeHandle</span> : <span class="title">NSObject</span>&lt;<span class="title">RCTBridgeDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line">implementation MallBridgeHandle</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)sourceURLForBridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"index.ios"</span> withExtension:<span class="string">@"jsbundle"</span>];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BridgeManager</span></span></span><br><span class="line"><span class="keyword">static</span> BridgeManager * manager = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">+ (BridgeManager*)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        manager = [BridgeManager alloc] initWithDelegate:[[BridgeHandle alloc] init] launchOptions:<span class="literal">nil</span>]; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>单例在程序启动时初始化。<br>测试验证可以发现：内存得到优化，白屏问题得到解决。</p><h1 id="桥接原生模块"><a href="#桥接原生模块" class="headerlink" title="桥接原生模块"></a>桥接原生模块</h1><p>首先我们需要创建一个类，然后导入头文件 #import &lt;RCTBridgeModule.h&gt; ,这个类需要实现 RCTBridgeModule 协议。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;RCTBridgeModule.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RNTestManager</span> : <span class="title">NSObject</span> &lt;<span class="title">RCTBridgeModule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>模块名字</strong></p><p>在类的实现部分，需要包含 RCT_EXPORT_MODULE() 宏，这个宏也可以添加一个参数用来指定在 JS 中访问这个模块的名字。如果你不指定，默认就会使用这个 OC 类的名字。</p><p><strong><em>导出方法</em></strong></p><p>RCT_EXPORT_METHOD()，导出到 JS 的方法名是 OC 的方法名的第一个部分，桥接到 JS 的方法返回值类型必须是 void。<strong>RN 的桥接操作是异步的</strong>，所以如果要返回结果给 JS，你必须通过回调或者触发事件来进行。传入的参数类型有以下几种：</p><p>string (NSString)<br>number (NSInteger, float, double, CGFloat, NSNumber)<br>boolean (BOOL, NSNumber)<br>array (NSArray) 包含本列表中任意类型<br>object (NSDictionary) 包含string类型的键和本列表中任意类型的值<br>function (RCTResponseSenderBlock)</p><p><strong>回调函数</strong><br>RCT_EXPORT_METHOD(RNInvokeOCPromise:(NSDictionary *)dictionary resolver:(RCTPromiseResolveBlock)resolve<br>                  rejecter:(RCTPromiseRejectBlock)reject){<br>}<br>桥接原生方法的最后两个参数是RCTPromiseResolveBlock 和RCTPromiseRejectBlock的话，则对应的JS方法就会返回一个Promise对象。</p><p><strong>设置原生模块执行操作的线程</strong><br>如果你在原生模块中需要更改 UI 或者必须在主线程的话，可以实现 </p><p><code>- (dispatch_queue_t)methodQueue 方法</code></p><p><code>- (dispatch_queue_t)methodQueue {    return dispatch_get_main_queue();}</code></p><h2 id="RN使用原生的View"><a href="#RN使用原生的View" class="headerlink" title="RN使用原生的View"></a>RN使用原生的View</h2><p>import入UIView+React.h文件，，原生视图都需要被一个RCTViewManager的子类来创建和管理。这些管理器在功能上有些类似“视图控制器”，但它们本质上都是单例 —— React Native只会为每个管理器创建一个实例。步骤：</p><ol><li>创建一个子类</li><li>添加 RCT_EXPORT_MODULE()标记宏</li><li>实现 -(UIView *)view 方法</li></ol><h3 id="创建一个子类"><a href="#创建一个子类" class="headerlink" title="创建一个子类"></a>创建一个子类</h3><p>该组件有回调需要处理，这里即必须用到 RCTDirectEventBlock 或者 RCTBubblingEventBlock，而且命名的时候要特别注意，需要已 on 开头，熟悉 JS 的朋友应该会反应过来，这很像 JS 的事件命名规范。</p><p><code>@property (nonatomic, copy) RCTBubblingEventBlock onValueChange;</code><br><code>@property (nonatomic, copy) RCTBubblingEventBlock onSlidingComplete;</code></p><h3 id="在自定义ViewManager中"><a href="#在自定义ViewManager中" class="headerlink" title="在自定义ViewManager中"></a>在自定义ViewManager中</h3><ol><li>初始化子View</li><li>添加 RCT_EXPORT_MODULE()标记宏<br>添加TYRCBarChartViewManager 来管理TYRCBarChartView。这个TYRCBarChartViewManager : 继承自RCTViewManager。 RCTViewManager 实现 RCTBridgeModule 协议。</li><li>自定义属性RCT_CUSTOM_VIEW_PROPERTY</li><li>自定义方法RCT_EXPORT_METHOD(refresh){<br> [_barView refreshData];<br>}<br>RCT_CUSTOM_VIEW_PROPERTY(name, type, viewClass)，完整的属性定义为</li></ol><h3 id="给JS发送事件使用-eventDispatcher"><a href="#给JS发送事件使用-eventDispatcher" class="headerlink" title="给JS发送事件使用 eventDispatcher"></a>给JS发送事件使用 eventDispatcher</h3><p>   [self.rootView.bridge.eventDispatcher sendAppEventWithName:@”deviceLocalStateChange”<br>                                                          body:@{@”state”:state}];</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ios2.1大礼包被拒经验分享<a href="https://zhuanlan.zhihu.com/p/54042709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54042709</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题&lt;/p&gt;
    
    </summary>
    
      <category term="RN" scheme="http://peilinghui.com/categories/RN/"/>
    
    
  </entry>
  
  <entry>
    <title>Mac获取ipa方法</title>
    <link href="http://peilinghui.com/2019/02/02/Mac%E8%8E%B7%E5%8F%96ipa%E6%96%B9%E6%B3%95/"/>
    <id>http://peilinghui.com/2019/02/02/Mac获取ipa方法/</id>
    <published>2019-02-02T05:46:05.000Z</published>
    <updated>2019-02-02T05:53:34.025Z</updated>
    
    <content type="html"><![CDATA[<p>从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。<br>新的方法。</p><a id="more"></a><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p> Apple Configurator 2   Mac appstore下载即可<br>登录appleId</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><ol><li>在Appstore下载相关App（以XX为例）到iPhone或iPad上;</li><li>打开 Apple Configurator 2</li><li>选中连接Mac的移动设备后，点击 Apple Configurator 2 工具菜单 ”添加“ –&gt; 应用；</li><li>搜索app-xx，选中，点击右下角添加，等待添加完成(如下图)；</li><li>不要操作  Apple Configurator 2,切换到桌面;</li><li>快捷键：command + shift + G 或者在Finder 中前往文件夹…</li><li>输入路径：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</li><li>拷贝出 上述路径中的ipa文件，之后在 Apple Configurator 2 工具的弹框中点击停止，即可；<br>zhifubao<br>done</li></ol></blockquote><h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><ol><li>修改上述获取的ipa文件，修改后缀名 ipa –&gt;zip;</li><li>解压zip文件，在完成的文件夹中打开Payload 文件夹，即可看到应用xx宝应用程序；</li><li>选中该应用程序，右键显示包内容即可查看图片资源等；</li></ol><h3 id="获取图片资源"><a href="#获取图片资源" class="headerlink" title="获取图片资源"></a>获取图片资源</h3><ol><li>找到包内容中的 Assets.car 文件；</li><li>打开 “Assets提取工具”，导入 Assets.car 文件，添加到处文件夹，点击提取即可获取；</li></ol><p>参考资料:</p><ol><li>Mac获取ipa和相关资源</li><li>Assets提取工具<a href="https://github.com/pcjbird/AssetsExtractor" target="_blank" rel="noopener">https://github.com/pcjbird/AssetsExtractor</a></li></ol><p>微信分享二维码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。&lt;br&gt;新的方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS逆向</title>
    <link href="http://peilinghui.com/2019/02/01/%E5%AD%A6%E4%B9%A0iOS%E9%80%86%E5%90%91/"/>
    <id>http://peilinghui.com/2019/02/01/学习iOS逆向/</id>
    <published>2019-02-01T02:26:24.000Z</published>
    <updated>2019-07-19T03:48:10.635Z</updated>
    
    <content type="html"><![CDATA[<p>从现有APP实现细节的过程.</p><a id="more"></a><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>壳是应用程序加密保护的一种方式，在APP Store上的应用程序都是有加密保护的。<br>查看是否加壳：<br><code>otool -l 可执行文件 | grep cryptid</code><br>例如：<code>localhost:ivwen.app peilinghui$ otool -l ivwen | grep cryptid        cryptid 1</code><br>    如果是1表示是加密的.0表示脱壳的。<br>查看架构：<br><code>lipo -info WeChat</code><br><code>Non-fat file: WeChat is architecture: arm64</code></p><h3 id="1-砸壳工具"><a href="#1-砸壳工具" class="headerlink" title="1. 砸壳工具"></a>1. 砸壳工具</h3><h4 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a>dumpdecrypted</h4><p><a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">https://github.com/stefanesser/dumpdecrypted</a><br>去 Github 下载 dumpdecrypted 源码, 源码就一个 C 源文件.下载 zip 包之后, 解压.在当前目录, 执行 make 即可完成编译,编译成功后生成 dumpdecrypted.dylib 文件.<br>iOS 逆向: dumpdecrypted 砸壳记<a href="http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/" target="_blank" rel="noopener">http://www.veryitman.com/2018/06/07/iOS-%E9%80%86%E5%90%91-dumpdecrypted-%E7%A0%B8%E5%A3%B3%E8%AE%B0/</a></p><h4 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a>Clutch</h4><p><a href="https://github.com/KJCracks/Clutch/releases" target="_blank" rel="noopener">https://github.com/KJCracks/Clutch/releases</a></p><h3 id="2-监控工具"><a href="#2-监控工具" class="headerlink" title="2.监控工具"></a>2.监控工具</h3><p>通过监控，可以获取界面的变化，文件的读取，网络的传输。</p><h4 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h4><p>对于去壳的应用可以得到所有类的头文件<br><a href="https://github.com/nygard/class-dump" target="_blank" rel="noopener">https://github.com/nygard/class-dump</a></p><h4 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h4><p><a href="https://revealapp.com/" target="_blank" rel="noopener">https://revealapp.com/</a><br>得到界面UI，得到响应事件。</p><h4 id="Snoop-it"><a href="#Snoop-it" class="headerlink" title="Snoop-it"></a>Snoop-it</h4><p><a href="https://code.google.com/archive/p/snoop-it/" target="_blank" rel="noopener">https://code.google.com/archive/p/snoop-it/</a></p><h4 id="introspy"><a href="#introspy" class="headerlink" title="introspy"></a>introspy</h4><p><a href="https://github.com/iSECPartners/Introspy-iOS" target="_blank" rel="noopener">https://github.com/iSECPartners/Introspy-iOS</a></p><h3 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h3><p>通过分析二进制文件，生成汇编代码，进而转换成高级语言。</p><h4 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h4><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><h3 id="调试跟踪工具"><a href="#调试跟踪工具" class="headerlink" title="调试跟踪工具"></a>调试跟踪工具</h3><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><h4 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h4><h2 id="程序功能具体实现"><a href="#程序功能具体实现" class="headerlink" title="程序功能具体实现"></a>程序功能具体实现</h2><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="应用代码框架构成"><a href="#应用代码框架构成" class="headerlink" title="应用代码框架构成"></a>应用代码框架构成</h2><h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><h2 id="执行流程参数传递"><a href="#执行流程参数传递" class="headerlink" title="执行流程参数传递"></a>执行流程参数传递</h2><p><code>class-dump -s -S -H WeChat.decrypted -o /Users/lecoding/Desktop/test/WeChatDemo/Headers</code></p><blockquote><p>WeChat.decrypted ： 砸壳后的Mach-o文件路径<br>/Users/lecoding/Desktop/test/WeChatDemo/Headers： 存储头文件目录<br>-s             sort classes and categories by name<br>-S             sort methods by name<br>-H            generate header files in current directory, or directory specified with -o<br>-o            output directory used for -H</p></blockquote><h1 id="iOS系统安全机制"><a href="#iOS系统安全机制" class="headerlink" title="iOS系统安全机制"></a>iOS系统安全机制</h1><p><code>image list -o -f</code>打印出iOS中二进制文件，库文件，动态链接文件，栈和堆内存地址的位置全部都是随机的。</p><h1 id="iOS越狱"><a href="#iOS越狱" class="headerlink" title="iOS越狱"></a>iOS越狱</h1><p>通过一系列iOS系统的漏洞，对系统安全权限进行破解，获取系统Root的权限。<br>引导式越狱，不完美越狱，完美越狱。</p><h2 id="越狱环境的配置"><a href="#越狱环境的配置" class="headerlink" title="越狱环境的配置"></a>越狱环境的配置</h2><h1 id="iOS底层的知识储备"><a href="#iOS底层的知识储备" class="headerlink" title="iOS底层的知识储备"></a>iOS底层的知识储备</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h2 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h2><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h2 id="UI控件的背后代码执行"><a href="#UI控件的背后代码执行" class="headerlink" title="UI控件的背后代码执行"></a>UI控件的背后代码执行</h2><h2 id="整个APP的结构以及构建的过程"><a href="#整个APP的结构以及构建的过程" class="headerlink" title="整个APP的结构以及构建的过程"></a>整个APP的结构以及构建的过程</h2><h3 id="手动打包APP模拟Xcode自动打包的过程"><a href="#手动打包APP模拟Xcode自动打包的过程" class="headerlink" title="手动打包APP模拟Xcode自动打包的过程"></a>手动打包APP模拟Xcode自动打包的过程</h3><h1 id="Hook的原理"><a href="#Hook的原理" class="headerlink" title="Hook的原理"></a>Hook的原理</h1><h2 id="Hook的几种方式"><a href="#Hook的几种方式" class="headerlink" title="Hook的几种方式"></a>Hook的几种方式</h2><h3 id="1-Method-Swizzle—OC"><a href="#1-Method-Swizzle—OC" class="headerlink" title="1.Method Swizzle—OC"></a>1.Method Swizzle—OC</h3><p>通过OC的Runtime机制，改变函数的地址来交换方法实现</p><h3 id="2-fishHook—–C"><a href="#2-fishHook—–C" class="headerlink" title="2.fishHook—–C"></a>2.fishHook—–C</h3><p>通过修改懒加载和非懒加载的表，通过修改表的指针来达到Hook的效果，作用于C函数</p><h3 id="3-Cydia-Substrate（框架）"><a href="#3-Cydia-Substrate（框架）" class="headerlink" title="3.Cydia Substrate（框架）"></a>3.Cydia Substrate（框架）</h3><p>针对OC，C函数，或者是函数地址来做Hook操作</p><h1 id="Theos"><a href="#Theos" class="headerlink" title="Theos"></a>Theos</h1><p><a href="http://codershmily.github.io/2017/04/03/iOS%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8BTheos/" target="_blank" rel="noopener">iOS逆向之Theos基础到实战</a></p><h1 id="iOSOpenDev"><a href="#iOSOpenDev" class="headerlink" title="iOSOpenDev"></a>iOSOpenDev</h1><p>基于Xcode创建模板和编译打包<br><a href="http://iosopendev.com/download/" target="_blank" rel="noopener">http://iosopendev.com/download/</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一条命令完成砸壳<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/" target="_blank" rel="noopener">http://www.alonemonkey.com/2018/01/30/frida-ios-dump/</a><br>书籍：&lt;iOS逆向&gt;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从现有APP实现细节的过程.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode10遇到的问题</title>
    <link href="http://peilinghui.com/2018/11/03/%E5%8D%87%E7%BA%A7Xcode10%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2018/11/03/升级Xcode10遇到的问题/</id>
    <published>2018-11-03T07:59:27.000Z</published>
    <updated>2019-08-21T03:46:11.287Z</updated>
    
    <content type="html"><![CDATA[<p>升级Xcode10遇到的问题以及最近解决的问题。</p><a id="more"></a><p>项目升级到Xcode10 以后报错：</p><h3 id="React-Native-‘config-h’-file-not-found"><a href="#React-Native-‘config-h’-file-not-found" class="headerlink" title="React-Native ‘config.h’ file not found"></a>React-Native ‘config.h’ file not found</h3><p>解决方法：</p><p>cd node_modules/react-native/third-party/glog-0.3.4<br>../../scripts/ios-configure-glog.sh</p><h3 id="Xcode-10-libfishhook-a-cannot-be-found"><a href="#Xcode-10-libfishhook-a-cannot-be-found" class="headerlink" title="Xcode 10 libfishhook.a cannot be found"></a>Xcode 10 libfishhook.a cannot be found</h3><p>解决方法：</p><p>在LIbrary下面的RCTWebSocket中的Target中的Build Phases中的Link Binary With Libraries 中的libfishhook.a文件删了重新导入就好了。</p><h3 id="Multiple-commands-produce"><a href="#Multiple-commands-produce" class="headerlink" title="Multiple commands produce"></a>Multiple commands produce</h3><p>Showing Recent Messages</p><p>2) Target ‘YAORecordProject’ (project ‘YAORecordProject’) has process command with output ‘/Users/peilinghui/Library/Developer/Xcode/DerivedData/YAORecordProject-frlkqcmjttdqtdandttwzrmfhjnt/Build/Products/Debug-iphonesimulator/YAORecordProject.app/Info.plist’</p><p>解决方法：</p><p>This issue might occur just because of multiple Plist/other files within App-<br>Solution -&gt; Open target -&gt; Build phases &gt; Copy Bundle Resources and remove info.plist from there.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级Xcode10遇到的问题以及最近解决的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://peilinghui.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
</feed>
