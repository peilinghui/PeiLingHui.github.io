<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2017-04-14T14:57:56.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自动化测试</title>
    <link href="http://peilinghui.com/2017/02/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://peilinghui.com/2017/02/16/自动化测试/</id>
    <published>2017-02-16T11:17:25.000Z</published>
    <updated>2017-04-14T14:57:56.000Z</updated>
    
    <content type="html">&lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;测试基础&quot;&gt;&lt;a href=&quot;#测试基础&quot; class=&quot;headerlink&quot; title=&quot;测试基础&quot;&gt;&lt;/a&gt;测试基础&lt;/h1&gt;&lt;h2 id=&quot;按测试手段分&quot;&gt;&lt;a href=&quot;#按测试手段分&quot; class=&quot;headerlink&quot; title=&quot;按测试手段分&quot;&gt;&lt;/a&gt;按测试手段分&lt;/h2&gt;&lt;h3 id=&quot;黑盒测试和白盒测试-按可见度分&quot;&gt;&lt;a href=&quot;#黑盒测试和白盒测试-按可见度分&quot; class=&quot;headerlink&quot; title=&quot;黑盒测试和白盒测试(按可见度分)&quot;&gt;&lt;/a&gt;黑盒测试和白盒测试(按可见度分)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;黑盒测试&lt;/strong&gt;&lt;br&gt;黑盒测试主要是通过相关的暴露的接口，接收输入，然后看是否能够输出正确。  &lt;/p&gt;
&lt;p&gt;优点：容易实施，不需要关注内部实现，主要关注的是用户需求。&lt;/p&gt;
&lt;p&gt;缺点：测试覆盖率低，不到40%，自动化测试覆盖率低，维护成本高，&lt;/p&gt;
&lt;p&gt;测试内容：是否有不正确或遗漏的功能？接口上输入是否能正确接受，输出是否能输出正确的结果？性能上是否能满足？&lt;/p&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白盒测试&lt;/strong&gt;&lt;br&gt;内部结构对测试人员透明，用逻辑覆盖率(语句，判断，条件，分支，路径)&lt;/p&gt;
&lt;p&gt;优点：迫使测试人员思考软件的实现，理解原理。&lt;br&gt;可以检测代码的每条分支和路径。揭示隐藏在代码中的错误。对代码的测试比较彻底。&lt;/p&gt;
&lt;p&gt;缺点：昂贵。无法检测代码中遗漏的路径和数据敏感性错误。不能直接验证需求的正确性。&lt;/p&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;h3 id=&quot;静态测试和动态测试&quot;&gt;&lt;a href=&quot;#静态测试和动态测试&quot; class=&quot;headerlink&quot; title=&quot;静态测试和动态测试&quot;&gt;&lt;/a&gt;静态测试和动态测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态测试&lt;/strong&gt;&lt;br&gt;不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程，评审软件文档或代码。只做静态检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态测试&lt;/strong&gt;&lt;br&gt;运行被测试的程序，检查运行结果和预期结果的差异，并分析运行效率和健壮性等性能。这种方法由三部分组成:构造测试实例、执行程序、分析程序癿输出结果。软件的动态测试，就是通过运行软件来检验软件的动态行为和运行结构的正确性。目前，动态测试也是公司的测试工作的主要方式。 根据动态测试在软件开发过程中所处的阶段和作用。动态测试可分为如下几个步骤:1、单元测试 2、集成测试 3、系统测试 4、验收测试 5、回归测试。&lt;br&gt;单元测试：&lt;br&gt;JUnit、OCUnit、GHUnit、GTM&lt;br&gt;集成测试：&lt;br&gt;API接口测试和iOS功能集成测试。&lt;br&gt;系统测试：&lt;/p&gt;
&lt;h3 id=&quot;手工测试和自动化测试&quot;&gt;&lt;a href=&quot;#手工测试和自动化测试&quot; class=&quot;headerlink&quot; title=&quot;手工测试和自动化测试&quot;&gt;&lt;/a&gt;手工测试和自动化测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;手工测试&lt;/strong&gt;&lt;br&gt;测试人员从用户视角来满足设计要求，深度测试和主观判断的测试，分为众包测试和探索式测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化测试&lt;/strong&gt;&lt;br&gt;借助单独的测试工具软件，控制测试的自动化执行以及对预期和结果进行自动检查。主要分为：单元测试，接口测试和性能测试。&lt;/p&gt;
&lt;h2 id=&quot;按测试模式来分类&quot;&gt;&lt;a href=&quot;#按测试模式来分类&quot; class=&quot;headerlink&quot; title=&quot;按测试模式来分类&quot;&gt;&lt;/a&gt;按测试模式来分类&lt;/h2&gt;&lt;p&gt;瀑布模式，敏捷测试，基于脚本的测试，基于风险的测试，探索式测试。&lt;br&gt;&lt;strong&gt;瀑布模型&lt;/strong&gt;&lt;br&gt;项目计划–需求分析–软件设计–程序开发–软件测试–集成维护&lt;/p&gt;
&lt;p&gt;扩展模型：&lt;br&gt;V模型，W 模型、H 模型、X 模型和前置模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏捷测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强调从客户角度，重点关注迭代测试新功能。尽早测试，不间断测试。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;&lt;a href=&quot;#性能测试&quot; class=&quot;headerlink&quot; title=&quot;性能测试&quot;&gt;&lt;/a&gt;性能测试&lt;/h2&gt;&lt;p&gt;负载测试，压力测试和稳定性的测试&lt;/p&gt;
&lt;p&gt;考虑并发用户数(VU)和每秒事务数(TPS)&lt;br&gt;来看系统响应时间和设备的性能。&lt;/p&gt;
&lt;p&gt;测试工具：LoadRunner，&lt;/p&gt;
&lt;h1 id=&quot;ios中自动化测试UI-Automation&quot;&gt;&lt;a href=&quot;#ios中自动化测试UI-Automation&quot; class=&quot;headerlink&quot; title=&quot;ios中自动化测试UI Automation&quot;&gt;&lt;/a&gt;ios中自动化测试UI Automation&lt;/h1&gt;&lt;p&gt;UI Automation不但支持脚本编写方式的自动化测试，还支持录制回放方式的自动化测试，是一款功能强大的自动化测试工具。&lt;br&gt;Instruments工具还自带了UI Automation脚本的录制功能。用户只需开启录制功能，然后在真是的设备或模拟器上进行操作即可。操作的动作会被翻译成自动化脚本显示在脚本的编辑区，等待用户确认。在脚本录制完成以后，可以通过选择来编辑脚本，如果选项中没有我们需要的操作选项，则只能删除手动写脚本。&lt;/p&gt;
&lt;h1 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;headerlink&quot; title=&quot;Selenium&quot;&gt;&lt;/a&gt;Selenium&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SeleniumHQ/selenium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SeleniumHQ/selenium&lt;/a&gt;&lt;br&gt;Web自动化测试中，Selenium是最成熟且应用最广泛的Web自动化测试工具。WebDriver的原理结构：&lt;br&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server&lt;/p&gt;
&lt;p&gt;WebDriver API：这一层表示WebDriver提供给使用者的最外层接口，使用者可以使用这些API进行自动化脚本的编辑。例如：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;diver.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;findElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(By.name(&lt;span class=&quot;string&quot;&gt;&quot;q&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;element.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Json Wire Protocol:是WebDriver的开发者们制定并命名的一种协议，使用REST风格的，并且以Json方法进行传输，协议传输测试脚本需要控制的控件，并且通知Selenium Server。&lt;/p&gt;
&lt;p&gt;Selenium Server：接受Json Wire Protocol协议并且解析，可以控制启动或者停止某一款浏览器，也可以完成对某一个控件的具体操作。&lt;/p&gt;
&lt;h1 id=&quot;Appium&quot;&gt;&lt;a href=&quot;#Appium&quot; class=&quot;headerlink&quot; title=&quot;Appium&quot;&gt;&lt;/a&gt;Appium&lt;/h1&gt;&lt;p&gt;适用于iOS，Android和Windows应用的自动化。&lt;br&gt;GitHub地址：&lt;a href=&quot;https://github.com/appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/appium&lt;/a&gt;&lt;br&gt;API:&lt;a href=&quot;http://appium.io/slate/cn/master/?ruby#about-appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://appium.io/slate/cn/master/?ruby#about-appium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Appium简介&quot;&gt;&lt;a href=&quot;#Appium简介&quot; class=&quot;headerlink&quot; title=&quot;Appium简介&quot;&gt;&lt;/a&gt;Appium简介&lt;/h2&gt;&lt;p&gt;Appium使用WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。  &lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Appium在不同平台中使用了标准的自动化APIs，所以在跨平台时，不需要重新编译或者修改自己的应用。&lt;/li&gt;
&lt;li&gt;Appium支持Selenium WebDriver支持的所有语言，如java、Object-C、JavaScript、Php、Python、Ruby、C#、Clojure，或者Perl语言，更可以使用Selenium WebDriver的Api。Appium支持任何一种测试框架。&lt;br&gt;如果只使用Apple的UIAutomation，我们只能用javascript来编写测试用例，而且只能用Instruction来运行测试用例。&lt;br&gt;如果只使用Google的UIAutomation，我们就只能用java来编写测试用例。Appium实现了真正的跨平台自动化测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;p&gt;提供各个语言的第三方库，将测试脚本转化成 WebDriver 协议下的 URL，通过 Node 服务发送到各个平台上的代理工具，代理工具在运行过程中不断接收 URL，根据 WebDriver 协议解析出要执行的操作，然后调用各个平台上的原生测试框架完成测试，再将测试结果返回给 Node 服务器。&lt;/p&gt;
&lt;p&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server–&amp;gt;UI Automation&lt;/p&gt;
&lt;h2 id=&quot;mac下搭建appium环境&quot;&gt;&lt;a href=&quot;#mac下搭建appium环境&quot; class=&quot;headerlink&quot; title=&quot;mac下搭建appium环境&quot;&gt;&lt;/a&gt;mac下搭建appium环境&lt;/h2&gt;&lt;p&gt;使用node.js实现的，首先确定有没有安装node,可以用HomeBrew安装。再看node解释器是否安装npm,然后下载并启动Appium.&lt;br&gt;参考文章：&lt;a href=&quot;http://www.15yan.com/story/4GbuTwXQKDU/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.15yan.com/story/4GbuTwXQKDU/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-环境搭建Java和Android开发环境&quot;&gt;&lt;a href=&quot;#windows-环境搭建Java和Android开发环境&quot; class=&quot;headerlink&quot; title=&quot;windows 环境搭建Java和Android开发环境&quot;&gt;&lt;/a&gt;windows 环境搭建Java和Android开发环境&lt;/h2&gt;&lt;p&gt;参考书:&lt;a href=&quot;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&lt;/a&gt;&lt;br&gt;英文版：&lt;a href=&quot;https://nishantverma.gitbooks.io/appium-for-android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nishantverma.gitbooks.io/appium-for-android/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS的持续集成&quot;&gt;&lt;a href=&quot;#iOS的持续集成&quot; class=&quot;headerlink&quot; title=&quot;iOS的持续集成&quot;&gt;&lt;/a&gt;iOS的持续集成&lt;/h1&gt;&lt;p&gt;持续集成工具可以对代码库进行监测，一旦发现有代码变动，该工具会自动编译和测试应用程序。如果出现错误，会立即通知开发人员。&lt;/p&gt;
&lt;p&gt;持续集成可以提供更快的反馈，从而降低项目风险。是集成和回归问题更快、更流畅，出现的错误更少。通过部署过程自动化，持续集成可以帮助软件测试人员更快、更可靠地、更省力地搭建测试环境和执行自动化测试。&lt;/p&gt;
&lt;h2 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Jenkins&quot;&gt;&lt;/a&gt;Jenkins&lt;/h2&gt;&lt;p&gt;Jenkins易于安装，不需要数据库的支持，直接通过Web界面进行配置，而且集成了RSS/Email的通知机制，支持分布式构建，具有丰富的插件，这些都是Jenkins相比其他持续集成服务器的优势所在。&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的安装&quot;&gt;&lt;a href=&quot;#Jenkins的安装&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的安装&quot;&gt;&lt;/a&gt;Jenkins的安装&lt;/h3&gt;&lt;p&gt;在Jenkins的官网&lt;a href=&quot;https://jenkins.io/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jenkins.io/index.html&lt;/a&gt;下载war包，并且执行 ‘java -jar jenkins.war’正确配置Java环境。&lt;/p&gt;
&lt;p&gt;mac下直接下载mac版本的Jenkins安装程序&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的相关插件&quot;&gt;&lt;a href=&quot;#Jenkins的相关插件&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的相关插件&quot;&gt;&lt;/a&gt;Jenkins的相关插件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode integration&lt;br&gt;通过对Xcode integration的简单设置，即可完成iOS项目的编译打包，还可以修改iOS应用的Technical Version和Marketing Version。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git Plugin&lt;br&gt;通过Git Plugin，用户可以很方便的下载项目的源代码，不是默认安装，需要用户手动安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Junit test result report&lt;br&gt;是Jenkins默认安装的插件之一。只需指定测试工具生成的XML形式的report文件，插件会自动解析XML，并且以更易查看的方式展现测试结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;a href=&quot;#iOS测试策略以及测试方法&quot; class=&quot;headerlink&quot; title=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;/a&gt;iOS测试策略以及测试方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能测试：根据产品需求、用户的使用场景和代码实现方式等设计测试用例。&lt;/li&gt;
&lt;li&gt;兼容性测试：硬件、软件、数据兼容性。iOS设备的多样化兼容测试&lt;/li&gt;
&lt;li&gt;网络流量的测试：根据不同的网络状况测试，网速，弱网环境的测试。&lt;/li&gt;
&lt;li&gt;升级测试：老版本升级到新版本的测试、&lt;/li&gt;
&lt;li&gt;性能测试：服务器端性能测试。客户端性能测试：大数据测试，显示速度。&lt;/li&gt;
&lt;li&gt;稳定性测试：检测应用程序长期稳定的运行能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Instrument&quot;&gt;&lt;a href=&quot;#Instrument&quot; class=&quot;headerlink&quot; title=&quot;Instrument&quot;&gt;&lt;/a&gt;&lt;strong&gt;Instrument&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;网络流量监测数据，监控电量、监控GPS和WIFI是否开启等状态。丽日：在一些音乐APP和一些FM的APP中是否支持自动同步喜欢的歌曲到设备上。当网络接入点只选择了在WiFi情况下同步，就必须保证用户的流量不被使用。Net Activity运行库图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能测试：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;快速启动测试：用instruments中TimeProfile来分析启动时的CPU消耗，并且以消耗CPU的数据为依据进行优化。&lt;/li&gt;
&lt;li&gt;内存泄露的检查：用Xcode分析（Analyze）代码。静态分析器可以根据经验猜测执行代码后可能发生的情况并报告问题，这些问题中可以存在内存泄露问题。静态分析器在检查代码时会枚举所有的代码路径，分别检查所以的函数和方法。为了看到静态分析的结构，在Recipes项目中可以随意找到几处release或者autorelease的调用项并删除，然后运行静态分析，用Instrument的两个组件来组合查看内存泄露的问题：Allocations和Leaks.&lt;/li&gt;
&lt;li&gt;Allocations：是监控对象调用了alloc方法申请内存以后的内存使用情况，可以记录对象这个生命周期内的内存引用计数的变化，在对象被正常释放后，Allocations 不再继续追踪。Leaks会监控内存泄露，一般和Allocations一起使用，因为在监控到内存泄露时需要定位问题。可以得到详细的内存泄露信息。&lt;/li&gt;
&lt;li&gt;稳定性测试：猴子测试，直接在instruments中运行UI Automation脚本。考虑在一些零界条件下对应用程序进行稳定性测试。考虑：1.频繁收到内存警告。2.电池电量低。3.3G网络不稳定时断时续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;及时响应用户交互和优秀的内存管理。通过测试定位并且解决问题。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;国内首家移动测试的社区网站：&lt;a href=&quot;https://testerhome.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://testerhome.com/&lt;/a&gt;&lt;br&gt;构建基于Jenkins + Github的持续集成环境 &lt;a href=&quot;http://blog.csdn.net/john_cdy/article/details/7738393&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/john_cdy/article/details/7738393&lt;/a&gt;&lt;br&gt;电子书：&lt;a href=&quot;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计读书笔记</title>
    <link href="http://peilinghui.com/2017/02/13/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</id>
    <published>2017-02-13T07:37:24.000Z</published>
    <updated>2017-02-15T12:59:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 JavaScript简介&quot;&gt;&lt;/a&gt;第一章 JavaScript简介&lt;/h1&gt;&lt;p&gt;JavaScript有下列三个不同的部分组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMA-262规定的语言组成部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法
类型
语句
关键字
保留字
操作符
对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DOM：&lt;br&gt;DOM把真个页面映射为一个多层结点结构。&lt;br&gt;DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。&lt;br&gt;DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。&lt;br&gt;DOM3级：以统一方式加载和保存文档的方法。验证文档的方法&lt;br&gt;BOM：&lt;br&gt;处理浏览器窗口和框架。&lt;/p&gt;
&lt;h1 id=&quot;第二章-在HTML中使用JavaScript&quot;&gt;&lt;a href=&quot;#第二章-在HTML中使用JavaScript&quot; class=&quot;headerlink&quot; title=&quot;第二章 在HTML中使用JavaScript&quot;&gt;&lt;/a&gt;第二章 在HTML中使用JavaScript&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;把JavaScript插入到HTML页面中要使用&amp;lt;script&amp;gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&amp;lt;script&amp;gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&amp;lt;script&amp;gt;元素中的代码之后，才会开始解析后面的&amp;lt;script&amp;gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&amp;lt;script&amp;gt;元素中的代码，然后再解析后面的内容，所以一般应该把&amp;lt;script&amp;gt;元素放在页面最后，即主要内容后面，&amp;lt;/body&amp;gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第三章-基本概念&quot;&gt;&lt;a href=&quot;#第三章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本概念&quot;&gt;&lt;/a&gt;第三章 基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript中的函数与其他语言中的函数有诸多不同之处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Undefined类型&lt;/strong&gt;&lt;br&gt;Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Null类型&lt;/strong&gt;&lt;br&gt;Null类型是第二个只有一个值的数据类型，这个特殊值时null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;br&gt;该类型只有两个字面值：true和false。&lt;br&gt;虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; messageAsBoolean&lt;/span&gt; = &lt;span class=&quot;typename&quot;&gt;Boolean&lt;/span&gt;(message);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给出各数据类型及其转换的规则：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alert(isNaN(NaN));              //true&lt;br&gt;alert(isNaN(10));               //false（10是一个数值）&lt;br&gt;alert(isNaN(“10”));             //false（可以被转换成数值10）&lt;br&gt;alert(isNaN(“blue”));           //false（不能被转换成数值）&lt;br&gt;alert(isNaN(true));             //false（可以被转换成数值1）&lt;/p&gt;
&lt;p&gt;有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&amp;quot;name&amp;quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;p&gt;一元操作符&lt;br&gt;递增操作符     ++&lt;br&gt;递减操作符     –&lt;br&gt;一元加操作符     +&lt;br&gt;一元减操作符     -&lt;br&gt;位操作符&lt;br&gt;按位非     NOT(~)&lt;br&gt;按位与     AND(&amp;amp;)&lt;br&gt;按位或     OR(|)     var result=25 | 3;alert(result);//27&lt;br&gt;按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26&lt;br&gt;左移     &amp;lt;&amp;lt;     var oldValue=2;var newValue=oldValue &amp;lt;&amp;lt; 5;//64&lt;br&gt;有符号的右移     &amp;gt;&amp;gt;     var oldValue=64;var newValue=oldValue &amp;gt;&amp;gt; 5;//2&lt;br&gt;无符号的右移     &amp;gt;&amp;gt;&amp;gt;     var oldValue=-64;var newValue=oldValue &amp;gt;&amp;gt;&amp;gt; 5;//134217726&lt;br&gt;布尔操作符&lt;br&gt;逻辑非     !     alert(!false);//true&lt;br&gt;逻辑与     &amp;amp;&amp;amp;     var result=true &amp;amp;&amp;amp; false;//false&lt;br&gt;逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true&lt;br&gt;乘性操作符（略）&lt;br&gt;加性操作符（略）&lt;br&gt;关系操作符（略）&lt;br&gt;条件操作符（略）&lt;br&gt;赋值操作符（略）&lt;br&gt;逗号操作符（略）         &lt;/p&gt;
&lt;p&gt;相等操作符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。&lt;/p&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h1 id=&quot;第四章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第四章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第四章 变量、作用域和内存问题&lt;/h1&gt;&lt;p&gt;JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。&lt;/p&gt;
&lt;h1 id=&quot;第五章-引用类型&quot;&gt;&lt;a href=&quot;#第五章-引用类型&quot; class=&quot;headerlink&quot; title=&quot;第五章 引用类型&quot;&gt;&lt;/a&gt;第五章 引用类型&lt;/h1&gt;&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;p&gt;大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。&lt;br&gt;第一种是使用new操作符后跟Object构造函数，如&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是使用对象字面量表示法，如&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;age :&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert(person[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);              &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);                 &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示方法&lt;/strong&gt;&lt;br&gt;创建数组的基本方式有两种。&lt;br&gt;第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;//空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含三个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含一个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是使用数组字面量表示法。如&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;//创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var names = []&lt;span class=&quot;comment&quot;&gt;;//创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含2或3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var options = [, , , , ,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含5或6项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;&lt;br&gt;数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测数组&lt;/strong&gt;&lt;br&gt;自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。&lt;br&gt;对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;isArray&lt;/span&gt;(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;转换方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toLocaleString() :&lt;br&gt;toString() :&lt;br&gt;valueOf() : &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈方法和队列方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。&lt;/p&gt;
&lt;p&gt;实现栈的方式（LIFO）后进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()： 栈中项插入
pop()：栈中项移除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现队列的方法（FIFO）先进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重排序方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组中已经存在两个可以直接用来重排序的方法：&lt;br&gt;reverse()和sort()方法。&lt;/p&gt;
&lt;p&gt;reverse()方法会反转数组项的顺序。&lt;/p&gt;
&lt;p&gt;默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。&lt;br&gt;另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需将其作为参数传递给sort()方法即可。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values.sort(compare);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(values);  &lt;span class=&quot;comment&quot;&gt;//0, 1, 5, 10, 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;ECMAScript为操作已经包含在数组中的项提供了很多内置方法。&lt;/p&gt;
&lt;p&gt;concat()：&lt;br&gt;该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.concat(&lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);  &lt;span class=&quot;comment&quot;&gt;//red, green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//red, green, blue, yellow, black, brown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;slice()：  &lt;/p&gt;
&lt;p&gt;该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors3&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow, purple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors3);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;splice()：&lt;br&gt;该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var removed = colors.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//删除第一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//red, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orange&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//从位置1开始插入两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, yellow, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//返回的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//插入两项，删除一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, red, purple, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//yellow, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。&lt;br&gt;这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。&lt;/p&gt;
&lt;p&gt;var person = {  name: “Nicholas” };&lt;br&gt;var people = [{ name: “Nicholas” }];&lt;/p&gt;
&lt;p&gt;var morePeople = [person];&lt;/p&gt;
&lt;p&gt;alert(people.indexOf(person));          //-1&lt;br&gt;alert(morePeople.indexOf(person));  //0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上方法都不会修改数组中的包含的值。&lt;/p&gt;
&lt;p&gt;其中，every()和filter()方法最相似。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var everyResult = numbers.every(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(everyResult);     &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var someResult = numbers.some(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(someResult);      &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var filterResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(filterResult);            &lt;span class=&quot;comment&quot;&gt;//[3, 4, 5, 4, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map()可以用来创建包含的项与另一个数组一一对应的项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var mapResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(mapResult);           &lt;span class=&quot;comment&quot;&gt;//[2, 4, 6, 8, 10, 8, 6, 4, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forEach()本质上和使用for循环迭代数组一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers.forEach(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;归并方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。&lt;br&gt;这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。&lt;br&gt;使用reduce()方法可以执行数组中所有值求和操作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var sum = values.reduce(function(prev, cur, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev + cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(sum);     &lt;span class=&quot;comment&quot;&gt;//15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Date类型&quot;&gt;&lt;a href=&quot;#Date类型&quot; class=&quot;headerlink&quot; title=&quot;Date类型&quot;&gt;&lt;/a&gt;Date类型&lt;/h2&gt;&lt;p&gt;创建日期对象，使用new操作符和Date构造函数即可。&lt;/p&gt;
&lt;p&gt;var now = new Date()&lt;/p&gt;
&lt;p&gt;根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。&lt;br&gt;Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式&lt;br&gt;var someDate = new Date(Date.parse(“May 25, 2004”));&lt;/p&gt;
&lt;p&gt;Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。&lt;/p&gt;
&lt;p&gt;//GMT时间2000年1月1日午夜零时&lt;br&gt;var y2k = new Date(Date.UTC(2000, 0));&lt;/p&gt;
&lt;p&gt;//GMT时间2005年5月5日下午5:55:55&lt;br&gt;var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));&lt;/p&gt;
&lt;p&gt;Date类型还有一些专门用于将日期格式化为字符串的方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.&lt;/p&gt;
&lt;h2 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h2&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。&lt;/p&gt;
&lt;p&gt;var expression = / pattern / flags ;&lt;/p&gt;
&lt;p&gt;其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。&lt;br&gt;关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。&lt;br&gt;另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。&lt;/p&gt;
&lt;h2 id=&quot;Function类型&quot;&gt;&lt;a href=&quot;#Function类型&quot; class=&quot;headerlink&quot; title=&quot;Function类型&quot;&gt;&lt;/a&gt;Function类型&lt;/h2&gt;&lt;p&gt;ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数声明与函数表达式&lt;/p&gt;
&lt;p&gt;解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;没有重载！&lt;/strong&gt;&lt;br&gt;由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为返回值的函数&lt;/strong&gt;&lt;br&gt;由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。&lt;br&gt;函数作为返回值是极有用的技术，是“闭包”技术的基础之一。&lt;br&gt;比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction (propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var data = [&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Zachary&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;&amp;#125;, &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据name来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Nicholas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据age来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Zachary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数内部属性（重点）&lt;/strong&gt;&lt;br&gt;在函数内部，有两个特殊的对象：arguments和this。&lt;/p&gt;
&lt;p&gt;arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//与函数名紧紧耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用arguments.callee替代函数名，消除耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * arguments.callee (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; trueFactorial = factorial;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;factorial = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(trueFactiorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));           &lt;span class=&quot;comment&quot;&gt;//120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));                    &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();             &lt;span class=&quot;comment&quot;&gt;//&quot;red&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor = sayColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor();           &lt;span class=&quot;comment&quot;&gt;//&quot;blue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。&lt;/p&gt;
&lt;p&gt;ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数属性和方法（重点）&lt;/strong&gt;&lt;br&gt;ECMAScript中函数是对象，因此也有属性和方法。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。&lt;br&gt;诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//传入arguments对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, [num1, num2]);       &lt;span class=&quot;comment&quot;&gt;//传入数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum1(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum2(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));     &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();                     &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(o);               &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; objectSayColor = sayColor.bind(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectSayColor();           &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2&lt;/span&gt; = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问s1时，访问过程处于读取模式，后台自动完成下列处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上三个步骤可以想象成下列代码&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。&lt;br&gt;引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed()：按指定小数位返回数值的字符串表示。&lt;/li&gt;
&lt;li&gt;toExponential()：返回以指数表示法表示的数值的字符串形式。&lt;/li&gt;
&lt;li&gt;toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符方法&lt;/strong&gt;&lt;br&gt;两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串操作方法&lt;/strong&gt;&lt;br&gt;concat()：&lt;br&gt;用于将一或多个字符串拼接起来，接受任意多个参数。&lt;/p&gt;
&lt;p&gt;slice()、substr()和substring()：&lt;br&gt;这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。&lt;/p&gt;
&lt;p&gt;当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串位置方法&lt;/strong&gt;&lt;br&gt;有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。&lt;br&gt;两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。&lt;br&gt;在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trim()方法&lt;/strong&gt;&lt;br&gt;该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串大小写转换方法&lt;/strong&gt;&lt;br&gt;ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串的模式匹配方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;match()：&lt;br&gt;在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。&lt;/p&gt;
&lt;p&gt;search()：&lt;br&gt;参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。&lt;/p&gt;
&lt;p&gt;replace()：&lt;br&gt;接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。&lt;/p&gt;
&lt;p&gt;split()：&lt;br&gt;该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。&lt;/p&gt;
&lt;p&gt;localeCompare()方法;&lt;br&gt;该方法比较两个字符串，并返回下列值中的一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fromCharCode()方法：&lt;/p&gt;
&lt;p&gt;String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。&lt;/p&gt;
&lt;h2 id=&quot;单体内置对象&quot;&gt;&lt;a href=&quot;#单体内置对象&quot; class=&quot;headerlink&quot; title=&quot;单体内置对象&quot;&gt;&lt;/a&gt;单体内置对象&lt;/h2&gt;&lt;p&gt;除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。&lt;/p&gt;
&lt;h3 id=&quot;Global对象&quot;&gt;&lt;a href=&quot;#Global对象&quot; class=&quot;headerlink&quot; title=&quot;Global对象&quot;&gt;&lt;/a&gt;Global对象&lt;/h3&gt;&lt;p&gt;所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()&lt;br&gt;isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI编码方法&lt;/strong&gt;&lt;br&gt;Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval()方法&lt;/strong&gt;&lt;br&gt;eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。&lt;br&gt;当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：&lt;/p&gt;
&lt;p&gt;var msg = “hello world”;&lt;br&gt;eval(“alert(msg)”);     //“hello world”&lt;/p&gt;
&lt;p&gt;变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Global对象的属性&lt;/strong&gt;&lt;br&gt;Global对象的所有属性：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window对象&lt;/strong&gt;&lt;br&gt;ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。&lt;/p&gt;
&lt;h3 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math()对象&quot;&gt;&lt;/a&gt;Math()对象&lt;/h3&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Math对象的属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Math对象的方法&lt;/strong&gt;&lt;br&gt;min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.&lt;br&gt;Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。&lt;br&gt;Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//选择一个介于2到10之间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var num = Math.&lt;span class=&quot;built_in&quot;&gt;floor&lt;/span&gt;(Math.random() * &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下函数可以直接指定随机范围（整数）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectFrom&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lowerValue, upperValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; choices = upperValue - lowerValue +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() * choices + lowerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = selectFrom(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(num);     &lt;span class=&quot;comment&quot;&gt;//介于2和10之间（包括2和10）的一个数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.abs(num)     返回num的绝对值&lt;br&gt;Math.asin(x)     返回x的反正弦值&lt;br&gt;Math.exp(num)     返回Math.E的num次幂&lt;br&gt;     Math.atan(x)     返回x的反正切值&lt;br&gt;Math.log(num)     返回num的自然对数&lt;br&gt;Math.atan2(y,x)     返回y/x的反正切值&lt;br&gt;Math.pow(num, power)     返回num的power次幂&lt;br&gt;Math.cos(x)     返回x的余弦值&lt;br&gt;Math.sqrt(num)     返回num的平方根&lt;br&gt;Math.sin(x)     返回x的正弦值&lt;br&gt;Math.acos(x)     返回x的反余弦值&lt;br&gt;Math.tan(x)     返回x的正切值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第六章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h3&gt;&lt;p&gt;ECMAScript中有两种属性：数据属性和访问器属性。&lt;br&gt;&lt;strong&gt;数据属性&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。&lt;br&gt;要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：&lt;br&gt;注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//抛出错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问器属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。&lt;br&gt;访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; book = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _year: &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edition: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(book, &lt;span class=&quot;string&quot;&gt;&quot;year&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.edition += newValue - &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;book.year = &lt;span class=&quot;number&quot;&gt;2005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(book.edition);        &lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一个属性的值会导致其他属性发生变化。&lt;br&gt;注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义多个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取属性的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。&lt;/p&gt;
&lt;p&gt;注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。&lt;/p&gt;
&lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;构造函数模式&quot;&gt;&lt;a href=&quot;#构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式&quot;&gt;&lt;/a&gt;构造函数模式&lt;/h3&gt;&lt;p&gt;像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age, job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;br&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。&lt;br&gt;创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将构造函数当做函数&lt;/strong&gt;&lt;br&gt;任何函数，只要通过new操作符来调用，那它就可以作为构造函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数的问题&lt;/strong&gt;&lt;br&gt;构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.&lt;/p&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;br&gt;创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。&lt;br&gt;如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。&lt;/p&gt;
&lt;p&gt;isPrototypeOf()：确定对象原型方法。&lt;br&gt;&lt;code&gt;alert(Person.prototype.isPrototypeOf(person1)); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; Object.getPrototypeOf()：ECMAScript 5新增方法。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt; == Person.prototype)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;  //true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt;.name)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; //&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;原型与in操作符&lt;/strong&gt;&lt;br&gt;有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;p&gt;而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function hasPrototypeProperty(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;/span&gt;name) &amp;amp;&amp;amp; (name in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。&lt;/p&gt;
&lt;p&gt;Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。&lt;/p&gt;
&lt;p&gt;如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型的动态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;h3 id=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;a href=&quot;#组合使用构造函数模式和原型模式&quot; class=&quot;headerlink&quot; title=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;/a&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。&lt;/p&gt;
&lt;h3 id=&quot;动态原型模式&quot;&gt;&lt;a href=&quot;#动态原型模式&quot; class=&quot;headerlink&quot; title=&quot;动态原型模式&quot;&gt;&lt;/a&gt;动态原型模式&lt;/h3&gt;&lt;p&gt;动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。&lt;/p&gt;
&lt;h3 id=&quot;寄生构造函数模式&quot;&gt;&lt;a href=&quot;#寄生构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;寄生构造函数模式&quot;&gt;&lt;/a&gt;寄生构造函数模式&lt;/h3&gt;&lt;p&gt;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。&lt;/p&gt;
&lt;h3 id=&quot;稳妥构造函数模式&quot;&gt;&lt;a href=&quot;#稳妥构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;稳妥构造函数模式&quot;&gt;&lt;/a&gt;稳妥构造函数模式&lt;/h3&gt;&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());    &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链的问题&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。&lt;br&gt;原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。&lt;/p&gt;
&lt;h3 id=&quot;借用构造函数&quot;&gt;&lt;a href=&quot;#借用构造函数&quot; class=&quot;headerlink&quot; title=&quot;借用构造函数&quot;&gt;&lt;/a&gt;借用构造函数&lt;/h3&gt;&lt;p&gt;在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递参数&lt;/strong&gt;&lt;br&gt;相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数的问题&lt;/strong&gt;&lt;br&gt;如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。&lt;/p&gt;
&lt;h3 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h3&gt;&lt;p&gt;组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SupType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Nicolas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayAge();         &lt;span class=&quot;comment&quot;&gt;//29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayAge();         &lt;span class=&quot;comment&quot;&gt;//27&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。&lt;br&gt;组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;/h3&gt;&lt;p&gt;借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    F.prototype = o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anttherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Rob&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yetAnotherPerosn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Linda&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Barbie&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.friends);  &lt;span class=&quot;comment&quot;&gt;//&quot;Shelby, Court, Van, Rob, Barbie&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。&lt;br&gt;ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。&lt;br&gt;object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。&lt;/p&gt;
&lt;h3 id=&quot;寄生式继承&quot;&gt;&lt;a href=&quot;#寄生式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生式继承&quot;&gt;&lt;/a&gt;寄生式继承&lt;/h3&gt;&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(original)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; = object(original);    &lt;span class=&quot;comment&quot;&gt;//通过调用函数创建一个新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;       &lt;span class=&quot;comment&quot;&gt;//以某种方式来增强这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;hi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;;                    &lt;span class=&quot;comment&quot;&gt;//返回这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson = createAnother(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.sayHi();  &lt;span class=&quot;comment&quot;&gt;//&quot;hi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。&lt;br&gt;注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。&lt;/p&gt;
&lt;h3 id=&quot;寄生组合式继承&quot;&gt;&lt;a href=&quot;#寄生组合式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生组合式继承&quot;&gt;&lt;/a&gt;寄生组合式继承&lt;/h3&gt;&lt;p&gt;组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);             &lt;span class=&quot;comment&quot;&gt;//第二次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();        &lt;span class=&quot;comment&quot;&gt;//第一次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。&lt;br&gt;而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(subType, superType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prototype = object(superType.prototype);    &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prototype.constructor = subType;                &lt;span class=&quot;comment&quot;&gt;//增强对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subType.prototype = prototype;                  &lt;span class=&quot;comment&quot;&gt;//指定对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inheritPrototype(SubType, SuperType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：&lt;br&gt;1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。&lt;br&gt;2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。&lt;br&gt;3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。&lt;br&gt;JavaScript主要使用原型链实现继承。&lt;strong&gt;原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的&lt;/strong&gt;。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。&lt;br&gt;使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。&lt;br&gt;此外，还存在下列可供选择的继承模式：&lt;br&gt;1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。&lt;br&gt;2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。&lt;br&gt;3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;h1 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h1&gt;&lt;p&gt;定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; functionName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num * arguments.callee(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var factorial = (&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;num * &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;不少开发人员总是搞不清匿名函数和闭包这两个概念。&lt;br&gt;&lt;strong&gt;闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;而匿名函数是指没有函数名称的函数。&lt;/strong&gt;&lt;br&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。&lt;br&gt;在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = compare(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 &lt;/p&gt;
&lt;p&gt;无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。&lt;br&gt;在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compare = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compare(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compareNames = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compareNames(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//解除对匿名函数的引用（以便释放内存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compareNames = null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包与变量&quot;&gt;&lt;a href=&quot;#闭包与变量&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数会返回一个函数数组，而其中的每个函数都返回10。&lt;br&gt;我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //匿名函数直接赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function(num) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于this对象&quot;&gt;&lt;a href=&quot;#关于this对象&quot; class=&quot;headerlink&quot; title=&quot;关于this对象&quot;&gt;&lt;/a&gt;关于this对象&lt;/h3&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;The Window&quot;（在非严格模式下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; that.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;My Object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(element.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//防止内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = element.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。&lt;/p&gt;
&lt;h2 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h2&gt;&lt;p&gt;JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。&lt;br&gt;用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//立即调用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里是块级作用域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数。&lt;br&gt;函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。&lt;/p&gt;
&lt;p&gt;无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outputNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(i);    &lt;span class=&quot;comment&quot;&gt;//导致一个错误！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。&lt;/p&gt;
&lt;h2 id=&quot;私有变量&quot;&gt;&lt;a href=&quot;#私有变量&quot; class=&quot;headerlink&quot; title=&quot;私有变量&quot;&gt;&lt;/a&gt;私有变量&lt;/h2&gt;&lt;p&gt;严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。&lt;br&gt;如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。&lt;br&gt;我们把有权访问私有变量和私有函数的公有方法成为&lt;strong&gt;特权方法&lt;/strong&gt;（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。&lt;br&gt;利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nihcholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。&lt;br&gt;构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。&lt;/p&gt;
&lt;h3 id=&quot;静态私有变量&quot;&gt;&lt;a href=&quot;#静态私有变量&quot; class=&quot;headerlink&quot; title=&quot;静态私有变量&quot;&gt;&lt;/a&gt;静态私有变量&lt;/h3&gt;&lt;p&gt;通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公有/特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject.prototype.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。&lt;br&gt;这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototye.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototype.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Michael&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person2.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。&lt;br&gt;以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。&lt;/p&gt;
&lt;h3 id=&quot;模块模式&quot;&gt;&lt;a href=&quot;#模块模式&quot; class=&quot;headerlink&quot; title=&quot;模块模式&quot;&gt;&lt;/a&gt;模块模式&lt;/h3&gt;&lt;p&gt;前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : value,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; : function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是方法的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权/公有方法和属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicProperty: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; application = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; components = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    components.push(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaseComponent());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公共&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getComponentCount : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; components.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerComponent : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; component == &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                components.push(component);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。&lt;br&gt;简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。&lt;/p&gt;
&lt;h3 id=&quot;增强的模块模式&quot;&gt;&lt;a href=&quot;#增强的模块模式&quot; class=&quot;headerlink&quot; title=&quot;增强的模块模式&quot;&gt;&lt;/a&gt;增强的模块模式&lt;/h3&gt;&lt;p&gt;有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。&lt;/p&gt;
&lt;h2 id=&quot;小结：&quot;&gt;&lt;a href=&quot;#小结：&quot; class=&quot;headerlink&quot; title=&quot;小结：&quot;&gt;&lt;/a&gt;小结：&lt;/h2&gt;&lt;p&gt;在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包还可以用于在对象中创建私有变量，相关概念和要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。&lt;/p&gt;
&lt;h1 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h1&gt;&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。&lt;/p&gt;
&lt;p&gt;定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。&lt;br&gt;尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，&lt;/p&gt;
&lt;h3 id=&quot;窗口关系及框架&quot;&gt;&lt;a href=&quot;#窗口关系及框架&quot; class=&quot;headerlink&quot; title=&quot;窗口关系及框架&quot;&gt;&lt;/a&gt;窗口关系及框架&lt;/h3&gt;&lt;p&gt;如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。&lt;br&gt;每个window对象都有一个name属性，其中包含框架的名称。&lt;br&gt;top对象始终指向最高（最外）层的框架，也就是浏览器窗口。&lt;br&gt;与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。&lt;/p&gt;
&lt;h3 id=&quot;窗口的位置&quot;&gt;&lt;a href=&quot;#窗口的位置&quot; class=&quot;headerlink&quot; title=&quot;窗口的位置&quot;&gt;&lt;/a&gt;窗口的位置&lt;/h3&gt;&lt;p&gt;使用如下代码可以取得窗口左边和上边的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; leftPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenY;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;moveTo():接收新位置的x,y坐标值&lt;/p&gt;
&lt;p&gt;moveBy():接收在水平和垂直方向上移动的像素数&lt;/p&gt;
&lt;h3 id=&quot;窗口大小&quot;&gt;&lt;a href=&quot;#窗口大小&quot; class=&quot;headerlink&quot; title=&quot;窗口大小&quot;&gt;&lt;/a&gt;窗口大小&lt;/h3&gt;&lt;p&gt;四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.&lt;/p&gt;
&lt;p&gt;resizeTo():接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy():接收新窗口与原窗口的宽度和高度之差&lt;/p&gt;
&lt;p&gt;innerWidth和innerHeight表示该容器中页面视图区的大小&lt;/p&gt;
&lt;h3 id=&quot;导航和打开新窗口&quot;&gt;&lt;a href=&quot;#导航和打开新窗口&quot; class=&quot;headerlink&quot; title=&quot;导航和打开新窗口&quot;&gt;&lt;/a&gt;导航和打开新窗口&lt;/h3&gt;&lt;p&gt;使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。&lt;/p&gt;
&lt;h3 id=&quot;间歇调用和超时调用&quot;&gt;&lt;a href=&quot;#间歇调用和超时调用&quot; class=&quot;headerlink&quot; title=&quot;间歇调用和超时调用&quot;&gt;&lt;/a&gt;间歇调用和超时调用&lt;/h3&gt;&lt;p&gt;javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。&lt;br&gt;超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。&lt;/p&gt;
&lt;p&gt;间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。&lt;/p&gt;
&lt;h3 id=&quot;系统对话框&quot;&gt;&lt;a href=&quot;#系统对话框&quot; class=&quot;headerlink&quot; title=&quot;系统对话框&quot;&gt;&lt;/a&gt;系统对话框&lt;/h3&gt;&lt;p&gt;浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;查询字符串参数&quot;&gt;&lt;a href=&quot;#查询字符串参数&quot; class=&quot;headerlink&quot; title=&quot;查询字符串参数&quot;&gt;&lt;/a&gt;查询字符串参数&lt;/h3&gt;&lt;p&gt;location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  &lt;/p&gt;
&lt;h3 id=&quot;位置操作&quot;&gt;&lt;a href=&quot;#位置操作&quot; class=&quot;headerlink&quot; title=&quot;位置操作&quot;&gt;&lt;/a&gt;位置操作&lt;/h3&gt;&lt;p&gt;用location对象改变浏览器位置的多种方式：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);  
window.location=&amp;quot;htttp://www.wrox.com&amp;quot;;  
location.href=&amp;quot;htttp://www.wrox.com&amp;quot;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。&lt;/p&gt;
&lt;p&gt;  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;&lt;a href=&quot;#navigator对象&quot; class=&quot;headerlink&quot; title=&quot;navigator对象&quot;&gt;&lt;/a&gt;navigator对象&lt;/h2&gt;&lt;p&gt;navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。&lt;/p&gt;
&lt;h3 id=&quot;检测插件&quot;&gt;&lt;a href=&quot;#检测插件&quot; class=&quot;headerlink&quot; title=&quot;检测插件&quot;&gt;&lt;/a&gt;检测插件&lt;/h3&gt;&lt;p&gt;navigator.plugins[]表示浏览器所用的插件的集合。&lt;br&gt;name: 插件的名字&lt;/p&gt;
&lt;p&gt;description:插件的描述&lt;/p&gt;
&lt;p&gt;filename:插件的文件名&lt;/p&gt;
&lt;p&gt;length:插件所处理的MIME类型数量&lt;/p&gt;
&lt;h3 id=&quot;注册处理程序&quot;&gt;&lt;a href=&quot;#注册处理程序&quot; class=&quot;headerlink&quot; title=&quot;注册处理程序&quot;&gt;&lt;/a&gt;注册处理程序&lt;/h3&gt;&lt;p&gt;FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。&lt;/p&gt;
&lt;p&gt;registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。&lt;/p&gt;
&lt;p&gt;navigator.registerContentHandler(‘application/rss+xml’, ‘&lt;a href=&quot;http://www.sohu.com?feed=%s’&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sohu.com?feed=%s’&lt;/a&gt;, ‘some Reader’);&lt;/p&gt;
&lt;p&gt;FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。&lt;/p&gt;
&lt;h2 id=&quot;screen对象&quot;&gt;&lt;a href=&quot;#screen对象&quot; class=&quot;headerlink&quot; title=&quot;screen对象&quot;&gt;&lt;/a&gt;screen对象&lt;/h2&gt;&lt;p&gt;screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;&lt;a href=&quot;#history对象&quot; class=&quot;headerlink&quot; title=&quot;history对象&quot;&gt;&lt;/a&gt;history对象&lt;/h2&gt;&lt;p&gt;history.go(-1) | history.back(); //后退一页&lt;/p&gt;
&lt;p&gt;history.go(1) | history.forward();//前进一页&lt;/p&gt;
&lt;p&gt;history.go(n);//前进n页&lt;/p&gt;
&lt;p&gt;history.go(‘sohu.com’);//跳转到最后的sohu页面&lt;/p&gt;
&lt;p&gt;history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。&lt;/p&gt;
&lt;h1 id=&quot;第9章，客户端检测&quot;&gt;&lt;a href=&quot;#第9章，客户端检测&quot; class=&quot;headerlink&quot; title=&quot;第9章，客户端检测&quot;&gt;&lt;/a&gt;第9章，客户端检测&lt;/h1&gt;&lt;p&gt;尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案&lt;/p&gt;
&lt;h2 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h2&gt;&lt;p&gt;检测浏览器是否具备某一能力。&lt;/p&gt;
&lt;p&gt;尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险&lt;/p&gt;
&lt;p&gt;并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。&lt;/p&gt;
&lt;h2 id=&quot;怪癖检测&quot;&gt;&lt;a href=&quot;#怪癖检测&quot; class=&quot;headerlink&quot; title=&quot;怪癖检测&quot;&gt;&lt;/a&gt;怪癖检测&lt;/h2&gt;&lt;p&gt;检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。&lt;/p&gt;
&lt;h2 id=&quot;用户代理检测&quot;&gt;&lt;a href=&quot;#用户代理检测&quot; class=&quot;headerlink&quot; title=&quot;用户代理检测&quot;&gt;&lt;/a&gt;用户代理检测&lt;/h2&gt;&lt;p&gt;通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。&lt;br&gt;识别呈现引擎&lt;/p&gt;
&lt;p&gt;注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera&lt;/p&gt;
&lt;p&gt;注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别&lt;br&gt;识别浏览器&lt;br&gt;识别平台&lt;br&gt;识别windows操作系统&lt;br&gt;识别移动设备&lt;br&gt;识别游戏系统&lt;br&gt;完整的用户代理检测代码&lt;/p&gt;
&lt;h1 id=&quot;第10章-DOM&quot;&gt;&lt;a href=&quot;#第10章-DOM&quot; class=&quot;headerlink&quot; title=&quot;第10章 DOM&quot;&gt;&lt;/a&gt;第10章 DOM&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>研究框架YYModel</title>
    <link href="http://peilinghui.com/2017/02/03/%E7%A0%94%E7%A9%B6%E6%A1%86%E6%9E%B6YYModel/"/>
    <id>http://peilinghui.com/2017/02/03/研究框架YYModel/</id>
    <published>2017-02-03T07:22:49.000Z</published>
    <updated>2017-04-14T14:59:41.000Z</updated>
    
    <content type="html">&lt;p&gt;在网络请求的传输和解析中，免不了用到字典转模型的内容。YYModel源码研究。&lt;br&gt;地址：&lt;a href=&quot;https://github.com/ibireme/YYModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ibireme/YYModel&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;分析源码&quot;&gt;&lt;a href=&quot;#分析源码&quot; class=&quot;headerlink&quot; title=&quot;分析源码&quot;&gt;&lt;/a&gt;分析源码&lt;/h1&gt;&lt;p&gt;就是runtime的应用。文件目录:&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.17.19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;YYClassInfo&quot;&gt;&lt;a href=&quot;#YYClassInfo&quot; class=&quot;headerlink&quot; title=&quot;YYClassInfo&quot;&gt;&lt;/a&gt;YYClassInfo&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;YYClassIvarInfo 对 Class的Ivar进行了进行封装增加描述
YYClassMethodInfo 对 Class 的 Method进行封装增加描述
YYClassPropertyInfo 对 Class 的 Property进行了封装描述
YYClassInfo 是对于Class进行了封装，进行封装增加描述
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.30.52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在runtime.h中obj_class定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class                                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYClassInfo中：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class的描述信息.对一个class进行封装&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYClassInfo&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class cls; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class superCls; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; super class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class metaCls;  &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; isMeta; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 是否为元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) YYClassInfo *superClassInfo; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 父类的描述信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; ivars 用字典来装，与YYClassIvarInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassIvarInfo *&amp;gt; *ivarInfos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; methods用字典来装，与YYClassMethodInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassMethodInfo *&amp;gt; *methodInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; properties用字典来装，与YYClassPropertyInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassPropertyInfo *&amp;gt; *propertyInfos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 当class中有内容被修改了，如增加了一个新的方法，需要调用这个方法进行刷新class的信息，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 这个方法调用后会将needUpdate方法中的返回值设置为YES，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 从而需要调用classInfoWithClass或者classInfoWithClassName来获取刷新class的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setNeedUpdate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; classInfo是否需要刷新，当返回值为YES的时候，需要停止使用改Instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)needUpdate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 获得cls的详细信息，并刷新&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable instancetype)classInfoWithClass:(Class)cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  获得cls的详细信息，并刷新&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable instancetype)classInfoWithClassName:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)className;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYClassInfo声明的方法里，我们可以看到YYClassInfo一旦class进行了修改，就要做对应的更新，这样的操作是为了能够高效缓存class的信息，如ivars，method，property，我们首先从这个类的入口方法开始看起.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过class获取对应class的信息，并且对这些信息进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)classInfoWithClass:(Class)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cls) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 类 缓存容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; classCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 元类 缓存容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; metaCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 为了线程安全 同步信号量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; dispatch_semaphore_t lock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classCache = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;CFAllocatorGetDefault&lt;/span&gt;(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryKeyCallBacks&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryValueCallBacks&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        metaCache = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;CFAllocatorGetDefault&lt;/span&gt;(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryKeyCallBacks&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryValueCallBacks&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock = dispatch_semaphore_create(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是元类还是Class，从结果的容器中进行查找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *info = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryGetValue&lt;/span&gt;(class_isMetaClass(cls) ? metaCache : classCache, (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(cls));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否找到info并且需要进行刷新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info &amp;amp;&amp;amp; info-&amp;gt;_needUpdate) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [info _update];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 释放信号量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_semaphore_signal(lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!info) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// info不在缓存容器中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ** &lt;span class=&quot;comment&quot;&gt;// 通过initWithClass重新创建一个info**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        **info = [[YYClassInfo alloc] initWithClass:cls];**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 缓存到对应的容器中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 再一次判断是meta还是class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(info&lt;span class=&quot;variable&quot;&gt;.isMeta&lt;/span&gt; ? metaCache : classCache, (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(cls), (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(info));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_semaphore_signal(lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对一个类建立实例变量，属性，方法的索引之后，会对这个类进行缓存，以便下一次使用的时候不用重新建立索引，YYModel使用了 CFDictionaryCreateMutable 来进行缓存类的 info ，key 是类名，value 是 YYClassInfo 对象。使用 dispatch_semaphore_t 保证线程安全，之所以选择个是基于性能的考虑。&lt;/p&gt;
&lt;p&gt;这里有几点需要说明一下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mutable不是线程安全的，所以这里需要创建锁
创建缓存容器，如果在缓存容器中直接找到了class，则直接获取到对应的ivar，method，property，这样在下次访问到的时候就不用再去找
如果没有获取到，就开始创建一个YYClassInfo获得class中的描述信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个YYClassInfo&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithClass:(&lt;span class=&quot;type&quot;&gt;Class&lt;/span&gt;)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cls) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _cls = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _superCls = class_getSuperclass(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _isMeta = class_isMetaClass(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_isMeta) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _metaCls = objc_getMetaClass(class_getName(cls));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 获得类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _name = &lt;span class=&quot;type&quot;&gt;NSStringFromClass&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ** [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; _update];**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _superClassInfo = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; classInfoWithClass:_superCls];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;YYClassInfo维护了一个变量来判断是否需要刷新，通过调用setNeedUpdate来修改_needUpdate=YES，进而调用_update方法来进行刷新.&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)_update &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 刷新ivar，method，property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ivarInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _methodInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _propertyInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls = self.cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取得类中的methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; methodCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method *methods = class_copyMethodList(cls, &amp;amp;methodCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (methods) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存method信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *methodInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _methodInfos = methodInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; methodCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用方法名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) methodInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(methods);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取类中的property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; propertyCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;objc_property_t&lt;/span&gt; *properties = class_copyPropertyList(cls, &amp;amp;propertyCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *propertyInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _propertyInfos = propertyInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; propertyCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用属性名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) propertyInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(properties);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取得类中的变量信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivarCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ivar *ivars = class_copyIvarList(cls, &amp;amp;ivarCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ivars) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存ivar信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *ivarInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _ivarInfos = ivarInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历ivar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ivarCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassIvarInfo *info = [[YYClassIvarInfo alloc] initWithIvar:ivars[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用变量名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) ivarInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(ivars);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果当中有不存在的内容，把缓存dict置为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_ivarInfos) _ivarInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_methodInfos) _methodInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_propertyInfos) _propertyInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 刷新结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _needUpdate = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;YYClassIvarInfo&quot;&gt;&lt;a href=&quot;#YYClassIvarInfo&quot; class=&quot;headerlink&quot; title=&quot;YYClassIvarInfo&quot;&gt;&lt;/a&gt;YYClassIvarInfo&lt;/h3&gt;&lt;p&gt;在runtime.h中ivar的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_name                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_type                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_offset                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYclassInfo中：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYClassIvarInfo&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Ivar ivar;              &lt;span class=&quot;comment&quot;&gt;///&amp;lt; ivar opaque struct&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;         &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) ptrdiff_t offset;       &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s offset变量偏移地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *typeEncoding; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s type encoding变量的编码类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) YYEncodingType type;    &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s type转化成YYType类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Creates and returns an ivar info object.创建，返回一个成员变量对象。可以直接在外面暴露的地方获取到这些属性。&lt;br&gt;&lt;code&gt;- (instancetype)initWithIvar:(Ivar)ivar;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;对于Ivar，property和Method都进行了一层封装，最后都服务于YYClassInfo，这样做的一个好处就是把原来里层的内容暴露在外层，方便查找，也可以进行缓存，提高访问效率和命中率，这也是对后面进行json转换做的一些工作&lt;/p&gt;
&lt;h2 id=&quot;NSObject-YYModel&quot;&gt;&lt;a href=&quot;#NSObject-YYModel&quot; class=&quot;headerlink&quot; title=&quot;NSObject+YYModel&quot;&gt;&lt;/a&gt;NSObject+YYModel&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.31.45.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.31.37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;提供数据-模型方法：&lt;br&gt;1.把json转换成对象，或者把对象转换成Json.&lt;br&gt;2.设置对象的属性用KVO字典&lt;br&gt;3.‘NSCoding’,”NSCopying”,”-hash”.”-isEqual:”的实现&lt;/p&gt;
&lt;h3 id=&quot;对映射处理的封装&quot;&gt;&lt;a href=&quot;#对映射处理的封装&quot; class=&quot;headerlink&quot; title=&quot;对映射处理的封装&quot;&gt;&lt;/a&gt;对映射处理的封装&lt;/h3&gt;&lt;h4 id=&quot;YYModelPropertyMeta&quot;&gt;&lt;a href=&quot;#YYModelPropertyMeta&quot; class=&quot;headerlink&quot; title=&quot;_YYModelPropertyMeta&quot;&gt;&lt;/a&gt;_YYModelPropertyMeta&lt;/h4&gt;&lt;p&gt;_YYModelPropertyMeta 是一个内部类，用来处理一个 Class 的 Property 的元数据类。和 YYClassPropertyInfo 不同的是，_YYModelPropertyMeta 还负责映射属性的维护。可以说是，对 YYClassPropertyInfo 更高层的封装，服务于映射的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建YYModelProperty的元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelPropertyMeta&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @package&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// property 名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *_name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// property 编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncodingType _type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Foundation类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncoding&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt; _nsType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否为基础数据类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isCNumber;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class _cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否为集合类型即Array／Set／Dicitinoary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class _genericCls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性的get方法和set方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL _getter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL _setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性是否提供KVC方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isKVCCompatible;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性是否支持归档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isStructAvailableForKeyedArchiver;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否有自定义的映射字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomClassFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key 如 @&amp;#123;@&quot;name&quot;:@&quot;user&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *_mappedToKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key是一个路径 @&amp;#123;@&quot;name&quot;:@&quot;person.name&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_mappedToKeyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key是一个数组,即一个key对应多个json key @&amp;#123;@&quot;name&quot;:@[@&quot;name&quot;,@&quot;user&quot;,@&quot;account&quot;]&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_mappedToKeyArray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 描述的property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassPropertyInfo *_info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    **&lt;span class=&quot;comment&quot;&gt;// 在多个属性映射一个json key 的时候使用**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    **_YYModelPropertyMeta *_next;**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;多个property对应一个json key的情况，很可能映射表是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;collection&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;     : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;fullName&quot;&lt;/span&gt; : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;username&quot;&lt;/span&gt; : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里name、fullName、username都对应json中name这个字段，我们拿刚刚这个json key 映射来做分析.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/677383-c43a21298b1a2f8c.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这样做有什么用呢，我们可以看到这样用了一个链表把所有映射到同一个json key的属性串联起来，这样如果json key 字段里的值改了，我们可以看到最先得到映射的是name属性，有了这样一个表，其他几个属性只需要通过next指针就可以拿到对应jsonkey 修改了的值，这样是不是直接把需要修改的都串联起来了呢..&lt;br&gt;YYModelPropertyMeta实现文件里的方法:&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@implementation&lt;/span&gt; _YYModelPropertyMeta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)&lt;span class=&quot;string&quot;&gt;metaWithClassInfo:&lt;/span&gt;(YYClassInfo *)classInfo &lt;span class=&quot;string&quot;&gt;propertyInfo:&lt;/span&gt;(YYClassPropertyInfo *)propertyInfo &lt;span class=&quot;string&quot;&gt;generic:&lt;/span&gt;(Class)generic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建一个meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _YYModelPropertyMeta *meta = [self &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将属性名赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_name = propertyInfo.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 赋值编码类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_type = propertyInfo.type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将描述属性赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_info = propertyInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 记录属性为容器类型的时候 元素的映射类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_genericCls = generic;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) == YYEncodingTypeObject) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 先匹配是否为NS类型 即Foundation 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_nsType = YYClassGetNSType(propertyInfo.cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 是否为C数据类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_isCNumber = YYEncodingTypeIsCNumber(meta-&amp;gt;_type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性为结构体类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) == YYEncodingTypeStruct) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         It seems that NSKeyedUnarchiver cannot decode NSValue except these structs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; NSSet *types = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 单例 创建一份c结构体类型映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            NSMutableSet *set = [NSMutableSet &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 32 bit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGSize=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGPoint=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGRect=&amp;#123;CGPoint=ff&amp;#125;&amp;#123;CGSize=ff&amp;#125;&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGAffineTransform=ffffff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIEdgeInsets=ffff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIOffset=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 64 bit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGSize=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGPoint=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGRect=&amp;#123;CGPoint=dd&amp;#125;&amp;#123;CGSize=dd&amp;#125;&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGAffineTransform=dddddd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIEdgeInsets=dddd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIOffset=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            types = set;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 只有以上的结构体才能被归档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([types &lt;span class=&quot;string&quot;&gt;containsObject:&lt;/span&gt;propertyInfo.typeEncoding]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_isStructAvailableForKeyedArchiver = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置class类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_cls = propertyInfo.cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果是容器类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (generic) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从容器class 中读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_hasCustomClassFromDictionary = [generic &lt;span class=&quot;string&quot;&gt;respondsToSelector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;modelCustomClassForDictionary:&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (meta-&amp;gt;_cls &amp;amp;&amp;amp; meta-&amp;gt;_nsType == YYEncodingTypeNSUnknown) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从class类型中读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_hasCustomClassFromDictionary = [meta-&amp;gt;_cls &lt;span class=&quot;string&quot;&gt;respondsToSelector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;modelCustomClassForDictionary:&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// getter 和 setter 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (propertyInfo.getter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([classInfo.cls &lt;span class=&quot;string&quot;&gt;instancesRespondToSelector:&lt;/span&gt;propertyInfo.getter]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_getter = propertyInfo.getter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (propertyInfo.setter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([classInfo.cls &lt;span class=&quot;string&quot;&gt;instancesRespondToSelector:&lt;/span&gt;propertyInfo.setter]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_setter = propertyInfo.setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  只有实现了getter和setter方法 才能实现归档&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (meta-&amp;gt;_getter &amp;amp;&amp;amp; meta-&amp;gt;_setter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         KVC中不支持的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         long double&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         指针对象 SEL等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeBool:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt8:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt8:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt16:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt16:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt32:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt32:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt64:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt64:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeFloat:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeDouble:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeObject:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeClass:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeBlock:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeStruct:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUnion:&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                meta-&amp;gt;_isKVCCompatible = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;            default:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; meta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;流程大概如下&lt;br&gt;1.如果是属性是对象，通过 YYClassGetNSType 来从propertyInfo获取 NSType&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断属性是否可以归档。除了 CGSize ，CGPoint，CGRect，CGAffineTransform，UIEdgeInsets，UIOffset 其他都不支持归档
是否需要对字典设置单独的 class 通过类方法 modelCustomClassForDictionary 来返回特定的 model 类
判断是否支持 setter，和getter 方法。
判断时候支持 KVC。只有 long double,指针对象, SEL不支持KVC
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;YYModelMeta&quot;&gt;&lt;a href=&quot;#YYModelMeta&quot; class=&quot;headerlink&quot; title=&quot;_YYModelMeta&quot;&gt;&lt;/a&gt;_YYModelMeta&lt;/h4&gt;&lt;p&gt;_YYModelMeta 是对一个需要映射的 Model YYClassInfo进行了一些描述信息的封装。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// YYModelMeta 对ClassInfo增加描述&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelMeta&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @package&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *_classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json key 和 property Meta 的映射关系字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *_mapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 所有属性的propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_allPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 映射jsonkeyPath 的PropertyMetas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_keyPathPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 映射多个jsonKey的propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_multiKeysPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// 需要映射的属性的总个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; _keyMappedCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// Model对应的Foundation class类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncoding&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt; _nsType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否实现了自定义的映射关系表 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomWillTransformFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomTransformFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomTransformToDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomClassFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelMeta&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithClass:(Class)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建classInfo对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1. 判断是否合法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!classInfo) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2. 获得黑名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *blacklist = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelPropertyBlacklist)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *properties = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelPropertyBlacklist];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            blacklist = [&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithArray:properties];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3. 获得白名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *whitelist = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelPropertyWhitelist)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *properties = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelPropertyWhitelist];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            whitelist = [&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithArray:properties];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4. 获取容器属性中的映射关系字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *genericMapper = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelContainerPropertyGenericClass)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断类中是否实现了对应的modelContainerPropertyGenericClass方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 例如&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&amp;#123;@&quot;shadows&quot; : [YYShadow class],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&quot;borders&quot; : YYBorder.class,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&quot;attachments&quot; : @&quot;YYAttachment&quot; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        genericMapper = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelContainerPropertyGenericClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (genericMapper) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 将字段名和对应的class存放在字典里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *tmp = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [genericMapper enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![key isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class meta = object_getClass(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (class_isMetaClass(meta)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    tmp[key] = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([obj isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Class cls = &lt;span class=&quot;built_in&quot;&gt;NSClassFromString&lt;/span&gt;(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cls) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tmp[key] = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            genericMapper = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 5. 创建Class中 所有属性的PropertyMeta对象 加入到字典中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用来保存class 和其父类的所有属性 除了NSOject外&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *allPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *curClassInfo = classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (curClassInfo &amp;amp;&amp;amp; curClassInfo&lt;span class=&quot;variable&quot;&gt;.superCls&lt;/span&gt; != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// recursive parse super class, but ignore root class (NSObject/NSProxy)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历当前ClassInfo 中的所有PropertyInfo， 将它们封装成PropertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (YYClassPropertyInfo *propertyInfo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; curClassInfo&lt;span class=&quot;variable&quot;&gt;.propertyInfos&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.allValues&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 检查是否合法和黑名单白名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (blacklist &amp;amp;&amp;amp; [blacklist containsObject:propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (whitelist &amp;amp;&amp;amp; ![whitelist containsObject:propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 通过propetyInfo来创建一个meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                    propertyInfo:propertyInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                         generic:genericMapper[propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// meta nanme必须非空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta || !meta-&amp;gt;_name) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 必须实现get方法和set方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta-&amp;gt;_getter || !meta-&amp;gt;_setter) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 字典中没有这个字段 避免重复操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allPropertyMetas[meta-&amp;gt;_name]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            allPropertyMetas[meta-&amp;gt;_name] = meta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历父类的property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curClassInfo = curClassInfo&lt;span class=&quot;variable&quot;&gt;.superClassInfo&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断是否为空，不为空赋值给model声明中的_allPropertyMetas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;) _allPropertyMetas = allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.allValues&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.copy&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建映射关系 jsonkey ：propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *mapper = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *keyPathPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *multiKeysPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否实现自定义的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomPropertyMapper)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获得自定义的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *customMapper = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &amp;lt;YYModel&amp;gt;)cls modelCustomPropertyMapper];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历自定义的字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [customMapper enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *propertyName, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *mappedToKey, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 创建propetyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 由于用户自定义映射，把原来映射的规则删除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [allPropertyMetas removeObjectForKey:propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([mappedToKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 判断key字段是否为非空NSString&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mappedToKey&lt;span class=&quot;variable&quot;&gt;.length&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 直接保存property映射的key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_mappedToKey = mappedToKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 如果是keyPath的情况， 用数组来处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *keyPath = [mappedToKey componentsSeparatedByString:&lt;span class=&quot;string&quot;&gt;@&quot;.&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// &amp;#123;@&quot;name&quot;:@&quot;user.name&quot;&amp;#125; =&amp;gt; name : @[@&quot;user&quot;,@&quot;name&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 保存keyPath映射关系&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    propertyMeta-&amp;gt;_mappedToKeyPath = keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 添加到keyPathPropertyMetas数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [keyPathPropertyMetas addObject:propertyMeta];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 多个属性的时候，用next指针来指向前一个jsonKey映射的meta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_next = mapper[mappedToKey] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 保存jsonKey映射到最新的meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mapper[mappedToKey] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([mappedToKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; class]]) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 如果是数组 属于一个属性映射多个jsonKey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *mappedToKeyArray = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *oneKey &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ((&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)mappedToKey)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![oneKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oneKey&lt;span class=&quot;variable&quot;&gt;.length&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *keyPath = [oneKey componentsSeparatedByString:&lt;span class=&quot;string&quot;&gt;@&quot;.&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        [mappedToKeyArray addObject:keyPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        [mappedToKeyArray addObject:oneKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta-&amp;gt;_mappedToKey) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        propertyMeta-&amp;gt;_mappedToKey = oneKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        propertyMeta-&amp;gt;_mappedToKeyPath = keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ? keyPath : &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta-&amp;gt;_mappedToKey) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_mappedToKeyArray = mappedToKeyArray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [multiKeysPropertyMetas addObject:propertyMeta];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_next = mapper[mappedToKey] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mapper[mappedToKey] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 处理没有自定义映射规则的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在上面的处理中 从allPropertyMetas中删除了有自定义映射规则的meta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩下来的是没有自定义规则的属性，在这里就让这些属性的mappedKey等于属性名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name, _YYModelPropertyMeta *propertyMeta, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 直接让mappedKey等于属性名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        propertyMeta-&amp;gt;_mappedToKey = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        propertyMeta-&amp;gt;_next = mapper[name] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapper[name] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对映射的数据做修正处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mapper&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;) _mapper = mapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _classInfo = classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _keyMappedCount = _allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _nsType = YYClassGet&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomWillTransformFromDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomTransformFromDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomTransformToDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomClassFromDictionary = ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomClassForDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;流程是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获取黑名单和白名单。
创建 allPropertyMetas ，将所有属性添加到其中，根据黑，白名单剔除其中的元素。
将 allPropertyMetas 中的处理 keyPath 的 key 添加到 _keyPathPropertyMetas，将需要处理多 key 映射的添加到 _multiKeysPropertyMetas 中。
缓存机制
对于处理好的映射关系，YYModel 会对它们进行缓存，用的也是 CFDictionaryGetValue 来完成，使用 dispatch_semaphore_t 来保证线程安全
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h2 id=&quot;简单的-Model-与-JSON-相互转换&quot;&gt;&lt;a href=&quot;#简单的-Model-与-JSON-相互转换&quot; class=&quot;headerlink&quot; title=&quot;简单的 Model 与 JSON 相互转换&quot;&gt;&lt;/a&gt;简单的 Model 与 JSON 相互转换&lt;/h2&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// JSON:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;uid&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;created&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1965-07-31T00:00:00+0000&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Model:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface &lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;: NSObject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;UInt64 uid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;NSString *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;NSDate *created;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation &lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;*user&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yy_modelWithJSON&lt;/span&gt;:json];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 将 Model 转换为 JSON 对象:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *json = [&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yy_modelToJSONObject&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-12%20%E4%B8%8B%E5%8D%883.01.36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Model-属性名和-JSON-中的-Key-不相同&quot;&gt;&lt;a href=&quot;#Model-属性名和-JSON-中的-Key-不相同&quot; class=&quot;headerlink&quot; title=&quot;Model 属性名和 JSON 中的 Key 不相同&quot;&gt;&lt;/a&gt;Model 属性名和 JSON 中的 Key 不相同&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;n&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry Pottery&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;ext&quot;&lt;/span&gt; : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;A book written by J.K.Rowing.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;ID&quot;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; page;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *bookID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)modelCustomPropertyMapper &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;page&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;p&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;ext.desc&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;bookID&quot;&lt;/span&gt; : @[&lt;span class=&quot;string&quot;&gt;@&quot;id&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;ID&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;book_id&quot;&lt;/span&gt;]&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。&lt;/p&gt;
&lt;p&gt;在 json-&amp;gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。&lt;/p&gt;
&lt;p&gt;在 model-&amp;gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。&lt;/p&gt;
&lt;h2 id=&quot;Model-包含其他-Model&quot;&gt;&lt;a href=&quot;#Model-包含其他-Model&quot; class=&quot;headerlink&quot; title=&quot;Model 包含其他 Model&quot;&gt;&lt;/a&gt;Model 包含其他 Model&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;author&quot;&lt;/span&gt;:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;J.K.Rowling&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;birthday&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1965-07-31T00:00:00+0000&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry Potter&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;pages&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model: 什么都不用做，转换会自动完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *birthday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; pages;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; Author *author; &lt;span class=&quot;comment&quot;&gt;//Book 包含 Author 属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;容器类属性&quot;&gt;&lt;a href=&quot;#容器类属性&quot; class=&quot;headerlink&quot; title=&quot;容器类属性&quot;&gt;&lt;/a&gt;容器类属性&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shadow&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Border&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Attachment&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *shadows; &lt;span class=&quot;comment&quot;&gt;//Array&amp;lt;Shadow&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *borders; &lt;span class=&quot;comment&quot;&gt;//Set&amp;lt;Border&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *attachments; &lt;span class=&quot;comment&quot;&gt;//Dict&amp;lt;NSString,Attachment&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)modelContainerPropertyGenericClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;shadows&quot;&lt;/span&gt; : [Shadow class],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;borders&quot;&lt;/span&gt; : Border&lt;span class=&quot;variable&quot;&gt;.class&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;attachments&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;Attachment&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;黑名单与白名单&quot;&gt;&lt;a href=&quot;#黑名单与白名单&quot; class=&quot;headerlink&quot; title=&quot;黑名单与白名单&quot;&gt;&lt;/a&gt;黑名单与白名单&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)modelPropertyBlacklist &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @[&lt;span class=&quot;string&quot;&gt;@&quot;test1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;test2&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果实现了该方法，则处理过程中不会处理该列表外的属性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)modelPropertyWhitelist &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @[&lt;span class=&quot;string&quot;&gt;@&quot;name&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数据校验与自定义转换&quot;&gt;&lt;a href=&quot;#数据校验与自定义转换&quot; class=&quot;headerlink&quot; title=&quot;数据校验与自定义转换&quot;&gt;&lt;/a&gt;数据校验与自定义转换&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;timestamp&quot;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1445534567&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *createdAt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当 JSON 转为 Model 完成后，该方法会被调用。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你也可以在这里做一些自动转换不能完成的工作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)modelCustomTransformFromDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)dic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *timestamp = dic[&lt;span class=&quot;string&quot;&gt;@&quot;timestamp&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![timestamp isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _createdAt = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSince1970:timestamp&lt;span class=&quot;variable&quot;&gt;.floatValue&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当 Model 转为 JSON 完成后，该方法会被调用。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你也可以在这里做一些自动转换不能完成的工作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)modelCustomTransformToDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *)dic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_createdAt) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dic[&lt;span class=&quot;string&quot;&gt;@&quot;timestamp&quot;&lt;/span&gt;] = @(n&lt;span class=&quot;variable&quot;&gt;.timeIntervalSince1970&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Coding-Copying-hash-equal-description&quot;&gt;&lt;a href=&quot;#Coding-Copying-hash-equal-description&quot; class=&quot;headerlink&quot; title=&quot;Coding/Copying/hash/equal/description&quot;&gt;&lt;/a&gt;Coding/Copying/hash/equal/description&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYShadow&lt;/span&gt; :&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;NSCoding&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;NSCopying&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYShadow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 直接添加以下代码即可自动完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)encodeWithCoder:(&lt;span class=&quot;built_in&quot;&gt;NSCoder&lt;/span&gt; *)aCoder &amp;#123; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelEncodeWithCoder:aCoder]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)initWithCoder:(&lt;span class=&quot;built_in&quot;&gt;NSCoder&lt;/span&gt; *)aDecoder &amp;#123; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init]; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelInitWithCoder:aDecoder]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)copyWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelCopy]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)hash &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelHash]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)isEqual:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelIsEqual:object]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)description &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelDescription]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;CocoaPods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在 Podfile 中添加 pod &amp;apos;YYModel&amp;apos;。
执行 pod install。
导入 &amp;lt;YYModel/YYModel.h&amp;gt;。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/b6aaf5d56257&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/b6aaf5d56257&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较YYModel和MJExtension：&lt;/strong&gt;&lt;br&gt;YYModel、MJExtension 都是采用 Category 方式来实现功能，比较灵活，无侵入。&lt;br&gt;但注意 MJExtension 为 NSObject/NSString 添加了一些没有前缀的方法，且方法命名比较通用，可能会和一个工程内的其他类有冲突。&lt;/p&gt;
&lt;p&gt;YYModel 会进行对象类型检查，避免将错误的对象类型赋值到属性，以避免潜在的 Crash 问题。YYModel 会尝试自动转换，&lt;/p&gt;
&lt;p&gt;MJExtension 会对部分对象进行自动转换（比如 NSString 和 NSNumber 之间的转换），但当自动转换不能完成时，它会直接把 JSON 对象赋值给类型不匹配的 Model 属性。这样的结果会导致稍后 Model 在使用时，造成潜在的 Crash 风险。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;iOS JSON 模型转换库评测&lt;a href=&quot;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在网络请求的传输和解析中，免不了用到字典转模型的内容。YYModel源码研究。&lt;br&gt;地址：&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;https://github.com/ibireme/YYModel&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二维码</title>
    <link href="http://peilinghui.com/2016/12/20/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://peilinghui.com/2016/12/20/二维码/</id>
    <published>2016-12-20T03:08:34.000Z</published>
    <updated>2017-02-20T03:43:15.000Z</updated>
    
    <content type="html">&lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的生成&quot;&gt;&lt;a href=&quot;#二维码的生成&quot; class=&quot;headerlink&quot; title=&quot;二维码的生成&quot;&gt;&lt;/a&gt;二维码的生成&lt;/h1&gt;&lt;h2 id=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;a href=&quot;#从服务器获取data地址再生成二维码&quot; class=&quot;headerlink&quot; title=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;/a&gt;从服务器获取data地址再生成二维码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;网络请求后处理data:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr_selector&quot;&gt;[self.progressHud hide:YES]&lt;/span&gt;;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; ([response.responseObject &lt;span class=&quot;attribute&quot;&gt;objectForKey&lt;/span&gt;:@&lt;span class=&quot;string&quot;&gt;&quot;data&quot;&lt;/span&gt;]) &amp;#123;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr_selector&quot;&gt;[self createImgWith:[response.responseObject objectForKey:@&quot;data&quot;]&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;生成二维码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)createImgWith:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)str &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.实例化二维码滤镜&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; *filter = [&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; filterWithName:&lt;span class=&quot;string&quot;&gt;@&quot;CIQRCodeGenerator&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.恢复滤镜的默认属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setDefaults];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3.将字符串转换成NSData&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *info = str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *infoData = [info dataUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//4.通过KVO设置滤镜inputMessage数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setValue:infoData forKey:&lt;span class=&quot;string&quot;&gt;@&quot;inputMessage&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 5.获得滤镜输出的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *outputImage = [filter outputImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//6. 将CIImage转换成UIImage，并放大显示,方法如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.qrCode&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.image&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:outputImage withSize:&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//return [UIImage imageWithCIImage:outputImage scale:20.0 orientation:UIImageOrientationUp];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  根据CIImage生成指定大小的UIImage 生成清晰的二维码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param image CIImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param size  图片宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *)image withSize:(&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; extent = &lt;span class=&quot;built_in&quot;&gt;CGRectIntegral&lt;/span&gt;(image&lt;span class=&quot;variable&quot;&gt;.extent&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; scale = MIN(size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent), size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.创建bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t width = &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t height = &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceRef&lt;/span&gt; cs = &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceCreateDeviceCMYK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; bitmapRef = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreate&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, width, height, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, cs, (&lt;span class=&quot;built_in&quot;&gt;CGBitmapInfo&lt;/span&gt;)k&lt;span class=&quot;built_in&quot;&gt;CGImageAlphaNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; *context = [&lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; contextWithOptions:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; bitmapImage = [context create&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:image fromRect:extent];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextSetInterpolationQuality&lt;/span&gt;(bitmapRef, k&lt;span class=&quot;built_in&quot;&gt;CGInterpolationNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextScaleCTM&lt;/span&gt;(bitmapRef, scale, scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextDrawImage&lt;/span&gt;(bitmapRef, extent, bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.保存bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; scaledImage = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreateImage&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRelease&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRelease&lt;/span&gt;(bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageWith&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:scaledImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;二维码的扫描&quot;&gt;&lt;a href=&quot;#二维码的扫描&quot; class=&quot;headerlink&quot; title=&quot;二维码的扫描&quot;&gt;&lt;/a&gt;二维码的扫描&lt;/h1&gt;&lt;p&gt;读取二维码需要导入AVFoundation框架&lt;br&gt;利用摄像头识别二维码中的内容（模拟器不行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入（摄像头）
由会话将摄像头采集到的二维码图像转换成字符串数据
输出（数据）
由预览图层显示扫描场景
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扫码主要用到的是AVFoundation用到的东西和相机基本相同，相机。遵守AVCaptureMetadataOutputObjectsDelegate.&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; ScanQRViewController ()&amp;lt;AVCaptureMetadataOutputObjectsDelegate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDevice *device;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDeviceInput *input;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置输出类型为Metadata，因为这种输出类型中可以设置扫描的类型，譬如二维码//当启动摄像头开始捕获输入时，如果输入中包含二维码，就会产生输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureMetadataOutput *output;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）关键用来操作扫描结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureSession *session;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图像预览层，实时显示捕获的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;开始扫描：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginScan&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//iOS 判断应用是否有使用相机的权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *mediaType = &lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//读取媒体类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatus&lt;/span&gt; authStatus = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; authorizationStatusForMediaType:mediaType];&lt;span class=&quot;comment&quot;&gt;//读取设备授权状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusRestricted&lt;/span&gt; || authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusDenied&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (TARGET_IPHONE_SIMULATOR) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//生成会话，用来结合输入输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	 _session =[[&lt;span class=&quot;built_in&quot;&gt;AVCaptureSession&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session setSessionPreset:&lt;span class=&quot;built_in&quot;&gt;AVCaptureSessionPresetHigh&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用AVMediaTypeVideo 默认使用后置摄像头进行初始化**实例化拍摄设备**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; *device           = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; defaultDeviceWithMediaType:&lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用设备初始化输入(设置输入设备)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; *input       = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; deviceInputWithDevice:device error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session addInput:input];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//生成输出对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; *output   = [[&lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置代理，一旦扫描到指定类型的数据，就会通过代理输出 //在扫描的过程中，会分析扫描的内容，分析成功后就会调用代理方法在队列中输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [output setMetadataObjectsDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; queue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [_session addOutput:output];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//指定当扫描到二维码的时候，产生输出 //AVMetadataObjectTypeQRCode 指定二维码 //指定识别类型一定要放到添加到session之后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [output setMetadataObjectTypes:@[&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeQRCode&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN13Code&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN8Code&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeCode128Code&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//设置扫描信息的识别区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; scanCrop = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; getRectOfInterest:_scanWindowView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; ViewoHoleBounds:_cameraView&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;x:%f y:%f width:%f height:%f&quot;&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.x&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.y&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output&lt;span class=&quot;variable&quot;&gt;.rectOfInterest&lt;/span&gt;             = scanCrop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//layer负责把图像渲染显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; *layer = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; layerWithSession:_session];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.videoGravity&lt;/span&gt;                = &lt;span class=&quot;built_in&quot;&gt;AVLayerVideoGravityResizeAspectFill&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;                       = _cameraView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_cameraView&lt;span class=&quot;variable&quot;&gt;.layer&lt;/span&gt; insertSublayer:layer atIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开始启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session startRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现代理方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark - 得到扫描二维码结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)captureOutput:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureOutput&lt;/span&gt; *)captureOutput didOutputMetadataObjects:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)metadataObjects fromConnection:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureConnection&lt;/span&gt; *)connection&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (metadataObjects&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_session stopRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//数组中包含的都是AVMetadataMachineReadableCodeObject 类型的对象，该对象中包含解码后的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;AVMetadataMachineReadableCodeObject&lt;/span&gt; * metadataObject = [metadataObjects objectAtIndex : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SystemSoundID completeSound;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *audioPath = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle] URLForResource:&lt;span class=&quot;string&quot;&gt;@&quot;beep&quot;&lt;/span&gt; withExtension:&lt;span class=&quot;string&quot;&gt;@&quot;ogg&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesCreateSystemSoundID((__bridge &lt;span class=&quot;built_in&quot;&gt;CFURLRef&lt;/span&gt; _Nonnull)(audioPath), &amp;amp;completeSound);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(completeSound);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sendRequestWithBarcode:metadataObject&lt;span class=&quot;variable&quot;&gt;.stringValue&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫码范围：&lt;/p&gt;
&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - 根据参数取得扫面范围reck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGRect)getRectOfInterest:(CGRect)rectFrame ViewoHoleBounds:(CGRect)holeBounds &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat x,y,&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;,heigth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = (rectFrame.origin.x)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = (rectFrame.origin.y)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt; = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    heigth = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; CGRectMake(y, x, heigth, &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫描动画：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;pragma&lt;/span&gt; mark - 扫描器开始进行动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginAnimated &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *lineImgView = [[UIImageView alloc]initWithFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lineImgView.image        = [UIImage imageNamed:@&lt;span class=&quot;string&quot;&gt;&quot;barcodeline&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_scanWindowView addSubview:lineImgView]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [UIView animateWithDuration:&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; delay:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; options:UIViewAnimationOptionRepeat animations:^&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineImgView.frame    = CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; completion:^(BOOL finished) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://my.oschina.net/u/2340880/blog/405847&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://my.oschina.net/u/2340880/blog/405847&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://c0ming.me/qr-code-scan/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://c0ming.me/qr-code-scan/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://yimouleng.com/2016/01/13/ios-QRCode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yimouleng.com/2016/01/13/ios-QRCode/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似支付宝二维码Demo：&lt;br&gt;&lt;a href=&quot;https://github.com/mokey1422/GBAliScan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mokey1422/GBAliScan&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的&quot;&gt;&lt;a href=&quot;#二维码的&quot; class=&quot;headerlink&quot; title=&quot;二维码的&quot;&gt;&lt;/a&gt;二维码的&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的加密实现</title>
    <link href="http://peilinghui.com/2016/12/02/iOS%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0/"/>
    <id>http://peilinghui.com/2016/12/02/iOS中的加密实现/</id>
    <published>2016-12-02T12:12:35.000Z</published>
    <updated>2017-04-14T15:00:42.000Z</updated>
    
    <content type="html">&lt;p&gt;在一个App登录的时候或者是一些个人信息输入的时候都需要有加密算法的实现来确保安全。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;p&gt;加密算法通常分为对称性加密算法和非对称性加密算法.&lt;/p&gt;
&lt;p&gt;对称性加密算法:信息接收双方都需事先知道密匙和加解密算法且其密匙是相同.  &lt;/p&gt;
&lt;p&gt;非对称算法:发送双方A,B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消 息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密.&lt;br&gt;&lt;strong&gt;加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加密分为两种，对称加密和非对称加密。&lt;br&gt;所谓的对称，就是指加密秘钥和解密秘钥相同，而非对称自然就是指两者不同。&lt;/p&gt;
&lt;p&gt;对称加密的优点在于速度快，但是假设秘钥由服务器保存，如何安全的让客户端得到秘钥是需要解决的问题。&lt;/p&gt;
&lt;p&gt;常见的一个非对称加密算法是 RSA 算法，利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。&lt;br&gt;因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。&lt;br&gt;因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。&lt;/p&gt;
&lt;h1 id=&quot;几种对称性加密算法：AES-DES-3DES&quot;&gt;&lt;a href=&quot;#几种对称性加密算法：AES-DES-3DES&quot; class=&quot;headerlink&quot; title=&quot;几种对称性加密算法：AES,DES,3DES&quot;&gt;&lt;/a&gt;几种对称性加密算法：AES,DES,3DES&lt;/h1&gt;&lt;h1 id=&quot;几种非对称性加密算法：RSA-DSA-ECC&quot;&gt;&lt;a href=&quot;#几种非对称性加密算法：RSA-DSA-ECC&quot; class=&quot;headerlink&quot; title=&quot;几种非对称性加密算法：RSA,DSA,ECC&quot;&gt;&lt;/a&gt;几种非对称性加密算法：RSA,DSA,ECC&lt;/h1&gt;&lt;h1 id=&quot;几种线性散列算法（签名算法）：MD5-SHA1-HMAC&quot;&gt;&lt;a href=&quot;#几种线性散列算法（签名算法）：MD5-SHA1-HMAC&quot; class=&quot;headerlink&quot; title=&quot;几种线性散列算法（签名算法）：MD5,SHA1,HMAC&quot;&gt;&lt;/a&gt;几种线性散列算法（签名算法）：MD5,SHA1,HMAC&lt;/h1&gt;&lt;p&gt;MD5加密后的密文都是32位字符：无论原先没有加密前的字符串有多长  加密后都是32位字符  另外我们认为MD5是不可逆的，但事实上网站  md5.com 记录了全球的状态码&lt;br&gt; 可以直接将密文进行解析：所以要对MD5进行加盐来解决&lt;/p&gt;
&lt;p&gt; 方式1、直接进行MD5加密&lt;br&gt; 方式2、加盐后进行MD5加密&lt;br&gt; 方式3、HMAC+MD5&lt;/p&gt;
&lt;p&gt;在iOS开发中，如果某个字符串需要进行MD5加密.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;包含头文件“CommonDigest.h”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import&amp;lt;CommonCrypto/CommonDigest.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写下述方法。函数参数为需要加密的字符串，返回值为加密后得到的结果，也是一个字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;type&quot;&gt;NSString&lt;/span&gt; *)md5HexDigest:(&lt;span class=&quot;type&quot;&gt;NSString&lt;/span&gt; *)url  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; *original_str = [url &lt;span class=&quot;type&quot;&gt;UTF8String&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;CC_MD5_DIGEST_LENGTH&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CC_MD5&lt;/span&gt;(original_str, strlen(original_str), &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSMutableString&lt;/span&gt; *hash = [&lt;span class=&quot;type&quot;&gt;NSMutableString&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;string&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;; i++)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [hash appendFormat:@&lt;span class=&quot;string&quot;&gt;&quot;%02X&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i]];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [hash lowercaseString];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;面试题目：&lt;br&gt;1）如果原文为字串s， 则在发送前先将s转换为UTF-8编码，然后按位取反，再将数据以字节为单位反转顺序，得到新的字节数组。&lt;br&gt;2）取出新字节数组的每一字节，为其生成一个0到100的随机数，用该字节减于随机数，得到的结果作为一个32位整数的最后8位，而随机数按位取反后则作为该整数的9至16位，从而生成一个新的整数，以此类推，得到一个整形数组d。&lt;br&gt;3） 将该整形数组发送给接收方，对方解密后得到原文内容s&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在一个App登录的时候或者是一些个人信息输入的时候都需要有加密算法的实现来确保安全。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习KVC和KVO</title>
    <link href="http://peilinghui.com/2016/08/20/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0KVC%E5%92%8CKVO/"/>
    <id>http://peilinghui.com/2016/08/20/深入学习KVC和KVO/</id>
    <published>2016-08-20T05:57:47.000Z</published>
    <updated>2017-03-25T14:50:47.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习KVC和KVO。研究源码NSKeyValueCoding.h和NSKeyValueObserving.h.在Foundation框架中。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;&lt;h3 id=&quot;什么是-KVC？&quot;&gt;&lt;a href=&quot;#什么是-KVC？&quot; class=&quot;headerlink&quot; title=&quot;什么是 KVC？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是 KVC？&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;KVC 是 Key-Value-Coding 的简称。&lt;/li&gt;
&lt;li&gt;KVC 是一种可以直接通过字符串的名字 key 来访问类属性的机制，而不是通过调用 setter、getter 方法去访问。&lt;/li&gt;
&lt;li&gt;我们可以通过在运行时动态的访问和修改对象的属性。而不是在编译时确定，KVC 是 iOS 开发中的黑魔法之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;键值编码（key-value coding）是一种间接更改对象状态的方式。通过传入的字符串（key）查找要更改的对象的状态。查找的规则是，先查找以字符串（key）命名的getter和setter方法。如果没有找到对应的方法，再查找key和_key的实例变量。KVC 是字典转模型，模型转字典的神器  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;KVC的主要方法&quot;&gt;&lt;a href=&quot;#KVC的主要方法&quot; class=&quot;headerlink&quot; title=&quot;KVC的主要方法&quot;&gt;&lt;/a&gt;KVC的主要方法&lt;/h3&gt;&lt;p&gt;KVC 定义了一种按名称访问对象属性的机制，支持这种访问的主要方法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置值&lt;br&gt;keyPath包含了key的功能&lt;br&gt;key：只能访问当前对象的属性&lt;br&gt;keyPath：能利用运算符一层一层往内部访问属性&lt;br&gt;对于标量值，会自动进行装箱和拆箱。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// value的值为OC对象，如果是基本数据类型要包装成NSNumber&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;(NSString *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// keyPath键路径，类型为xx.xx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forKeyPath:&lt;/span&gt;(NSString *)keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 它的默认实现是抛出异常，可以重写这个函数做错误处理。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forUndefinedKey:&lt;/span&gt;(NSString *)key;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;获取值:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForUndefinedKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;KVC-实现细节&quot;&gt;&lt;a href=&quot;#KVC-实现细节&quot; class=&quot;headerlink&quot; title=&quot;KVC 实现细节&quot;&gt;&lt;/a&gt;KVC 实现细节&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置值&lt;code&gt;- (void)setValue:(id)value forKey:(NSString *)key;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;首先搜索 setter 方法，有就直接赋值。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果上面的 setter 方法没有找到，再检查类方法&lt;code&gt;+ (BOOL)accessInstanceVariablesDirectly&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回 NO，则执行setValue：forUNdefinedKey：
返回 YES，则按_&amp;lt;key&amp;gt;，_&amp;lt;isKey&amp;gt;，&amp;lt;key&amp;gt;，&amp;lt;isKey&amp;gt;的顺序搜索成员名。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还没有找到的话，就调用setValue:forUndefinedKey:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当一个对象调用setValue方法时，方法内部会做以下操作：
①检查是否存在相应key的set方法，如果存在，就调用set方法
②如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值
③如果没有找到_key,就会查找相同名称的属性key，如果有就直接赋值
④如果还没找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;获取值&lt;code&gt;- (id)valueForKey:(NSString *)key;&lt;/code&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先查找 getter 方法，找到直接调用。如果是 bool、int、float 等基本数据类型，会做 NSNumber 的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没查到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回 NO，则执行valueForUNdefinedKey:
返回 YES，则按_&amp;lt;key&amp;gt;,_is&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序搜索成员名。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;还没有找到的话，调用valueForUndefinedKey:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;KVC-与点语法比较&quot;&gt;&lt;a href=&quot;#KVC-与点语法比较&quot; class=&quot;headerlink&quot; title=&quot;KVC 与点语法比较&quot;&gt;&lt;/a&gt;&lt;strong&gt;KVC 与点语法比较&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;用 KVC 访问属性和用点语法访问属性的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用点语法编译器会做预编译检查，访问不存在的属性编译器会报错，但是用 KVC 方式编译器无法做检查，如果有错误只能运行的时候才能发现（crash）。&lt;/li&gt;
&lt;li&gt;相比点语法用 KVC 方式 KVC 的效率会稍低一点，但是灵活，可以在程序运行时决定访问哪些属性。&lt;/li&gt;
&lt;li&gt;用 KVC 可以访问对象的私有成员变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h2&gt;&lt;h3 id=&quot;字典转模型&quot;&gt;&lt;a href=&quot;#字典转模型&quot; class=&quot;headerlink&quot; title=&quot;字典转模型&quot;&gt;&lt;/a&gt;字典转模型&lt;/h3&gt;&lt;p&gt;&lt;code&gt;- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;KVC-总结&quot;&gt;&lt;a href=&quot;#KVC-总结&quot; class=&quot;headerlink&quot; title=&quot;KVC 总结&quot;&gt;&lt;/a&gt;KVC 总结&lt;/h3&gt;&lt;p&gt;键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要通过 setter、getter 方法去访问对象的属性，&lt;/li&gt;
&lt;li&gt;可以访问私有成员变量的值，可以间接修改私有变量的值。&lt;/li&gt;
&lt;li&gt;可以轻松处理集合类(NSArray)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一旦使用KVC你的编译器无法检查出错误，即不会对设置的键、键值路径进行错误检查。&lt;/li&gt;
&lt;li&gt;执行效率要低于 setter 和 getter 方法。因为使用 KVC 键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量。&lt;/li&gt;
&lt;li&gt;使用 KVC 会破坏类的封装性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;p&gt;KVO 是 Key-Value-Observing 的简称。在Foundation框架中的NSKeyValueObserver.h文件中。&lt;/p&gt;
&lt;p&gt;KVO 是一个观察者模式。观察一个对象的属性，注册一个指定的路径，若这个对象的的属性被修改，则 KVO 会自动通知观察者。&lt;/p&gt;
&lt;p&gt;更通俗的话来说就是任何对象都允许观察其他对象的属性，并且可以接收其他对象状态变化的通知。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 注册观察者，实施监听；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.person&lt;/span&gt; addObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              forKeyPath:&lt;span class=&quot;string&quot;&gt;@&quot;age&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 options:&lt;span class=&quot;built_in&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 context:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 回调方法，在这里处理属性发生的变化；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)observeValueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      ofObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        change:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *,&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;gt; *)change&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       context:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 移除观察者；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; removeObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:@“age&lt;span class=&quot;string&quot;&gt;&quot;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;KVO是基于runtime机制实现的&lt;br&gt;Apple 使用了 isa 搅拌技术（isa-swizzling）来实现的 KVO 。当一个观察者注册对象的一个属性 isa 观察对象的指针被修改，指着一个中间类而不是在真正的类。&lt;/p&gt;
&lt;p&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。&lt;br&gt;派生类在被重写的 setter 方法实现真正的通知机制（Person-&amp;gt;NSKVONotifying_Person）&lt;/p&gt;
&lt;p&gt; 当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。&lt;/p&gt;
&lt;p&gt;原来，这个中间类，继承自原本的那个类。不仅如此，Apple 还重写了 -class 方法，企图欺骗我们这个类没有变，就是原本那个类。更具体的信息，去跑一下 Mike Ash 的那篇文章里的代码就能明白，这里就不再重复。&lt;/p&gt;
&lt;h2 id=&quot;KVO底层实现&quot;&gt;&lt;a href=&quot;#KVO底层实现&quot; class=&quot;headerlink&quot; title=&quot;KVO底层实现&quot;&gt;&lt;/a&gt;KVO底层实现&lt;/h2&gt;&lt;p&gt;当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 (isa 指针告诉 Runtime 系统这个对象的类是什么) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例，如下所示：&lt;/p&gt;
&lt;p&gt;KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 怎么做到的呢?&lt;br&gt;答案是通过 isa 混写（isa-swizzling）。&lt;/p&gt;
&lt;p&gt;第一次对一个对象调用 &lt;code&gt;addObserver:forKeyPath:options:context:&lt;/code&gt; 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setNow:&lt;/span&gt;(NSDate *)aDate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [self &lt;span class=&quot;string&quot;&gt;willChangeValueForKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;aDate &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [self &lt;span class=&quot;string&quot;&gt;didChangeValueForKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。&lt;/p&gt;
&lt;h1 id=&quot;应用-1&quot;&gt;&lt;a href=&quot;#应用-1&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h3 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h3&gt;&lt;p&gt;在AFN中的AFURLSessionManager中使用了KVO&lt;/p&gt;
&lt;p&gt;UIProgressView (AFNetworking)&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加键值观察&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 观察者，负责处理监听事件的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 观察的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 观察的选项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 上下文&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.person &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;forKeyPath:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;options:&lt;/span&gt;NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld &lt;span class=&quot;string&quot;&gt;context:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;Person Name&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;observer中需要实现一下方法：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 所有的 kvo 监听到事件，都会调用此方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1. 观察的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2. 观察的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3. change 属性变化字典（新／旧）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4. 上下文，与监听的时候传递的一致&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;observeValueForKeyPath:&lt;/span&gt;(NSString *)keyPath &lt;span class=&quot;string&quot;&gt;ofObject:&lt;/span&gt;(id)object &lt;span class=&quot;string&quot;&gt;change:&lt;/span&gt;(NSDictionary *)change &lt;span class=&quot;string&quot;&gt;context:&lt;/span&gt;(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; *)context;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]如何手动触发一个value的KVO?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自动触发 KVO 的原理：&lt;/p&gt;
&lt;p&gt;键值观察通知依赖于 NSObject 的两个方法: &lt;code&gt;willChangeValueForKey:&lt;/code&gt;和 &lt;code&gt;didChangevlueForKey:&lt;/code&gt;。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， &lt;code&gt;observeValueForKey:ofObject:change:context:&lt;/code&gt;会被调用，继而 didChangeValueForKey: 也会被调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果可以手动实现这些调用，就可以实现“手动触发”了。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？&lt;br&gt;都可以。 &lt;/li&gt;
&lt;li&gt;[※※※※]KVC的keyPath中的集合运算符如何使用？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必须用在集合对象上或普通对象的集合属性上&lt;/li&gt;
&lt;li&gt;简单集合运算符有@avg， @count ， @max ， @min ，@sum，&lt;/li&gt;
&lt;li&gt;格式 @”@sum.age”或 @”集合属性.@max.age”&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]KVC和KVO的keyPath一定是属性么？&lt;br&gt;[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？&lt;br&gt;[※※※※※]apple用什么方式实现对一个对象的KVO？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leejayID/KVC-KVO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/leejayID/KVC-KVO&lt;/a&gt;&lt;br&gt;Objective-C中的KVC和KVO&lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/#KVO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/#KVO&lt;/a&gt;&lt;br&gt;如何自己动手实现 KVO&lt;a href=&quot;http://tech.glowing.com/cn/implement-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习KVC和KVO。研究源码NSKeyValueCoding.h和NSKeyValueObserving.h.在Foundation框架中。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习RunLoop</title>
    <link href="http://peilinghui.com/2016/07/19/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RunLoop/"/>
    <id>http://peilinghui.com/2016/07/19/深入学习RunLoop/</id>
    <published>2016-07-19T14:45:17.000Z</published>
    <updated>2017-03-23T12:26:41.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。&lt;br&gt;源码：&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://opensource.apple.com/tarballs/CF/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;RunLoop-的概念&quot;&gt;&lt;a href=&quot;#RunLoop-的概念&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 的概念&quot;&gt;&lt;/a&gt;RunLoop 的概念&lt;/h1&gt;&lt;p&gt;其实，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&amp;gt;等待-&amp;gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。  &lt;/p&gt;
&lt;p&gt;OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。&lt;br&gt;&lt;strong&gt;CFRunLoopRef&lt;/strong&gt; 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是&lt;strong&gt;线程安全&lt;/strong&gt;的。&lt;br&gt;&lt;strong&gt;NSRunLoop&lt;/strong&gt; 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API &lt;strong&gt;不是线程安全&lt;/strong&gt;的。它的方法只应在当前线程的上下文中被调用。您不应该尝试调用NSRun​Loop在不同线程中运行的对象的方法，因为这样做可能会导致意外的结果。一个NSRun​Loop对象处理用于来源如从窗口系统鼠标和键盘事件，输入NSPort对象，和NSConnection对象。一个NSRun​Loop对象也处理NSTimer事件。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持程序的持续运行(比如主运行循环)&lt;/li&gt;
&lt;li&gt;处理App中的各种事件（比如触摸事件、定时器事件、Selector事件）&lt;/li&gt;
&lt;li&gt;节省CPU资源，提高程序性能：该做事时做事，该休息时休息&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;RunLoop的工作模式&quot;&gt;&lt;a href=&quot;#RunLoop的工作模式&quot; class=&quot;headerlink&quot; title=&quot;RunLoop的工作模式&quot;&gt;&lt;/a&gt;RunLoop的工作模式&lt;/h1&gt;&lt;p&gt;Run loop接收输入事件来自两种不同的来源：输入源（input source）和定时源（timer source）。两种源都使用程序的某一特定的处理例程来处理到达的事件。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.15.58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RunLoop-内部结构&quot;&gt;&lt;a href=&quot;#RunLoop-内部结构&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 内部结构&quot;&gt;&lt;/a&gt;RunLoop 内部结构&lt;/h2&gt;&lt;p&gt;CFRunloop.h文件中&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//CFRunloop.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_EXTENSIBLE_STRING_ENUM&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopSource&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//是事件产生的地方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserver&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimer&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//基于时间的触发器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  CFRunLoop.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_t _pthread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _commonModes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeRef&lt;/span&gt; _currentMode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _observers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _timers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RunLoop 与线程的关系&lt;/strong&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每条线程都有唯一的一个与之对应的RunLoop对象&lt;/li&gt;
&lt;li&gt;主线程的RunLoop已经自动启动的，子线程的RunLoop需要主动创建。&lt;/li&gt;
&lt;li&gt;RunLoop在第一次获取时创建，在线程结束时销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;iOS的应用程序里面，程序启动后会有一个如下的main（）函数&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  main（&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc，&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * argv []）&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;built_in&quot;&gt;UIApplicationMain&lt;/span&gt;（argc，argv，&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;，&lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;（[AppDelegate class ]））;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重点是UIApplicationMain（）函数，这个方法会为主线程设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候还能立马响应。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在任何一个Cocoa程序的线程中，都可以通过以下代码来获取到当前线程的运行循环。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;NSRunLoop * runloop = [NSRunLoop  currentRunLoop];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关系；&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.37.07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。&lt;/li&gt;
&lt;li&gt;每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。&lt;/li&gt;
&lt;li&gt;如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。&lt;/li&gt;
&lt;li&gt;这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CFRunLoopMode&quot;&gt;&lt;a href=&quot;#CFRunLoopMode&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopMode&quot;&gt;&lt;/a&gt;CFRunLoopMode&lt;/h3&gt;&lt;p&gt;系统默认注册了5个Mode:(前两个跟最后一个常用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行&lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用&lt;/li&gt;
&lt;li&gt;GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到&lt;/li&gt;
&lt;li&gt;kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode。&lt;br&gt;在CFRunLoop.h中暴露的是：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCommonModes&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;CFRunLoopRef&quot;&gt;&lt;a href=&quot;#CFRunLoopRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopRef&quot;&gt;&lt;/a&gt;CFRunLoopRef&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//获取当前线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetMain&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//获取主线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;CFRunLoopSourceRef&quot;&gt;&lt;a href=&quot;#CFRunLoopSourceRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopSourceRef&quot;&gt;&lt;/a&gt;CFRunLoopSourceRef&lt;/h3&gt;&lt;p&gt;CFRunLoopSourceRef是事件源（输入源）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照官方文档的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Port-Based Sources，系统底层的 Port 事件，例如 CFSocketRef ，在应用层基本用不到&lt;/li&gt;
&lt;li&gt;Custom Input Sources，用户手动创建的 Source&lt;/li&gt;
&lt;li&gt;Cocoa Perform Selector Sources， Cocoa 提供的 performSelector 系列方法，也是一种事件源  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;按照函数调用栈的分类&lt;/strong&gt;&lt;br&gt;源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Source0：非基于Port的。 app 内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。&lt;/li&gt;
&lt;li&gt;Source1：基于Port的。包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CFRunLoopTimerRef&quot;&gt;&lt;a href=&quot;#CFRunLoopTimerRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopTimerRef&quot;&gt;&lt;/a&gt;CFRunLoopTimerRef&lt;/h3&gt;&lt;p&gt;CFRunLoopTimerRef是基于时间的触发器,在 iOS 用到的 NSTimer 或者 performSelector:afterDelay: 都是通过它来实现的。使用时先设置一个时间长度和一个回调，然后将其加入 RunLoop，这样 RunLoop 就会注册对应的时间点，当到了该时间点时就会唤醒 RunLoop 来执行那个回调。iOS7 之后，timer 还可有一个 tolerance，因为 timer 不太准确，如上面提到的，某个 mode 下的 timer 在 RunLoop 切换 mode 时可能就失效了，而 tolerance 则用来计算最后能执行那个回调的时间点。&lt;/p&gt;
&lt;p&gt;基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响&lt;/p&gt;
&lt;p&gt;GCD的定时器不受RunLoop的Mode影响&lt;/p&gt;
&lt;h3 id=&quot;CFRunLoopObserverRef&quot;&gt;&lt;a href=&quot;#CFRunLoopObserverRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopObserverRef&quot;&gt;&lt;/a&gt;CFRunLoopObserverRef&lt;/h3&gt;&lt;p&gt;CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变&lt;/p&gt;
&lt;p&gt;可以监听的时间点有以下几个：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Run Loop Observer Activities */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CF_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CFOptionFlags, CFRunLoopActivity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopEntry = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),		&lt;span class=&quot;comment&quot;&gt;//即将进入Loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeTimers = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将处理Timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeSources = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将处理Source&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeWaiting = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将进入休眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopAfterWaiting = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//刚从休眠中唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopExit = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;),       &lt;span class=&quot;comment&quot;&gt;//即将推出Loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopAllActivities = &lt;span class=&quot;number&quot;&gt;0x0FFFFFFF&lt;/span&gt;U&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以使用 CFRunLoopObserverCreateWithHandler() 来创建 observer，创建时设置要监听的状态变化和回调，再用 CFRunLoopAddObserver() 来给 RunLoop 添加 observer，当该 RunLoop 状态发生在监听类型内的变化时，observer 就会执行回调 ：&lt;/p&gt;
&lt;!--## 定时源
![](http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%883.35.47.png)

RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。


--&gt;
&lt;h1 id=&quot;运行逻辑&quot;&gt;&lt;a href=&quot;#运行逻辑&quot; class=&quot;headerlink&quot; title=&quot;运行逻辑&quot;&gt;&lt;/a&gt;运行逻辑&lt;/h1&gt;&lt;h2 id=&quot;获取RunLoop&quot;&gt;&lt;a href=&quot;#获取RunLoop&quot; class=&quot;headerlink&quot; title=&quot;获取RunLoop&quot;&gt;&lt;/a&gt;获取RunLoop&lt;/h2&gt;&lt;p&gt;苹果不允许我们创建 RunLoop，要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数，获取过程大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CF_EXPORT&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_t t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第一次进入时，创建全局 dictionary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建可变字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; dict = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 先创建主线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; mainLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCreate&lt;/span&gt;(pthread_main_thread_np());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 主线程的 RunLoop 存进字典中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(dict, pthread_main_thread_np(), mainLoop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用 传进来的线程 作 key，获取对应的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; loop = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryGetValue&lt;/span&gt;(__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;, t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果获取不到，则新建一个，并存入字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!loop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; newLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCreate&lt;/span&gt;(t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;, pthreadPointer(t), newLoop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取主线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetMain&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!__main) __main = _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_main_thread_np());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __main;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取当前线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_self());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见，线程和 RunLoop 是一一对应的，对应关系保存在一个全局的 dictionary 中。RunLoop 类似懒加载，只有在第一次获取的时候才会创建。当线程销毁时，也销毁对应的 RunLoop。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop的运行&quot;&gt;&lt;a href=&quot;#RunLoop的运行&quot; class=&quot;headerlink&quot; title=&quot;RunLoop的运行&quot;&gt;&lt;/a&gt;RunLoop的运行&lt;/h2&gt;&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 用 &lt;span class=&quot;type&quot;&gt;DefaultMode&lt;/span&gt; 启动(&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;循环)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRun&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;) &amp;#123;	/* &lt;span class=&quot;type&quot;&gt;DOES&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CALLOUT&lt;/span&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int32_t &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(), kCFRunLoopDefaultMode, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;e10, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;CHECK_FOR_FORK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (kCFRunLoopRunStopped != &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; &amp;amp;&amp;amp; kCFRunLoopRunFinished != &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 用指定的 mode 启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;SInt32&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunInMode&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFStringRef&lt;/span&gt; modeName, &lt;span class=&quot;type&quot;&gt;CFTimeInterval&lt;/span&gt; seconds, &lt;span class=&quot;type&quot;&gt;Boolean&lt;/span&gt; returnAfterSourceHandled) &amp;#123;     /* &lt;span class=&quot;type&quot;&gt;DOES&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CALLOUT&lt;/span&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CHECK_FOR_FORK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(), modeName, seconds, returnAfterSourceHandled);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &lt;span class=&quot;type&quot;&gt;RunLoop&lt;/span&gt; 的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;SInt32&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;type&quot;&gt;CFStringRef&lt;/span&gt; modeName, &lt;span class=&quot;type&quot;&gt;CFTimeInterval&lt;/span&gt; seconds, &lt;span class=&quot;type&quot;&gt;Boolean&lt;/span&gt; returnAfterSourceHandled) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 根据 modeName 找到对应的 mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CFRunLoopModeRef&lt;/span&gt; currentMode = __CFRunLoopFindMode(rl, modeName, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 判断 mode 是否为空 (即 source/timer 皆空)，是的话则返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;NULL&lt;/span&gt; == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&amp;gt;_currentMode)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 通知 observers: 即将进入 loop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 进入 loop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 通知 observers： 即将退出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 进入 RunLoop 后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; int32_t __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRun&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_source_t timeout_timer = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置过期时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    seconds = &lt;span class=&quot;number&quot;&gt;9999999999.0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int32_t retVal = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开始 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 告诉 observer：要处理 timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeTimers&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   &lt;span class=&quot;comment&quot;&gt;// 告诉 observer：要处理 sources&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeSources&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行被加入的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 处理 Sources0（非 port）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Boolean sourceHandledThisLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoSources0&lt;/span&gt;(rl, rlm, stopAfterHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceHandledThisLoop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!didDispatchPortLastTime) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果有 GCD 分发到 main queue 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopServiceMachPort&lt;/span&gt;(dispatchPort, &amp;amp;msg)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 跳过睡眠阶段，直接去处理消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; handle_msg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知 observers：即将进入睡眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; () __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeWaiting&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 调用 mach_msg 等待接受 mach_port 的消息，线程将进入睡眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopServiceMachPort&lt;/span&gt;(waitSet, &amp;amp;msg, ...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知 observers：刚被唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAfterWaiting&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 处理消息的标记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handle_msg:;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过判断端口，找出要处理的事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (MACH_PORT_NULL == livePort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 纯粹是被手动唤醒的，无消息，则不做任何处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (livePort == rlm-&amp;gt;_timerPort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;comment&quot;&gt;// 被 timer 唤醒,则触发这个 timer 的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoTimers&lt;/span&gt;(rl, rlm, mach_absolute_time())；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (livePort == dispatchPort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;comment&quot;&gt;// 被 GCD 唤醒,则执行所有调用 dispatch_async 等方法放入main queue 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__&lt;/span&gt;(msg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 如果被 source1（基于 port） 唤醒的，则处理这个事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoSource1&lt;/span&gt;(rl, rlm, &amp;amp;reply) || sourceHandledThisLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; != reply) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               mach_msg(reply, MACH_SEND_MSG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行加入到 loop 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 判断是否应该退出 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 传入的参数是否说明应该在处理完事件就返回&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunHandledSource&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 是否过期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunTimedOut&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopIsStopped&lt;/span&gt;(rl)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 是否被强制停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rlm-&amp;gt;_stopped) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeIsEmpty&lt;/span&gt;(rl, rlm)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// mode 是否为空，即 source、timer 为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunFinished&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 都不是，则继续 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; == retVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retVal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而判断 mode 的逻辑大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__CFRunLoopModeIsEmpty() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources0 &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFSetGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources0)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources1 &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFSetGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources1)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_timers &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFArrayGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_timers)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h2 id=&quot;AutoreleasePool（自动释放池）&quot;&gt;&lt;a href=&quot;#AutoreleasePool（自动释放池）&quot; class=&quot;headerlink&quot; title=&quot;AutoreleasePool（自动释放池）&quot;&gt;&lt;/a&gt;AutoreleasePool（自动释放池）&lt;/h2&gt;&lt;p&gt;一般我们比较关心的是自动释放池什么时候会释放？&lt;br&gt;在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;CFRunLoopObserver&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;activities = 0x1, callout = _wrapRunLoopWithAutoreleasePoolHandler&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;CFRunLoopObserver&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即 app 启动后，苹果会给 RunLoop 注册很多个 observers，其中有两个是跟自动释放池相关的，其回调都是 &lt;code&gt;_wrapRunLoopWithAutoreleasePoolHandler()&lt;/code&gt;&lt;br&gt;第一个 observer 监听的是 activities = 0x1（kCFRunLoopEntry），也就是在即将进入 loop 时，其回调会调用 &lt;code&gt;_objc_autoreleasePoolPush()&lt;/code&gt; 创建自动释放池；&lt;br&gt;第二个 observer 监听的是 &lt;code&gt;activities = 0xa0（kCFRunLoopBeforeWaiting | kCFRunLoopExit）&lt;/code&gt;，即监听的是准备进入睡眠和即将退出 loop 两个事件。在准备进入睡眠之前，因为睡眠可能时间很长，所以为了不占用资源先调用 &lt;code&gt;_objc_autoreleasePoolPop()&lt;/code&gt;释放旧的释放池，并调用 &lt;code&gt;_objc_autoreleasePoolPush()&lt;/code&gt; 创建新建一个新的，用来装载被唤醒后要处理的事件对象；在最后即将退出 loop 时则会 &lt;code&gt;_objc_autoreleasePoolPop()&lt;/code&gt; 释放池子。&lt;/p&gt;
&lt;h2 id=&quot;事件响应&quot;&gt;&lt;a href=&quot;#事件响应&quot; class=&quot;headerlink&quot; title=&quot;事件响应&quot;&gt;&lt;/a&gt;事件响应&lt;/h2&gt;&lt;p&gt;苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件。&lt;br&gt;_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括&lt;strong&gt;识别 UIGesture/处理屏幕旋转/发送给 UIWindow&lt;/strong&gt; 等。通常事件比如 &lt;strong&gt;UIButton 点击&lt;/strong&gt;、&lt;strong&gt;touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;手势识别&quot;&gt;&lt;a href=&quot;#手势识别&quot; class=&quot;headerlink&quot; title=&quot;手势识别&quot;&gt;&lt;/a&gt;手势识别&lt;/h2&gt;&lt;p&gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。&lt;/p&gt;
&lt;p&gt;当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。&lt;/p&gt;
&lt;h2 id=&quot;界面更新&quot;&gt;&lt;a href=&quot;#界面更新&quot; class=&quot;headerlink&quot; title=&quot;界面更新&quot;&gt;&lt;/a&gt;界面更新&lt;/h2&gt;&lt;p&gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;h2 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h2&gt;&lt;p&gt;NSTimer 其实就是 CFRunLoopTimerRef。&lt;br&gt;解决界面卡顿&lt;/p&gt;
&lt;h2 id=&quot;PerformSelecter&quot;&gt;&lt;a href=&quot;#PerformSelecter&quot; class=&quot;headerlink&quot; title=&quot;PerformSelecter&quot;&gt;&lt;/a&gt;PerformSelecter&lt;/h2&gt;&lt;p&gt;当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。&lt;/p&gt;
&lt;p&gt;当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop-与-GCD&quot;&gt;&lt;a href=&quot;#RunLoop-与-GCD&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 与 GCD&quot;&gt;&lt;/a&gt;RunLoop 与 GCD&lt;/h2&gt;&lt;p&gt;RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。 例如 dispatch_async()。&lt;br&gt;当调用 &lt;code&gt;dispatch_async(dispatch_get_main_queue(), block)&lt;/code&gt;时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 &lt;code&gt;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()&lt;/code&gt; 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。&lt;/p&gt;
&lt;h2 id=&quot;UIImageView-延迟加载图片&quot;&gt;&lt;a href=&quot;#UIImageView-延迟加载图片&quot; class=&quot;headerlink&quot; title=&quot;UIImageView 延迟加载图片&quot;&gt;&lt;/a&gt;UIImageView 延迟加载图片&lt;/h2&gt;&lt;p&gt;给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。&lt;/p&gt;
&lt;h2 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h2&gt;&lt;p&gt;子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。具体做法是：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 返回一个线程 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *)networkRequestThread &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *_networkRequestThread = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; oncePredicate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;oncePredicate, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建一个线程，并在该线程上执行下一个方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _networkRequestThread = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(networkRequestThreadEntryPoint:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                          object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 开启线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_networkRequestThread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _networkRequestThread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 在新开的线程中执行的第一个方法 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)networkRequestThreadEntryPoint:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)__unused object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread] setName:&lt;span class=&quot;string&quot;&gt;@&quot;AFNetworking&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取当前线程对应的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; *runLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 为 RunLoop 添加 source，模式为 DefaultMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop addPort:[&lt;span class=&quot;built_in&quot;&gt;NSMachPort&lt;/span&gt; port] forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 开始运行 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop run];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。&lt;/p&gt;
&lt;h2 id=&quot;AsyncDisplayKit&quot;&gt;&lt;a href=&quot;#AsyncDisplayKit&quot; class=&quot;headerlink&quot; title=&quot;AsyncDisplayKit&quot;&gt;&lt;/a&gt;AsyncDisplayKit&lt;/h2&gt;&lt;p&gt;AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，&lt;/p&gt;
&lt;h1 id=&quot;与-Runloop-相关的坑&quot;&gt;&lt;a href=&quot;#与-Runloop-相关的坑&quot; class=&quot;headerlink&quot; title=&quot;与 Runloop 相关的坑&quot;&gt;&lt;/a&gt;与 Runloop 相关的坑&lt;/h1&gt;&lt;p&gt;日常开发中，与 runLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行。&lt;/p&gt;
&lt;p&gt;有如下两种解决方案：&lt;/p&gt;
&lt;p&gt;第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。&lt;br&gt;第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。&lt;br&gt;在 AFNetworking 3.0 中，就有相关的代码，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)startActivationDelayTimer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelayTimer&lt;/span&gt; = [&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; timerWithTimeInterval:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelay&lt;/span&gt; target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(activationDelayTimerFired) userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; repeats:&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; mainRunLoop] addTimer:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelayTimer&lt;/span&gt; forMode:&lt;span class=&quot;built_in&quot;&gt;NSRunLoopCommonModes&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里就是添加了一个计时器，由于指定了 NSRunLoopCommonModes，所以不管 RunLoop 出于什么状态，都执行这个计时器任务。&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;[※※※]runloop和线程有什么关系？&lt;/li&gt;
&lt;li&gt;[※※※]runloop的mode作用是什么？&lt;br&gt;model主要是用来指定事件在运行循环中的优先级的，分为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态  &lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：ScrollView滑动时&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode：启动时&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）：模式集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;苹果公开提供的模式有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]猜想runloop内部是如何实现的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何刷新View界面？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程和RunLoop的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer有什么需注意的以及和RunLoop的关系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;主线程runloop(mainRunloop)主要执行事件：&lt;br&gt;负责创建Autoreleasepool和释放autoreleasepool,  周期大概是event loop(事件循环)；&lt;br&gt;事件响应—&amp;gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;手势识别—&amp;gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;界面更新—&amp;gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NSTimer事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PerformSelecter—&amp;gt;performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;br&gt;iOS RunLoop进阶:&lt;a href=&quot;http://www.jianshu.com/p/2c067bdc7e47#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/2c067bdc7e47#&lt;/a&gt;&lt;br&gt;解密-神秘的RunLoop：&lt;a href=&quot;http://www.jianshu.com/p/cf4915508929&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/cf4915508929&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/&lt;/a&gt;&lt;br&gt;RunLoop源码观察:&lt;a href=&quot;http://tutudev.com/2016/06/28/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tutudev.com/2016/06/28/runloop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入理解RunLoop&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/05/18/runloop/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。&lt;br&gt;源码：&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot;&gt;https://opensource.apple.com/tarballs/CF/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot;&gt;API&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入学习GCD</title>
    <link href="http://peilinghui.com/2016/07/05/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0GCD/"/>
    <id>http://peilinghui.com/2016/07/05/深入学习GCD/</id>
    <published>2016-07-05T08:22:32.000Z</published>
    <updated>2017-03-20T02:31:38.000Z</updated>
    
    <content type="html">&lt;p&gt;再次学习GCD的内容，并总结。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;h3 id=&quot;GCD概要&quot;&gt;&lt;a href=&quot;#GCD概要&quot; class=&quot;headerlink&quot; title=&quot;GCD概要&quot;&gt;&lt;/a&gt;GCD概要&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;异步执行的技术之一，开发者只需要定义向执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(queue,^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(),^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//主线程可以执行的处理：用户页面更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程, 并发&lt;/strong&gt;&lt;br&gt; 一个应用就相当于一个进程, 而一个进程可以同时分发几个线程同时处理任务.而并发正是一个进程开启多个线程同时执行任务的意思, 主线程专门用来刷新UI,处理触摸事件等 而子线程呢, 则用来执行耗时的操作, 例如访问数据库, 下载数据等..&lt;br&gt;1个CPU执行的CPU命令列为一条无分叉路径，即为“线程”。&lt;br&gt;由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU能够并列执行多个线程一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的优势&lt;/strong&gt;&lt;br&gt;说到优势, 当然有比较, 才能显得出优势所在. 事实上, iOS中我们能使用的多线程管理技术有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pthread(来自Clang, 纯C语言, 需要手动创建线程, 销毁线程, 手动进行线程管理. 而且代码极其恶心, )
NSThread(Foundation框架下的OC对象, 依旧需要自己进行线程管理，线程同步。 线程同步对数据的加锁会有一定的开销。)
GCD(两个字, 牛逼, 虽然是纯C语言, 但是它用难以置信的非常简洁的方式实现了极其复杂的多线程编程, 而且还支持block内联形式进行制定任务. 简洁! 高效! 而且我们再也不用手动进行线程管理了.)
NSOperationQueue(相当于Foundation框架的GCD, 以面向对象的语法对GCD进行了封装. 效率一样高)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下优点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。
GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。
GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;GCD的API&quot;&gt;&lt;a href=&quot;#GCD的API&quot; class=&quot;headerlink&quot; title=&quot;GCD的API&quot;&gt;&lt;/a&gt;GCD的API&lt;/h3&gt;&lt;p&gt;在介绍GCD的API之前, 我们先搞清楚四个名词: 串行, 并行, 同步, 异步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;串行 : 一个任务执行完, 再执行下一个任务
并行 : 多个任务同时执行
同步 : 在当前线程中执行任务, 不具备开启线程的能力
异步 : 在新的线程中执行任务, 具备开启线程的能力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Dispatch Queue&lt;/strong&gt;&lt;br&gt;Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.队列分两种.&lt;br&gt;一种是串行队列(Serial Dispatch Queue),&lt;br&gt;一种是并行队列(Concurrent Dispatch Queue).  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch Queue的种类            说明  
Serial Dispatch Queue            等待现在执行中处理结束  
Concurrent Dispatch Queue       不等待现在执行中处理结束
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并发队列 : 让多个任务同时执行(自动开启多个线程执行任务)&lt;br&gt;并发功能只有在异步函数(dispatch_async)下才有效(想想看为什么?)&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%885.08.16.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建队列&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)&lt;/code&gt;&lt;br&gt; 手动创建一个队列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label : 队列的标识符, 日后可用来调试程序
attr : 队列类型
DISPATCH_QUEUE_CONCURRENT : 并发队列
DISPATCH_QUEUE_SERIAL 或 NULL : 串行队列
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是, 通过dispatch_queue_create函数生成的queue在使用结束后需要通过dispatch_release函数来释放.(只有在MRC下才需要释放)&lt;/p&gt;
&lt;p&gt;并不是什么时候都需要手动创建队列, 事实上系统给我们提供2个很常用的队列. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主队列&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_get_main_queue();&lt;/code&gt;&lt;br&gt;该方法返回的是主线程中执行的同步队列. 用户界面的更新等一些必须在主线程中执行的操作追加到此队列中.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局并发队列&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_get_global_queue(long identifier, unsigned long flags);&lt;/code&gt;&lt;br&gt;该方法返回的是全局并发队列. 使用十分广泛.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;identifier : 优先级
DISPATCH_QUEUE_PRIORITY_HIGH : 高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT : 默认优先级
DISPATCH_QUEUE_PRIORITY_LOW : 低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND : 后台优先级
flags : 暂时用不上, 传 0 即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 : 对Main Dispatch Queue和Global Dispatch Queue执行dispatch_release和dispatch_retain没有任何问题. (MRC)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_sync(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下同步执行block&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_async(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下异步执行block(开启新线程)&lt;br&gt;dispatch_async 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_time(dispatch_time_t when, int64_t delta);&lt;/code&gt;&lt;br&gt;根据传入的时间(when)和延迟(delta)计算出一个未来的时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;when :
DISPATCH_TIME_NOW : 现在
DISPATCH_TIME_FOREVER : 永远(别传这个参数, 否则该时间很大)
delta : 该参数接收的是纳秒, 可以用一个宏NSEC_PER_SEC来进行转换, 例如你要延迟3秒, 则为 3 * NSEC_PER_SEC.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;延迟执行&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_after(dispatch_time_t when, dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有了上述获取时间的函数, 则可以直接把时间传入, 然后定义该延迟执行的block在哪一个queue队列中执行.&lt;br&gt;苹果还给我们提供了一个在主队列中延迟执行的代码块, 如下&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;, &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;delayInSeconds&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            code to be executed after a specified delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要传入需要延迟的秒数(delayInSeconds)和执行的任务block就可以直接调用了, 方便吧~&lt;/p&gt;
&lt;p&gt;注意 : 延迟执行不是在指定时间后执行任务处理, 而是在指定时间后将处理追加到队列中, 这个是要分清楚的.还是在主队列做这些操作吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列组&lt;/strong&gt;  （调度组）&lt;br&gt;Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 dispatch_group_t 的实例来记下这些不同的任务。&lt;/p&gt;
&lt;p&gt;当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。&lt;br&gt;第一种是 &lt;code&gt;dispatch_group_wait&lt;/code&gt;，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的&lt;br&gt;第二章是&lt;code&gt;dispatch_group_notify&lt;/code&gt;,以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 completionBlock 便会运行。你还指定了运行 completionBlock 的队列，此处，主队列就是你所需要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 dispatch_source_create 如何工作。下面是创建一个源的函数原型：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;dispatch_source_t&lt;/span&gt; dispatch_source_create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;dispatch_source_type_t&lt;/span&gt; type,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; handle,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; mask,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 Xcode 文档 得到哪些选项可用于每个 dispatch_source_type_t 参数。&lt;/p&gt;
&lt;p&gt;下面你将监控 DISPATCH_SOURCE_TYPE_SIGNAL 。如文档所显示的：&lt;/p&gt;
&lt;p&gt;一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_group_create();&lt;/code&gt;&lt;br&gt;有时候我们想要在队列中的多个任务都处理完毕之后做一些事情, 就能用到这个Group. 同队列一样, Group在使用完毕也是需要dispatch_release掉的(MRC).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栅栏&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dispatch_barrier_async(dispatch_queue_t queue, ^(void)block)&lt;/code&gt;&lt;br&gt;GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。&lt;br&gt;在访问数据库或文件时, 为了提高效率, 读取操作放在并行队列中执行. 但是写入操作必须在串行队列中执行(避免资源抢夺问题). 为了避免麻烦, 此时dispatch_barrier_async函数作用就出来了, 在这函数里进行写入操作, 写入操作会等到所有读取操作完毕后, 形成一道栅栏, 然后进行写入操作, 写入完毕后再把栅栏移除, 同时开放读取操作. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // code here
});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行10次代码, index顺序不确定. dispatch_apply会等待全部处理执行结束才会返回. 意味着dispatch_apply会阻塞当前线程. 所以&lt;strong&gt;dispatch_apply一般用于异步函数的block中.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那何时才适合用 dispatch_apply 呢？&lt;/p&gt;
&lt;p&gt;自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。&lt;br&gt;主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。&lt;br&gt;并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次性代码&lt;/strong&gt;&lt;br&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 只执行1次的代码(这里面默认是线程安全的)
});&lt;/code&gt;&lt;br&gt;该代码在整个程序的生命周期中只会执行一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂起和恢复&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_suspend(queue)&lt;/code&gt;&lt;br&gt;挂起指定的queue队列, 对已经执行的没有影响, 追加到队列中尚未执行的停止执行.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_resume(queue)&lt;/code&gt;&lt;br&gt;恢复指定的queue队列, 使尚未执行的处理继续执行. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的注意点&lt;/strong&gt;&lt;br&gt;因为在ARC下, 不需要我们释放自己创建的队列, 所以GCD的注意点就剩下死锁&lt;br&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;dispatch_sync&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;222&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;333&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三行代码将输出什么?&lt;br&gt;111&lt;br&gt;222&lt;br&gt;333 ?&lt;br&gt;还是&lt;br&gt;111&lt;br&gt;333 ?&lt;br&gt;其实都不对, 输出结果是&lt;br&gt;111&lt;br&gt;无疑问会先输出111, 然后在当前队列下调用dispatch_sync函数, dispatch_sync函数会把block追加到当前队列上, 然后等待block调用完毕该函数才会返回, 不巧的是, block在队列的尾端, 而队列正在执行的是dispatch_sync函数. 现在的情况是, block不执行完毕, dispatch_sync函数就不能返回, dispatch_sync不返回, 就没机会执行block函数. 这种你等我, 我也等你的情况就是死锁, 后果就是大家都执行不了, 当前线程卡死在这里.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免死锁?&lt;/strong&gt;&lt;br&gt;不要在当前队列使用同步函数, 在队列嵌套的情况下也不允许. 如下图,&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AD%BB%E9%94%81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;队列嵌套调用同步函数引发死锁&lt;/p&gt;
&lt;p&gt;大家可以想象, 队列1执行完NSLog后到队列2中执行NSLog, 队列2执行完后又跳回队列1中执行NSLog, 由于都是同步函数, 所以最内层的NSLog(“333”); 追加到队列1中, 实际上最外层的dispatch_sync是还没返回的, 所以它没有执行的机会. 也形成死锁. 运行程序, 果不其然, 打印如下 :&lt;br&gt;111&lt;br&gt;222&lt;/p&gt;
&lt;h3 id=&quot;GCD实现-GCD的使用场景&quot;&gt;&lt;a href=&quot;#GCD实现-GCD的使用场景&quot; class=&quot;headerlink&quot; title=&quot;GCD实现.(GCD的使用场景)&quot;&gt;&lt;/a&gt;GCD实现.(GCD的使用场景)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是GCD最常用的使用场景了, 如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 执行耗时操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;()&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 回到主线程作刷新UI等操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不阻塞主线程, 我们总是在后台线程中发送网络请求, 处理数据, 然后再回到主线程中刷新UI界面.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例&lt;/strong&gt;&lt;br&gt;     &lt;br&gt;单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了&lt;strong&gt;dispatch_once函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列和锁&lt;/strong&gt;&lt;br&gt;利用队列, 实现getter方法可以并发执行, 而setter方法串行执行并且setter和getter不能并发执行呢??? 没错, 我们这里用到了dispatch_barrier_async函数.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; )myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; localMyString = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        localMyString = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; localMyString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setMyString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_barrier_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _myString = myString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里利用了栅栏块必须单独执行, 不能与其他块并行的特性, 写入操作就必须等当前的读取操作都执行完毕, 然后单独执行写入操作, 等待写入操作执行完毕后再继续处理读取. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;它是BSD系内核惯有功能kqueue的包装. kqueue的CPU负荷非常小, 可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种. &lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;介绍一下GCD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有GCD，你怎样实现多线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSthread的缺点是什么？使用NSthread怎么实现数据同步？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何防止死锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD如何实现同步任务，即如何执行完一段代码后再去执行另一段代码；（线程组，barrier，信号量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS中如何实现单例，用GCD来实现一下；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;GCD中如何创建异步线程，GCD中是否能stop一个线程执行； &lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD中有哪些方法？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD和NSOperation的区别；哪一个的复用性更好；NSOperation的队列可以cancel吗，里面的任务可以cancel吗； NSOperation并发有顺序吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多线程有哪几种实现方式，GCD的具体使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD中的数据不安全是怎么处理的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_main,同步和异步如何使用;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD指向了野指针了怎么办&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD有何缺点？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;br&gt;使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt; = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt; = dispatch_group_create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片1 */&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片2 */&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片3 */&lt;/span&gt; &amp;#125;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notify(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 合并图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]dispatch_barrier_async的作用是什么？&lt;/li&gt;
&lt;li&gt;[※※※※※]苹果为什么要废弃dispatch_get_current_queue？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;br&gt;Objective-C高级编程书。&lt;br&gt;&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;再次学习GCD的内容，并总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Runtime</title>
    <link href="http://peilinghui.com/2016/07/05/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Runtime/"/>
    <id>http://peilinghui.com/2016/07/05/深入学习Runtime/</id>
    <published>2016-07-05T08:22:32.000Z</published>
    <updated>2017-03-27T02:16:03.000Z</updated>
    
    <content type="html">&lt;p&gt;研究Runtime的源码。看runtime.h文件。runtime是一套比较底层的纯C语言API。平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;有什么用？&lt;br&gt; runtime是属于OC的底层, 可以进行一些非常底层的操作。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt; 发送消息(objc_send)
2&amp;gt; 交换方法(method_exchangeImplementations)
3&amp;gt; 动态创建一个类（比如KVO的底层实现）  
4&amp;gt; 动态添加方法，（performSelector）
5&amp;gt; 给分类添加属性。(其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间) objc_setAssociatedObject与objc_getAssociatedObject
6&amp;gt; 字典转模型（利用runtime,遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。）
6&amp;gt; 可以把消息转发给想要的对象，或者随意交换一个方法的实现。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;objc的文件夹中的源码文件，看完就能明白runtime和对象消息转发机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-07%20%E4%B8%8B%E5%8D%883.09.36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Objective-C的元素&quot;&gt;&lt;a href=&quot;#Objective-C的元素&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的元素&quot;&gt;&lt;/a&gt;Objective-C的元素&lt;/h2&gt;&lt;p&gt;你创建的每个类（派生形式NSObject / NSObject子类）将在堆上分配并将返回一个指针。&lt;br&gt;先看objc.h文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !OBJC_TYPES_DEFINED&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// An opaque type that represents an Objective-C class.**Class是一个指向objc_class结构体的指针**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//我们所说的类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// Represents an instance of a class.isa是一个指向objc_class结构体的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// A pointer to an instance of a class.id是一个指向objc_object结构体的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//我们所说的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object *id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再看runtime.h文件中关于objc_class的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Class isa                                 OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// metaclass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Class super_class                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 父类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                              OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 该类的实例变量大小（包括从父类继承下来的实例变量）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars              OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 该类的成员变量地址列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                  OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 缓存最近使用的方法地址，用于提升效率；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols      OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 存储该类声明遵守的协议的列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Use `Class` instead of `struct objc_class *` */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由此可以看到，对象(id)就是一个isa指针，而类(class)中不仅有isa指针，还有其他成员变量。类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object也就是中的isa)，这样我们就可以区别对象和类了。&lt;/p&gt;
&lt;p&gt;再仔细看其中成员变量的含义：&lt;/p&gt;
&lt;h3 id=&quot;1-isa：&quot;&gt;&lt;a href=&quot;#1-isa：&quot; class=&quot;headerlink&quot; title=&quot;1. isa：&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;isa&lt;/strong&gt;：&lt;/h3&gt;&lt;p&gt;id中的isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）。&lt;br&gt;而class中的isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。&lt;/p&gt;
&lt;h4 id=&quot;2-super-class&quot;&gt;&lt;a href=&quot;#2-super-class&quot; class=&quot;headerlink&quot; title=&quot;2. super_class:&quot;&gt;&lt;/a&gt;2. super_class:&lt;/h4&gt;&lt;p&gt;指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。&lt;/p&gt;
&lt;p&gt;类与对象的继承层次关系如图（图片源自网络）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/objective-runtime-1.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;所有的class中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。&lt;/p&gt;
&lt;h4 id=&quot;3-SEL&quot;&gt;&lt;a href=&quot;#3-SEL&quot; class=&quot;headerlink&quot; title=&quot;3. SEL:&quot;&gt;&lt;/a&gt;3. SEL:&lt;/h4&gt;&lt;p&gt;&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;SEL是selector在Objective-C中的表示类型。selector可以理解为区别方法的ID。&lt;/p&gt;
&lt;h4 id=&quot;4-IMP&quot;&gt;&lt;a href=&quot;#4-IMP&quot; class=&quot;headerlink&quot; title=&quot;4. IMP:&quot;&gt;&lt;/a&gt;4. IMP:&lt;/h4&gt;&lt;p&gt;是“implementation”的缩写，它是由编译器生成的&lt;strong&gt;方法实现的一个函数指针&lt;/strong&gt;。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。(obj.h)&lt;br&gt;一个函数是由一个selector(SEL)，和一个implement(IML)组成的；Selector相当于门牌号，而Implement才是真正的住户（函数实现）。理解Selector和Implementation的关系蛮重要的！&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/// A &lt;span class=&quot;type&quot;&gt;pointer&lt;/span&gt; to the function &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; implementation. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#if !OBJC_OLD_DISPATCH_PROTOTYPES&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;type&quot;&gt;IMP&lt;/span&gt;)(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; /* id, &lt;span class=&quot;type&quot;&gt;SEL&lt;/span&gt;, ... */ ); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef id (*&lt;span class=&quot;type&quot;&gt;IMP&lt;/span&gt;)(id, &lt;span class=&quot;type&quot;&gt;SEL&lt;/span&gt;, ...); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;5-Method：&quot;&gt;&lt;a href=&quot;#5-Method：&quot; class=&quot;headerlink&quot; title=&quot;5. Method：&quot;&gt;&lt;/a&gt;5. Method：&lt;/h4&gt;&lt;p&gt;Method代表类中的某个方法的类型。(runtime.h中)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_method *Method;&lt;/code&gt;&lt;br&gt;objc_method的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL method_name                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *method_types                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IMP method_imp                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;6-Ivar&quot;&gt;&lt;a href=&quot;#6-Ivar&quot; class=&quot;headerlink&quot; title=&quot;6. Ivar:&quot;&gt;&lt;/a&gt;6. Ivar:&lt;/h4&gt;&lt;p&gt;代表类中实例变量的类型&lt;code&gt;typedef struct objc_ivar *Ivar;&lt;/code&gt;&lt;br&gt;objc_ivar的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_name                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 变量名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_type                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 变量类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_offset                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 基地址偏移字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 占用空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;7-Category&quot;&gt;&lt;a href=&quot;#7-Category&quot; class=&quot;headerlink&quot; title=&quot;7. Category :&quot;&gt;&lt;/a&gt;7. Category :&lt;/h4&gt;&lt;p&gt;代表一个分类&lt;code&gt;typedef struct objc_category *Category;&lt;/code&gt;&lt;br&gt;objc_category的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_category &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *category_name                                      OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *class_name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list *instance_methods                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list *class_methods                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在运行时，类（包括class和metaclass）的objc_class结构体是固定的，不可能往这个结构体中添加数据，只能修改！譬如可以修改isa指针，让它指向一个中间类；在我的理解里，应该也可以修改ivars和methodLists，让它们指向一个新的区域；若可以这样，那么就可以在运行时随意添加/修改/删除成员变量和方法了。&lt;br&gt;但是，貌似Objective-C Runtime没有提供修改ivars和methodLists指针值的接口。&lt;br&gt;也因此，ivars在运行时指向的是一个固定区域，当然可以修改这个区域的值了，但这其实只是修改成员变量值而已；「在这个内存区域后面续上一段空余区域用于存放新的成员变量」？呵呵，想多了吧！因此，我们没办法在运行时为对象添加成员变量，这解释了为什么category中不能定义property（dynamic property不算）；&lt;br&gt;P.S: 那为什么protocol中可以添加变量，在我的理解里，protocol是在编译器处理的。所以objc_class中有一个变量叫protocols；&lt;br&gt;和ivars不同，methodLists是一个二维数组。虽然我们没办法扩展methodLists指向的内存区域，但是我们可以改变这个内存区域（这个内存区域存储的都是指针）的值。因此，我们可以在运行时动态添加（以及做其他的处理，譬如交换等）方法！&lt;/p&gt;
&lt;h4 id=&quot;8-objc-property-t&quot;&gt;&lt;a href=&quot;#8-objc-property-t&quot; class=&quot;headerlink&quot; title=&quot;8. objc_property_t:&quot;&gt;&lt;/a&gt;8. objc_property_t:&lt;/h4&gt;&lt;p&gt;objc_property_t是属性，它可以动态的为已存在的类添加新的方法。它的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;&lt;br&gt;objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name; &lt;span class=&quot;comment&quot;&gt;// 名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *value;  &lt;span class=&quot;comment&quot;&gt;// 值（通常是空的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;objc_property_attribute_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;9-Cache&quot;&gt;&lt;a href=&quot;#9-Cache&quot; class=&quot;headerlink&quot; title=&quot;9. Cache&quot;&gt;&lt;/a&gt;9. Cache&lt;/h4&gt;&lt;p&gt;Catch的定义如下：&lt;/p&gt;
&lt;p&gt;typedef struct objc_cache *Cache&lt;br&gt;objc_cache的定义如下：&lt;/p&gt;
&lt;p&gt;struct objc_cache {&lt;br&gt;    unsigned int mask                   OBJC2_UNAVAILABLE;&lt;br&gt;    unsigned int occupied               OBJC2_UNAVAILABLE;&lt;br&gt;    Method buckets[1]                   OBJC2_UNAVAILABLE;&lt;br&gt;};&lt;br&gt;mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。&lt;br&gt;occupied: 实际占用cache buckets的总数。&lt;br&gt;buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。&lt;br&gt;&lt;strong&gt;objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;10-Module&quot;&gt;&lt;a href=&quot;#10-Module&quot; class=&quot;headerlink&quot; title=&quot;10.Module&quot;&gt;&lt;/a&gt;10.Module&lt;/h4&gt;&lt;p&gt;Module定义如下：&lt;br&gt;&lt;code&gt;typedef struct objc_module *Module                           OBJC2_UNAVAILABLE;&lt;/code&gt;&lt;br&gt;objc_module定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_module &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Symtab symtab                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Objective-C的消息传递&quot;&gt;&lt;a href=&quot;#Objective-C的消息传递&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的消息传递&quot;&gt;&lt;/a&gt;Objective-C的消息传递&lt;/h2&gt;&lt;p&gt;消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；&lt;/p&gt;
&lt;p&gt;消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现&lt;/p&gt;
&lt;p&gt;消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。&lt;/p&gt;
&lt;h3 id=&quot;objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend的作用&quot;&gt;&lt;/a&gt;objc_msgSend的作用&lt;/h3&gt;&lt;p&gt;在面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会从对象发送消息转换成Runtime的objc_msgSend函数调用。&lt;br&gt;例如某实例变量receiver实现某一个方法oneMethod&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[receiver oneMethod];&lt;/code&gt;&lt;br&gt;Runtime会将其转成类似这样的代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector);&lt;/code&gt;&lt;br&gt;具体会转换成什么代码呢？&lt;/p&gt;
&lt;p&gt;objc_msgSend:普通的消息都会通过该函数发送&lt;br&gt;objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值&lt;br&gt;objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例&lt;br&gt;objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值。&lt;/p&gt;
&lt;p&gt;objc_msgSend函数的调用过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。&lt;/li&gt;
&lt;li&gt;检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。&lt;/li&gt;
&lt;li&gt;如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。&lt;/li&gt;
&lt;li&gt;如果 cache 找不到就找一下方法分发表。&lt;/li&gt;
&lt;li&gt;如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。&lt;/li&gt;
&lt;li&gt;如果还找不到就要开始进入动态方法解析了，后面会提到。&lt;br&gt;PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举 objc_msgSend(obj, foo) 这个例子来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，通过 obj 的 isa 指针找到它的 class ;
在 class 的 method list 找 foo ;
如果 class 中没到 foo，继续往它的 superclass 中找 ;
一旦找到 foo 这个函数，就去执行它的实现IMP .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.&lt;/p&gt;
&lt;h4 id=&quot;第11条：理解objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#第11条：理解objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;第11条：理解objc_msgSend的作用&quot;&gt;&lt;/a&gt;第11条：理解objc_msgSend的作用&lt;/h4&gt;&lt;p&gt;消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。&lt;br&gt;OC的消息机制&lt;br&gt;&lt;code&gt;[someObject messageName: parameter]&lt;/code&gt;&lt;br&gt;&lt;code&gt;id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&amp;quot;方法列表&amp;quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&amp;quot;消息转发&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一些函数：&lt;br&gt;objc_msgSend_stret:待发送的消息要返回结构体&lt;br&gt;objc_msgSend_fpret:消息返回的是浮点数&lt;br&gt;objc_msgSendSuper:要给超类发送消息&lt;/p&gt;
&lt;h3 id=&quot;动态方法解析和转发&quot;&gt;&lt;a href=&quot;#动态方法解析和转发&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析和转发&quot;&gt;&lt;/a&gt;动态方法解析和转发&lt;/h3&gt;&lt;p&gt;动态解析流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8A%E5%8D%889.16.01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象在收到无法解读的消息后，首先将调用其所属类的下列方法：(NSObject.h中)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//尚未实现的方法是类方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)&lt;span class=&quot;string&quot;&gt;resolveClassMethod:&lt;/span&gt;(SEL)sel &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//尚未实现的方法是实例方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)&lt;span class=&quot;string&quot;&gt;resolveInstanceMethod:&lt;/span&gt;(SEL)sel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这步会进入forwardingTargetForSelector:方法，&lt;br&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；&lt;br&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。&lt;br&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;第12条：消息转发机制&quot;&gt;&lt;a href=&quot;#第12条：消息转发机制&quot; class=&quot;headerlink&quot; title=&quot;第12条：消息转发机制&quot;&gt;&lt;/a&gt;第12条：消息转发机制&lt;/h4&gt;&lt;p&gt;消息转发分为两大阶段：第一阶段：征询接受者，动态方法解析。&lt;br&gt;第二阶段：完整的消息转发机制，请接收者看看有没有其他对象能处理这条消息，若有，则把消息转给那个对象。若没有，则启动完整的消息转发机制，会把消息有关的细节全都封装到NSInvocation中去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析：对象收到无法解读的消息后，调用类方法：&lt;br&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)selector&lt;/code&gt;&lt;br&gt;要访问CoreData框架中的NSManagedObjects对象时，用resolveInstanceMethod来实现@dynamic属性。  &lt;/li&gt;
&lt;li&gt;备援接收者：能不能把这条消息传给其他接收者来处理&lt;br&gt;&lt;code&gt;-(id)forwardingTargetForSelector:(SEL)selctor;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完整的消息转发：首先，创建NSInvocation对象，把选择子，目标(target)及参数都封装于其中，在触发NSInvocation对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。&lt;br&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以完整的例子演示动态方法解析&lt;br&gt;由开发者来添加属性定义，并将其声明为@dynamic，而类则会自动处理相关属性值的存放于获取操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;a href=&quot;#第14条：理解“类对象”的用意&quot; class=&quot;headerlink&quot; title=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;/a&gt;第14条：理解“类对象”的用意&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Objective-c对象的本质：都是指向某块内存数据的指针，所以声明变量时，类型后面要加“&lt;em&gt;”字符。`NSString &lt;/em&gt;point= @“string”；&lt;code&gt;id类型本身就是指针。可以改写为&lt;/code&gt;id point= @“string”;`&lt;br&gt;描述objective-c对象所用的数据结构定义在runtime.h文件中，对于id，Class，还有is a 指针，涉及到runtime的机制.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在类继承体系中查询类型信息&lt;br&gt;“isMemberOfClass”:能够判断出对象是否为某个特定类的实例。&lt;br&gt;“isKindOfClass”:能够判断出对象是否为某类或某派生类的实例。&lt;br&gt;通过使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。
如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。
尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h2&gt;&lt;h3 id=&quot;isa-swizzling-的应用&quot;&gt;&lt;a href=&quot;#isa-swizzling-的应用&quot; class=&quot;headerlink&quot; title=&quot;isa swizzling 的应用&quot;&gt;&lt;/a&gt;isa swizzling 的应用&lt;/h3&gt;&lt;h4 id=&quot;KVO的实现&quot;&gt;&lt;a href=&quot;#KVO的实现&quot; class=&quot;headerlink&quot; title=&quot;KVO的实现&quot;&gt;&lt;/a&gt;KVO的实现&lt;/h4&gt;&lt;p&gt;利用runtime动态产生一个类。&lt;br&gt;PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;据此，我们可以手动实现一个KVO。&lt;a href=&quot;http://tech.glowing.com/cn/implement-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C中的KVC和KVO&lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Method-Swizzling-应用&quot;&gt;&lt;a href=&quot;#Method-Swizzling-应用&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzling 应用&quot;&gt;&lt;/a&gt;Method Swizzling 应用&lt;/h3&gt;&lt;p&gt;Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现：&lt;br&gt;class_replaceMethod 替换类方法的定义&lt;br&gt;&lt;strong&gt;method_exchangeImplementations 交换 2 个方法的实现&lt;/strong&gt;&lt;br&gt;method_setImplementation 设置 1 个方法的实现&lt;/p&gt;
&lt;p&gt;使用 method swizlling 来修改原有的方法时, 就是在分类 load 中实现的.不在 initialize 方法中改变方法实现的原因是 initialize 可能会被子类所继承并重新执行最终导致无限递归, 而 load 并不会被继承.&lt;/p&gt;
&lt;h4 id=&quot;第13条：用method-swizzling调试黑盒方法&quot;&gt;&lt;a href=&quot;#第13条：用method-swizzling调试黑盒方法&quot; class=&quot;headerlink&quot; title=&quot;第13条：用method swizzling调试黑盒方法&quot;&gt;&lt;/a&gt;第13条：用method swizzling调试黑盒方法&lt;/h4&gt;&lt;p&gt;method swizzling：与给定的选择子名称相对应得方法也可以在运行期改变。（不需要源码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能）可用在本类的所有实例中。&lt;strong&gt;使用另一份实现来替换原有的方法实现&lt;/strong&gt;&lt;br&gt;IMP指针：id(*IMP)(id,SEL,….)类的方法列表会吧选择子的名称映射到相关方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示。&lt;br&gt;互换两个方法的实现：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互换两个已经写好方法实现：(两个参数为待交换的两个方法实现)&lt;br&gt;&lt;code&gt;void method_exchangeImplementations(Method m1,Method m2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获得方法实现：&lt;br&gt;&lt;code&gt;Method class_getInstanceMethod(Class aClass,SEL aselector)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 来为既有的方法添加新功能，新方法添加在NSString的一个“分类”中，在方法中实现所需的附加功能，并调用原有的实现。
- 为完全不知道其具体实现的黑盒方法增加日志记录，有助于程序调试。不宜乱用
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;给分类添加属性&quot;&gt;&lt;a href=&quot;#给分类添加属性&quot; class=&quot;headerlink&quot; title=&quot;给分类添加属性&quot;&gt;&lt;/a&gt;给分类添加属性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Category实现的原理，同样解释了Category不能添加属性的原因&lt;/strong&gt;&lt;br&gt;在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，&lt;/p&gt;
&lt;p&gt;最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的深入理解Objective-C：Category&lt;a href=&quot;http://tech.meituan.com/DiveIntoCategory.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.meituan.com/DiveIntoCategory.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;任性的话可以在Category中添加@dynamic的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。&lt;strong&gt;所以无法在运行时动态给对象增加成员变量&lt;/strong&gt;。&lt;br&gt;相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 methodLists的指针的指针。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是Category实现的原理。&lt;strong&gt;同时也说明了为什么Category只可为对象增加成员方法，却不能增加成员变量。&lt;/strong&gt;&lt;br&gt;iOS 关联引用为分类添加属性:&lt;br&gt; 主要代码：（runtime.h）&lt;/p&gt;
 &lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value, objc_AssociationPolicy policy)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;字典转模型&quot;&gt;&lt;a href=&quot;#字典转模型&quot; class=&quot;headerlink&quot; title=&quot;字典转模型&quot;&gt;&lt;/a&gt;字典转模型&lt;/h3&gt;&lt;p&gt;要将JSON转换为Model啦！&lt;br&gt;利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上。&lt;/p&gt;
&lt;h3 id=&quot;利用runtime遍历模型对象的所有属性来归档和解档&quot;&gt;&lt;a href=&quot;#利用runtime遍历模型对象的所有属性来归档和解档&quot; class=&quot;headerlink&quot; title=&quot;利用runtime遍历模型对象的所有属性来归档和解档&quot;&gt;&lt;/a&gt;利用runtime遍历模型对象的所有属性来归档和解档&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;/p&gt;
&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;讲讲Runtime，以及消息转发过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;讲讲runtime，以及hook，以及如何进行方法交换；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;详解runtime，OC为什么是动态的语言，内部机制；&lt;br&gt;在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得Objective-C成为一门真正的动态语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;runtime 的运行机制？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KVO如何实现，内部机制；&lt;br&gt;&lt;a href=&quot;http://zhangbuhuai.com/understanding-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zhangbuhuai.com/understanding-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kvo的底层实现？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何去手动触发KVO，如何让KVO去监听一个方法；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※]objc中向一个nil对象发送消息将会发生什么？&lt;br&gt;在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]什么时候会报unrecognized selector的异常？&lt;br&gt;objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;br&gt;见上图。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）  &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.&lt;/li&gt;
&lt;li&gt;每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的对象方法列表成员变量的列表,属性列表。它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。&lt;/li&gt;
&lt;li&gt;根对象就是NSObject，它的superclass指针指向nil。&lt;/li&gt;
&lt;li&gt;类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※]一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isa是对象中的隐藏指针,指向创建这个对象的类。
对象会顺着内部的isa指针找到存储于类中的方法并执行。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）&lt;br&gt;selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论在MRC下还是ARC下均不需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。&lt;br&gt;_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：&lt;/p&gt;
&lt;p&gt;resolveInstanceMethod:方法 (或 resolveClassMethod:)。&lt;br&gt;forwardingTargetForSelector:方法&lt;br&gt;methodSignatureForSelector:方法&lt;br&gt;forwardInvocation:方法&lt;br&gt;doesNotRecognizeSelector: 方法&lt;/p&gt;
&lt;p&gt;直接调用调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，&lt;/p&gt;
&lt;p&gt;如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”&lt;/p&gt;
&lt;p&gt;哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的：JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。&lt;br&gt;作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RAC(ReactiveCocoa) 源码中也用到了该方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]runtime如何实现weak变量的自动置nil？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不能向编译后得到的类中增加实例变量;&lt;/li&gt;
&lt;li&gt;能向运行时创建的类中添加实例变量;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;下面的代码分别输出什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Son&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Father&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;答案：都输出”Son”&lt;br&gt;解释：objc中super是编译器标示符，并不像self一样是一个对象，遇到向super发的方法时会转译成&lt;strong&gt;objc_msgSendSuper(…)&lt;/strong&gt;，而参数中的对象还是self，于是从父类开始沿继承链寻找 - class这个方法，最后在NSObject中找到（若无override），此时，[self class]和[super class]已经等价了。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;Objective-C 消息发送与转发机制原理&lt;br&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C Runtime 1小时入门教程：&lt;br&gt;&lt;a href=&quot;https://www.ianisme.com/ios/2019.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C对象模型及应用&lt;a href=&quot;http://blog.devtang.com/2013/10/15/objective-c-object-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2013/10/15/objective-c-object-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Method Swizzling 和 AOP 实践&lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/method-swizzling-aop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Method Swizzling&lt;br&gt;&lt;a href=&quot;http://nshipster.com/method-swizzling/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nshipster.com/method-swizzling/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手Runtime（附MJExtension的底层实现）&lt;br&gt;&lt;a href=&quot;http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iOS面试题sunny&lt;a href=&quot;http://blog.sunnyxx.com/2015/07/04/ios-interview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/07/04/ios-interview/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;答案&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;研究Runtime的源码。看runtime.h文件。runtime是一套比较底层的纯C语言API。平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TableView的一些事</title>
    <link href="http://peilinghui.com/2016/07/02/TableView%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://peilinghui.com/2016/07/02/TableView的一些事/</id>
    <published>2016-07-02T02:32:49.000Z</published>
    <updated>2016-10-12T12:07:46.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView的基本信息&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UITableView的基本信息&quot;&gt;&lt;a href=&quot;#UITableView的基本信息&quot; class=&quot;headerlink&quot; title=&quot;UITableView的基本信息&quot;&gt;&lt;/a&gt;UITableView的基本信息&lt;/h2&gt;&lt;h3 id=&quot;初始化方法&quot;&gt;&lt;a href=&quot;#初始化方法&quot; class=&quot;headerlink&quot; title=&quot;初始化方法&quot;&gt;&lt;/a&gt;初始化方法&lt;/h3&gt;&lt;p&gt; &lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;&lt;/code&gt;&lt;br&gt;这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;// 标准的表视图风格    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStyleGrouped&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;// 分组的表视图风格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用属性&quot;&gt;&lt;a href=&quot;#常用属性&quot; class=&quot;headerlink&quot; title=&quot;常用属性&quot;&gt;&lt;/a&gt;常用属性&lt;/h3&gt;&lt;p&gt;获取表视图的风格(只读属性)&lt;br&gt;&lt;code&gt;@property(nonatomic, readonly) UITableViewStyle    style;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图代理和数据源代理(代理方法后面讨论)&lt;br&gt;&lt;code&gt;@property (nonatomic, assign)id &amp;lt;UITableViewDataSource&amp;gt; dataSource;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property(nonatomic, assign)id &amp;lt;UITableViewDelegate&amp;gt;   delegate;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图的行高(默认为44)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat rowHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat  sectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  sectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedRowHeight;&lt;/code&gt;&lt;br&gt;注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。&lt;/p&gt;
&lt;p&gt;下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的位置&lt;br&gt;&lt;code&gt;@property (nonatomic)UIEdgeInsets  separatorInset;&lt;/code&gt;&lt;br&gt;如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tab=[[&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; style:&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tab&lt;span class=&quot;variable&quot;&gt;.separatorInset&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, tab&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置tableView背景view视图&lt;br&gt;&lt;code&gt;@property(nonatomic, readwrite, retain) UIView *backgroundView;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用方法详解&quot;&gt;&lt;a href=&quot;#常用方法详解&quot; class=&quot;headerlink&quot; title=&quot;常用方法详解&quot;&gt;&lt;/a&gt;常用方法详解&lt;/h3&gt;&lt;p&gt;重载tableView&lt;br&gt;&lt;code&gt;- (void)reloadData;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重载索引栏&lt;br&gt;&lt;code&gt;- (void)reloadSectionIndexTitles;&lt;/code&gt;&lt;br&gt;这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。&lt;/p&gt;
&lt;p&gt;获取分区数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSections;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取行数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取分区的大小(包括头视图，所有行和尾视图)&lt;br&gt;&lt;code&gt;- (CGRect)rectForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区分别获取头视图，尾视图和行的高度&lt;br&gt;&lt;code&gt;- (CGRect)rectForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个点在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个cell在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过位置路径获取cell&lt;br&gt;&lt;code&gt;- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见的cell&lt;br&gt;&lt;code&gt;- (NSArray *)visibleCells;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见行的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForVisibleRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取头视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取尾视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到某一位置(行)&lt;br&gt;&lt;code&gt;- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPosition&lt;/span&gt;) &amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//同UITableViewScrollPositionTop   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的顶部        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionMiddle&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的中间      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionBottom&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView最下面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到选中行&lt;br&gt;&lt;code&gt;- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;这个函数与上面的非常相似，只是它是将表示图定位到选中的行。&lt;/p&gt;
&lt;h2 id=&quot;tableView操作刷新块的应用&quot;&gt;&lt;a href=&quot;#tableView操作刷新块的应用&quot; class=&quot;headerlink&quot; title=&quot;tableView操作刷新块的应用&quot;&gt;&lt;/a&gt;tableView操作刷新块的应用&lt;/h2&gt;&lt;p&gt;在介绍动画块之前，我们先看几个函数：&lt;br&gt;插入分区&lt;br&gt;&lt;code&gt;- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;animation参数是一个枚举，枚举的动画类型如下&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimation&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationFade&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//淡入淡出  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationRight&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从右滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationLeft&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从左滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从上滑入    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationBottom&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从下滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationNone&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//没有动画   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationMiddle&lt;/span&gt;,           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationAutomatic&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 自动选择合适的动画&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除分区&lt;br&gt;&lt;code&gt;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一个分区&lt;br&gt;&lt;code&gt;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ;&lt;/code&gt;&lt;br&gt;移动一个分区&lt;br&gt;&lt;code&gt;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;&lt;/code&gt;&lt;br&gt;插入一些行&lt;br&gt;&lt;code&gt;- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;删除一些行&lt;br&gt;&lt;code&gt;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一些行&lt;br&gt;&lt;code&gt;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;移动某行&lt;br&gt;&lt;code&gt;- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;&lt;/code&gt;&lt;br&gt;了解了上面几个函数，我们来看什么是操作刷新块：&lt;br&gt;当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。&lt;br&gt;IOS为我们提供了下面两个函数解决这个问题：&lt;br&gt;开始块标志&lt;br&gt;&lt;code&gt;- (void)beginUpdates;&lt;/code&gt;&lt;br&gt;结束快标志&lt;br&gt;&lt;code&gt;- (void)endUpdates;&lt;/code&gt;&lt;br&gt;我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下：&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab beginUpdates]&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]&lt;/span&gt;] &lt;span class=&quot;tag&quot;&gt;withRowAnimation&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:UITableViewRowAnimationLeft&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[dataArray removeObjectAtIndex:1]&lt;/span&gt;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[tab endUpdates]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：不要在这个块中调用reloadData这个方法，它会使动画失效。&lt;/p&gt;
&lt;h2 id=&quot;tableView的编辑操作&quot;&gt;&lt;a href=&quot;#tableView的编辑操作&quot; class=&quot;headerlink&quot; title=&quot;tableView的编辑操作&quot;&gt;&lt;/a&gt;tableView的编辑操作&lt;/h2&gt;&lt;p&gt;设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮)&lt;br&gt;&lt;code&gt;@property (nonatomic, getter=isEditing) BOOL editing;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)setEditing:(BOOL)editing animated:(BOOL)animated;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以被选中(默认为YES)&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell编辑模式下是否可以被选中&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑模式下是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;选中cell的相关操作&quot;&gt;&lt;a href=&quot;#选中cell的相关操作&quot; class=&quot;headerlink&quot; title=&quot;选中cell的相关操作&quot;&gt;&lt;/a&gt;选中cell的相关操作&lt;/h2&gt;&lt;p&gt;获取选中cell的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForSelectedRow;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取多选cell的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForSelectedRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码手动选中与取消选中某行&lt;br&gt;&lt;code&gt;- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;注意：这两个方法将不会回调代理中的方法。 &lt;/p&gt;
&lt;h2 id=&quot;tableView附件的相关方法&quot;&gt;&lt;a href=&quot;#tableView附件的相关方法&quot; class=&quot;headerlink&quot; title=&quot;tableView附件的相关方法&quot;&gt;&lt;/a&gt;tableView附件的相关方法&lt;/h2&gt;&lt;p&gt;设置索引栏最小显示行数&lt;br&gt;&lt;code&gt;@property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;设置索引栏字体颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏背景颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏被选中时的颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的风格&lt;br&gt;&lt;code&gt;@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle;&lt;/code&gt;&lt;br&gt;这个风格是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//无线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLine&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//有线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLineEtched&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置分割线颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor           *separatorColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线毛玻璃效果(IOS8之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic, copy) UIVisualEffect      *separatorEffect;&lt;/code&gt;&lt;br&gt;注意：这个属性是IOS8之后新的。&lt;/p&gt;
&lt;p&gt;设置tableView头视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableHeaderView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView尾视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableFooterView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池中取cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个已注册的cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池获取头视图或尾视图&lt;br&gt;&lt;code&gt;- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过xib文件注册cell&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过OC类注册cell&lt;br&gt; &lt;code&gt;- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier&lt;/code&gt;&lt;br&gt;上面两个方法是IOS6之后的方法。&lt;/p&gt;
&lt;p&gt;通过xib文件和OC类获取注册头视图和尾视图&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-UITableView的代理方法&quot;&gt;&lt;a href=&quot;#iOS-UITableView的代理方法&quot; class=&quot;headerlink&quot; title=&quot;iOS UITableView的代理方法&quot;&gt;&lt;/a&gt;iOS UITableView的代理方法&lt;/h2&gt;&lt;h3 id=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;a href=&quot;#UITableViewDataSource（数据源代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;/a&gt;UITableViewDataSource（数据源代理）&lt;/h3&gt;&lt;p&gt;1、必须实现的回调方法&lt;br&gt;返回每个分区的行数&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每一行的cell&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、可选实现的方法&lt;br&gt;返回分区数(默认为1)&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区头部的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区的尾部标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可编辑&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可以被移动&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引）&lt;br&gt;&lt;code&gt;- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题对应的分区&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;tableView接受编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyle&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//没有编辑操作  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleDelete&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//删除操作    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleInsert&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//插入操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tableView的cell被移动时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;a href=&quot;#UITableViewDelegate（tableView代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;/a&gt;UITableViewDelegate（tableView代理）&lt;/h3&gt;&lt;p&gt;cell将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;头视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尾视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的方法&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率)&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置自定义头视图和尾视图&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以高亮&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;cell高亮和取消高亮时分别调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经选中和已经取消选中后调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格&lt;br&gt;&lt;code&gt;- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义删除按钮的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。&lt;br&gt;&lt;code&gt;- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath*)indexPath ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑时背景是否缩进&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将要编辑和结束编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移动特定的某行&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;TableView性能优化&quot;&gt;&lt;a href=&quot;#TableView性能优化&quot; class=&quot;headerlink&quot; title=&quot;TableView性能优化&quot;&gt;&lt;/a&gt;TableView性能优化&lt;/h2&gt;&lt;p&gt;tableview优化两个思路：缓存操作和异步操作。&lt;br&gt;最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。&lt;/p&gt;
&lt;h3 id=&quot;cell复用机制。&quot;&gt;&lt;a href=&quot;#cell复用机制。&quot; class=&quot;headerlink&quot; title=&quot;cell复用机制。&quot;&gt;&lt;/a&gt;cell复用机制。&lt;/h3&gt;&lt;p&gt;如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先注册cell&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt; ()&amp;lt;&lt;span class=&quot;title&quot;&gt;UITableViewDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UITableViewDelegate&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tableView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *cellId = &lt;span class=&quot;string&quot;&gt;@&quot;Cell&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.delegate&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.dataSource&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第一种注册cell&amp;lt;nib文件类HomeTableViewCell&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.tableView&lt;/span&gt; registerNib:[&lt;span class=&quot;built_in&quot;&gt;UINib&lt;/span&gt; nibWithNibName:&lt;span class=&quot;string&quot;&gt;@&quot;HomeTableViewCell&quot;&lt;/span&gt; bundle:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;] forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第二种注册Cell&amp;lt;纯手工打造的HomeVC&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [self.tableView registerClass:[HomeVC class]forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重用相关API&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Cell：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forIndexPath:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Section 的 Header/Footer：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableHeaderFooterViewWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UITableViewCell *)&lt;span class=&quot;string&quot;&gt;tableView:&lt;/span&gt;(UITableView *)tableView &lt;span class=&quot;string&quot;&gt;cellForRowAtIndexPath:&lt;/span&gt;(NSIndexPath *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//获取重用池中的cell&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HomeTableViewCell *cell = [tableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果没有取到,就初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cell) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell = [[HomeTableViewCell alloc] &lt;span class=&quot;string&quot;&gt;initWithStyle:&lt;/span&gt;UITableViewCellStyleDefault &lt;span class=&quot;string&quot;&gt;reuseIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cell.cellNameLab.text = @&lt;span class=&quot;string&quot;&gt;&quot;Name&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;a href=&quot;#cell使用drawRect方法添加子控件&quot; class=&quot;headerlink&quot; title=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;/a&gt;cell使用drawRect方法添加子控件&lt;/h3&gt;&lt;p&gt;如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。&lt;/p&gt;
&lt;h3 id=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;a href=&quot;#高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot; class=&quot;headerlink&quot; title=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;/a&gt;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;- (CGSize)systemLayoutSizeFittingSize: (CGSize)targetSize&lt;/code&gt;&lt;br&gt;方法计算。&lt;/p&gt;
&lt;h3 id=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;a href=&quot;#避免快速滑动情况下开过多线程。&quot; class=&quot;headerlink&quot; title=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;/a&gt;避免快速滑动情况下开过多线程。&lt;/h3&gt;&lt;p&gt;cell中的图片开线程异步加载&lt;sdwebimage(异步操作)&gt;。但是线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; canLoad:Bool = !tableView&lt;span class=&quot;variable&quot;&gt;.dragging&lt;/span&gt; &amp;amp;&amp;amp; !tableView&lt;span class=&quot;variable&quot;&gt;.declearating&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;  canLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//开始loaddata，异步加载图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidScroll:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)sender&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//刷新tableview&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//在此刷新的是屏幕上显示的cell的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.table&lt;/span&gt; reloadData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/sdwebimage(异步操作)&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片处理&quot;&gt;&lt;a href=&quot;#图片处理&quot; class=&quot;headerlink&quot; title=&quot;图片处理&quot;&gt;&lt;/a&gt;图片处理&lt;/h3&gt;&lt;p&gt;1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。&lt;br&gt;2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示&lt;br&gt;3）避免对layer做过多的操作，尽量设置图片为不透明&lt;/p&gt;
&lt;h2 id=&quot;tableView的数据刷新&quot;&gt;&lt;a href=&quot;#tableView的数据刷新&quot; class=&quot;headerlink&quot; title=&quot;tableView的数据刷新&quot;&gt;&lt;/a&gt;tableView的数据刷新&lt;/h2&gt;&lt;p&gt;对tableView的刷新直接就是reloadData.调用这个方法之后,控制器会把数据源方法重新执行一遍,如果前面我们的数据需要保存,reloadData重新执行一遍,我们的数据都会被刷新掉,那么我改如何解决这个问题呢 ? 这就我们对其中某一个分组,或者某一个指定的Cell进行刷新.具体的代码实现如下,&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个section刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexSet *indexSet=[[NSIndexSet alloc]&lt;span class=&quot;string&quot;&gt;initWithIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableview &lt;span class=&quot;string&quot;&gt;reloadSections:&lt;/span&gt;indexSet &lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationAutomatic];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个指定cell刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexPath *indexPath=[NSIndexPath &lt;span class=&quot;string&quot;&gt;indexPathForRow:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;inSection:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableView &lt;span class=&quot;string&quot;&gt;reloadRowsAtIndexPaths:&lt;/span&gt;[NSArray &lt;span class=&quot;string&quot;&gt;arrayWithObjects:&lt;/span&gt;indexPath,nil] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationNone];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多参考资料：&quot;&gt;&lt;a href=&quot;#更多参考资料：&quot; class=&quot;headerlink&quot; title=&quot;更多参考资料：&quot;&gt;&lt;/a&gt;更多参考资料：&lt;/h3&gt;&lt;p&gt;优化UITableViewCell高度计算的那些事：&lt;a href=&quot;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&lt;/a&gt;&lt;br&gt;objc的期刊：更轻量的View Controller：&lt;a href=&quot;https://objccn.io/issue-1-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-1-1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView的基本信息&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中页面传值和页面跳转 </title>
    <link href="http://peilinghui.com/2016/07/02/iOS%E4%B8%AD%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <id>http://peilinghui.com/2016/07/02/iOS中页面传值和页面跳转/</id>
    <published>2016-07-02T02:32:09.000Z</published>
    <updated>2016-10-12T14:03:54.000Z</updated>
    
    <content type="html">&lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios的页面通信&quot;&gt;&lt;a href=&quot;#ios的页面通信&quot; class=&quot;headerlink&quot; title=&quot;ios的页面通信&quot;&gt;&lt;/a&gt;ios的页面通信&lt;/h2&gt;&lt;p&gt;开发过程中我们在页面传值时我们通常使用的方法有:属性传值法,block传值法,代理传值法,以及单例传值法,通知传值法。&lt;/p&gt;
&lt;h3 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;属性传值多用于在将前一个页面的值传到后一个页面去,也就是我们通常说的从前往后传值，  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当第一个页面push到第二个页面的时候.我们在第二个页面声明一个属性用于接受从第一个页面传递过去的值,然后在push这个事件被触发的时候进行赋值.&lt;br&gt;也就是说,先初始化创建第二个控制器(页面),然后通过创建的控制器来访问它所对应的属性,将即将传递的值赋给它,这样就完成了属性传值.于是当页面(控制器)被push到第二个页面之后我们访问它的属性的时候,也就顺便获取到了传递过来的值.&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;next:&lt;/span&gt;(UINavigationController *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ScondViewController *secondNC = [[ScondViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将第一个界面的输入框信息赋值给第二个页面的Label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondNC.tfString = _firstTF.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.navigationController &lt;span class=&quot;string&quot;&gt;pushViewController:&lt;/span&gt;secondNC &lt;span class=&quot;string&quot;&gt;animated:&lt;/span&gt;YES];   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代理传值多用于从后往前传值.只要在协议中声明一个协议方法，然后两个类一个作为委托方一个作为遵守方来调用和实现方法就可以实现传值。十分高效而且针对性很强。委托者：声明delegate属性，调用协议方法。被委托者：遵守协议，设定被委托者，覆写协议方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的.h中创建一个协议,并且设置代理属性,让其遵循该协议.&lt;br&gt;// 设置一个协议方法&lt;br&gt;@protocol SecondVCDelegate&lt;br&gt; // 代理传值    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)passValue:(NSString *)value;&lt;br&gt;@end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明代理属性进行代理传值&lt;br&gt;@property(nonatomic,weak)id delegate;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SecondViewController的导航控制器设置了右按钮(返回按钮),那么,我们只需要在其触发事件(back:)中调用代理方法去执行传值即可.&lt;br&gt;代码如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;back&lt;/span&gt;:(UINavigationController *)&lt;span class=&quot;tag&quot;&gt;sender&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[_delegate passValue:_secondTF.text]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[self.navigationController popViewControllerAnimated:YES]&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;然后在FirstViewController的next方法中为SecondNC制定其代理为其自身即可.&lt;/li&gt;
&lt;li&gt;实现其代理方法&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)passValue:(NSString *)&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;_f&lt;/span&gt;irstLab.text = &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样我们就可以在第一个页面得到第二个页面的值了.&lt;/p&gt;
&lt;h3 id=&quot;block传值&quot;&gt;&lt;a href=&quot;#block传值&quot; class=&quot;headerlink&quot; title=&quot;block传值&quot;&gt;&lt;/a&gt;block传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;block的本质就和其他OC中变量类似,只不过,block中存储的数据是函数体,但是在使用block时完全可以像调用其他函数似的,传入参数,然后得到返回值.从后往前传值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在SecondViewController中定义并声明block属性.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义有参无返回值的匿名函数(传递字符串)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^MyBlock)(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SecondViewController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)MyBlock block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的back方法中调用block,并且将在这个控制器的textField中的文字作为block的参数传递给block.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt;(_secondTF&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;FirstViewController的next方法中,也就是alloc出SecondViewController的时候调用SecondViewController的block,实现传值&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)temp = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secVC&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt; = ^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过回调将传进来的字符串赋值给label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp&lt;span class=&quot;variable&quot;&gt;.firstLab&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt; = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述代码中,因为block里面不能直接使用属性,实例变量和方法(因为会造成循环引用),所以我们重新用__weak修饰self并重新命名为temp.这样我们就实现了传值.&lt;/p&gt;
&lt;h3 id=&quot;通知传值&quot;&gt;&lt;a href=&quot;#通知传值&quot; class=&quot;headerlink&quot; title=&quot;通知传值&quot;&gt;&lt;/a&gt;通知传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类似于广播的一种传值模式，十分简单易用。一般负责在两个不同的类之间传值，且耦合度很低。这种方式中NSNotificationCenter担任一个中介者的身份，已提供观察者与被观察者相互传递信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C中使用NSNotifation表示通知，每个NSNotifation对象都具有名称name（NSNotificationCenter根据该名称检索此通知的所有观察者）、来源对象Poster-object（发布该通知的对象）和可选的userInfo字典（来源对象需要告诉观察者的额外信息NSDictionary）。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter就相当于一个俱乐部，只要一行代码一个类就能加入其中成为会员(Observer向NSNotificationCenter注册感兴趣信息)，当然这个类要告诉俱乐部它对哪些信息感兴趣，当有新的信息出现时，俱乐部会询问每一位会员这个信息是否是它们所需要的(Poster向NSNotificationCenter发送通知)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在ViewController中添加观察者&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;prepareForSegue:&lt;/span&gt;(UIStoryboardSegue *)segue &lt;span class=&quot;string&quot;&gt;sender:&lt;/span&gt;(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[NSNotificationCenter defaultCenter] &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;changeLabelText:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;改变名称&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中实现观察者接到消息之后执行的方法&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)changeLabelText:(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt;*)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.NameLabel&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;=sender&lt;span class=&quot;variable&quot;&gt;.userInfo&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在NextViewController.m中发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心发送通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSNotificationAction&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;* dic=@&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.nameTextField&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter] postNotificationName:&lt;span class=&quot;string&quot;&gt;@&quot;改变名称&quot;&lt;/span&gt; object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; userInfo:dic];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; dismissViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中要移除观察者&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除通知中心&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr_selector&quot;&gt;[[NSNotificationCenter defaultCenter]&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSNotificationCenter *)defaultCenter;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)postNotification:(NSNotification *)notification;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)removeObserver:(id)observer;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)removeObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地通知和远程推送通知&quot;&gt;&lt;a href=&quot;#本地通知和远程推送通知&quot; class=&quot;headerlink&quot; title=&quot;本地通知和远程推送通知&quot;&gt;&lt;/a&gt;本地通知和远程推送通知&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本地通知：由本应用负责调用，只能从当前设备上的iOS发出。&lt;br&gt;远程通知：由远程服务器上的程序发送至Apple Push Notification service(APNs)，再由APNs把消息推送住设备上对应的程序。&lt;/li&gt;
&lt;li&gt;本地通知是一个UILocalNotification对象，创建这个对象以后，就可以通过UIApplication的两个方法来发送通知了。&lt;br&gt;&lt;code&gt;- (void)presentLocalNotificationNow:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)scheduleLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;  // copies notification&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)cancelLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)cancelAllLocalNotifications NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程通知&lt;br&gt;UIApplication中注册远程push通知：&lt;br&gt;&lt;code&gt;- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;br&gt;调用下面方法：(重写应用程序委托类的3个方法)&lt;br&gt; &lt;code&gt;- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);&lt;/code&gt;- &lt;/p&gt;
&lt;h3 id=&quot;单例传值&quot;&gt;&lt;a href=&quot;#单例传值&quot; class=&quot;headerlink&quot; title=&quot;单例传值&quot;&gt;&lt;/a&gt;单例传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;由于单例在内存中只创建一次的并且可以全局访问的属性,我们可以在必要的时候将数据存放在单例的属性中,并且在必要的时候从单例中通过访问其属性进行调用,这样就实现值的传递&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *Str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明静态区对象的原因,希望程序运行期间,在内存中一直存在,这样对外界来说,可以随时读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DataHandle *dataHandle = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例(全局区)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; == dataHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 我们创建单例使用加号方法的原因是因为,在创建之前,无法存在一个实例对象去调用动态方法来创建它本身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataHandle = [[DataHandle alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataHandle; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只需要在需要的时候通过其类方法(+ (instancetype)sharedDataHandle)来创建出单例对象来,然后将textField的text属性以赋值的方式赋给单例的Srt属性即可.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习内存管理</title>
    <link href="http://peilinghui.com/2016/07/01/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://peilinghui.com/2016/07/01/深入学习内存管理/</id>
    <published>2016-07-01T08:57:25.000Z</published>
    <updated>2017-03-24T05:17:42.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习内存管理。理解相关基础知识。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h1&gt;&lt;h3 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h3&gt;&lt;p&gt; 1&amp;gt; 自己生成的对象，自己持有&lt;br&gt; alloc,new,copy,mutablecopy(copy方法利用NSCopying方法约定，由各类实现copyWithZone：方法生成并持有不可变对象的副本)&lt;br&gt; 2&amp;gt; 非自己生成的对象，自己持有&lt;br&gt; NSMutableArray类的array方法。使用retain方法可以持有&lt;br&gt; &lt;code&gt;id obj = [NSMutableArray array];
    [obj retain];&lt;/code&gt;&lt;br&gt; 3&amp;gt;不再需要自己持有的对象时释放&lt;br&gt; 用alloc\new\copy\mutableCopy方法生成并持有的对象，或用retain方法持有的对象，一旦不再需要，务必要用release进行释放。&lt;br&gt;4&amp;gt;无法释放非自己持有的对象&lt;br&gt;&lt;strong&gt;程序崩溃情况&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 再度释放已经释放了的对象
- 访问已经释放的对象时。
- 释放了非自己持有的对象
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;alloc-retain-release-dealloc在GUNstep中的实现：&quot;&gt;&lt;a href=&quot;#alloc-retain-release-dealloc在GUNstep中的实现：&quot; class=&quot;headerlink&quot; title=&quot;alloc/retain/release/dealloc在GUNstep中的实现：&quot;&gt;&lt;/a&gt;alloc/retain/release/dealloc在GUNstep中的实现：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 在objective-c的对象中存有引用计数这一整数值
- 调用alloc或是retain方法后，引用计数值加1.
- 调用release后，引用计数值减1.
- 引用计数值为0时，调用dealloc方法废弃对象。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;苹果的实现&quot;&gt;&lt;a href=&quot;#苹果的实现&quot; class=&quot;headerlink&quot; title=&quot;苹果的实现&quot;&gt;&lt;/a&gt;苹果的实现&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GNUstep&lt;/strong&gt;将用内存块头部管理引用计数的好处：（GNUstep是与苹果Cocoa框架互换的框架）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 少量代码即可完成
- 能够统一管理引用计数用内存块与对象用内存块。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;苹果实现&lt;/strong&gt;通过&lt;strong&gt;引用技术表&lt;/strong&gt;来管理引用计数的好处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 对象用内存块的分配无需考虑内存块头部
- 引用计数表各记录中存有内存块地址，可以从各个记录追溯到各对象的内存块。（在调试的时候，只要内存技术表没有被破坏，就可以确认各内存块的位置；使用工具检测内存泄露时，引用计数表的各记录也有助于检测各对象的持有者是否存在）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;autorelease简介&quot;&gt;&lt;a href=&quot;#autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;autorelease简介&quot;&gt;&lt;/a&gt;autorelease简介&lt;/h3&gt;&lt;p&gt;autorelease类似于C语言的局部变量。只是编程人员可以设定变量的作用域&lt;br&gt;具体使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类方法用于返回autorelease对象：&lt;br&gt;&lt;code&gt;id array = [NAMutableArray arrayWithCapacity];&lt;/code&gt;&lt;br&gt;相当于：&lt;br&gt;&lt;code&gt;id array = [[NAMutableArray arrayWithCapacity]autorelease];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;autorelease实现&quot;&gt;&lt;a href=&quot;#autorelease实现&quot; class=&quot;headerlink&quot; title=&quot;autorelease实现&quot;&gt;&lt;/a&gt;autorelease实现&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[obj autorelease];&lt;/code&gt;相当于&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(id) &lt;span class=&quot;tag&quot;&gt;autorelease&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr_selector&quot;&gt;[NSAutoreleasePool addObject:self]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot;&gt;&lt;a href=&quot;#autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot; class=&quot;headerlink&quot; title=&quot;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot;&gt;&lt;/a&gt;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&lt;/h3&gt;&lt;p&gt;autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。&lt;/p&gt;
&lt;h1 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h1&gt;&lt;p&gt;ARC自动引用计数&lt;br&gt;  Automatic Reference Counting，降低了程序崩溃、内存泄露的风险，很大程度上减少了开发程序的工作量。&lt;br&gt; 使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Xcode4.2或以上版本&lt;/li&gt;
&lt;li&gt;使用LLVM编译器3.0或以上版本&lt;/li&gt;
&lt;li&gt;编译器选项中设置ARC为有效1. “-fobjc-arc”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或release代码&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;所有权的修饰符&quot;&gt;&lt;a href=&quot;#所有权的修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权的修饰符&quot;&gt;&lt;/a&gt;所有权的修饰符&lt;/h3&gt;&lt;p&gt;在ARC环境下，id类型和对象类型和C语言其他类型不同，类型前必须加上所有权的修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__strong
__weak
__unsafe_unretained
__autoreleasing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;__strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARC中, id及其他对象默认就是__strong修饰符修饰，持有强引用的变量超出其作用域时被废弃, 随着强引用的失效, 引用的对象会随之释放.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__weak&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;__strong修饰符修饰在两个对象持有和自己持有自己时很容易有循环引用，从而造成内存泄露。&lt;br&gt;避免循环引用问题。弱引用不能持有对象实例。 并且弱引用的对象被废弃时, 则此弱引用将自动失效并等于nil。&lt;/p&gt;
&lt;p&gt;通过__weak变量访问对象实际上必定是访问注册到autoreleasepool的对象, 因为该修饰符只持有对象的弱引用, 在访问对象的过程中, 该对象可能被废弃, 如果把要访问的对象注册到autoreleasepool中, 那么在block结束之前都能确保该对象存在.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj0 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     obj1 = obj0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;A:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;B:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;A:&lt;/span&gt; &amp;lt;&lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt;ox753e180&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;B:&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;__weak 的几个使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Delegate 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 Delegate 属性为 weak 的。但是这里有一个疑问，我们常用到的 UITableView 的 delegate 属性是这样定义的： @property (nonatomic, assign) id&lt;uitableviewdelegate&gt; delegate;，为什么用的修饰符是 assign 而不是 weak？其实这个 assign 在 ARC 中意义等同于 __unsafe_unretaied（后面会讲到），它是为了在 ARC 特性下兼容 iOS4 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 weak。&lt;/uitableviewdelegate&gt;&lt;/li&gt;
&lt;li&gt;在 Block 中防止强引用循环。关于 Block 可以看这篇文章的详细探讨：Block&lt;/li&gt;
&lt;li&gt;用来修饰指向由 Interface Builder 创建的控件。比如：@property (weak, nonatomic) IBOutlet UIButton *testButton;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unsafe_unretained 修饰的指针纯粹只是指向对象，没有任何额外的操作，&lt;strong&gt;不会去持有对象使得对象的 retainCount +1。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 nil，所以成为了野指针，非常不安全。&lt;/strong&gt;&lt;br&gt;不安全的修饰符, 附有该修饰符的变量不属于编译器的内存管理对象. 该修饰符与&lt;/strong&gt;weak一样, 是弱引用, &lt;strong&gt;并不能持有对象.并且访问该修饰符的变量时如果不能确保其确实存在, 则应用程序会崩溃!&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __unsafe_unretained obj1 = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj0 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     obj1 = obj0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;A:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;B:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &amp;lt;&lt;span class=&quot;constant&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:ox753e180&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &amp;lt;&lt;span class=&quot;constant&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:ox753e180&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;__unsafe_unretained 的应用场景：&lt;/p&gt;
&lt;p&gt;在 ARC 环境下但是要兼容 iOS4.x 的版本，用 &lt;strong&gt;unsafe_unretained 替代 &lt;/strong&gt;weak 解决强引用循环的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__autoreleasing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 ARC 模式下，我们不能显示的使用 autorelease 方法了，但是 autorelease 的机制还是有效的。  &lt;/p&gt;
&lt;p&gt;通过将对象赋给&lt;strong&gt;__autoreleasing&lt;/strong&gt;修饰的变量就能达到在 MRC 模式下调用对象的 autorelease 方法同样的效果。&lt;br&gt;&lt;strong&gt;可理解为, ARC下用@autoreleasepool block代替NSAutoreleasePool类, 用__autoreleasing修饰符的变量代替autorelease方法.&lt;/strong&gt;&lt;br&gt;但是, 显式使用&lt;strong&gt;autoreleasing修饰符跟&lt;/strong&gt;strong一样罕见,&lt;/p&gt;
&lt;p&gt;ps : id的指针或者对象的指针会被隐式附上__autoreleasing修饰符, 如 :&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == id __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 ARC 模式下，显式的使用 __autoreleasing 的场景很少见，但是 autorelease 的机制却依然在很多地方默默起着作用。我们来看看这些场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法返回值。(保证返回时对象没被释放以便方法外的接收方能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 autorelease 机制。)&lt;/li&gt;
&lt;li&gt;访问 &lt;strong&gt;weak 修饰的变量。 ( &lt;/strong&gt;weak 修饰的变量时，实际上必定会访问注册到 Autorelease Pool 的对象,因为 __weak 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 Autorelease Pool 中，就能保证 Autorelease Pool 被销毁前对象是存在的。)&lt;/li&gt;
&lt;li&gt;id 的指针或对象的指针(id &lt;em&gt;)。（所有这种指针的指针类型（id &lt;/em&gt;）的函数参数如果不加修饰符，编译器会默认将他们认定为 &lt;strong&gt;autoreleasing 类型。）【提醒】某些类的方法会隐式地使用自己的 Autorelease Pool，在这种时候使用 &lt;/strong&gt;autoreleasing 类型要特别小心。NSDictionary 的 enumerateKeysAndObjectsUsingBlock 方法：所以要在Block外加　// 加 __block 保证可以在Block内被修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ARC规则&quot;&gt;&lt;a href=&quot;#ARC规则&quot; class=&quot;headerlink&quot; title=&quot;ARC规则&quot;&gt;&lt;/a&gt;ARC规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 不能使用retain/release/retainCount/autorelease
- 不能使用NSAllocateObject/NSDeallocateObject(alloc实现实际上是通过直接调用NSAllocateObject函数来生成并持有对象, ARC下禁止使用NSAllocateObject函数与NSDeallocateObject函数)
- 需遵循内存管理的方法命名规则
- 不要显示调用dealloc(可以重写dealloc，但是不能调用[super dealloc])
- 使用@autoreleasepool块代替NSAutoreleasePool
- 不能使用区域（NSZone）
- 对象型变量不能作为C语言结构体(struct/union)的成员(可强制转换为void *或者是添加__unsafe__retained修饰符)
- 显示转换id和“void *”（通过__bridge可以id和void *相互转换，__bridge__retain可使要转换赋值的变量也持有所赋值的对象相当于retain，__bridge__transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放相当于release）这些转换也多数适用在OC对象和Core Foundation对象之间的相互转换。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt; &lt;code&gt;@property (nonatomic, strong) NSString *name;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在ARC下, 以下可作为这种属性声明中使用的属性来用.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-24%20%E4%B8%8A%E5%8D%8810.25.04.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从修饰符也可看出assign和weak的区别，和assign为什么不能修饰对象。&lt;/p&gt;
&lt;h1 id=&quot;ARC的实现&quot;&gt;&lt;a href=&quot;#ARC的实现&quot; class=&quot;headerlink&quot; title=&quot;ARC的实现&quot;&gt;&lt;/a&gt;ARC的实现&lt;/h1&gt;&lt;p&gt;ARC是由编译器+运行时库共同完成的.&lt;/p&gt;
&lt;h3 id=&quot;strong修饰符&quot;&gt;&lt;a href=&quot;#strong修饰符&quot; class=&quot;headerlink&quot; title=&quot;__strong修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__strong修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行. 它是用来持有返回注册在autoreleasepool中对象的方法.这个函数是成对的, 另外一个objc_autoreleaseReturnValue函数则用于alloc/new/copy/mutableCopy方法以外的类方法返回对象的实现上, 如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autoreleaseReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数有什么用?&lt;/p&gt;
&lt;p&gt;可以这样来总结 :&lt;/p&gt;
&lt;p&gt;如果编译器检测到调用autorelease之后又紧接着调用retain的话, 就省略掉autorelease方法的调用. 通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数将对象直接传递, 忽略掉多余的操作, 优化程序.&lt;/p&gt;
&lt;h3 id=&quot;weak修饰符&quot;&gt;&lt;a href=&quot;#weak修饰符&quot; class=&quot;headerlink&quot; title=&quot;__weak修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__weak修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;若附有__weak修饰符的变量所引用的对象被废弃, 则将nil赋值给该变量.&lt;/li&gt;
&lt;li&gt;使用附有__weak修饰符的变量, 即是使用注册到autoreleasepool中的对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id __weak obj1 = obj&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1 = 0&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, 0)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;访问__weak变量时, 相当于访问注册到autoreleasepool的对象&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = objc_loadWeakRetained(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objc_loadWeakRetained函数取出附有__weak修饰符变量所引用对象并retain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是, 通过&lt;strong&gt;weak变量访问所引用的对象几次, 对象就被注册到autoreleasepool里几次. (将附有&lt;/strong&gt;weak修饰符的变量赋值给附有__strong修饰符的变量后再使用可避免此问题)&lt;/p&gt;
&lt;h3 id=&quot;autoreleasing修饰符&quot;&gt;&lt;a href=&quot;#autoreleasing修饰符&quot; class=&quot;headerlink&quot; title=&quot;__autoreleasing修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__autoreleasing修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;将对象赋值给附有__autoreleasing修饰符的变量等同于MRC下调用对象的autorelease方法.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么调用alloc/new/&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;/mutableCopy以外的方法会怎样呢?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见注册autorelease的方法没有改变, 仍是objc_autorelease函数&lt;/p&gt;
&lt;h3 id=&quot;如何获取引用计数值&quot;&gt;&lt;a href=&quot;#如何获取引用计数值&quot; class=&quot;headerlink&quot; title=&quot;如何获取引用计数值&quot;&gt;&lt;/a&gt;&lt;strong&gt;如何获取引用计数值&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;获取引用数值的函数&lt;br&gt;uinptr_t _objc_rootRetainCount(id obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSUInteger)retainCount;
该方法返回的引用计数不一定准确, 因为有时系统会优化对象的释放行为, 在保留计数为1的时候就把它回收. 所以你用这个方法打印出来的引用计数可能永远不会出现0. 我们不应该根据retainCount来调试程序!!
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们现在的工程几乎都运行在ARC下, 所以大部分内存管理代码都不需要我们自己写, 而由编译器帮我们搞定. 所以在ARC下我们只需要怎样不要去破坏这个生态即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;避免循环引用(使用__weak修饰符)
遵循ARC方法命名规则
适时清空指针(赋值nil即可, 避免野指针错误)
如用到Core Foundation对象, 则在dealloc方法中释放
在dealloc方法中只释放引用并移除监听(不能在dealloc中开启异步任务)
对于内存开销较大的资源, 如file descriptor, socket, 大块内存等应在不需要使用的时候调用close方法释放掉而不是在dealloc中处理.
适当使用@autoreleasepool block来降低内存峰值(之前我写的一篇文章中有demo)
必要时开启&amp;quot;僵尸对象&amp;quot;调试内存管理问题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;属性与内存管理&quot;&gt;&lt;a href=&quot;#属性与内存管理&quot; class=&quot;headerlink&quot; title=&quot;属性与内存管理&quot;&gt;&lt;/a&gt;属性与内存管理&lt;/h2&gt;&lt;p&gt;@property实际上是getter和setter和ivar，@synthesize是合成这2个方法.&lt;br&gt;@property()，如果你里面什么都不写，那么系统会默认的把你的属性设置为：&lt;br&gt;@property(atomic, assign)….  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于nonatomic&lt;/strong&gt;&lt;br&gt;指定 nonatomic特性，编译器合成访问器的时候不会去考虑线程安全问题。&lt;br&gt;如果你的多个线程在同一时间会访问到这个变量的话，可以将特性声明为 atomic(通过省略关键字nonatomic)。在这种特性的状态下，编辑器在合成访问器的时候就会在访问器里面加一个锁 （@synchronized），在同一时间只能有一个线程访问该变量。&lt;br&gt;但是使用锁是需要付出代价的，一个声明为atomic的属性，在设置和获取这个变量的时候都要比声明为nonatomic的慢。所以如果你不打算编写多线程代码，最好把变量的属性特性声明为nonatomic。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于assign、retain和copy&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign：适用基本数据类型，（不适用于对象）简单赋值，不更改索引计数。&lt;strong&gt;因为assign对于在引用计数下的对象特性，只创建了一个弱引用（也就是平时说的浅复制）。这样使用变量会很危险。&lt;/strong&gt;当你release了前一个对象的时候，被赋值的对象指针就成了无头指针了。因此在为对象类型的变量声明属性的时候，尽量不要使用assign。）&lt;br&gt;retain：适用于普通对象。释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1。&lt;br&gt;copy：适用于NSString与block。建立一个索引计数为1的对象，然后释放旧对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;weak和strong的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;copy与retain的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;copy其实是建立了一个相同的对象，而retain不是；&lt;br&gt;copy是内容拷贝，retain是指针拷贝；&lt;br&gt;copy是内容的拷贝 ,对于像NSString,的确是这样。如果拷贝的是NSArray这时只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;assign和weak的区别；&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；&lt;br&gt;weak一旦不进行使用后，永远不会使用了，就不会产生野指针！ 用weak避免循环引用.&lt;br&gt;assign 可以用非 OC 对象,而 weak 必须用于 OC 对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Autorelease-Pool&quot;&gt;&lt;a href=&quot;#Autorelease-Pool&quot; class=&quot;headerlink&quot; title=&quot;Autorelease Pool&quot;&gt;&lt;/a&gt;Autorelease Pool&lt;/h2&gt;&lt;p&gt;一般地，在新建一个iphone 项目的时候，xcode会自动地为你创建一个autorelease pool，这个pool就写在Main函数里面。&lt;br&gt;在NSAutoreleasePool中包含了一个可变数组，用来存储被声明为autorelease的对象。当NSAutoreleasePool自身被销毁的时候，它会遍历这个数组，release数组中的每一个成员（注意，这里只是release，并没有直接销毁对象）。若成员的retain count 大于1，那么对象没有被销毁，造成内存泄露。&lt;br&gt;默认的NSAutoreleasePool只有一个，你可以在你的程序中创建NSAutoreleasePool，被标记为autorelease的对象会跟最近的 NSAutoreleasePool匹配。&lt;br&gt; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];&lt;br&gt;//Create some objects&lt;br&gt;//do something…&lt;br&gt;[pool  release];&lt;br&gt;你也可以嵌套使用NSAutoreleasePool ，就像你嵌套使用for一样。&lt;br&gt;即使NSAutoreleasePool 看起来没有手动release那么繁琐，但是使用NSAutoreleasePool 来管理内存的方法还是不推荐的。因为在一个NSAutoreleasePool 里面，如果有大量对象被标记为autorelease，在程序运行的时候，内存会剧增，直到NSAutoreleasePool 被销毁的时候才会释放。如果其中的对象足够的多，在运行过程中你可能会收到系统的低内存警告，或者直接crash。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;autorelease的具体使用方法：&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象。&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法。&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;RunLoop开始 -&amp;gt; 创建autoreleasepool -&amp;gt; 线程处理事件循环 -&amp;gt; 废弃autoreleasepool -&amp;gt; RunLoop结束 -&amp;gt; 等待下一个Loop开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Autorelease Pool 扩展&lt;/strong&gt;：&lt;br&gt; 如果你极具好奇心，把Main函数中的NSAutoreleasePool代码删除掉，然后再自己的代码中把对象声明为autorelease，你会 发现系统并不会给你发出错误信息或者警告。用内存检测工具去检测内存的话，你可能会惊奇的发现你的对象仍然被销毁了。&lt;br&gt;其实在新生成一个Run Loop的时候，系统会自动的创建一个NSAutoreleasePool ，这个NSAutoreleasePool 无法被删除。&lt;br&gt;在做内存测试的时候，请不要用NSString。OC对字符串作了特殊处理&lt;br&gt;NSString *str =[[NSString alloc] stringWithString:@”123”];&lt;br&gt;在输出str的retain count 的时候，你会发现retain count 大于1。&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存管理，MRC，ARC的区别；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property 后面可以有哪些修饰符？&lt;br&gt;属性可以拥有的特质分为四类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原子性--- nonatomic 特质  
读/写权限---readwrite(读写)、readonly (只读) 
内存管理语义---assign、strong、 weak、unsafe_unretained、copy  
方法名---getter=&amp;lt;name&amp;gt; 、setter=&amp;lt;name&amp;gt;
不常用的：nonnull,null_resettable,nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况使用 weak 关键字，相比 assign 有什么不同？assign为什么不能修饰对象？修饰了对象后会发生什么？  weak为什么比assign安全，其实现原理是怎样的？ weak在它指向的对象被释放后，会被置为nil，该机制是如何实现的；&lt;br&gt;因为assign对于在引用计数下的对象特性，只创建了一个弱引用（也就是平时说的浅复制）。这样使用变量会很危险。当你release了前一个对象的时候，被赋值的对象指针就成了无头指针了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怎么用 copy 关键字？NSString为什么用的copy，copy和strong有什么区别；&lt;br&gt;NSString，NSArray，NSDictionary，Block使用copy。&lt;br&gt;用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。&lt;br&gt;另一篇：深拷贝和浅拷贝的详解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个写法会出什么问题： @property (copy) NSMutableArray *array;&lt;br&gt;两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；&lt;br&gt;2、使用了 atomic 属性会严重影响性能 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;br&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property 的本质是什么？&lt;br&gt;@property = ivar + getter + setter;&lt;br&gt;property在runtime中是objc_property_t定义如下:&lt;br&gt;&lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;&lt;br&gt;而objc_property是一个结构体，包括name和attributes，定义如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;property_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *attributes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;ivar、getter、setter 是如何生成并添加到这个类中的？&lt;/strong&gt;&lt;br&gt;“自动合成”( autosynthesis).编译器会自动编写访问这些属性所需的方法,在编译期执行.生成了五个东西&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
setter 与 getter 方法对应的实现函数
ivar_list ：成员变量列表
method_list ：方法列表
prop_list ：属性列表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;@protocol 和 category 中如何使用 @property&lt;br&gt;在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性.&lt;br&gt;category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：&lt;br&gt;objc_setAssociatedObject&lt;br&gt;objc_getAssociatedObject&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Category和Extension区别；Category的缺点和优点；如何克服或者弥补这个缺点（不能添加实例变量，用Runtime实现）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Category；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 用于给class及其subclass添加新的方法
- 有自己单独的 .h 和 .m 文件
- 用于添加新方法，而不能添加新属性（property）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Extension&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Extension常被称为是匿名的Category
- 用于给类添加新方法，但只作用于原始类，不作用于subclass
- 只能对有implementation源代码的类写Extension，对于没有implementation源代码的类，比如framework class，是不可以的
- **Extension可以给原始类添加新方法，以及新属性**
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;category 与extension不同在于后者可以添加属性，后者添加的方法也必须是要实现的。extension是私有的category。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Category的缺点和优点：&lt;/strong&gt;&lt;br&gt;    缺陷：一是无法向类中添加新的实例变量。&lt;br&gt;          二是名称冲突，在自己的类别方法名中添加一个前缀，以确保不会发生冲突。&lt;br&gt;    优势：将类的实现代码分散到多个不同文件或框架中，创建对私有方法的前向引用，以及向对象添加非正式协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;runtime 如何实现 weak 属性?（runtime 如何实现 weak 变量的自动置nil？）&lt;br&gt;对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; - (void)setObject:(&lt;span class=&quot;type&quot;&gt;NSObject&lt;/span&gt; *)&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(self, &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;OBJC_ASSOCIATION_ASSIGN&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cyl_runAtDealloc&lt;/span&gt;:&lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _object = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;weak属性需要在dealloc中置nil么？  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要。&lt;br&gt;在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@synthesize和@dynamic分别有什么作用?&lt;br&gt;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。&lt;br&gt;@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&lt;br&gt;对应基本数据类型默认关键字是：atomic,readwrite,assign&lt;br&gt;对于普通的 Objective-C 对象：atomic,readwrite,strong&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？&lt;br&gt;使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.&lt;br&gt;如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？不会&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结下 @synthesize 合成实例变量的规则，有以下几点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
如果这个成员已经存在了就不再生成了.
如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：
如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,
如果是 @synthesize foo = _foo; 就不会生成成员变量了.
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？&lt;br&gt;什么情况下不会autosynthesis（自动合成）？就需要使用@synthesize 来手动合成ivar。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;同时重写了 setter 和 getter 时
重写了只读属性的 getter 时
使用了 @dynamic 时
在 @protocol 中定义的所有属性
在 category 中定义的所有属性
重载的属性
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;releasepool被释放了，里面的对象都会被释放吗？过程是怎样的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动释放池底层怎么实现？&lt;br&gt;自动释放池以队列数组的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况下会发生内存泄漏和内存溢出？ 如何查看或者检测内存泄露；&lt;br&gt;内存泄露：如果失去了对一个对象的访问权，而又没有将retain count减至0，就会造成内存泄露。不再需要的对象没有释放，导致内存泄露，内存泄露会导致应用闪退。循环引用造成内存不可回收。&lt;br&gt;1&amp;gt;block中使用strong self，如果不注意很容易造成内存泄露&lt;br&gt;2&amp;gt;delegate如果设置为strong也很大可能造成内存泄露，不过具体还要看有没有循环引用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARC是依靠什么实现的？ARC是一种编译时特性还是运行时特性；&lt;br&gt;编译期和运行期两部分共同帮助开发者管理内存。&lt;br&gt;简单来说，编译器在编译代码时，会自动生成实例的引用计数代码，帮助我们完成之前MRC需要完成的工作，不过据说除此之外，编译器也会执行某些优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果自己实现一个setter方法，该如何写代码？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;讲讲Foundation和CoreFoundation之间的区别；CoreFoundation是不支持ARC的，如何与Foundation之间进行转化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。&lt;br&gt;Foundation框架提供Objective-C接口。  &lt;/p&gt;
&lt;p&gt;CocoaFoundation指针与CoreFoundation指针转换，需要考虑的是所指向对象所有权的归属。ARC提供了3个修饰符来管理。&lt;br&gt;　　1. &lt;strong&gt;bridge，什么也不做，仅仅是转换。此种情况下：&lt;br&gt;　　　　i). 从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。&lt;br&gt;　　　　ii). 从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。&lt;br&gt;　　2. &lt;/strong&gt;bridge_retained，转换后自动调用CFRetain，即帮助自动解决上述i的情形。&lt;br&gt;　　3. __bridge_transfer，转换后自动调用CFRelease，即帮助自动解决上述ii的情形。&lt;br&gt;  参考：&lt;a href=&quot;http://www.jianshu.com/p/5c98ac2dab58&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/5c98ac2dab58&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;release如何实现对象释放？autorelease如何实现？两者的区别与联系？release能做的事情autorelease都能做，那么release可不可以舍弃？为什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;release和autorelease区别&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;release立即释放，autorelease不立即释放，先放到autoreleasepool中，当pool结束后自动调用release。&lt;br&gt;一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;dealloc里做哪些操作？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dealloc不remove通知会怎么样?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;atomic一定是线程安全的吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BAD_ACCESS这个bug是如何出现的？&lt;br&gt;野指针。正在使用的对象被释放了，导致野指针，访问野指针导致程序崩溃。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※]objc使用什么机制管理对象内存？—-&lt;strong&gt;引用计数&lt;/strong&gt;&lt;br&gt;通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]ARC通过什么方式帮助开发者管理内存？&lt;br&gt;ARC的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）&lt;br&gt;UIKit通过CFRunLoopObserve在RunLoop两次sleep间，对Autorelease Pool进行pop和push，将这次loop中产生的autorelease对象释放。&lt;br&gt;如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存不足的产生的例子？如何解决？&lt;br&gt;在for循环中读入大量图片的同时，改变其尺寸。图像文件读入到NSData对象，并从中产生UIImage对象，改变该尺寸后生成新的UIImage对象，这种情况就会产生大量的autorelease的对象。不废弃NSAutoreleasePool对象，那么生成的对象就不能释放，就会产生内存不足。&lt;br&gt;解决：在适当的地方生成、持有或废弃NSAutoreleasePool对象；&lt;br&gt;返回NSMutableArray类的arrayWithCapcity方法。来返回autorelease对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.weak是怎么实现自动设置为nil的？&lt;br&gt;答：当把一个强引用的变量赋值给一个弱引用的变量时， 实际上编译器做了以下几步:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、把__weak变量初始化为0
2、使用__strong变量的地址作为键值，把__weak变量的地址注册到weak表中，weak表是一个散列表
3、如果__strong变量的地址为0，就把对应__weak变量的地址从weak表中删除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用weak表，使用废弃变量的地址作为键值进行检索，就能高速获取对应的附有__weak修饰符的变量的地址。&lt;br&gt;废弃谁都不持有的对象时，编译器进行了如下几步操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、从weak表中获取废弃对象的地址作为键值的记录
2、将记录中所有weak变量的地址赋值为nil
3、将记录从weak表中删除
4、将废弃对象的地址作为键值的记录从引用计数表中删除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，如果大量的使用附有&lt;strong&gt;weak修饰符的变量，会消耗相应的CPU资源，所以应该只在为了避免循环引用时再使用&lt;/strong&gt;weak修饰符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/22&quot; alt=&quot;&quot;&gt;&lt;br&gt;参考：&lt;/p&gt;
&lt;p&gt;iOS ARC 内存管理要点&lt;a href=&quot;http://www.samirchen.com/ios-arc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.samirchen.com/ios-arc/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习内存管理。理解相关基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://peilinghui.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="iOS面试" scheme="http://peilinghui.com/tags/iOS%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习笔记</title>
    <link href="http://peilinghui.com/2016/06/29/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2016/06/29/ReactiveCocoa学习笔记/</id>
    <published>2016-06-29T08:24:44.000Z</published>
    <updated>2016-07-04T01:40:17.000Z</updated>
    
    <content type="html">&lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;官网文档地址：&lt;a href=&quot;https://github.com/peilinghui/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/ReactiveCocoa&lt;/a&gt;&lt;br&gt;学习一些优秀的博客地址：&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程二&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa简介&quot;&gt;&lt;a href=&quot;#ReactiveCocoa简介&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa简介&quot;&gt;&lt;/a&gt;ReactiveCocoa简介&lt;/h1&gt;&lt;p&gt;ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架.&lt;/p&gt;
&lt;p&gt;ReactiveCocoa结合了几种编程风格：&lt;/p&gt;
&lt;p&gt;函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。&lt;br&gt;响应式编程（Reactive Programming）：关注于数据流和变化传播。&lt;br&gt;ReactiveCocoa就被开发者们描述为响应式函数编程框架(FRP);使用RAC就不需要考虑调用的顺序,直接考虑结果,使得代码高聚合,方便管理.&lt;br&gt;一个优点提供了一个单一的、统一的方法去处理异步的行为，包括delegate方法,blocks回调,target-action机制,notifications和KVO.&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa使用&quot;&gt;&lt;a href=&quot;#ReactiveCocoa使用&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa使用&quot;&gt;&lt;/a&gt;ReactiveCocoa使用&lt;/h1&gt;&lt;h2 id=&quot;RACSiganl-RAC的核心类-信号类-用来数据传递&quot;&gt;&lt;a href=&quot;#RACSiganl-RAC的核心类-信号类-用来数据传递&quot; class=&quot;headerlink&quot; title=&quot;RACSiganl(RAC的核心类):信号类 用来数据传递&quot;&gt;&lt;/a&gt;RACSiganl(RAC的核心类):信号类 用来数据传递&lt;/h2&gt;&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 该信号默认是一个冷信号,当值改变了,也并不会触发改信号,只有订阅了该信号,才会触发改信号.
- 订阅信号的方法: subscribeNext:
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//1.创建一个信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RACSignal *singal = [RACSignal createSignal:^RACDisposable *(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;RACSubscriber&amp;gt; subscriber) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//2. 发送一个信号.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;Signal&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendCompleted];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [RACDisposable disposableWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//信号取消&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;信号被销毁&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//3. 订阅信号 ,激活信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [singal subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//x : 就是信号发送到数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;error:^(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;error = %@&quot;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; completed:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;completed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;a href=&quot;#RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot; class=&quot;headerlink&quot; title=&quot;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;/a&gt;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&lt;/h2&gt;&lt;p&gt;使用场景:通常用来代替代理，有了它，就不必要定义代理了。&lt;br&gt;RACReplaySubject:重复提供信号类，RACSubject的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject与RACSubject区别:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。
- 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。
- 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;RACSubject和RACReplaySubject简单使用&quot;&gt;&lt;a href=&quot;#RACSubject和RACReplaySubject简单使用&quot; class=&quot;headerlink&quot; title=&quot;RACSubject和RACReplaySubject简单使用:&quot;&gt;&lt;/a&gt;RACSubject和RACReplaySubject简单使用:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RACSubject使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
3.发送信号 sendNext:(id)value

**RACSubject:底层实现和RACSignal不一样**
1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。
2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.创建信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSubject *subject = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2.订阅信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第一个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第二个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3.发送信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;1&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSignal不一样，创建信号时没有block。
2.可以先订阅信号，也可以先发送信号。
   2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
   2.2 发送信号 sendNext:(id)value

// RACReplaySubject:底层实现和RACSubject不一样。
// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock

// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。
// 也就是先保存值，在订阅值。

// 1.创建信号
RACReplaySubject *replaySubject = [RACReplaySubject subject];

// 2.发送信号
[replaySubject sendNext:@1];
[replaySubject sendNext:@2];

// 3.订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第一个订阅者接收到的数据%@&amp;quot;,x);
}];

// 订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第二个订阅者接收到的数据%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RACSubject替换代理&lt;br&gt;    // 需求:&lt;br&gt;    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面&lt;br&gt;    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器&lt;/p&gt;
&lt;p&gt;步骤一：在第二个控制器.h，添加一个RACSubject代替代理。&lt;br&gt;@interface TwoViewController : UIViewController&lt;/p&gt;
&lt;p&gt;@property (nonatomic, strong) RACSubject *delegateSignal;&lt;/p&gt;
&lt;p&gt;@end&lt;/p&gt;
&lt;p&gt;步骤二：监听第二个控制器按钮点击&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; TwoViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)&lt;span class=&quot;attribute&quot;&gt;notice&lt;/span&gt;:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通知第一个控制器，告诉它，按钮被点了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 通知代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 判断代理信号是否有值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; (self.delegateSignal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 有值，才需要通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr_selector&quot;&gt;[self.delegateSignal sendNext:nil]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OneViewController&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)btnClick:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TwoViewController *twoVc = [[TwoViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 订阅代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;点击了通知按钮&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 跳转到第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; presentViewController:twoVc animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;替换Target和Action&quot;&gt;&lt;a href=&quot;#替换Target和Action&quot; class=&quot;headerlink&quot; title=&quot;替换Target和Action&quot;&gt;&lt;/a&gt;替换Target和Action&lt;/h2&gt;&lt;h3 id=&quot;TextField的字符变化&quot;&gt;&lt;a href=&quot;#TextField的字符变化&quot; class=&quot;headerlink&quot; title=&quot;TextField的字符变化&quot;&gt;&lt;/a&gt;TextField的字符变化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[self.textFild.rac_textSignal map:^id(id value) {
    NSLog(@&amp;quot;%@&amp;quot;, value);
    return @1;
}] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;, x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;构造的映射块value的值就是控件中的字符变化，根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回text.length，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。&lt;br&gt;&lt;strong&gt;filter&lt;/strong&gt;就是过滤，它可以帮助你筛选出你需要的信号变化。&lt;br&gt;take是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以take 2就是获取前两个信号，skip 2就是跳过前两个。repeat是重复发送信号。&lt;br&gt;&lt;strong&gt;delay&lt;/strong&gt;延时信号，顾名思义，即延迟发送信号.&lt;br&gt;&lt;strong&gt;throttle&lt;/strong&gt;搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。&lt;br&gt;&lt;strong&gt;distinctUntilChanged&lt;/strong&gt;网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。distinctUntilChanged的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。&lt;br&gt;&lt;strong&gt;timeout&lt;/strong&gt;超时信号，当超出限定时间后会给订阅者发送error信号。&lt;br&gt;&lt;strong&gt;ignore&lt;/strong&gt;忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。&lt;/p&gt;
&lt;h3 id=&quot;UIButton的事件的监听&quot;&gt;&lt;a href=&quot;#UIButton的事件的监听&quot; class=&quot;headerlink&quot; title=&quot;UIButton的事件的监听&quot;&gt;&lt;/a&gt;UIButton的事件的监听&lt;/h3&gt;&lt;p&gt;  [[button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {&lt;br&gt;        //这个x就是button,已经知道了类型就可以把id x 修改成UIButton *button&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }]; &lt;/p&gt;
&lt;h3 id=&quot;手势事件&quot;&gt;&lt;a href=&quot;#手势事件&quot; class=&quot;headerlink&quot; title=&quot;手势事件&quot;&gt;&lt;/a&gt;手势事件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UITapGestureRecognizer *tap =[[UITapGestureRecognizer alloc]init];
[[tap rac_gestureSignal] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
[self.view addGestureRecognizer:tap];   
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RAC的通知不需要移除remove observer，因为在rac_add方法中他已经写了remove&lt;/strong&gt;&lt;br&gt;[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];  &lt;/p&gt;
&lt;h3 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h3&gt;&lt;p&gt;//延迟一定时间做某事&lt;br&gt;    [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{&lt;br&gt;        NSLog(@”Ricky”);&lt;br&gt;    }];&lt;br&gt;//每个多长时间调用一次事件&lt;br&gt;    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];&lt;/p&gt;
&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;RACObserve(TARGET, KEYPATH)这种形式，TARGET是监听目标，KEYPATH是要观察的属性值&lt;br&gt;&lt;strong&gt;监听UIScrollView的contentOffset&lt;/strong&gt;&lt;br&gt;UIScrollView *scroller =[[UIScrollView alloc]initWithFrame:CGRectMake(100, 100, 100, 200)];&lt;br&gt;    [self.view addSubview:scroller];&lt;br&gt;    [RACObserve(scroller, contentOffset) subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];   &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt;
    
    </summary>
    
      <category term="RAC" scheme="http://peilinghui.com/categories/RAC/"/>
    
    
      <category term="RAC,学习笔记" scheme="http://peilinghui.com/tags/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS调试技巧</title>
    <link href="http://peilinghui.com/2016/05/14/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://peilinghui.com/2016/05/14/iOS调试技巧/</id>
    <published>2016-05-14T09:50:17.000Z</published>
    <updated>2016-05-23T01:31:21.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;对于bug,我们要合理的假设，找原因；对原因与bug之间的因果关系进行分析。&lt;/p&gt;
&lt;h2 id=&quot;lldb的使用&quot;&gt;&lt;a href=&quot;#lldb的使用&quot; class=&quot;headerlink&quot; title=&quot;lldb的使用&quot;&gt;&lt;/a&gt;lldb的使用&lt;/h2&gt;&lt;p&gt;主要是打断点的时候使用lldb.&lt;/p&gt;
&lt;h3 id=&quot;查看值&quot;&gt;&lt;a href=&quot;#查看值&quot; class=&quot;headerlink&quot; title=&quot;查看值&quot;&gt;&lt;/a&gt;查看值&lt;/h3&gt;&lt;p&gt;1&amp;gt;非对象的值&lt;br&gt;&lt;code&gt;int a = 10;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) p a&lt;br&gt;(原始命令：p = print = expression –)&lt;br&gt;输出：(int)$0 = 10&lt;br&gt;(lldb)p 10 + 10&lt;br&gt;输出：$1 = 20  &lt;/p&gt;
&lt;p&gt;2&amp;gt;对象的值&lt;br&gt;&lt;code&gt;NSString *string = @“Hello，world”;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) po string&lt;br&gt;(原始命令：po = expression -o – = e -o –string)&lt;br&gt;输出：Hello，world  &lt;/p&gt;
&lt;p&gt;注意：清空控制台：command+K  &lt;/p&gt;
&lt;h3 id=&quot;修改变量的值&quot;&gt;&lt;a href=&quot;#修改变量的值&quot; class=&quot;headerlink&quot; title=&quot;修改变量的值&quot;&gt;&lt;/a&gt;修改变量的值&lt;/h3&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第一个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第二个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) e(代表expression表达式) a=11&lt;br&gt;输出：(int) $0 = 11  &lt;/p&gt;
&lt;h3 id=&quot;定义一个变量&quot;&gt;&lt;a href=&quot;#定义一个变量&quot; class=&quot;headerlink&quot; title=&quot;定义一个变量&quot;&gt;&lt;/a&gt;定义一个变量&lt;/h3&gt;&lt;p&gt;(lldb) e int $b = 20&lt;br&gt;(lldb) e int $b + $0&lt;br&gt;输出：(int) $1 = 31&lt;/p&gt;
&lt;h3 id=&quot;调用一个函数&quot;&gt;&lt;a href=&quot;#调用一个函数&quot; class=&quot;headerlink&quot; title=&quot;调用一个函数&quot;&gt;&lt;/a&gt;调用一个函数&lt;/h3&gt;&lt;p&gt;代码中：&lt;br&gt;&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; test]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;test&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;test被调用了&quot;&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(lldb) call [self init]&lt;br&gt;输出：test被调用了&lt;/p&gt;
&lt;h3 id=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;a href=&quot;#函数提前返回，返回一个特定值&quot; class=&quot;headerlink&quot; title=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;/a&gt;函数提前返回，返回一个特定值&lt;/h3&gt;&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; returnValue = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; testReturn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)testReturn&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) thread return 100&lt;br&gt;(lldb) p returnValue&lt;br&gt;输出：(NSInteger) $1 = 0&lt;br&gt;(NSInteger) $2 = 100&lt;/p&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;p&gt;1&amp;gt;继续运行 (相当于控制台第一个按钮)&lt;br&gt;c = continue = process continue&lt;br&gt;2&amp;gt;step over&lt;br&gt;n = next = thread step-over&lt;br&gt;3&amp;gt;step in(跳入函数)&lt;br&gt;s = thread step-in&lt;br&gt;4&amp;gt;step out(跳出函数)&lt;br&gt;finish = thread step-over&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络编程</title>
    <link href="http://peilinghui.com/2016/04/14/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://peilinghui.com/2016/04/14/iOS网络编程/</id>
    <published>2016-04-14T14:07:11.000Z</published>
    <updated>2016-07-16T00:56:39.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS网络编程知识总结&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS网络编程&quot;&gt;&lt;a href=&quot;#iOS网络编程&quot; class=&quot;headerlink&quot; title=&quot;iOS网络编程&quot;&gt;&lt;/a&gt;iOS网络编程&lt;/h1&gt;&lt;h2 id=&quot;检测网络状态&quot;&gt;&lt;a href=&quot;#检测网络状态&quot; class=&quot;headerlink&quot; title=&quot;检测网络状态&quot;&gt;&lt;/a&gt;检测网络状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;检查网络状态。&lt;br&gt;1&amp;gt;下载和添加Reachablity类.&lt;br&gt;2&amp;gt;为项目添加SystemConfiguration.framework框架。&lt;br&gt;若要手动禁用ARC源文件，输入框添加“-fno-objc-arc”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;a href=&quot;#使用CFNetwork实现TCP协议的通信&quot; class=&quot;headerlink&quot; title=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;/a&gt;使用CFNetwork实现TCP协议的通信&lt;/h2&gt;&lt;p&gt;CFNetwork对基于TCP协议的网络通信提供了良好的封装，CFNetwork使用CFSocket来代表两端的通信端口，还可以通过CFStream读/写数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IP地址是32位整数，分为A，B,C,D,E五类。用于唯一标识网络上的一个通信实体&lt;br&gt;A类：10.0.0.0~10.255.255.255&lt;br&gt;B类：172.16.0.0~172.31.255.255&lt;br&gt;C类：192.168.0.0~192.168.255.255&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;端口是16为整数，表示数据交给哪个通信程序处理，是应用程序和外界交流的出入口，包括一些数据结构和I/O。&lt;br&gt;公认端口：从0到1023，紧紧绑定一些特定的服务。&lt;br&gt;注册端口：从1024到49151，松散的绑定一些服务，适用于应用程序。&lt;br&gt;动态和/私有端口：从49152到65535.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP服务器端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个监听Socket Accept的CFSocket,并为kCFSocketAcceptCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketSetAddress()函数，将服务器的CFSocket绑定到本地IP地址和端口。&lt;br&gt;3&amp;gt;将CFSocket作为source添加到指定线程的CFRunLoop上，并运行该线程的CFRunLoop，从而保证该CFSocket能持续不断的接受来自客户端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP客户端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个不监听任何事件或监听Connection的CFSocket。如果要监听Connection，则需要为kCFSocketConnectCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketConnectionToAddress()函数，将客户端的CFSocket；连接到指定IP地址和端口的服务器上。&lt;br&gt;3&amp;gt;得到客户端CFSocket之后，既可直接使用CFSocketNativeHandle进行读/写，也可通过CFSocket获取CFReadStreamRef、CFWriteStreamRef后进行读、写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CocoaAsyncSocket实现TCP客户端&lt;br&gt;降低直接使用CFSocket编程的复杂度，另外有开发者提供了一套开源的CocoaAsyncSocket库。&lt;br&gt;CocoaAsyncSocket封装了CFNetwork底层的CFSocket和CFStream，并提供了异步操作，支持TCP和UDP。&lt;br&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞方式的读和写，而且可设置超时时长。&lt;/li&gt;
&lt;li&gt;自动的socket接受，如果调用它接受连接，它将为每个连接启动新的实例，当然也可以立即关闭这些连接。&lt;/li&gt;
&lt;li&gt;委托支持，错误、连接、接收、完整的读取、完整的写入、进度以及断开连接，都可通过代理模式调用。&lt;/li&gt;
&lt;li&gt;所有操作都封装在一个类中，开发者无需操作socket或流，该类封装了所有操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用NSURLConnection&quot;&gt;&lt;a href=&quot;#使用NSURLConnection&quot; class=&quot;headerlink&quot; title=&quot;使用NSURLConnection&quot;&gt;&lt;/a&gt;使用NSURLConnection&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用NSURLConnection从网络获取数据&lt;br&gt;方法:&lt;br&gt;&lt;code&gt;- (NSURLRequest *)originalRequest://获取该NSURLConnection最初的NSURLRequest对象的深拷贝&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSURLRequest *)currentRequest://返回该该NSURLConnection当前使用的NSURLRequest对象。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1&amp;gt;同步请求获取网络数据：&lt;br&gt;&lt;code&gt;+ sendSynchronousRequest:returningResponse:error:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;异步请求获取网络数据：&lt;br&gt;总指定一个NSURLConnectionDelegate对象，将该对象作为NSURLConnection的delegate，负责服务器响应到来的各种事件。&lt;br&gt;&lt;code&gt;+ connectionWithRequest:delegate://异步请求的方式获取数据&lt;/code&gt;&lt;br&gt;&lt;code&gt;- initWithRequest:delegate//实例方法，必须先调用alloc,再调用该方法。&lt;/code&gt;&lt;br&gt;&lt;code&gt;+ sendAsynchronousRequest:queue:CompletionHandler://表明将请求交给指定的NSOperationQueue处理&lt;/code&gt;&lt;br&gt;&lt;code&gt;- start://开始发送请求&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用使用NSURLConnection从网络获取数据的步骤：&lt;br&gt;1&amp;gt;创建NSURLRequest对象，该对象代表对远程服务器的请求。包括：请求的URL，缓存策略，超时时长等。&lt;br&gt;2&amp;gt;调用NSURLConnection的实例方法或类方法，以NSURLRequest对象为参数创建NSURLConnection即可发送请求。&lt;br&gt;3&amp;gt;以异步方式加载服务器响应，则需要为NSURLConnection对象指定delegate对象，因此还需要为delegate对象实现特定的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用NSMutableURLRequest向服务器发送请求&lt;br&gt;NSURLRequest只能想服务器发送简单的请求，不能添加请求头和请求参数，使用NSMutableURLRequest可以。&lt;br&gt;&lt;code&gt;-addValue:forHTTPHeaderField:为使用NSMutableURLRequest添加请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setAllHTTPHeaderField:通过一个NSDictionary一次性为NSMutableURLRequest设置多个请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBody:设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBodyStream:以NSInputStream为参数设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPMethod:设置提交请求方式，要么是POST，要么是GET。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPShouldHandleCookies:设置该HTTP请求是否处理Cookie。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setValue：forHTTPHeaderField：为指定的请求头设置请求值。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;XML解析&quot;&gt;&lt;a href=&quot;#XML解析&quot; class=&quot;headerlink&quot; title=&quot;XML解析&quot;&gt;&lt;/a&gt;XML解析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DOM与SAX&lt;br&gt;DOM：Document Object Model。文档对象模型、&lt;br&gt;SAX：Simple API for XML。&lt;br&gt;iOS SDK提供了NSXMLParser和libxml2两个类库，还有第三方库GDataXML，TBXML，TouchXML，KissXML等。&lt;br&gt;需要读取和修改XML文档，使用GDataXML，KissXML。&lt;br&gt;需要读取非常大的XML文档，使用libxml2或TBXML。&lt;/li&gt;
&lt;li&gt;NSXMLParser解析XML文档&lt;br&gt;步骤：&lt;ul&gt;
&lt;li&gt;创建NSXMLParser对象。&lt;/li&gt;
&lt;li&gt;为NSXMLParser对象指定delegate对象，该delegate对象必须实现NSXMLParserDelegate协议，并根据需要实现协议中特定的方法。&lt;/li&gt;
&lt;li&gt;调用NSXMLParser对象的parse方法开始解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;libxml2解析XML文档&lt;br&gt;使用C语言的库，准备步骤：&lt;ul&gt;
&lt;li&gt;为项目添加libxml2.dylib库&lt;/li&gt;
&lt;li&gt;添加头文件的搜索路径&lt;br&gt;步骤：    &lt;/li&gt;
&lt;li&gt;创建XMLTextReaderPtr对象.如果以本地XML文档来创建XMLTextReaderPtr对象，则调用XMLTextReaderFilename()函数即可。如果以内存中XML文档来创建该对象，则调用XMLReaderForMemeory（）函数即可。&lt;/li&gt;
&lt;li&gt;依次调用XMLTextReaderxxx()函数来读取XML文档的元素名，元素值，属性等各种内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML解析XML文档&lt;br&gt;第三方开源库，对libxml2的宝座，底层依赖libxml2，既支持解析XML文档 ，也支持修改XML文档，支持XPath方式查询，提供了更好的面向对象的封装。&lt;br&gt;准备步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 调用GDataXMLDocument的初始化方法根据XML文档或XML字符初始化GDataXMLDocument对象。（GDataXMLDocument对象就是XML文档转换得到的DOM树）
- 调用GDataXMLDocument对象的rootElement方法即可获取该文档的根元素
- 获取根元素后，就可以根据XML元素之间的父子关系来逐层遍历，访问该XML文档中的每一个元素，从而获取XML元素的内容。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;GDataXML生成XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法创建 GDataXMLelement对象，并以该对象作为XML文档的根元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法不断创建 GDataXMLelement对象（XML元素），并利用元素之间的父子关系组织这些XML元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLData方法获取XML文档对应的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML修改XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLDocument方法根据指定的XML文档或者XML字符串来生成对应的GDataXMLDocument对象–它代表了XML文档在内存中的形式。&lt;/li&gt;
&lt;li&gt;获取GDataXMLDocument对象的根元素，然后利用元素之间父子关系添加子元素、删除子元素或修改元素的内容。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对应的NSData 对象，调用NSdata的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;p&gt;JSON具有跨平台，跨语言的优势。两种数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 由key-value对组成的数据结构。
- 有序集合  
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;使用JSON语法创建对象&lt;br&gt;直接创建一个JavaScript对象，&lt;/li&gt;
&lt;li&gt;使用JSON语法创建数组&lt;br&gt;&lt;code&gt;var a = [&amp;#39;yeeku&amp;#39;,&amp;#39;nono&amp;#39;];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用NSJSONSerialization处理JSON数据 (系统自带)&lt;br&gt;满足条件：&lt;br&gt;顶级对象只能是NSArray或NSDictionary。&lt;br&gt;集合中包含对象只能是NSString，NSNumber，NSArray，NSDictionary或NSNull对象。&lt;br&gt;所有NSDictionary的key只能是NSString。&lt;br&gt;NSNumber保证的数值不是NaN或Infinity。  &lt;/li&gt;
&lt;li&gt;使用SBJson解析JSON数据&lt;br&gt;提供了两个工具类：SBJsonParser和SBJsonWriter.&lt;br&gt;SBJsonParser负责吧NSData或NSString形式的JSON数据转换为objective-c对象。&lt;br&gt;SBJSonWriter负责把objective-c对象转换为NSData或NSString形式的JSON数据。&lt;/li&gt;
&lt;li&gt;第三方类库解析JSON， 使用JSONKit解析JSON数据&lt;br&gt;地址：&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/johnezang/JSONKit&lt;/a&gt;&lt;br&gt;JSONKit速度快，JsonKit1.4不支持ARC，需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;JSONKit采用分类方式为已有的类增加了新方法。用于将JSON数据恢复为objective-c对象。&lt;br&gt;研究一下第三方框架就可以发现:&lt;br&gt;JSONKit用分类为NSString和NSDate增加了如下方法，&lt;br&gt;把JSON数据转换为OC对象：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JSONKit用分类为NSString、NSStringArray和NSDictionary增加了如下方法：将OC对象装潢为NSString和NSData形式的JSON数据。&lt;br&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSData&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONData&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSString&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONString&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;a href=&quot;#使用AFNetworking实现网络通信&quot; class=&quot;headerlink&quot; title=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;/a&gt;使用AFNetworking实现网络通信&lt;/h2&gt;&lt;p&gt;只是需要向web某个站点的某个简单页面提交请求并获取服务器响应，则使用NSURLConnection来完成。为了更好的处理web站点请求，包括处理Session,Cookie，可以用AFNetworking，用于发送HTTP请求，接受HTTP响应。但不会缓存服务器响应，不能执行HTML页面中嵌入的JavaScript代码，也不会对页面内容进行任何解析处理。AFNetworking还支持JSON、Plist属性文件和XML解析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提交GET请求与提交POST请求&lt;br&gt;步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建AFHTTRequestOperationManager对象。&lt;/li&gt;
&lt;li&gt;根据服务器响应内容不同，为HTTORequestOperationManager对象指定不同的解析器。（JSON或Plist数据）&lt;/li&gt;
&lt;li&gt;如果需要发送GET请求，调用AFHTTRequestOperationManager对象的GET：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;如果要发送POST请求，调用AFHTTRequestOperationManager对象的POST：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;在success：参数指定的代码块中处理服务器响应成功的正确数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理JSON和Plist响应&lt;br&gt;可以直接将JSON和Plist转化为NSArray或NSDictionary对象。  AFHTTORequestOperationManager默认可以处理JSON或Plist对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理XML响应&lt;br&gt;为AFHTTORequestOperationManager显示使用&lt;br&gt;AF X MLParserResponseSerializer响应解析器，当使用AF X MLParserResponseSerializer解析器时，服务器返回的数据是一个NSXMLParser对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传文件&lt;br&gt;AFHTTRequestOperationManager对象的POST：    parameters:constructingBodyWithBlock:success：failure：方法提交POST请求即可，多了三个参数，一个是带AFMultipartFormData形参的代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;a href=&quot;#使用ASIHTTPRequest框架实现网络编程&quot; class=&quot;headerlink&quot; title=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;/a&gt;使用ASIHTTPRequest框架实现网络编程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发送同步或异步的GET请求&lt;br&gt;准备步骤：&lt;br&gt;目前不支持ARC，应该需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用代码块&lt;br&gt;ASIHTTPRequest发送异步请求，即可使用delegate为ASIHTTPRequest设置回调处理代码，也可用代码块来设置回调处理代码。&lt;br&gt;&lt;code&gt;-setCompletionBlock:设置发送请求、获取服务器响应完成时激发的代码块。&lt;/code&gt;&lt;br&gt;`-setFailedBlock:获取发送请求失败时激发的代码块。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS网络编程知识总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于NSString的引用计数问题</title>
    <link href="http://peilinghui.com/2016/04/10/%E5%85%B3%E4%BA%8ENSString%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2016/04/10/关于NSString的引用计数问题/</id>
    <published>2016-04-10T10:11:36.000Z</published>
    <updated>2017-04-10T12:29:27.000Z</updated>
    
    <content type="html">&lt;p&gt;NSString的神奇的引用计数问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSString的retainCount的变化&quot;&gt;&lt;a href=&quot;#NSString的retainCount的变化&quot; class=&quot;headerlink&quot; title=&quot;NSString的retainCount的变化&quot;&gt;&lt;/a&gt;NSString的retainCount的变化&lt;/h3&gt;&lt;h4 id=&quot;用NSString声明的字符串变量的retainCount变化由你初始化字符串时的方式决定&quot;&gt;&lt;a href=&quot;#用NSString声明的字符串变量的retainCount变化由你初始化字符串时的方式决定&quot; class=&quot;headerlink&quot; title=&quot;用NSString声明的字符串变量的retainCount变化由你初始化字符串时的方式决定&quot;&gt;&lt;/a&gt;用NSString声明的字符串变量的retainCount变化由你初始化字符串时的方式决定&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%886.43.32.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%886.43.43.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;NSCFConstantString（编译时）&quot;&gt;&lt;a href=&quot;#NSCFConstantString（编译时）&quot; class=&quot;headerlink&quot; title=&quot;__NSCFConstantString（编译时）&quot;&gt;&lt;/a&gt;__NSCFConstantString（编译时）&lt;/h4&gt;&lt;p&gt;用NSString &lt;em&gt;str = @”123”;定义的字符串是常量字符串&lt;br&gt;这些对象地址相同，是因为他们都是&lt;em&gt;*__NSCFConstantString&lt;/em&gt;&lt;/em&gt;对象，也就是字符串常量对象，可以看到其isa都是__NSCFConstantString，该对象存储在栈上，创建之后由系统来管理内存释放，相同内容的NSCFConstantString对象地址相同。该对象引用计数很大，为固定值不会变化，表示无限运行的retainCount，对其进行retain或release也不会影响其引用计数。&lt;/p&gt;
&lt;p&gt;当创建一个NSCFConstantString对象时，会检测这个字符串内容是否已经存在，如果存在，则直接将地址赋值给变量；不存在的话，则创建新地址，再赋值。&lt;/p&gt;
&lt;p&gt;总的来说，对于NSCFConstantString对象，只要字符串内容不变，就不会分配新的内存地址，无论你是赋值、retain、copy。这种优化在大量使用NSString的情况下可以节省内存，提高性能。&lt;/p&gt;
&lt;h4 id=&quot;NSCFString（运行时）&quot;&gt;&lt;a href=&quot;#NSCFString（运行时）&quot; class=&quot;headerlink&quot; title=&quot;__NSCFString（运行时）&quot;&gt;&lt;/a&gt;__NSCFString（运行时）&lt;/h4&gt;&lt;p&gt;使用stringWithFormat创建的NSString为变量，系统会进行引用计数。&lt;br&gt;在上面的输出结果中，我们看到另外还有两类isa分别是：&lt;strong&gt;__NSCFString&lt;/strong&gt;和&lt;strong&gt;NSTaggedPointerString&lt;/strong&gt;，先来看__NSCFString。&lt;/p&gt;
&lt;p&gt;在我的理解，__NSCFString对象是一种NSString子类，存储在堆上，不属于字符串常量对象。该对象创建之后和其他的Obj对象一样引用计数为1，对其执行retain和release将改变其retainCount。&lt;/p&gt;
&lt;h4 id=&quot;NSTaggedPointerString&quot;&gt;&lt;a href=&quot;#NSTaggedPointerString&quot; class=&quot;headerlink&quot; title=&quot;__NSTaggedPointerString&quot;&gt;&lt;/a&gt;__NSTaggedPointerString&lt;/h4&gt;&lt;p&gt;这个对象是标签指针，苹果在 64 位环境下对NSString、NSNumber等对象做了一些优化。简单的说就是把指针指向的内容直接放在了指针变量的内存地址中，在 64 位环境下指针变量的大小达到了 8 位，能容纳长度较小的内容，于是使用了标签指针来优化数据的存储。从其引用计数可以看出，这种对象也是无垠的retainCount，这种对象存储在指针的内容中。&lt;/p&gt;
&lt;p&gt;对 NSString对象来说，当非字面量的数字，英文字母字符串的长度小于等于9的时候会自动成为NSTaggedPointerString类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为__NSCFString类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%886.57.27.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%886.57.46.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;stringWithString取决于后面跟的string, 后面string的retainCount是多少那么用stringWithString创建的对象就为多少&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;用NSMutableArray结合着NSMutableString来观察一下retainCount的变化。&quot;&gt;&lt;a href=&quot;#用NSMutableArray结合着NSMutableString来观察一下retainCount的变化。&quot; class=&quot;headerlink&quot; title=&quot;用NSMutableArray结合着NSMutableString来观察一下retainCount的变化。&quot;&gt;&lt;/a&gt;用NSMutableArray结合着NSMutableString来观察一下retainCount的变化。&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%887.03.40.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%887.03.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;操作系统的内存管理分成堆和栈。&lt;/p&gt;
&lt;p&gt;在堆中分配的内存，都适用引用计数模式；在栈中则不是。&lt;/p&gt;
&lt;p&gt;NSString 定义的对象是保存在栈中，所以它没有引用计数，不是通过引用计数对内存进行管理的。常量的引用计数会是一个很大的整数，测试的结果显示它是－1. 对该对象进行 retain 操作，不好改变它的retainCount 值。&lt;/p&gt;
&lt;p&gt;NSMutableNSString 定义的对象，需要先分配堆中的内存空间，再初始化才能使用。它是采用引用计数管理内存的。对该对象做 retainCount 操作则每次增加一个。&lt;/p&gt;
&lt;p&gt;其实，引用计数是对内存区域的空间管理方式，是应从内存块的视角去看的。任何对象都是指向内存块的指针，有多少个指针指向这个内存块，这个内存块就有多少个引用计算。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10220683/what-is-the-different-between-nscfstring-and-nsconstantstring&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stackoverflow上关于NSCFString和NSConstantstring的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.cnbluebox.com/blog/2014/04/16/nsstringte-xing-fen-xi-xue-xi/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSString特性分析学习&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSString的神奇的引用计数问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>effective objective-c 2.0读书笔记</title>
    <link href="http://peilinghui.com/2016/04/03/effective%20objective-c%202.0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2016/04/03/effective objective-c 2.0读书笔记/</id>
    <published>2016-04-03T05:01:49.000Z</published>
    <updated>2017-03-27T07:22:53.000Z</updated>
    
    <content type="html">&lt;p&gt;effective objective-c 2.0读书笔记.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;effective-objective-c-2-0&quot;&gt;&lt;a href=&quot;#effective-objective-c-2-0&quot; class=&quot;headerlink&quot; title=&quot;effective objective-c 2.0&quot;&gt;&lt;/a&gt;effective objective-c 2.0&lt;/h1&gt;&lt;p&gt;作者网站：&lt;a href=&quot;http://www.galloway.me.uk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.galloway.me.uk/&lt;/a&gt;&lt;br&gt;英文原版：&lt;a href=&quot;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就把重点的几个摘录出来了。&lt;/p&gt;
&lt;h2 id=&quot;熟悉Objective-c&quot;&gt;&lt;a href=&quot;#熟悉Objective-c&quot; class=&quot;headerlink&quot; title=&quot;熟悉Objective-c&quot;&gt;&lt;/a&gt;熟悉Objective-c&lt;/h2&gt;&lt;h3 id=&quot;Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot;&gt;&lt;a href=&quot;#Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot; class=&quot;headerlink&quot; title=&quot;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&quot;&gt;&lt;/a&gt;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;消息结构 : 运行时所执行的代码由运行时环境决定
函数调用 : 运行时所执行的代码由编译期决定.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;code&gt;[person run];&lt;/code&gt;&lt;br&gt;给person对象发送一条run消息 : 不到程序运行的时候你都不知道他究竟会执行什么代码. 而且, person这个对象究竟是Person类的对象, 还是其他类的对象, 也要到运行时才能确定, 这个过程叫动态绑定.&lt;/p&gt;
&lt;p&gt;对象所占内存总是分配在堆空间中. 不能在栈中分配Objective-C对象.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;栈空间 : 栈空间的内存不用程序员管理.
堆空间 : 堆空间的内存需要程序员管理.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#第2条：在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;第2条：在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;p&gt;在.h文件中用@Class,在.m文件中再引入头文件。来缩短编译时间，降低彼此的依赖程度，降低类之间的耦合。&lt;/p&gt;
&lt;h3 id=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;a href=&quot;#第3条：多用字面量语法，少用与之等价的方法&quot; class=&quot;headerlink&quot; title=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;/a&gt;第3条：多用字面量语法，少用与之等价的方法&lt;/h3&gt;&lt;p&gt;字面量数值：&lt;code&gt;NSNumber *someNumber = @1;&lt;/code&gt;&lt;br&gt;字面量数组：&lt;code&gt;NSArray *animals=@[@&amp;quot;cat&amp;quot;,@&amp;quot;dog&amp;quot;,@&amp;quot;mouse&amp;quot;];&lt;/code&gt;  取某个下标所对应的对象更方便：&lt;code&gt;NSString *dog = animals[1]&lt;/code&gt;&lt;br&gt;字面量字典：&lt;code&gt;NSDictionary *personData = @{
                @&amp;quot;firstname&amp;quot;: @&amp;quot;pei&amp;quot;,
                @&amp;quot;lastname&amp;quot;: @&amp;quot;linghui&amp;quot;,
                @&amp;quot;age&amp;quot;: @&amp;quot;21&amp;quot;;
     };&lt;/code&gt;取值：&lt;code&gt;mutableDictionary[@&amp;quot;firstname&amp;quot;] = @&amp;quot;pei&amp;quot;;&lt;/code&gt;&lt;br&gt;使用字面量语法创建出来的字符串、数组、字典对象都是不可变的，若想变成可变的需在后面添加mutableCopy;&lt;/p&gt;
&lt;p&gt;我用们字面量语法替代传统的alloc-init来创建对象的好处 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方便直观
更加安全
更利于debug
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;局限性 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只有NSString, NSArray, NSDictionary, NSNumber支持字面量语法
若想用字面量语法创建出可变对象, 则需要再次调用mutableCopy方法复制多一份(多调用了一个方法, 多创建了一个对象. 不必要)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;p&gt;一般在工程中，会把常量定义在prefix.pch或者是一些接口常量定义在Constants.h文件中。更好的方法是在.m文件中用static与const来声明&lt;code&gt;static const NSTimeInterval Duration = 0.3&lt;/code&gt;&lt;br&gt;若是全局变量，则在.h中用extern关键字修饰，在.m文件中赋值。&lt;br&gt;&lt;code&gt;extern NSString *const TDFConstants&lt;/code&gt;&lt;br&gt;&lt;code&gt;NSString *const TDFConstants = @&amp;quot;VALUE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高.  &lt;/p&gt;
&lt;p&gt;宏能做到const不能办到的事.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;宏能定义函数
OC的单例模式用到宏
宏还能根据传入的参数生成字符串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么少用#define预处理指令?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用预处理指令定义的常量不含类型信息
编译时只会进行简单查找与替代操作, 会分配多次内存
如果有人重新定义了常量值, 则会导致程序中常量值不一致
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么多用类型常量?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在实现文件中使用static const定义只在该文件内可见的常量, 其他文件无法使用(无需给常量名称加前缀)
在头文件中使用extern来声明全局常量, 并在实现文件中定义其值, 可以供整个程序使用(需要给常量名称加前缀)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;a href=&quot;#第5条：用枚举表示状态、选项、状态码&quot; class=&quot;headerlink&quot; title=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;/a&gt;第5条：用枚举表示状态、选项、状态码&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CASH&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;现金&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CARD&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;银行卡&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CREDIT_ACCOUNT&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,   &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;挂账&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;constant&quot;&gt;KindPay_Kind&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项不需要组合使用, 则用NS_ENUM&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransition&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionNone&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromLeft&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromRight&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlUp&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlDown&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项可能组合使用, 则用NS_OPTIONS&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NS_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NSUInteger, UIViewAutoresizing)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingNone                 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleLeftMargin   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleWidth        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleRightMargin  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleTopMargin    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleHeight       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleBottomMargin = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码为苹果源码.&lt;strong&gt;使用NS_ENUM和NS_OPTIONS来替代C语言的enum的好处&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可以自定义枚举的底层数据类型
在C中使用C的语法, 在OC中使用OC的语法, 保持语法的统一
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外, 在处理枚举的switch语句中, 不要使用default分支, 因为以后你加入新枚举之后, 编译器会提示开发者 : switch语句没有处理所有枚举(没使用default的情况下).&lt;/p&gt;
&lt;h2 id=&quot;对象、消息、运行期&quot;&gt;&lt;a href=&quot;#对象、消息、运行期&quot; class=&quot;headerlink&quot; title=&quot;对象、消息、运行期&quot;&gt;&lt;/a&gt;对象、消息、运行期&lt;/h2&gt;&lt;h3 id=&quot;第6条：属性&quot;&gt;&lt;a href=&quot;#第6条：属性&quot; class=&quot;headerlink&quot; title=&quot;第6条：属性&quot;&gt;&lt;/a&gt;第6条：属性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;@property, @synthesize, @dynamic&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;@property&lt;/strong&gt;可以自动创建存取方法，帮我们分解成setter和getter方法声明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@synthesize firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上代码相当于给Person类添加一个_firstName的实例变量并为该实例变量生成setter和getter方法的实现(存取方法).&lt;br&gt;手动调用@synthesize可以用来修改实例变量的名称&lt;br&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@dynamic firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该代码会告诉编译器 : 不要自动创建实现属性(property)所用的实例变量(_property)和存取方法实现(setter和getter).&lt;br&gt;也就是说, 实例变量不存在了, 因为编译器不会自动帮你创建了. 而且如果你不手动实现setter和getter, 使用者用点语法或者对象方法调用setter和getter时, 程序会直接崩溃, 崩溃原因很简单 : unrecognized selector sent to instance&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 原子性：nonatomic不使用同步锁。
- 读写权限：readwrite(读写)有setter和getter由@synthesize自动实现；readonly(只读)只有getter方法
- 内存管理：assign：简单赋值(纯量)；strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。unsafe_retained:在属性所指对象遭到摧毁时，属性值不会清空，与assign类似，不过只用于对象。copy：与strong类似，但是不保留新值，而是拷贝，用于NSString。
- 方法名：getter=&amp;lt;name&amp;gt;;  setter=&amp;lt;name&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;a href=&quot;#第7条：在对象内部尽量直接访问实例变量&quot; class=&quot;headerlink&quot; title=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;/a&gt;第7条：在对象内部尽量直接访问实例变量&lt;/h3&gt;&lt;p&gt;为什么呢? 使用点语法不好吗? 这里说说区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接用_xxx访问实例变量而不用点语法可以绕过OC的&amp;quot;方法派发&amp;quot;, 效率比用点语法来访问快
直接用_xxx访问实例变量而不用点语法不会调用setter方法, 所以不会触发KVO(Key Value Observing), 同时如果你访问的该属性是声明为copy的属性, 则不会进行拷贝, 而是直接保留新值, 释放旧值.
使用点语法访问有助于debug, 因为可以在setter或getter中增加断点来监控方法的调用
属性使用懒加载时, 必须使用点语法, 否则实例变量永远不会初始化(因为懒加载实际就是调用getter方法, 直接访问实例变量绕过了该方法, 所以该变量则永远为nil)
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;在&lt;strong&gt;读取&lt;/strong&gt;实例变量的时候采用&lt;strong&gt;直接访问&lt;/strong&gt;的形式，在&lt;strong&gt;设置&lt;/strong&gt;实例变量的时候采用通过&lt;strong&gt;属性&lt;/strong&gt;。 &lt;/li&gt;
&lt;li&gt;在初始化方法以及dealloc方法中，直接通过实例变量来读写数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第8条：对象等同性&quot;&gt;&lt;a href=&quot;#第8条：对象等同性&quot; class=&quot;headerlink&quot; title=&quot;第8条：对象等同性&quot;&gt;&lt;/a&gt;第8条：对象等同性&lt;/h3&gt;&lt;p&gt;比较两个对象是否相同.&lt;br&gt;我们可以重写isEqual方法自定义对象等同的条件&lt;/p&gt;
&lt;h3 id=&quot;第9条：类族模式&quot;&gt;&lt;a href=&quot;#第9条：类族模式&quot; class=&quot;headerlink&quot; title=&quot;第9条：类族模式&quot;&gt;&lt;/a&gt;第9条：类族模式&lt;/h3&gt;&lt;p&gt;Objective-C的系统框架中普遍使用此模式, 用子类来隐藏”抽象基类”的内部实现细节.&lt;br&gt;我们肯定使用过UIButton的这个类方法&lt;/p&gt;
&lt;p&gt; &lt;code&gt;+ (UIButton *)buttonWithType:(UIButtonType)type;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这就是UIButton类实现的”工厂方法”, 根据传入的枚举创建并返回合乎条件的子类.&lt;/p&gt;
&lt;p&gt;Foundation框架中大部分容器类都是类族, 如NSArray与NSMutableArray, NSSet与NSMutableSet, NSDictionary与NSMutableDictionary.&lt;/p&gt;
&lt;p&gt;用isKindOfClass方法可以判断对象所属的类是否位于类族之中.&lt;/p&gt;
&lt;p&gt;在类族中实现子类时所需遵循的规范一般都会定义于基类的文档之中, 使用前应先看看.&lt;/p&gt;
&lt;p&gt;具体类族的使用方法大家请看书~~&lt;/p&gt;
&lt;h3 id=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;a href=&quot;#第10条：在既有类中使用关联对象存放自定义数据&quot; class=&quot;headerlink&quot; title=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;/a&gt;第10条：在既有类中使用关联对象存放自定义数据&lt;/h3&gt;&lt;p&gt;在类的内部利用哈希表映射技术, 关联一个与该类毫无耦合的对象.&lt;br&gt;使用场景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为现有的类添加私有变量以帮助实现细节
为现有的类添加公有属性
为KVO创建一个关联的观察者
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;鉴于书中所说, 容易出现循环引用, 以及关联对象释放和移除不同步等缺陷,&lt;/p&gt;
&lt;h3 id=&quot;第11条：理解objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#第11条：理解objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;第11条：理解objc_msgSend的作用&quot;&gt;&lt;/a&gt;第11条：理解objc_msgSend的作用&lt;/h3&gt;&lt;p&gt;消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。&lt;br&gt;OC的消息机制&lt;br&gt;&lt;code&gt;[someObject messageName: parameter]&lt;/code&gt;&lt;br&gt;&lt;code&gt;id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&amp;quot;方法列表&amp;quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&amp;quot;消息转发&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一些函数：&lt;br&gt;objc_msgSend_stret:待发送的消息要返回结构体&lt;br&gt;objc_msgSend_fpret:消息返回的是浮点数&lt;br&gt;objc_msgSendSuper:要给超类发送消息&lt;/p&gt;
&lt;h2 id=&quot;接口与API设计&quot;&gt;&lt;a href=&quot;#接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;接口与API设计&quot;&gt;&lt;/a&gt;接口与API设计&lt;/h2&gt;&lt;h3 id=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;a href=&quot;#第15条：用前缀避免命名空间的冲突&quot; class=&quot;headerlink&quot; title=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;/a&gt;第15条：用前缀避免命名空间的冲突&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;选择与你公司、应用程序或者二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。
若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。
Apple宣称保留使用所有两字母前缀的权利，所以自己所选用的前缀最好是三字母的。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;a href=&quot;#第16条：提供“全能初始化方法”&quot; class=&quot;headerlink&quot; title=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;/a&gt;第16条：提供“全能初始化方法”&lt;/h3&gt;&lt;h3 id=&quot;第17条：实现description方法&quot;&gt;&lt;a href=&quot;#第17条：实现description方法&quot; class=&quot;headerlink&quot; title=&quot;第17条：实现description方法&quot;&gt;&lt;/a&gt;第17条：实现description方法&lt;/h3&gt;&lt;p&gt;调试程序时，LLDB调试，在封装的JSONHelper中看到了这样的方法：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//对象转换为json对象.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSString *) &lt;span class=&quot;string&quot;&gt;transJson:&lt;/span&gt;(Jastor *) obj&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *returnDic = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *array =[JastorRuntimeHelper &lt;span class=&quot;string&quot;&gt;propertyNames:&lt;/span&gt;[obj &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;NSString&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;description&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;debugDescription&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;superclass&quot;&lt;/span&gt;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [returnDic &lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;[obj &lt;span class=&quot;string&quot;&gt;valueForKey:&lt;/span&gt;key] &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *returnString = [returnDic JSONString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中description在Foundation框架的NSString.h中&lt;br&gt;&lt;code&gt;@property (readonly, copy) NSString *description;&lt;/code&gt;&lt;br&gt;在objc的NSObject.h中&lt;br&gt;`+ (NSString *)description;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(NSString *)debugDescription;`&lt;br&gt;在Foundation框架的NSproxy.h中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;a href=&quot;#第18条：尽量使用不可变对象&quot; class=&quot;headerlink&quot; title=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;/a&gt;第18条：尽量使用不可变对象&lt;/h3&gt;&lt;h3 id=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;a href=&quot;#第19条：使用清晰而协调的命名方式&quot; class=&quot;headerlink&quot; title=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;/a&gt;第19条：使用清晰而协调的命名方式&lt;/h3&gt;&lt;h3 id=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;a href=&quot;#第20条：为私有方法名加前缀&quot; class=&quot;headerlink&quot; title=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;/a&gt;第20条：为私有方法名加前缀&lt;/h3&gt;&lt;p&gt;便于修改方法名或方法签名，可以使用- (void)p_private{};私有方法只在实现的时候声明。&lt;br&gt;不要单用一个下划线做私有方法的前缀，因为这种做法的预留给苹果公司用的。&lt;/p&gt;
&lt;h3 id=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;a href=&quot;#第21条：理解Objective-C错误模型&quot; class=&quot;headerlink&quot; title=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;/a&gt;第21条：理解Objective-C错误模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ARC下,想生成“异常安全”的代码，需要打开的编译器标志叫做-fobjc-arc-exception.&lt;/li&gt;
&lt;li&gt;objective-c所采用的方法：只在极其罕见的情况下抛出异常，异常抛出后，无需考虑恢复问题，而且应用程序此时也应该退出。最好的方法：在那些子类必须覆写的超类方法里抛出异常。令方法返回nil/0.或是使用NSError，以表明其中有错误发生。如：  &lt;/li&gt;
&lt;li&gt;初始化方法无法根据传入的参数来初始化当前实例，那么就可以令其返回nil/0。&lt;/li&gt;
&lt;li&gt;NSError：&lt;ul&gt;
&lt;li&gt;Error domain（类型为字符串）：用全局变量定义，在从URL中解析或取得数据时出错了，就使用NSURLErrorDomain来表示错误范围。&lt;/li&gt;
&lt;li&gt;Error code（类型为整数）：用enum定义，当HTTP请求出错时，可能会把HTTP状态码设置为错误码。&lt;/li&gt;
&lt;li&gt;User Info（类型为字典）：可将错误串成“错误链”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NSError的用法：&lt;ul&gt;
&lt;li&gt;通过委托协议来传递此错误。NSURLConnection在NSURLConnectionDelegate中定义了：&lt;code&gt;-(void)connection:(NSURLConnection *)connection didFail WithError:(NSError *)error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;经由方法的“输出参数”返回给调用者&lt;code&gt;-(BOOL)doSomething:(NSError **)error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结：&lt;br&gt; 只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;br&gt; 在错误不那么严重的情况下，可以指派委托方法来处理错误，也可把错误信息放在NSError对象里，经由输出参数返回给调用者。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;a href=&quot;#第22条：理解NSCopying协议&quot; class=&quot;headerlink&quot; title=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;/a&gt;第22条：理解NSCopying协议&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;copy 执行的一定是不可变版本的拷贝，哪怕NSMutableArray, NSMutableString 这类可变对象，进行&lt;code&gt;copy&lt;/code&gt;操作，返回对象的也是不可变的，返回对象类型本质为 NSArray， NSString 类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;mutableCopy 执行的是可变版本的拷贝，不论对象是可变的对象（NSMutableString， NSMutableArray），还是不可变对象（NSArray， NSString），执行&lt;code&gt;mutableCopy&lt;/code&gt;方法后返回对象都是可变的。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Foundation 框架中的所有collection类在默认情况下都执行浅拷贝，即，只拷贝容器对象本身，而不复制其中数据。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有专门定义深拷贝的协议，绝大多数遵从&lt;code&gt;NSCoping&lt;/code&gt;协议的对象执行的都是浅拷贝。除非文档说明是深拷贝，或者自定义方法来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;若想令自己所写的对象具有拷贝功能，则需遵循NSCopying协议。&lt;br&gt;实现方法：&lt;code&gt;-(id)copyWithZone:(NSZone *)zone&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。&lt;/li&gt;
&lt;li&gt;深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。&lt;br&gt;浅拷贝：在拷贝对象时，只拷贝容器对象本身，而不复制其中每个对象。（Foundation框架中的所有collection类在默认情况下执行浅拷贝）&lt;br&gt;复制对象时，一般执行浅拷贝。&lt;/li&gt;
&lt;li&gt;如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;协议与分类&quot;&gt;&lt;a href=&quot;#协议与分类&quot; class=&quot;headerlink&quot; title=&quot;协议与分类&quot;&gt;&lt;/a&gt;协议与分类&lt;/h2&gt;&lt;h3 id=&quot;第23条：通过delegate与data-source协议进行对象间通信&quot;&gt;&lt;a href=&quot;#第23条：通过delegate与data-source协议进行对象间通信&quot; class=&quot;headerlink&quot; title=&quot;第23条：通过delegate与data source协议进行对象间通信&quot;&gt;&lt;/a&gt;第23条：通过delegate与data source协议进行对象间通信&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Delegate pattern：定义一套接口，某对象若想接受另一个对象的委托，需遵从该接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。    &lt;/li&gt;
&lt;li&gt;好处：可将数据与业务解耦，如：页面有个显示一系列数据所用的视图，此视图只需要包含显示数据所需的逻辑代码，而不应该决定要显示何种数据以及数据之间如何交互。  &lt;/li&gt;
&lt;li&gt;委托协议名要在相关类名@protocol后面加Delegate，类中用一个用一个属性来存放其委托对象，&lt;code&gt;@property(nonatomic,weak)id&amp;lt;TDFNetworkingDelegate&amp;gt;delegate;&lt;/code&gt;必须设置为weak或unsafe_unretained（使用strong容易引入“保留环”）&lt;br&gt;委托协议常用@option来标注大部分或全部方法。&lt;/li&gt;
&lt;li&gt;委托模式：对象把应对某个行为的责任委托给另外一个类了。&lt;/li&gt;
&lt;li&gt;数据源模式：信息从data source流向Class再流向delegate。&lt;/li&gt;
&lt;li&gt;若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;a href=&quot;#第24条：将类的实现代码分散到便于管理的数个分类之中&quot; class=&quot;headerlink&quot; title=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;/a&gt;第24条：将类的实现代码分散到便于管理的数个分类之中&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用category机制把类的实现代码划分成易于管理的小块。&lt;/li&gt;
&lt;li&gt;将应该视为私有的方法归入名叫Private的分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;a href=&quot;#第25条：总是为第三方类的分类名称加前缀&quot; class=&quot;headerlink&quot; title=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;/a&gt;第25条：总是为第三方类的分类名称加前缀&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其名称加上你专用的前缀。&lt;/li&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;a href=&quot;#第26条：勿在分类中声明属性&quot; class=&quot;headerlink&quot; title=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;/a&gt;第26条：勿在分类中声明属性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;把封装数据所用的全部属性都定义在主接口里。&lt;/li&gt;
&lt;li&gt;在class-continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。&lt;/li&gt;
&lt;li&gt;如果需要在分类中为该属性实现存取方法，可以把存取方法声明为@dynamic。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;a href=&quot;#第27条：使用class-continuation分类隐藏实现细节&quot; class=&quot;headerlink&quot; title=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;/a&gt;第27条：使用class-continuation分类隐藏实现细节&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;class-continuation分类与普通分类不同，它必须定义在其所接续的那个类的实现文件中，唯一能声明实例变量的分类。&lt;/li&gt;
&lt;li&gt;作用：定义方法和实例变量。&lt;/li&gt;
&lt;li&gt;可以实现OC和C++的混编，如：网页浏览器的框架WebKit，大部分代码是C++，而对外显示的却是OC代码，CoreAnimation里面后端代码使用C++，对外公布却是OC接口。&lt;/li&gt;
&lt;li&gt;将public接口中声明为“只读”的属性扩展为“可读写”以便在类的内部使用其属性。（我们通常不直接访问实例变量，而是通过设置访问方法来做，因为这样能触发KVO通知，其他对象有可能监听此事件）&lt;h3 id=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;a href=&quot;#第28条：通过协议提供匿名对象&quot; class=&quot;headerlink&quot; title=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;/a&gt;第28条：通过协议提供匿名对象&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;第29条：理解引用计数&quot;&gt;&lt;a href=&quot;#第29条：理解引用计数&quot; class=&quot;headerlink&quot; title=&quot;第29条：理解引用计数&quot;&gt;&lt;/a&gt;第29条：理解引用计数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;OC 使用引用计数来管理内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;引用计数工作原理&quot;&gt;&lt;a href=&quot;#引用计数工作原理&quot; class=&quot;headerlink&quot; title=&quot;引用计数工作原理&quot;&gt;&lt;/a&gt;引用计数工作原理&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;引用计数：用以表示当前有多少个事物想令此对象继续存活下去。查看引用计数的属性为&lt;code&gt;retainCount&lt;/code&gt;，但只能作为参考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;retain：递增&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;release：递减&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;autorelease：在清理“自动释放池”（autorelease pool）时，才递减引用计数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象A被创建出来时，引用计数最少为1，因为不确定在&lt;code&gt;alloc&lt;/code&gt;或&lt;code&gt;init&lt;/code&gt;方法中，是否有其他对象B也保留了该对象A。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当引用计数为1时，再次调用release方法，对象就被回收了，而这时候调用对象的&lt;code&gt;retainCount&lt;/code&gt;方法，不一定为0，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;向一个已经被回收的对象发送&lt;code&gt;retainCount&lt;/code&gt;消息，输出结果是不确定的，而且，如果对象内存被重新使用了，就可能造成程序异常崩溃&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当执行最后一次release时，系统知道马上就要回收内存，就没必要将&lt;code&gt;retainCount&lt;/code&gt;减1，可以减少一次内存的写操作，加速对象的回收&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;悬挂指针（dangling pointer）：指针所指向的对象内存被释放了，但指针没有清空，指针指向的是无效对象。所以一般对象被释放后，要把指针置为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明为retain/strong的属性，设置set方法时，应该是先保留新值，再释放旧值，最后更新实例变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为如果新旧值一样的话，先执行release，可能会导致系统将值对象永久回收，而后续的retain操作是无法令已经彻底回收的对象复生的，于是实例变量就成了悬挂指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一般是在方法中，有返回对象时，不可能在&lt;code&gt;return&lt;/code&gt;之后，再进行&lt;code&gt;release&lt;/code&gt;，这时候就需要&lt;code&gt;autorelease&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease 可以让保证对象在跨越“方法调用边界”（method call boundary）后存活一段时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;autorelease实际释放是在清空最外层的自动释放池时，即当前线程的下一次事件循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;循环引用会导致内存泄漏，因为循环中的对象其保留技术不会降为0，永远不会释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 引用计数机制通过可以递增递减的计数器来管理内存。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 在对象生命期中，其余对象通过引用来保留或释放此对象，保留与释放操作分别会递增及递减引用计数&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第36条：不要使用retainCount&quot;&gt;&lt;a href=&quot;#第36条：不要使用retainCount&quot; class=&quot;headerlink&quot; title=&quot;第36条：不要使用retainCount&quot;&gt;&lt;/a&gt;第36条：不要使用retainCount&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;retainCount&lt;/code&gt;返回的保留计数只是某个给定时间点上的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;该方法并未考虑到系统会稍后把自动释放池清空，因而不会将后续的释放操作从返回值里减去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;retainCount&lt;/code&gt;可能永远不为0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签指针（tagged pointer）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标注特定类型的值，一般是存储小的对象，eg：NSNumber，NSDate&lt;/li&gt;
&lt;li&gt;把与数值有关的全部消息都放在指针里面&lt;/li&gt;
&lt;li&gt;内存读取效率高 ，提升性能、节省内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;a href=&quot;#第30条：以ARC简化引用计数&quot; class=&quot;headerlink&quot; title=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;/a&gt;第30条：以ARC简化引用计数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;使用ARC时，引用计数实际上还是要执行的，只是由ARC自动添加保留和释放操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ARC在执行&lt;code&gt;retain&lt;/code&gt;和&lt;code&gt;release&lt;/code&gt;方法时，会直接调用其底层C语言版本，这样性能更好，节省CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;使用ARC时必须遵循的方法命名规则&quot;&gt;&lt;a href=&quot;#使用ARC时必须遵循的方法命名规则&quot; class=&quot;headerlink&quot; title=&quot;使用ARC时必须遵循的方法命名规则&quot;&gt;&lt;/a&gt;使用ARC时必须遵循的方法命名规则&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以&lt;code&gt;alloc&lt;/code&gt;、&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;copy&lt;/code&gt;、&lt;code&gt;mutableCopy&lt;/code&gt;开头的方法名（这里称方法X）返回的对象归调用者所有，调用者要负责返回对象的释放。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比如以&lt;code&gt;new&lt;/code&gt;开头的方法&lt;code&gt;+ (NSString *)newName&lt;/code&gt;，在返回的时候，ARC在&lt;code&gt;return&lt;/code&gt;的时候不会加上&lt;code&gt;autorelease&lt;/code&gt;，因为它是被调用者所拥有的，它必须被调用者来释放。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *newName = [NSString newName];
//对newName进行处理，完之后执行下面语句
[newName release];
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;而其他不以这四个词开头的方法（以下均称为方法Y），返回对象不归调用者所有，它们在方法内生成的时候，&lt;code&gt;return&lt;/code&gt;后面会加上&lt;code&gt;autorelease&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARC 在编译期会把能够互相抵消的retain、release、autorelease操作约简。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如在同一个对象上执行多次保留与释放操作，ARC有时可以成对地移除这两个操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC 也包含运行期组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;以方法Y创建的对象，在外层使用的时候，因为不被拥有，需要进行&lt;code&gt;retain&lt;/code&gt;操作，而这时，运行期会进行优化：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用对象的&lt;code&gt;autorelease&lt;/code&gt;方法时，会改为调用&lt;code&gt;objc_autoreleaseReturnValue&lt;/code&gt;，当后面发现&lt;code&gt;retain&lt;/code&gt;方法时，会设置全局的一个标志位，并且不执行&lt;code&gt;autorelease&lt;/code&gt;操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用对象的&lt;code&gt;retain&lt;/code&gt;方法时，改为执行&lt;code&gt;objc_retainAutoreleaseReturnValue&lt;/code&gt;，如果发现之前的标志位，就直接返回对象，不执行&lt;code&gt;retain&lt;/code&gt;操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置并检测标志位，比调用&lt;code&gt;autorelease&lt;/code&gt;和&lt;code&gt;retain&lt;/code&gt;更快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以上的所有处理，只能由编译器的开发者来完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;变量的内存管理语义&quot;&gt;&lt;a href=&quot;#变量的内存管理语义&quot; class=&quot;headerlink&quot; title=&quot;变量的内存管理语义&quot;&gt;&lt;/a&gt;变量的内存管理语义&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;默认情况下，每个变量都是指向对象的强引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC在设置set方法时：先保留新值，再释放旧值，最后设置实例变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;__strong: 默认语义，保留此值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unsafe&lt;/strong&gt;unretained: 不保留此值，对象被回收，指针不为空，可能会出问题&lt;/li&gt;
&lt;li&gt;__weak: 不保留此值，对象被回收，指针变量会自动清空&lt;/li&gt;
&lt;li&gt;__autoreleasing: 把对象“按引用传递”（pass by reference）给方法时，使用这个特殊的修饰符，此值在方法返回时自动释放。&lt;/li&gt;
&lt;li&gt;__weak 最经常用来打破由block所引入的“保留环”（retain cycle）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;ARC-清理实例变量&quot;&gt;&lt;a href=&quot;#ARC-清理实例变量&quot; class=&quot;headerlink&quot; title=&quot;ARC 清理实例变量&quot;&gt;&lt;/a&gt;ARC 清理实例变量&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARC也负责对实例变量进行内存管理。在回收分配给对象的内存时生成必要的清理代码，凡是具备强引用的变量，都必须释放。手动管理时在dealloc方法中进行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc {
    //ARC 自动添加的代码
    [_foo release];
    [_bar release];
    [super dealloc];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于非Objective-C的对象，需要手动进行内存管理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//释放有malloc创建的对象
void     (*free)(struct _malloc_zone_t *zone, void *ptr); 
//释放CoreFoundation中的对象
void CFRelease(CFTypeRef cf);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC 下，不能覆写内存管理方法。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. ARC之后，无需担心内存管理问题，也可省去类中的许多样板代码&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;2. ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”与“释放”操作。ARC下变量的内存管理语义由修饰符来指明&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;3. 由方法所返回的对象，其内存管理语义总是通过方法名来体现（注意方法X和方法Y）&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;4. ARC只负责管理OC对象的内存，CoreFoundation对象要手动管理，需要适时调用CFRetain/CFRelease&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;a href=&quot;#第31条：在dealloc方法中只释放引用并解除监听&quot; class=&quot;headerlink&quot; title=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;/a&gt;第31条：在dealloc方法中只释放引用并解除监听&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对象在经历其生命周期后，最终会为系统所回收，这时就要执行&lt;code&gt;dealloc&lt;/code&gt;方法，每个对象的声明周期内，此方法仅执行一次&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;运行期系统会在适当的时机调用&lt;code&gt;dealloc&lt;/code&gt;方法，最好不要自己手动调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dealloc 中执行的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;释放对象所拥有的引用，即所有OC对象都释放掉&lt;/li&gt;
&lt;li&gt;非OC对象需要手工释放&lt;/li&gt;
&lt;li&gt;清理所有配置过的观测行为（observation behavior）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开销较大或系统内稀缺的资源（文件描述符、套接字、大块内存等）最好不要等到系统调用&lt;code&gt;dealloc&lt;/code&gt;方法时才释放，应该是在应用程序用完资源对象后，手工实现方法来释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对于上述资源，最好添加释放标志，在dealloc中进行检测，以防忘记清理。 &lt;/li&gt;
&lt;li&gt;系统并不保证创建的每个对象都会执行&lt;code&gt;dealloc&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;dealloc&lt;/code&gt;方法中，尽量不要调用其他方法&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;dealloc&lt;/code&gt;的线程，并不一定是主线程&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;dealloc&lt;/code&gt;方法中，禁止调用属性的存取方法，（MRC下释放属性变量的时候，要使用&lt;code&gt;_&lt;/code&gt;，而不能是&lt;code&gt;self.&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 在&lt;code&gt;dealloc&lt;/code&gt;方法中，只能做的是释放指向其他对象的引用，并取消原来订阅的“键值观测”（KVO）或&lt;code&gt;NSNotificationCenter&lt;/code&gt;等通知，不要做其他事情&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;2. 如果对象持有文件描述符等系统资源，应该专门编写一个方法来释放此种资源，并约定为规则&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;3. 执行异步任务的方法不应再dealloc里调用；只能在正常状态下执行的方法也不应再dealloc里调用，因为此时对象已处于正在回收的状态&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;a href=&quot;#第32条：编写异常安全代码时留意内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;/a&gt;第32条：编写异常安全代码时留意内存管理问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在运行期系统中，C++与Objective-C的异常相互兼容，即从其中一门语言里抛出的异常能用另外一门语言所编的“异常处理程序”（exception handler）来捕获&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;a href=&quot;#第33条：以弱引用避免重复引用&quot; class=&quot;headerlink&quot; title=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;/a&gt;第33条：以弱引用避免重复引用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当对象以某种方式互相引用就会形成“环”，这些引用会使对象永远不会被系统所回收，从而造成内存泄漏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;避免保留环的最佳方法就是弱引用。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;weak&lt;/code&gt;比&lt;code&gt;unsafe_unretained&lt;/code&gt;更安全，&lt;code&gt;weak&lt;/code&gt;修饰的属性，一旦被系统回收，属性值会自动设为&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当一个对象实例被回收，其所有的属性和变量都应当置空，如果还能使用的话，就是编程错误。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免循环引用，使用weak弱引用，两种方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__weak __typeof(self)weakSelf = self;   
  __weak ClassName *weakSelf = self;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;a href=&quot;#第34条：以自动释放池块降低内存峰值&quot; class=&quot;headerlink&quot; title=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;/a&gt;第34条：以自动释放池块降低内存峰值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空（drain）自动释放池时，系统会向其中的对象发送&lt;code&gt;release&lt;/code&gt;消息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;系统会自动创建一些线程，比如主线程或GCD中的线程，这些线程默认都有自动释放池，每次执行事件循环时，都会将其清空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主main函数的自动释放池包裹应用程序的主入口点（main application entry point），是最外围捕获自动释放对象所用的池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当循环创建了大量对象时，应该在循环内创建&lt;code&gt;autoreleasepool&lt;/code&gt;，这样在每次进行循环的时候就会创建自动释放池，并且把新建的对象放在池中，使用完之后，在块的末尾把对象回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存峰值（high-memory waterline）是指应用程序在某个特定时间段内的最大内存用量（highest memory footprint）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自动释放池机制就像栈一样。系统创建好自动释放池后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就等于将其放入栈顶的那个池里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;@autoreleasepool&lt;/code&gt;要视情况使用，当内存用量没达到需要优化的程度，尽量不要创建额外的自动释放池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;NSAutoreleasePool&lt;/code&gt;通过用来创建那种偶尔需要清空的池，相比&lt;code&gt;@autoreleasepool&lt;/code&gt;更为重量级。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;NSAutoreleasePool&lt;/code&gt;是通过&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;drain&lt;/code&gt;来限定范围的，不如&lt;code&gt;@autoreleasepool{}&lt;/code&gt;显而易见。所以，@autoreleasepool好处：可以避免无意间误用了那些在清空池后已为系统所回收的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;a href=&quot;#第35条：用“僵尸对象”调试内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;/a&gt;第35条：用“僵尸对象”调试内存管理问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;启用“僵尸对象”（Zombie Object）后，运行期系统会把所有已经回收的实例转化成特殊的僵尸对象，其所在的内存将无法重用，因此不可能遭到覆写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;僵尸对象收到消息后，会抛出异常，其中准确说明了发送过来的消息，并描述了回收之前的那个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编辑应用程序的Scheme，对话框左侧选择“Run”，切换至“Diagnostics”分页，勾选“Enable Zombie Objects”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;僵尸对象工作原理：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动僵尸对象功能后，在回收对象时，系统会把对象转化为僵尸对象，而不会彻底回收&lt;/li&gt;
&lt;li&gt;运行期系统如果发现&lt;code&gt;NSZombieEnable&lt;/code&gt;环境变量已设置，就会调配&lt;code&gt;dealloc&lt;/code&gt;方法，对象所属的类会变成&lt;code&gt;_NSZombie_OriginalClass&lt;/code&gt;    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;僵尸类（zombie class）是从名为&lt;code&gt;_NSZombie_&lt;/code&gt;的模板类里赋值出来的，只是充当一个标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;僵尸类没有实现任何方法，因此接收到的消息都要经过完整的消息转发机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;僵尸类经过消息转发后，打印一条特殊的消息，其中指明僵尸对象所收到的消息及原来所属的类，然后应用程序终止。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1. 通过&lt;code&gt;NSZombieEnable&lt;/code&gt;开启僵尸对象功能，系统不会真正回收对象，而将其转发为僵尸对象，以避免对象内存覆写&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2. 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方法为：打印一条包含消息内容及接收者的消息，然后终止应用程序&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;block与GCD&quot;&gt;&lt;a href=&quot;#block与GCD&quot; class=&quot;headerlink&quot; title=&quot;block与GCD&quot;&gt;&lt;/a&gt;block与GCD&lt;/h2&gt;&lt;h3 id=&quot;第37条：理解block的概念&quot;&gt;&lt;a href=&quot;#第37条：理解block的概念&quot; class=&quot;headerlink&quot; title=&quot;第37条：理解block的概念&quot;&gt;&lt;/a&gt;第37条：理解block的概念&lt;/h3&gt;&lt;p&gt;block的基础知识&lt;/p&gt;
&lt;p&gt;Block的内部结构&lt;/p&gt;
&lt;p&gt;Block的三种块&lt;/p&gt;
&lt;p&gt;给块对象发送copy消息可解决在定义它的范围之外使用了。&lt;br&gt;ARC下回自动copy&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块是C,C++,Objective-C中的词法闭包.&lt;/li&gt;
&lt;li&gt;块可接受参数,也可返回值.&lt;/li&gt;
&lt;li&gt;块可以分配在栈或堆上,也可以是全局的.分配在栈上的块可拷贝到堆里,这样的话,就和标准的Objective-C对象一样,具备引用计数了. &lt;h3 id=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;a href=&quot;#第38条：为常用的block类型创建typedef&quot; class=&quot;headerlink&quot; title=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;/a&gt;第38条：为常用的block类型创建typedef&lt;/h3&gt;以typedef重新定义块类型,可令块变量用起来更加简单.&lt;br&gt;定义新类型时应遵从现有的命名习惯,勿使其名称与别的类型相冲突.&lt;br&gt;不妨为同一个块签名定义多个类型命名.如果要重构的代码使用了块类型的某个别名,那么只需修改相应typedef中的块签名即可,无须改动其它typedef.&lt;h3 id=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;a href=&quot;#第39条：用handler块降低代码分散程度&quot; class=&quot;headerlink&quot; title=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;/a&gt;第39条：用handler块降低代码分散程度&lt;/h3&gt;同时开启若干个下载器, 那么在代理方法里面是不是就要对各个下载器进行判断然后执行对应的操作呢? 很麻烦对吧, 一大堆判断, if, else, if, else. 然而handler的优势马上展现出来了.&lt;/li&gt;
&lt;li&gt;在创建对象时,可以使用内联的handle块将相关业务逻辑一并声明.&lt;/li&gt;
&lt;li&gt;在有多个实例需要监控时,如果采用委托模式,那么经常需要根据传入的对象来切换,而若改用handler块来实现.则可直接将块与相关对象放在一起.&lt;/li&gt;
&lt;li&gt;设计API时如果用到了handler块,那么可以增加一个参数,使调用者可通过此参数来决定应该把块安排在哪个队列上执行.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;a href=&quot;#第40条：用block引用其所属对象时不要出现循环引用&quot; class=&quot;headerlink&quot; title=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;/a&gt;第40条：用block引用其所属对象时不要出现循环引用&lt;/h3&gt;&lt;p&gt;我们知道, 使用__weak确实可以避免循环引用. 但是还有点小瑕疵, 假如block是在子线程中执行, 而对象本身在主线程中被销毁了, 那么block内部的弱引用就会置空(nil). 而这在KVO中会导致崩溃.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Strong-Weak Dance&lt;/strong&gt;就是针对以上问题的. 使用方法很简单, 只需要加一行代码&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__weak typeof(self) wself = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.completionHandler = ^(&lt;span class=&quot;type&quot;&gt;NSInteger&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __strong typeof(wself) sself = wself;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [sself removeObserver: sself forKeyPath:@&lt;span class=&quot;string&quot;&gt;&quot;dog&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样一来, block中sself所指向的对象在block执行完毕之前都不会被释放掉, 因为在ARC下, 只要对象被强引用着, 就不会被释放.&lt;/p&gt;
&lt;h3 id=&quot;第41条：多用派发队列dispatch-sync和async，少用同步锁&quot;&gt;&lt;a href=&quot;#第41条：多用派发队列dispatch-sync和async，少用同步锁&quot; class=&quot;headerlink&quot; title=&quot;第41条：多用派发队列dispatch_sync和async，少用同步锁&quot;&gt;&lt;/a&gt;第41条：多用派发队列dispatch_sync和async，少用同步锁&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;派发队列可用来表述同步语义(synchronization semantic),这种做法要比使用@synchronized块或NSLock对象更简单.&lt;/li&gt;
&lt;li&gt;将同步与异步派发结合起来,可以实现与普通加锁机制一样的同步行为,而这么做却不会阻塞执行异步派发的线程.&lt;/li&gt;
&lt;li&gt;使用同步队列与栅栏块,可以令同步行为更加高效.（在并发队列中，读取操作使用普通的块来实现，写入操作则用栅栏块来实现。读取操作可以并行，但是写入操作必须单独执行）dispatch_barrier_sync&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;a href=&quot;#第42条：用GCD，少用performSelector系列方法&quot; class=&quot;headerlink&quot; title=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;/a&gt;第42条：用GCD，少用performSelector系列方法&lt;/h3&gt;&lt;/li&gt;
&lt;li&gt;performSelector 系列方法在内存管理方面容易有疏失.它无法确定将要执行的选择子具体是什么,因而ARC编译器也就无法插入适当的内存管理方法.&lt;/li&gt;
&lt;li&gt;performSelector 系列方法所能处理的选择子太过局限了,选择子的返回值类型及发送给方法的参数个数都受到限制.&lt;/li&gt;
&lt;li&gt;如果想把任务放在另一个线程上执行,那么最好不要用performSelector系列方法,而是应该把任务封闭到块里,然后调用大中枢派发机制的相关方法来实现.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;a href=&quot;#第43条：掌握GCD及操作队列的使用时机&quot; class=&quot;headerlink&quot; title=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;/a&gt;第43条：掌握GCD及操作队列的使用时机&lt;/h3&gt;&lt;p&gt;NSOperation和GCD的区别：&lt;/p&gt;
&lt;p&gt;NSOperation的底层是用GCD来实现的。GCD是纯C的API。&lt;/p&gt;
&lt;p&gt;使用NSOperation以及NSOperationQueue的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取消某个操作，在运行任务之前，在NSOperation对象上调用cancel方法，会设置对象内的标识为，用以表示此任务不需执行。&lt;/li&gt;
&lt;li&gt;指定操作间的依赖关系。可以指定操作之间的依赖关系，使得特定的操作再另外的操作顺利执行后方可执行。&lt;/li&gt;
&lt;li&gt;通过KVO检测NSOperation对象的属性。用isCancel属性来判断任务是否已经取消。isFinish来判断任务是否已经完成。&lt;/li&gt;
&lt;li&gt;指定操作的优先级。&lt;/li&gt;
&lt;li&gt;重用NSOperation对象。系统内置了一些NSOperation的子类（NSBlockOperation）供开发者使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot;&gt;&lt;a href=&quot;#第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot; class=&quot;headerlink&quot; title=&quot;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&quot;&gt;&lt;/a&gt;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;dispatch group 能够把任务分组&lt;/strong&gt;。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。&lt;br&gt;&lt;strong&gt;通常是将要并发执行的多个任务合为一组，调用者就可以知道这些任务何时全部执行完毕。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建group&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;dispatch_group_t group = dispatch_group_create();&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将任务编组，两种方式：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;把queue添加group里面&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;dispatch_group_t&lt;/span&gt; group,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  					 &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  					 &lt;span class=&quot;keyword&quot;&gt;dispatch_block_t&lt;/span&gt; block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;设置标志位，只要在标志位中间的queue都属于group，但必须要一一对应。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_enter(dispatch_group_t &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 中间的线程都属于group	&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_leave(dispatch_group_t &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;等待group执行完毕，等待时间为timeout，线程阻塞时间也由timeout决定，直至线程全部执行完毕&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;group执行完毕回调方法，在特定的线程queue上执行block方法&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notify(&lt;span class=&quot;keyword&quot;&gt;dispatch_group_t&lt;/span&gt; group,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              		  &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              		  &lt;span class=&quot;keyword&quot;&gt;dispatch_block_t&lt;/span&gt; block);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;dispatch group 在并发队列中比较有用，在串行队列中，意义不大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在并发队列中，执行任务所用的并发线程的数量，取决于各种因素，而GCD主要是根据系统资源状况来判定这些因素的，即GCD通过判定这些因素，来具体创建多少线程来执行任务.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD 有并发队列机制，能够根据可用的系统资源状况来并发执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_apply函数会将块(block)反复执行一定次数(iterations)，并且每次传给块的参数值都会递增&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;queue 可以是并发队列，系统会根据资源来并行执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以是串行队列，但会阻塞线程，直到所有任务执行完毕&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_apply(&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; iterations, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			   &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^block)(&lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一系列任务可归入一个dispatch group之中，开发者可在这组任务执行完毕时获得通知&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过dispatch group，可以在并发式队列里同时执行多项任务，此时，GCD会根据系统资源状况来调度这些并发执行的任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot;&gt;&lt;a href=&quot;#第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot; class=&quot;headerlink&quot; title=&quot;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&quot;&gt;&lt;/a&gt;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;dispatch_once最常用于单例模式，整个类中只有一个共用的单例实例，每次调用时不会创建新的实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_once(&lt;span class=&quot;keyword&quot;&gt;dispatch_once_t&lt;/span&gt; *predicate,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			  &lt;span class=&quot;keyword&quot;&gt;dispatch_block_t&lt;/span&gt; block)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (FDNetwork *)shareManager &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FDNetwork *manager = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        manager = [[FDNetwork alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; manager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用dispatch_once&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;简化代码并且彻底保证线层安全，而且高效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标记声明为&lt;code&gt;static&lt;/code&gt;，可以保证每次调用时都是完全相同的标记。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第46条：不要使用dispatch-get-current-queue&quot;&gt;&lt;a href=&quot;#第46条：不要使用dispatch-get-current-queue&quot; class=&quot;headerlink&quot; title=&quot;第46条：不要使用dispatch_get_current_queue&quot;&gt;&lt;/a&gt;第46条：不要使用dispatch_get_current_queue&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;dispatch_get_current_queue函数的行为常常与开发者所预期的不同.此函数已经废弃,只应做调试之用.&lt;/li&gt;
&lt;li&gt;由于派发队列是按层级来组织的,所以无法单用某个队列对象来描述”当前的队列”这一概念.&lt;/li&gt;
&lt;li&gt;dispatch_get_current_queue函数用于解决由不可重入的代码所引发的死锁,然而能用此函数解决的问题,通常也能改为”队列特定数据”来解决.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统框架&quot;&gt;&lt;a href=&quot;#系统框架&quot; class=&quot;headerlink&quot; title=&quot;系统框架&quot;&gt;&lt;/a&gt;系统框架&lt;/h2&gt;&lt;h3 id=&quot;第47条：熟悉系统框架&quot;&gt;&lt;a href=&quot;#第47条：熟悉系统框架&quot; class=&quot;headerlink&quot; title=&quot;第47条：熟悉系统框架&quot;&gt;&lt;/a&gt;第47条：熟悉系统框架&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;许多系统框架都可以直接使用.其中最重要的是Foundation与CoreFoundation,这两个框架提供了构建应用程序所需的许多核心功能.&lt;/li&gt;
&lt;li&gt;很多常见任务都能用框架来做,例如音频与视频处理,网络通信,数据管理等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;a href=&quot;#第48条：多用块枚举，少用for循环&quot; class=&quot;headerlink&quot; title=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;/a&gt;第48条：多用块枚举，少用for循环&lt;/h3&gt;&lt;h4 id=&quot;for循环&quot;&gt;&lt;a href=&quot;#for循环&quot; class=&quot;headerlink&quot; title=&quot;for循环&quot;&gt;&lt;/a&gt;for循环&lt;/h4&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *adictionary = &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *array = [adictionary allkeys];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; array&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; key = keys[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value = adictionary[key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSEnumerator遍历法&quot;&gt;&lt;a href=&quot;#NSEnumerator遍历法&quot; class=&quot;headerlink&quot; title=&quot;NSEnumerator遍历法&quot;&gt;&lt;/a&gt;NSEnumerator遍历法&lt;/h4&gt;&lt;p&gt; NSEnumerator是抽象基类，这种方法已经过时了&lt;/p&gt;
&lt;h4 id=&quot;快速遍历&quot;&gt;&lt;a href=&quot;#快速遍历&quot; class=&quot;headerlink&quot; title=&quot;快速遍历&quot;&gt;&lt;/a&gt;快速遍历&lt;/h4&gt;&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;NSArray &lt;/span&gt;*array = &lt;span class=&quot;regexp&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (id obj &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; something with &lt;span class=&quot;string&quot;&gt;&#39;obj&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;基于块的遍历方式&quot;&gt;&lt;a href=&quot;#基于块的遍历方式&quot; class=&quot;headerlink&quot; title=&quot;基于块的遍历方式&quot;&gt;&lt;/a&gt;基于块的遍历方式&lt;/h4&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt;都有基于block的遍历方式, 例如数组的 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *array = &lt;span class=&quot;comment&quot;&gt;/* ... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[array enumerateObjectsUsingBlock:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj, &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; idx, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// do something with &#39;obj&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (shouldStop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *stop = &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不仅能简单遍历, 还能控制什么时候退出遍历. 还有更高级的块遍历方法能够指定选项, 例如反向遍历, 并行快速遍历等等.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 数组的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)enumerateObjectsWithOptions:(&lt;span class=&quot;built_in&quot;&gt;NSEnumerationOptions&lt;/span&gt;)opts usingBlock:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(ObjectType obj, &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; idx, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop))block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 字典的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)enumerateKeysAndObjectsWithOptions:(&lt;span class=&quot;built_in&quot;&gt;NSEnumerationOptions&lt;/span&gt;)opts usingBlock:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(KeyType key, ObjectType obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop))block;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;遍历collection有四种方式.最基本的办法是for循环,其次是NSEnumerator遍历法及快速遍历法,最新,最先进的方式则是”块枚举法”.&lt;/li&gt;
&lt;li&gt;“块枚举法”本身就能通过GCD来并发执行遍历操作,无须另行编写代码.而采用其他遍历方式则无法轻易实现这一点.&lt;/li&gt;
&lt;li&gt;若提前知道待遍历的collection含有何种对象,则应修改块签名,指出对象的具体类型.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;a href=&quot;#第49条：队自定义其内存管理语义的collection使用无缝桥接&quot; class=&quot;headerlink&quot; title=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;/a&gt;第49条：队自定义其内存管理语义的collection使用无缝桥接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通过无缝桥接技术,可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在CoreFoundation层面创建collection时,可以指定许多回调函数,这些函数表示此collection应如何处理其元素.然后,可运用无缝桥接技术,将其转换成具备特殊内存管理语义的Objective-C collection.&lt;/p&gt;
&lt;h3 id=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;a href=&quot;#第50条：构建缓存是选用NSCachae而非NSDictionary&quot; class=&quot;headerlink&quot; title=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;/a&gt;第50条：构建缓存是选用NSCachae而非NSDictionary&lt;/h3&gt;&lt;p&gt;NSCache是Foundation框架中为缓存而生的类. NSCache对比NSDictionary的优点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当系统的资源将要耗尽时, 它可以自动删减缓存.先行删减”最久未使用的对象”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;NSCache不会”拷贝”键, 而是”保留”键. 所有在键不支持拷贝的情况下比字典方便.&lt;/li&gt;
&lt;li&gt;线程安全, 开发者无需自己编写加锁代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发者可以操纵缓存删减其内容的时机, 也就是清理缓存的策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存中的对象总数(countLimit属性)&lt;/li&gt;
&lt;li&gt;缓存中所有对象的总开销(totalCostLimit属性)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;NSCache还经常会跟NSPurgeableData(NSMutableData的子类)搭配使用, 当NSPurgeableData对象所占内存被系统所丢弃时, 该对象自身也会从缓存中移除.&lt;/p&gt;
&lt;p&gt;该类有2个特别的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;beginContentAccess : 告诉它, 现在还不应该丢弃自己所占据的内存&lt;/li&gt;
&lt;li&gt;endContentAccess : 告诉它, 必要时可以丢弃自己所占据的内存了&lt;br&gt;缓存使用得当, 将会大大提高应用程序的响应速度. 但并不是什么东西都需要缓存, 只有那种”重新计算起来费劲”的数据, 才值得放入缓存中. 例如从网络获取或从磁盘读取的数据.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;a href=&quot;#第51条：精简initialize与load的实现代码&quot; class=&quot;headerlink&quot; title=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;/a&gt;第51条：精简initialize与load的实现代码&lt;/h3&gt;&lt;p&gt;&lt;code&gt;+ (void)load&lt;/code&gt;&lt;br&gt;该方法特点如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序一启动, 就会调用每个类及分类的load方法.&lt;/li&gt;
&lt;li&gt;执行子类的load方法之前必定会先执行超类的load方法.&lt;/li&gt;
&lt;li&gt;执行分类的load方法之前必定会先执行本类的load方法&lt;/li&gt;
&lt;li&gt;该方法不遵从继承规则, 也就是说如果子类没有实现load方法, 那么不管其超类有没有实现该方法, 系统都不会自动调用.&lt;/li&gt;
&lt;li&gt;该方法会阻塞主线程!!!!!!!!!!!!!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;+ (void)initialize&lt;/code&gt;&lt;br&gt;该方法特点如下 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该方法会在程序首次使用该类之前调用, 且只调用一次. 也就是说该方法是懒加载的, 如果某个类一直没使用, 就永远不会调用.&lt;/li&gt;
&lt;li&gt;该方法一定会在”线程安全的环境”下执行. 意思就是只有执行该方法的那个线程可以操作类和类实例. 其他线程都要先阻塞, 等着该方法执行完.&lt;/li&gt;
&lt;li&gt;该方法遵从继承规则, 子类如果没实现它, 则会调用超类的实现代码.&lt;br&gt;回到主题, 为什么initialize 与 load的代码要尽量精简呢?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;load方法会阻塞主线程;&lt;br&gt;initialize方法会阻塞当前线程, 如果该线程恰好是主线程, 你懂的…&lt;br&gt;开发者无法控制类的初始化时机, 也许将来苹果会修改类的初始化方式呢?&lt;br&gt;如果某类的该两方法引入了其他类, 而那些类又没初始化, 系统就会迫使其初始化, 而那些类初始化一不小心又刚刚好引入了某类, 则会出现”依赖环”&lt;br&gt;综上, 尽量不要重写load方法, 而initialize方法只应该用来&lt;br&gt;设置内部数据, 不应该调用其他方法, 哪怕是本类自己的方法.&lt;br&gt;如果单例类在首次使用之前需要做一些操作&lt;/p&gt;
&lt;h3 id=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;a href=&quot;#第52条：别忘了NSTimer会保留其目标对象&quot; class=&quot;headerlink&quot; title=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;/a&gt;第52条：别忘了NSTimer会保留其目标对象&lt;/h3&gt;&lt;p&gt;这种情况跟block引用self那种情况差不多. 目标对象保留计时器, 计时器反过来又保留对象, 则会导致循环引用.&lt;/p&gt;
&lt;p&gt;我们可以利用block或者”Strong-Weak Dance”来解决此问题.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSTimer对象会保留其目标,直到计时器本身失效为止,调用invalidate方法可令计时器失效,另外,一次性的计时器在触发完任务之后也会失效.&lt;/li&gt;
&lt;li&gt;反复执行任务的计时器,很容易引入保留环,如果这种计时器的目标对象又保留了计时器本身,那肯定会导致保留环.这种环状保留关系,可能是直接发生的,也可能是通过对象图里的其它对象间接发生的.&lt;/li&gt;
&lt;li&gt;可以扩充NSTimer的功能,用”块”来打破保留环.不过除非NSTimer将来在公共接口里提供此功能,否则必须创建分类,将相关实现代码加入其中.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;load和initialize的区别 &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;load在main函数之前调用，initialize在main函数之后调用，都为“+”类方法。&lt;/li&gt;
&lt;li&gt;load加载编译期使用，子类有load，会自动调用父类的load。子类没有load方法。不会自动调用父类的load。 initialize运行时懒加载，子类有没有initialize，都会自动调用父类的initialize。主要是在给某个对象发送消息时调用，应该会调用objc_msgSendSuper()吧？（自认为）&lt;/li&gt;
&lt;li&gt;load用于Method Swizzle.例如MJRefresh中UIScrollView+MJRefresh中，方法1和方法2交换，调用runtime中的方法method_exchangeImplementations方法。&lt;br&gt; initialize主要是变量初始化和通知的添加和移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;delegate和Block那个好？&lt;br&gt;Block更加简洁，可以访问此范围内的全部变量。Block无需保存获取器，也无需再回调方法里切换。在Block中来操作成功和失败的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;delegate的缺点：如果类要分别使用多个获取器下载不同该数据，那么就得在delegate回调方法里根据传入的获取器参数来切换。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存泄露的场景&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用performSelector方法，编译器不知道将要调用的选择子是什么，不了解其方法签名以及返回值，在ARC内存管理中就不知道返回值是否应该释放。如果不释放的话，就会造成内存泄露&lt;/li&gt;
&lt;li&gt;Block中&lt;/li&gt;
&lt;li&gt;NSTimer的时候要特别注意内存泄漏的问题, 因为NSTimer会持有目标对象, 很容易造成循环引用的问题, 也许你会想到在这个目标对象的dealloc里面让NSTimer失效(调用 invalidation 并且置为nil), 但是这根本就没有用, 因为循环引用的原因, 根本就不会调用dealloc方法, 所以在里面销毁是没有用的, 需要在对象被销毁之前手动销毁计时器。&lt;/li&gt;
&lt;li&gt;相互引用多个对象的循环引用会导致内存泄漏，因为循环中的对象其保留计数不会降为0，永远不会释放。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;effective objective-c 2.0读书笔记.&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://peilinghui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Block</title>
    <link href="http://peilinghui.com/2016/04/01/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Block/"/>
    <id>http://peilinghui.com/2016/04/01/深入学习Block/</id>
    <published>2016-04-01T05:01:49.000Z</published>
    <updated>2017-03-25T12:30:46.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习Block。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Block&quot;&gt;&lt;a href=&quot;#Block&quot; class=&quot;headerlink&quot; title=&quot;Block&quot;&gt;&lt;/a&gt;Block&lt;/h1&gt;&lt;h2 id=&quot;Block的概要&quot;&gt;&lt;a href=&quot;#Block的概要&quot; class=&quot;headerlink&quot; title=&quot;Block的概要&quot;&gt;&lt;/a&gt;Block的概要&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Block功能：带有自动变量(局部变量)的匿名函数(不带名称的函数)。Blocks 是闭包在 OC 语言中的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同而已。在objc中，block实际上就算是对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block语法：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;^void&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt; event)&lt;/span&gt;&lt;span class=&quot;collection&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	print&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;buttonId:%d event = %d\n&quot;&lt;/span&gt;,i,event)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特点：a.没有函数名  b.带有“^”号&lt;br&gt;&lt;code&gt;^  返回值类型  参数列表  表达式&lt;/code&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可代替 Delegate 完成回调，而不需要像 Delegate 那样繁琐
在某些方面，可代替 selector（如 NSNotificationCenter 在 addObserver 的时候，可以使用 block，而不用单独定义方法）
延长对象的生命周期（Block 会自动持有对象）
提高代码的复用性和可读性
常用于：View 动画、GCD、网络异步请求
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Block模式—block特性&quot;&gt;&lt;a href=&quot;#Block模式—block特性&quot; class=&quot;headerlink&quot; title=&quot;Block模式—block特性&quot;&gt;&lt;/a&gt;Block模式—&lt;strong&gt;block特性&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;截获自动变量值&quot;&gt;&lt;a href=&quot;#截获自动变量值&quot; class=&quot;headerlink&quot; title=&quot;截获自动变量值&quot;&gt;&lt;/a&gt;截获自动变量值&lt;/h3&gt;&lt;p&gt;“带有自动变量值”在Block中表现为“截获自动变量值”&lt;/p&gt;
&lt;p&gt;1&amp;gt; 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的. 也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 10&lt;/p&gt;
&lt;p&gt;2&amp;gt; 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 18&lt;/p&gt;
&lt;p&gt;第一种情况block内部不允许修改变量的值, 第二种情况下可以. (有例外, 静态变量, 静态全局变量, 全局变量即使不使用&lt;strong&gt;block修饰符也可以在block内部修改其值)&lt;br&gt;附有&lt;/strong&gt;block说明符的自动变量可在Block中赋值，该变量成为__block变量。&lt;/p&gt;
&lt;h3 id=&quot;截获对象&quot;&gt;&lt;a href=&quot;#截获对象&quot; class=&quot;headerlink&quot; title=&quot;截获对象&quot;&gt;&lt;/a&gt;截获对象&lt;/h3&gt;&lt;p&gt;对象不同于自动变量, 就算对象不加上&lt;strong&gt;block修饰符, 在block内部能够修改对象的属性.&lt;br&gt;block截获对象与截获自动变量有所不同.&lt;br&gt;堆块会持有对象, 而不会持有&lt;/strong&gt;block修饰的对象, 而栈块永远不会持有对象, 为什么呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;堆块作用域不同于栈块, 堆块可以超出其作用域地方使用, 所以堆块结构体内部会保留对象的强指针, 保证堆块在生命周期结束之前都能访问对象. 而对于__block对象为什么不会持有呢? 原因很简单, 因为__block对象会跟随block被复制到堆中, block再去引用堆中的__对象(后面会讲这个过程)..
栈块只能在当前作用域下使用, 所以其内部不会持有对象. 因为不存在在作用域之外访问对象的可能(栈离开当前作用域立马被销毁)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Block的实现&quot;&gt;&lt;a href=&quot;#Block的实现&quot; class=&quot;headerlink&quot; title=&quot;Block的实现&quot;&gt;&lt;/a&gt;Block的实现&lt;/h2&gt;&lt;h3 id=&quot;Block的实质&quot;&gt;&lt;a href=&quot;#Block的实质&quot; class=&quot;headerlink&quot; title=&quot;Block的实质&quot;&gt;&lt;/a&gt;Block的实质&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Blocks 的数据结构&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.35.54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应的结构体定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *dst, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *src);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*dispose)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_layout &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*invoke)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *, ...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor *descriptor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Imported variables. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过该图，我们可以知道，一个 Block 实例实际上由 6 部分构成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isa 指针: 所有对象都有该指针，用于实现对象相关的功能

flags: 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用；

reserved: 保留变量；

invoke: 函数指针，指向具体的 block 实现的函数调用地址；

descriptor: 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针；

variables: capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中；
copy : 用于保留捕获的对象
dispose : 用于释放捕获的对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Objective-C 中的 Stack 和 Heap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先所有的 Objective-C 对象都是分配在 Heap(堆) 的。 在 OC 最典型的内存分配与初始化就是这样的：&lt;/p&gt;
&lt;p&gt;NSObject *obj = [[NSObject alloc] init];&lt;/p&gt;
&lt;p&gt;一个对象在 alloc 的时候，就在 Heap 分配了内存空间。&lt;/p&gt;
&lt;p&gt;Stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 Heap 的呢？ 原因在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 Stack Frame（栈帧）就会被销毁。那么此时返回的对象也会一并销毁。这个时候我们去 retain 这个对象是无效的。因为整个 Stack Frame 都已经被销毁了。简单而言，就是 Stack 对象的生命周期不适合 OC 的引用计数内存管理方法。

Stack 对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的 Stack Frame。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Block-存储域&quot;&gt;&lt;a href=&quot;#Block-存储域&quot; class=&quot;headerlink&quot; title=&quot;Block 存储域&quot;&gt;&lt;/a&gt;Block 存储域&lt;/h3&gt;&lt;p&gt;block中的isa指向的是该block的Class。在block runtime中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;全局块(_NSConcreteGlobalBlock)程序的数据区域(.data区)
栈块(_NSConcreteStackBlock)
堆块(_NSConcreteMallocBlock)

全局块存在于全局内存中, 相当于单例.
栈块存在于栈内存中, 超出其作用域则马上被销毁
堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。&lt;/p&gt;
&lt;p&gt;当函数返回时，函数的栈帧被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数。详细代码可以直接点这里查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局块(_NSConcreteGlobalBlock)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block定义在全局变量的地方
block没有截获任何自动变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两个情况满足任意一个则该block为全局块, 全局块的生命周期贯穿整个程序, 相当于单例.全局的静态 Block，不会访问任何外部变量。&lt;br&gt;简单地讲，如果一个block钟没有引用外部变量并且没有被其他对象持有，就是NSConcreteGlobalBlock。NSConcreteGlobalBlock是全局的block，在编译期间就已经决定了，如同宏一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈块(_NSConcreteStackBlock)&lt;/strong&gt;&lt;br&gt;保存在栈中的 Block，当函数返回时会被销毁。（ARC 中系统实现了自动 copy, 将创建在栈上的 Block 自动拷贝到堆上，所以不存在此类型的 Block）NSConcreteStackBlock就是引用了外部变量的block，&lt;/p&gt;
&lt;p&gt;NSConcreteGlobalBlock由于处在 data段，可以通过指针安全访问。StackBlock处在内存栈区，如果其变量作用域结束， 这个 block 就被废弃，block 上的&lt;strong&gt;block变量也同样会被废弃。为了解决这个问题，block 提供了 copy 的功能，将block和&lt;/strong&gt;block 变量从栈拷贝到堆。当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block。堆上的 block 类型为 _NSConcreteMallocBlock，会将 _NSConcreteMallocBlock 写入 isa。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆块(_NSConcreteMallocBlock)&lt;/strong&gt;&lt;br&gt;栈块copy之后就变成堆块，一个block被copy时，将生成NSConcreteMallocBlock（block没有retain）&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.51.44.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;只要这个NSConcreteMallocBlock存在，内部对象的引用计数就会+1。&lt;/p&gt;
&lt;p&gt;NSConcreteStackBlock处于内存的栈区,ARC中大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上。当block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法。但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝。&lt;/p&gt;
&lt;h3 id=&quot;block变量的存储域&quot;&gt;&lt;a href=&quot;#block变量的存储域&quot; class=&quot;headerlink&quot; title=&quot;__block变量的存储域&quot;&gt;&lt;/a&gt;__block变量的存储域&lt;/h3&gt;&lt;p&gt;默认block捕获到的变量，都是赋值给block的结构体的，相当于const不可改。为了让block能访问并修改外部变量，需要加上__block修饰词。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%8811.14.42.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;block的copy操作究竟做了什么呢?&lt;/p&gt;
&lt;p&gt;由上图可知, 对一个栈块进行copy操作会连同block与&lt;strong&gt;block变量(不管有没有使用)在内一同copy到堆上, 并且block会持有&lt;/strong&gt;block变量(使用).&lt;br&gt;ps : 堆上的block及__block变量均为对象, 都有各自的引用计数&lt;/p&gt;
&lt;p&gt;当然, 当block被销毁时, block持有的__block也会被释放&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;到这里我们能知道, 此思考方式与Objective-C的引用计数内存管理完全相同.&lt;/p&gt;
&lt;p&gt;那么有人就会问了, 既然&lt;strong&gt;block变量也被复制到堆上去了, 那么访问该变量是访问栈上的还是堆上的呢?? &lt;/strong&gt;forwarding 终于要闪亮登场了.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.19.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过&lt;strong&gt;forwarding, 无论实在block中, block外访问&lt;/strong&gt;block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量. &lt;/p&gt;
&lt;p&gt;当 block 从栈被拷贝到堆时，&lt;strong&gt;forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从 &lt;/strong&gt;forwarding 产生的缘由说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将 &lt;strong&gt;forwarding 指针指向堆上结构体。后面如果要想使用 &lt;/strong&gt;block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了。。&lt;/p&gt;
&lt;h3 id=&quot;block-的自动拷贝和手动拷贝&quot;&gt;&lt;a href=&quot;#block-的自动拷贝和手动拷贝&quot; class=&quot;headerlink&quot; title=&quot;block 的自动拷贝和手动拷贝&quot;&gt;&lt;/a&gt;block 的自动拷贝和手动拷贝&lt;/h3&gt;&lt;p&gt;那么Blocks提供的复制方法究竟是什么？&lt;/p&gt;
&lt;p&gt;ARC有效的时候，大多数轻型下编译器会恰当的进行判断，自动生成将Block从栈上复制到堆上的代码。&lt;/p&gt;
&lt;h4 id=&quot;block-的自动拷贝&quot;&gt;&lt;a href=&quot;#block-的自动拷贝&quot; class=&quot;headerlink&quot; title=&quot;block 的自动拷贝&quot;&gt;&lt;/a&gt;block 的自动拷贝&lt;/h4&gt;&lt;p&gt;ARC下, 以下几种情况下, 编译器会帮我们把栈上的block复制到堆中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block作为函数返回值返回时。编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；

将block赋值给__strong修饰符id类型或block类型成员变量时。编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；
在方法名中含有usingBlock的Cocoa框架方法或GCD的API中传递block时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;block-的手动拷贝&quot;&gt;&lt;a href=&quot;#block-的手动拷贝&quot; class=&quot;headerlink&quot; title=&quot;block 的手动拷贝&quot;&gt;&lt;/a&gt;block 的手动拷贝&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;此外的情况需要手动对block调用copy方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把block作为函数/方法的参数传入时才需要对block进行copy操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们对不同地方的block调用copy会产生什么效果呢?&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%883.12.58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Block-循环引用&quot;&gt;&lt;a href=&quot;#Block-循环引用&quot; class=&quot;headerlink&quot; title=&quot;Block 循环引用&quot;&gt;&lt;/a&gt;Block 循环引用&lt;/h3&gt;&lt;p&gt;如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，该对象为 Block 所持有，于是便导致了循环引用的产生。&lt;br&gt;self 持有 Block，Block 持有 self，这正是循环引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面对使用 block 变量避免循环引用的方法和使用 weak 修饰符及 __unsafe_unretained 修饰符避免循环引用的方法做个比较。  &lt;/p&gt;
&lt;p&gt;使用 __block 变量的优点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过 __block 变量可控制对象的持有期间
在不能使用 __weak 修饰符的环境中不使用 __unsafe_unretained 修饰符即可（不必担心 悬垂指针 ）
在执行 Block 时可动态地决定是否将 nil 或其他对象赋值在 __block 变量中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 __block 变量的缺点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为避免循环引用必须执行 Block
存在执行了 Block 语法，却不执行 Block 的路径时，无法避免循环引用。若由于 Block 引发了循环引用时，根据 Block 的用途选择使用 __block 变量、 __weak 修饰符或 __unsafe_unretained 修饰符来避免循环引用。
MRC下用__block可以避免循环引用(原因见上面block特性之截获自动变量值)
ARC下用__weak来避免循环引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要提醒大家的是, 只有堆块(_NSConcreteMallocBlock)才可能会造成循环引用, 其他两种block不会&lt;/p&gt;
&lt;h3 id=&quot;Block用weakSelf、strongSelf、-weakify、-strongify解决循环引用&quot;&gt;&lt;a href=&quot;#Block用weakSelf、strongSelf、-weakify、-strongify解决循环引用&quot; class=&quot;headerlink&quot; title=&quot;Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&quot;&gt;&lt;/a&gt;Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;weakSelf 是为了block不持有self，避免Retain Circle循环引用。在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。

strongSelf的目的是因为一旦进入block执行，假设不允许self在这个执行过程中释放，就需要加入strongSelf。block执行完后这个strongSelf 会自动释放，没有不会存在循环引用问题。如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AFN经典说起，以下是AFN其中的一段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark - NSOperation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setCompletionBlock:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (^)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;))block &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.lock&lt;/span&gt; lock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!block) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; setCompletionBlock:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)weakSelf = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; setCompletionBlock:^ &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(weakSelf)strongSelf = weakSelf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_group_t group = strongSelf&lt;span class=&quot;variable&quot;&gt;.completionGroup&lt;/span&gt; ?: url_request_operation_completion_group();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;dispatch_queue_t&lt;/span&gt; queue = strongSelf&lt;span class=&quot;variable&quot;&gt;.completionQueue&lt;/span&gt; ?: dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                block();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [strongSelf setCompletionBlock:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.lock&lt;/span&gt; unlock];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果block里面不加&lt;strong&gt;strong &lt;/strong&gt;typeof(weakSelf)strongSelf = weakSelf会如何呢？就会输出null。&lt;br&gt;&lt;strong&gt;weakSelf之后，无法控制什么时候会被释放，为了保证在block内不会被释放，需要添加__strong。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在block里面使用的__strong修饰的weakSelf是为了在函数生命周期中防止self提前释放。strongSelf是一个自动变量当block执行完毕就会释放自动变量strongSelf不会对self进行一直进行强引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;@weakify(self) 和 @strongify(self) 就是比我们日常写的weakSelf、strongSelf多了一个@autoreleasepool{}而已.&lt;/p&gt;
&lt;h2 id=&quot;要点总结&quot;&gt;&lt;a href=&quot;#要点总结&quot; class=&quot;headerlink&quot; title=&quot;要点总结&quot;&gt;&lt;/a&gt;要点总结&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Block 执行的代码其实在编译的时候就已经准备好了
本身 Block 就是一个普通的 OC 对象。正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值
__block 修饰符在 MRC 下不会进行引用计数加 1，而 ARC 下则会加 1
对于 Block 外的变量引用，Block 默认是将其复制到其数据结构中来实现访问的
对于用 __block 修饰的外部变量引用，Block 是复制其引用地址来实现访问的
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;讲讲block；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么?&lt;br&gt;注意：1&amp;gt;block的内存管理 (block的实现是基于指针和函数指针)   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有copy操作，block代码默认放在栈内存（弱引用）。&lt;/li&gt;
&lt;li&gt;如果有copy操作，block升级放在堆内存（强引用）。&lt;br&gt;2&amp;gt;防止循环引用&lt;br&gt; 解决：非ARC（MRC）：&lt;strong&gt;__block&lt;/strong&gt;&lt;br&gt;ARC：&lt;strong&gt;__weak&lt;/strong&gt;或者&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;blockquote&gt;
&lt;p&gt;补充：&lt;strong&gt;__block&lt;/strong&gt; 和 &lt;strong&gt;__weak&lt;/strong&gt;修饰符的区别&lt;br&gt;&lt;strong&gt;__block&lt;/strong&gt; 不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。&lt;br&gt;&lt;strong&gt;__weak&lt;/strong&gt;只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。&lt;br&gt;&lt;strong&gt;__block&lt;/strong&gt; 对象可以在block中被重新赋值，&lt;strong&gt;__weak&lt;/strong&gt;不可以。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;block和self的循环引用；到底是如何循环引用的；block的代码实现；为什么会造成循环引用；block是如何强引用self的；&lt;/p&gt;
&lt;p&gt;一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。&lt;br&gt;解决方法是将该对象使用&lt;strong&gt;weak或者&lt;/strong&gt;block修饰符修饰之后再在block中使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;id weak weakSelf = self; 或者 weak &lt;strong&gt;typeof(&amp;amp;*self)weakSelf = self该方法可以设置宏&lt;br&gt;id &lt;/strong&gt;block weakSelf = self;&lt;br&gt;或者将其中一方强制制空 xxx = nil。&lt;/p&gt;
&lt;p&gt;检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具 FBRetainCycleDetector 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;block为什么要修饰为copy；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;有哪几种类型的block；什么情况下block会从栈区复制到堆区；&lt;br&gt;三种。在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSMutableArray在block中修改时，是否要修饰为__block;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;block和delegate你更倾向于用哪个？为什么？&lt;br&gt;Block.&lt;br&gt;block使代码更紧凑,便于阅读,delegate可以设置必选和可选的方法实现.&lt;br&gt;block可以访存局部变量. 不需要像以前的回调一样，把在操作后所有需要用到的数据封装成特定的数据结构, 你完全可以直接访问局部变量.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;block在MRC下如何解决循环引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;block循环引用了如何解决？如何解除循环引用；&lt;/li&gt;
&lt;li&gt;Block在栈中还是堆中？全局变量是在栈还是在堆中？成员变量呢？block分配在哪里；&lt;/li&gt;
&lt;li&gt;block的原理是什么，如何去找到这个block；（函数指针）&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;block在传递的时候，是否会改变存储位置？比如是否会从栈复制到堆；原来的block是否会被释放；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block的实现内部机制，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block中的循环引用；Block的复制；Block的存储位置；Block如何改变外面的变量；__block修饰符的内部机制！！！；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block的嵌套使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※]在block内如何修改block外部变量？外部的变量是怎么传到Block中去的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？&lt;br&gt;UIView的block版本写动画时不需要考虑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：&lt;/p&gt;
&lt;p&gt;所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，&lt;br&gt;但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;http: 28=&quot;&quot; 2013=&quot;&quot; blog.devtang.com=&quot;&quot; 07=&quot;&quot; a-look-inside-blocks=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/abeb5848b57a#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/abeb5848b57a#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;/http:&gt;&lt;/p&gt;
&lt;p&gt;深入研究Block用weakSelf、strongSelf、@weakify、@strongify解决循环引用&lt;a href=&quot;https://halfrost.com/ios_block_retain_circle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://halfrost.com/ios_block_retain_circle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;block没那么难（一）：block的实现&lt;a href=&quot;https://www.zybuluo.com/MicroCai/note/51116&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zybuluo.com/MicroCai/note/51116&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Block&lt;a href=&quot;http://www.samirchen.com/block-in-objc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.samirchen.com/block-in-objc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　
　　
　　
　　
　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习Block。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式解析</title>
    <link href="http://peilinghui.com/2016/04/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <id>http://peilinghui.com/2016/04/01/设计模式解析/</id>
    <published>2016-04-01T05:01:49.000Z</published>
    <updated>2017-04-10T12:32:56.000Z</updated>
    
    <content type="html">&lt;p&gt;设计模式解析&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;第七章-单例模式&quot;&gt;&lt;a href=&quot;#第七章-单例模式&quot; class=&quot;headerlink&quot; title=&quot;第七章 单例模式&quot;&gt;&lt;/a&gt;第七章 单例模式&lt;/h2&gt;&lt;p&gt;单例模式：它可以保证某个类创建出来的对象永远只有1个。类的一个对象成为系统中的唯一实例。&lt;strong&gt;一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;br&gt;定义包含三层含义：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须向整个系统提供这个实例。&lt;/p&gt;
&lt;h3 id=&quot;何时使用单例&quot;&gt;&lt;a href=&quot;#何时使用单例&quot; class=&quot;headerlink&quot; title=&quot;何时使用单例&quot;&gt;&lt;/a&gt;何时使用单例&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类只能有一个实例。作用：节省内存资源&lt;/li&gt;
&lt;li&gt;这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;单例模式的实现&quot;&gt;&lt;a href=&quot;#单例模式的实现&quot; class=&quot;headerlink&quot; title=&quot;单例模式的实现&quot;&gt;&lt;/a&gt;单例模式的实现&lt;/h3&gt;&lt;p&gt;在Objective-C中实现单例模式，需要完成如下四个步骤：&lt;/p&gt;
&lt;p&gt;第一步：定义一个静态实例变量mySingleton(名字可以自己取)，初始化为nil，代码如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static MySingleton *mySingleton = nil;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：实现一个类方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// mySingleton = [[super allocWithZone:NULL]init];    如果在self中重载了基本的对象分配方法，就需要借用父类(NSObject)的功能，来帮助处理底层内存分配的杂务   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; dispatch_once函数是GCD中的API，它保证应用程序即使在多线程环境下，也只执行一次。当然，也可以使用@synchronize来达到线程安全的目的，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三步：重写allocWithZone方法，用来保证使用alloc和init试图获得一个新实例的时候不产生新实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:zone];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四步：适当实现copyWithZone，release和autorelease等方法。代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果有其他初始化操作，可在这里进行初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 防止外界拷贝造成多个实例，保证实例的唯一性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)copyWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，所以retain不能增加引用计数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)retain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，设置默认引用计数。这里是取的NSUinteger的最大值，当然也可以设置成1或其他值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)retainCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UINT_MAX&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// denotes an object that cannot be released&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// oneway是用于多线程编程中，表示单向执行，不能“回滚”，即原子操作。该方法是空的,不让用户release掉这个对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;oneway&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//除了返回单例外，什么也不做。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)autorelease&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 该方法永远不会被调用,因为在程序的生命周期内容，该单例一直都存在。（所以该方法可以不实现）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; dealloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;子类化Singleton&quot;&gt;&lt;a href=&quot;#子类化Singleton&quot; class=&quot;headerlink&quot; title=&quot;子类化Singleton&quot;&gt;&lt;/a&gt;子类化Singleton&lt;/h3&gt;&lt;p&gt;【补充】说明，对于第二步和第三步可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过返回当前的sharedInstance实例，就能防止实例化一个新的对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sharedInstance] retain];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;alloc调用被转发给super，意味着NSObject晖处理对象分配，如果不做修改的子类化Singleton，返回的实例总是Single。因为Singleton重载了所以实例化相关的方法，实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonSon&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton *shareSingleton=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//向上转型，重定义自己的sharedsingleton类变量，不与父类共享。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(SingletonSon *) shareInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(sharedSingleton==&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//不调用父类alloc方法，在此调用父类alloc方法可能回调此方法，从而产生死循环，我们直接创建对象。(重点下面函数)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     sharedSingleton=[&lt;span class=&quot;built_in&quot;&gt;NSAllocateObject&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;// 子类可以重写一下retain copy release autorelease进行合适的内存管理。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;单例模式实现代码：（MRC）&lt;br&gt; &lt;code&gt;static MJSoundTool *_soundTool = nil;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8D%95%E4%BE%8B%E6%8A%BD%E5%87%BA%E5%AE%8F.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;若是ARC：&lt;br&gt;在build加标记-fobjc-arc&lt;br&gt;与MRC类似，只是没有了release，retain。&lt;br&gt;在宏中用&lt;code&gt;if__has_feature(objc_arc)&lt;/code&gt;判断&lt;br&gt;创建单例设计模式的基本步骤：&lt;ul&gt;
&lt;li&gt;声明一个单件对象的静态实例,并初始化为nil。 &lt;/li&gt;
&lt;li&gt;创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类的实例&lt;/li&gt;
&lt;li&gt;实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和初始化对象时,不会产 生另一个对象。&lt;br&gt;&lt;code&gt;@interface MJSoundTool : NSObject&amp;lt;NSCopying&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/2.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;覆盖release、autorelease、retain、retainCount方法, 以此确保单例的状态。 &lt;/li&gt;
&lt;li&gt;在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实例被正确的创建和初始化。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;单例模式在IOS中的应用&quot;&gt;&lt;a href=&quot;#单例模式在IOS中的应用&quot; class=&quot;headerlink&quot; title=&quot;单例模式在IOS中的应用&quot;&gt;&lt;/a&gt;单例模式在IOS中的应用&lt;/h3&gt;&lt;p&gt;单例模式在IOS中的应用非常广泛，如&lt;br&gt;　　[NSNotificationCenter defaultCenter]、&lt;br&gt;　　[UIApplication sharedApplication]、&lt;br&gt;　　[NSFileManager defaultManager]&lt;br&gt;　　[UIAccelerometer sharedAccelerometer]接收来自单例实例的加速度数据等。
　　
　　
　　&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式解析&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>ViewController的生命周期</title>
    <link href="http://peilinghui.com/2016/03/14/ViewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://peilinghui.com/2016/03/14/ViewController的生命周期/</id>
    <published>2016-03-14T14:40:25.000Z</published>
    <updated>2017-04-10T14:25:52.000Z</updated>
    
    <content type="html">&lt;p&gt;ViewController的生命周期&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1436896-16bffaa910655097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕快照 2016-11-30 下午4.57.03.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、-ARC环境&quot;&gt;&lt;a href=&quot;#一、-ARC环境&quot; class=&quot;headerlink&quot; title=&quot;一、 ARC环境&quot;&gt;&lt;/a&gt;一、 ARC环境&lt;/h2&gt;&lt;h3 id=&quot;单个viewController的生命周期&quot;&gt;&lt;a href=&quot;#单个viewController的生命周期&quot; class=&quot;headerlink&quot; title=&quot;单个viewController的生命周期&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;单个viewController的生命周期&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）&lt;/li&gt;
&lt;li&gt;loadView：加载view&lt;/li&gt;
&lt;li&gt;viewDidLoad：view加载完毕&lt;/li&gt;
&lt;li&gt;viewWillAppear：控制器的view将要显示&lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews：控制器的view将要布局子控件&lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews：控制器的view布局子控件完成&lt;br&gt;这期间系统可能会多次调用viewWillLayoutSubviews 、  viewDidLayoutSubviews 俩个方法&lt;/li&gt;
&lt;li&gt;viewDidAppear:控制器的view完全显示&lt;/li&gt;
&lt;li&gt;viewWillDisappear：控制器的view即将消失的时候&lt;br&gt;这期间系统也会调用viewWillLayoutSubviews 、viewDidLayoutSubviews 两个方法&lt;/li&gt;
&lt;li&gt;viewDidDisappear：控制器的view完全消失的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;多个viewControllers跳转&quot;&gt;&lt;a href=&quot;#多个viewControllers跳转&quot; class=&quot;headerlink&quot; title=&quot;多个viewControllers跳转&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;多个viewControllers跳转&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initWithCoder:(NSCoder *)aDecoder：ViewController2&lt;br&gt;(如果用xib创建的情况下）  &lt;/li&gt;
&lt;li&gt;loadView：ViewController2  &lt;/li&gt;
&lt;li&gt;viewDidLoad：ViewController2  &lt;/li&gt;
&lt;li&gt;viewWillDisappear：&lt;strong&gt;ViewController1&lt;/strong&gt; 将要消失  &lt;/li&gt;
&lt;li&gt;viewWillAppear：ViewController2将要出现  &lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews：ViewController2  &lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews：ViewController2  &lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews:&lt;strong&gt;ViewController1&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews:&lt;strong&gt;ViewController1&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;viewDidDisappear:&lt;strong&gt;ViewController1&lt;/strong&gt; 完全消失  &lt;/li&gt;
&lt;li&gt;viewDidAppear:ViewController2完全出现  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%8810.17.31.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当第一个页面显示的时候调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%8810.17.00.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当点击按钮跳转到第二个页面的时候调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%8810.18.02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当点击按钮回退到第一个页面的时候调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-10%20%E4%B8%8B%E5%8D%8810.18.39.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;小结：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个控制器声明周期： viewDidLoad -&amp;gt; viewWillAppear -&amp;gt; viewWillLayoutSubviews -&amp;gt; viewDidLayoutSubviews -&amp;gt; viewDidAppear -&amp;gt; viewWillDisappear -&amp;gt; viewDidDisappear&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;ViewController的生命周期&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
