<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <icon>https://www.gravatar.com/avatar/f1a75c66faf43f3b1652aef0eb09037e</icon>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2019-03-08T02:20:00.639Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于RN的热更新</title>
    <link href="http://peilinghui.com/2019/03/07/%E5%85%B3%E4%BA%8ERN%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://peilinghui.com/2019/03/07/关于RN的热更新/</id>
    <published>2019-03-07T09:46:13.000Z</published>
    <updated>2019-03-08T02:20:00.639Z</updated>
    
    <content type="html"><![CDATA[<p>写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题</p><a id="more"></a><p>在APPDelegate中加载RN，一般的加载方式是：<br><code>RCTRootView *rootView= [[RCTRootView alloc] initWithBundleURL:jsCodeLocation                                                   moduleName:@&quot;authen_native&quot;                                            initialProperties:nil                                               launchOptions:nil];</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(instancetype)</span>initWithBundleURL:<span class="params">(NSURL *)</span>bundleURL</span><br><span class="line">                       moduleName:<span class="params">(NSString *)</span>moduleName</span><br><span class="line">                initialProperties:<span class="params">(NSDictionary *)</span>initialProperties</span><br><span class="line">                    launchOptions:<span class="params">(NSDictionary *)</span>launchOptions;</span><br></pre></td></tr></table></figure><p>但在调试中发现两个现象：<br>1.重复进入react-native页面、退出react-native页面的操作，RCTBridge对象会被重复创建、销毁。有时候RCTBridge对象未能及时创建还会crash<br>2.在原生页面和react-native页面相互跳转是RCTBridge也会被重复创建，造成很大的内存开销</p><p>阅读RCTRootView.h发现一些细节:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Convenience initializer -</span></span><br><span class="line"><span class="comment"> * A bridge will be created internally.</span></span><br><span class="line"><span class="comment"> * This initializer is intended to be used when the app has a single RCTRootView,</span></span><br><span class="line"><span class="comment"> * otherwise create an `RCTBridge` and pass it in via `initWithBridge:moduleName:`</span></span><br><span class="line"><span class="comment"> * to all the instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBundleURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">bundleURL</span></span><br><span class="line">                       <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">                <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span></span><br><span class="line">                    <span class="selector-tag">launchOptions</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">launchOptions</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * - Designated initializer -</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithBridge</span><span class="selector-pseudo">:(RCTBridge</span> *)<span class="selector-tag">bridge</span></span><br><span class="line">                    <span class="selector-tag">moduleName</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">moduleName</span></span><br><span class="line">             <span class="selector-tag">initialProperties</span><span class="selector-pseudo">:(NSDictionary</span> *)<span class="selector-tag">initialProperties</span> <span class="selector-tag">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><h2 id="initWithBundleURL与initWithBridge的区别"><a href="#initWithBundleURL与initWithBridge的区别" class="headerlink" title="initWithBundleURL与initWithBridge的区别"></a>initWithBundleURL与initWithBridge的区别</h2><p>对于项目中只有一个RCTRootView的时候建议initWithBundleURL的方法，这个方法内部创建了一个RCTBridge.</p><p>而有多个RCTRootView的情况，建议initWithBridge的方法.开发者直接创建RCTBridge，多个RCTRootView可共用一个RCTBridge。</p><h1 id="RN版本升级更新"><a href="#RN版本升级更新" class="headerlink" title="RN版本升级更新"></a>RN版本升级更新</h1><p>项目中使用多个RCTRootView，推荐使用以下方法initWithBridge初始化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">_bridge</span> <span class="string">=</span> <span class="string">[[RCTBridge</span> <span class="string">alloc]</span> <span class="attr">initWithBundleURL:[SDRrectFileOption</span> <span class="attr">SetFileWithOption:self.luanchOption]</span></span><br><span class="line"><span class="attr">                                  moduleProvider:</span><span class="string">nil</span></span><br><span class="line"><span class="attr">                                   launchOptions:</span><span class="string">self.luanchOption];</span></span><br><span class="line"><span class="string">RCTRootView</span> <span class="meta">*rootView</span> <span class="string">=</span> <span class="string">[[RCTRootView</span> <span class="string">alloc]</span> <span class="attr">initWithBridge:_bridge</span></span><br><span class="line"><span class="attr">                                                   moduleName:</span><span class="string">@"authen_native"</span></span><br><span class="line"><span class="attr">                                            initialProperties:</span><span class="string">nil];</span></span><br></pre></td></tr></table></figure><p>在SDRrectFileOption中返回的是jsbundle的地址。在这个文件中可以使用NSFileManager来把jsbundle缓存到本地。但是如果是新版本的RN比如0.57要替换老版本的比如0.54的APP覆盖更新的话，记得要对比版本号，然后把缓存里面的jsbundle清除掉再返回新的jsbundle地址。不然会导致crash。</p><h1 id="RN的热更新"><a href="#RN的热更新" class="headerlink" title="RN的热更新"></a>RN的热更新</h1><p>在APPdelegate的didFinishLaunchingWithOptions方法中来判断是否需要Update。在Update方法中如果需要强制更新的话就就把RCTBridge调用reload方法进行热更新—和初始化使用的是同一个bridge。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>checkUpdate &#123;</span><br><span class="line">  <span class="keyword">patch</span>Class *<span class="keyword">patch</span> = [<span class="keyword">patch</span>Class sharedInstance];</span><br><span class="line">  [<span class="keyword">patch</span> checkUpdate];</span><br><span class="line">  <span class="keyword">patch</span>.IS_COERCIVE = ^<span class="params">(NSURL *newPath)</span> &#123;</span><br><span class="line">    <span class="string">//</span>是强制更新的话，就把RCTBridge调用<span class="keyword">reload</span>方法进行热更新</span><br><span class="line">    [_bridge <span class="keyword">reload</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在patchClass中使用的是单例，在这个里面通过接口判断是否需要热更还是强制更新，是只更新jsbundle还是整包更新，下载文件，把下载的压缩文件解压缩，如果缓存里面有文件先删除旧的jsbundle再保存，</p><h1 id="解决白屏问题"><a href="#解决白屏问题" class="headerlink" title="解决白屏问题"></a>解决白屏问题</h1><p>使用单例初始化一个bridge对象解决上述问题：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeManager</span>: <span class="title">RCTBridge</span></span></span><br><span class="line"></span><br><span class="line">+ (BridgeManager*)shareInstance;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BridgeHandle</span> : <span class="title">NSObject</span>&lt;<span class="title">RCTBridgeDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.m</span></span><br><span class="line">implementation MallBridgeHandle</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSURL</span> *)sourceURLForBridge:(RCTBridge *)bridge</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"index.ios"</span> withExtension:<span class="string">@"jsbundle"</span>];  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BridgeManager</span></span></span><br><span class="line"><span class="keyword">static</span> BridgeManager * manager = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">+ (BridgeManager*)shareInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken,^&#123;</span><br><span class="line">        manager = [BridgeManager alloc] initWithDelegate:[[BridgeHandle alloc] init] launchOptions:<span class="literal">nil</span>]; </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> manager ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>单例在程序启动时初始化。<br>测试验证可以发现：内存得到优化，白屏问题得到解决。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>ios2.1大礼包被拒经验分享<a href="https://zhuanlan.zhihu.com/p/54042709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54042709</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写点关于RN的热更新和RN版本升级后的强制更新。以及优化白屏问题&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac获取ipa方法</title>
    <link href="http://peilinghui.com/2019/02/02/Mac%E8%8E%B7%E5%8F%96ipa%E6%96%B9%E6%B3%95/"/>
    <id>http://peilinghui.com/2019/02/02/Mac获取ipa方法/</id>
    <published>2019-02-02T05:46:05.000Z</published>
    <updated>2019-02-02T05:53:34.025Z</updated>
    
    <content type="html"><![CDATA[<p>从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。<br>新的方法。</p><a id="more"></a><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><p> Apple Configurator 2   Mac appstore下载即可<br>登录appleId</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><ol><li>在Appstore下载相关App（以XX为例）到iPhone或iPad上;</li><li>打开 Apple Configurator 2</li><li>选中连接Mac的移动设备后，点击 Apple Configurator 2 工具菜单 ”添加“ –&gt; 应用；</li><li>搜索app-xx，选中，点击右下角添加，等待添加完成(如下图)；</li><li>不要操作  Apple Configurator 2,切换到桌面;</li><li>快捷键：command + shift + G 或者在Finder 中前往文件夹…</li><li>输入路径：~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/</li><li>拷贝出 上述路径中的ipa文件，之后在 Apple Configurator 2 工具的弹框中点击停止，即可；<br>zhifubao<br>done</li></ol></blockquote><h3 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h3><ol><li>修改上述获取的ipa文件，修改后缀名 ipa –&gt;zip;</li><li>解压zip文件，在完成的文件夹中打开Payload 文件夹，即可看到应用xx宝应用程序；</li><li>选中该应用程序，右键显示包内容即可查看图片资源等；</li></ol><h3 id="获取图片资源"><a href="#获取图片资源" class="headerlink" title="获取图片资源"></a>获取图片资源</h3><ol><li>找到包内容中的 Assets.car 文件；</li><li>打开 “Assets提取工具”，导入 Assets.car 文件，添加到处文件夹，点击提取即可获取；</li></ol><p>参考资料:</p><ol><li>Mac获取ipa和相关资源</li><li>Assets提取工具<a href="https://github.com/pcjbird/AssetsExtractor" target="_blank" rel="noopener">https://github.com/pcjbird/AssetsExtractor</a></li></ol><p>微信分享二维码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从那次ITunes升级以后就不能显示应用，也不能从ITunes安装应用到手机，就不能从ITunes中导出IPA，并且获取应用程序的Assets资源文件。&lt;br&gt;新的方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS逆向</title>
    <link href="http://peilinghui.com/2019/02/01/%E5%AD%A6%E4%B9%A0iOS%E9%80%86%E5%90%91/"/>
    <id>http://peilinghui.com/2019/02/01/学习iOS逆向/</id>
    <published>2019-02-01T02:26:24.000Z</published>
    <updated>2019-03-06T05:08:30.934Z</updated>
    
    <content type="html"><![CDATA[<p>从现有APP实现细节的过程<br><a id="more"></a></p><h2 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h2><p>壳是应用程序加密保护的一种方式，在APP Store上的应用程序都是有加密保护的。<br>查看是否加壳：<br><code>otool -l 可执行文件 | grep cryptid</code><br>例如：<code>localhost:ivwen.app peilinghui$ otool -l ivwen | grep cryptid        cryptid 1</code><br>    如果是1表示是加密的.0表示脱壳的。<br>查看架构：<br><code>lipo -info WeChat</code><br><code>Non-fat file: WeChat is architecture: arm64</code></p><h3 id="砸壳工具"><a href="#砸壳工具" class="headerlink" title="砸壳工具"></a>砸壳工具</h3><h4 id="dumpdecrypted"><a href="#dumpdecrypted" class="headerlink" title="dumpdecrypted"></a>dumpdecrypted</h4><h4 id="Clutch"><a href="#Clutch" class="headerlink" title="Clutch"></a>Clutch</h4><h1 id="工具分析（主要是mac上）"><a href="#工具分析（主要是mac上）" class="headerlink" title="工具分析（主要是mac上）"></a>工具分析（主要是mac上）</h1><h2 id="软件界面的组成结构"><a href="#软件界面的组成结构" class="headerlink" title="软件界面的组成结构"></a>软件界面的组成结构</h2><p>###监控工具<br>通过监控，可以获取界面的变化，文件的读取，网络的传输。</p><h4 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h4><p>对于去壳的应用可以得到所有类的头文件</p><h4 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h4><p>得到界面UI，得到响应事件。</p><h4 id="Snoop-it"><a href="#Snoop-it" class="headerlink" title="Snoop-it"></a>Snoop-it</h4><h4 id="introsy"><a href="#introsy" class="headerlink" title="introsy"></a>introsy</h4><h3 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h3><p>通过分析二进制文件，生成汇编代码，进而转换成高级语言。</p><h4 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h4><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><h3 id="调试跟踪工具"><a href="#调试跟踪工具" class="headerlink" title="调试跟踪工具"></a>调试跟踪工具</h3><h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><h4 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h4><h2 id="程序功能具体实现"><a href="#程序功能具体实现" class="headerlink" title="程序功能具体实现"></a>程序功能具体实现</h2><h1 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h1><h2 id="应用代码框架构成"><a href="#应用代码框架构成" class="headerlink" title="应用代码框架构成"></a>应用代码框架构成</h2><h1 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h1><h2 id="执行流程参数传递"><a href="#执行流程参数传递" class="headerlink" title="执行流程参数传递"></a>执行流程参数传递</h2><p><code>class-dump -s -S -H WeChat.decrypted -o /Users/lecoding/Desktop/test/WeChatDemo/Headers</code></p><blockquote><p>WeChat.decrypted ： 砸壳后的Mach-o文件路径<br>/Users/lecoding/Desktop/test/WeChatDemo/Headers： 存储头文件目录<br>-s             sort classes and categories by name<br>-S             sort methods by name<br>-H            generate header files in current directory, or directory specified with -o<br>-o            output directory used for -H</p></blockquote><h1 id="iOS系统安全机制"><a href="#iOS系统安全机制" class="headerlink" title="iOS系统安全机制"></a>iOS系统安全机制</h1><p><code>image list -o -f</code>打印出iOS中二进制文件，库文件，动态链接文件，栈和堆内存地址的位置全部都是随机的。</p><h1 id="iOS越狱"><a href="#iOS越狱" class="headerlink" title="iOS越狱"></a>iOS越狱</h1><p>通过一系列iOS系统的漏洞，对系统安全权限进行破解，获取系统Root的权限。<br>引导式越狱，不完美越狱，完美越狱。</p><h2 id="越狱环境的配置"><a href="#越狱环境的配置" class="headerlink" title="越狱环境的配置"></a>越狱环境的配置</h2><h1 id="iOS底层的知识储备"><a href="#iOS底层的知识储备" class="headerlink" title="iOS底层的知识储备"></a>iOS底层的知识储备</h1><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h2 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h2><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h2 id="UI控件的背后代码执行"><a href="#UI控件的背后代码执行" class="headerlink" title="UI控件的背后代码执行"></a>UI控件的背后代码执行</h2><h2 id="整个APP的结构以及构建的过程"><a href="#整个APP的结构以及构建的过程" class="headerlink" title="整个APP的结构以及构建的过程"></a>整个APP的结构以及构建的过程</h2><h3 id="手动打包APP模拟Xcode自动打包的过程"><a href="#手动打包APP模拟Xcode自动打包的过程" class="headerlink" title="手动打包APP模拟Xcode自动打包的过程"></a>手动打包APP模拟Xcode自动打包的过程</h3><h1 id="Hook的原理"><a href="#Hook的原理" class="headerlink" title="Hook的原理"></a>Hook的原理</h1><h2 id="Hook的几种方式"><a href="#Hook的几种方式" class="headerlink" title="Hook的几种方式"></a>Hook的几种方式</h2><h3 id="1-Method-Swizzle—OC"><a href="#1-Method-Swizzle—OC" class="headerlink" title="1.Method Swizzle—OC"></a>1.Method Swizzle—OC</h3><p>通过OC的Runtime机制，改变函数的地址来交换方法实现</p><h3 id="2-fishHook—–C"><a href="#2-fishHook—–C" class="headerlink" title="2.fishHook—–C"></a>2.fishHook—–C</h3><p>通过修改懒加载和非懒加载的表，通过修改表的指针来达到Hook的效果，作用于C函数</p><h3 id="3-Cydia-Substrate（框架）"><a href="#3-Cydia-Substrate（框架）" class="headerlink" title="3.Cydia Substrate（框架）"></a>3.Cydia Substrate（框架）</h3><p>针对OC，C函数，或者是函数地址来做Hook操作</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>一条命令完成砸壳<a href="http://www.alonemonkey.com/2018/01/30/frida-ios-dump/" target="_blank" rel="noopener">http://www.alonemonkey.com/2018/01/30/frida-ios-dump/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从现有APP实现细节的过程&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最近感悟</title>
    <link href="http://peilinghui.com/2019/01/26/%E6%9C%80%E8%BF%91%E6%84%9F%E6%82%9F/"/>
    <id>http://peilinghui.com/2019/01/26/最近感悟/</id>
    <published>2019-01-26T01:59:21.000Z</published>
    <updated>2019-02-01T02:23:54.944Z</updated>
    
    <content type="html"><![CDATA[<p>人在闲的时候就不会不自觉的想好多东西。</p><a id="more"></a><ol><li>越来越觉得，人生就是需要不断的学习，不断的提高，其实在学校里面是学习然后是考试，在工作中是工作然后考核KPI，其实不论是在哪里，只要你开始努力，什么时候都不晚，确实看到很多出身学历不好的人，在工作中经过自己长期不断的努力也能获得比那些高学历人更多的回报。</li><li>学历只是敲门砖，是入场券，但是只代表过去，不能代表现在，更不能代表将来，你不论进入什么公司，都需要持续不断的热情和坚持不懈的努力，认真的工作态度，其实一个人有没有认真工作，老板都是可以看出来的。如果你长期抱怨，并且不积极努力，意味着你离打包走人也不远了。不论你是什么出身。</li><li>毕业出了学校，你才发现自律对一个人是多么的重要，学校的生活并不代表学校多好，条件多棒，学校是多么出名，更多的是你从学校以及周围的人所学到的东西，是否能主动高效并且自律安排自己的学习和生活，同样，你进入工作，才能有条不紊的安排自己的学习、工作和生活。你会发现那些越自律的人越优秀并且越有上升空间。你会发现那些比你优秀的人比你还更努力。</li><li>从勤奋到懒惰容易，从懒惰到勤奋难，人总是偏向于懒惰的方向，不愿挑战自己，一直在给自己制造舒适区。从奢入简难，从简入奢易。总是这个道理，其实人有的时候也没必要和别人比较，其实你最大的敌人和最难克服的难道不是自己的私欲么？人肉体的私欲，想要吃，想要玩，想要快乐，想要放纵自己，管不住自己的私欲，很多时候就阻挡了自己向前的动力，就像是你想要往前走，但是你的身体就是不动。心有余而力不足。就是你没有能打败自己。温饱思淫欲，当人吃喝玩乐都觉得没意思了以后就会想淫欲，能管住自己的下半身的人才能管住自己的下半生，这个管住和你在什么位置，有多少钱没有关系，为什么辣么多事业有成的人还会出轨，可能就是没有克制了自己的私欲，管不住自己，这就说到了自律是多么的重要，我们一直在和自己做斗争。勤奋小人和懒惰小人。善与恶小人，还有很多的小人每天在我们的心里做斗争，看谁会打败谁。然后就铸造了现在的你。</li><li>钱，这世上有谁不想赚钱，不想赚更多钱，不论是为了生活还是为了生存还是为了更优越的生存。但是赚钱这件事和你是什么学历，什么教育水平关系不是绝对的正比关系，财商和智商沾边，但不是完全成正比，不得不说，高学历高智商的人还是会在各行各业占据主要地位，甚至创造价值，学历高会让你有更多的选择，不论你是想在官场，还是职场，还是商场上都会为你留个位置，但是这只代表的选择，并不代表你自己的发展，所以，为什么说读书才是能进入上层阶级的入场券也是这个道理把。不得不说，学历更高的人薪资更高。但是，为什么学历一样的人，还是有人能当CEO或者CTO，有人能赚一个亿也是小目标的呢？这就不仅仅是智商或者是学历的因素了，更多的是财商和眼界还有见识的问题了。对于一个码农，光靠敲代码可能也不能达到财富自由，为什么马云不会敲代码还是中国首富呢？这就说到了见识和你所能看到的世界，决定了你所占的高度，而不仅是能力，一个码农，只是代表了一项技术，你有一门手艺，能在这个社会生存和站住脚，但是这仅仅是一个技工，只不过有些人是高级技工，有些人是中级技工，有些人是普通技工，更重要的是思想，这就为什么腾讯马化腾能从高级码农上升到CTO。还有其他公司的老总是技术出身还是老总的原因咯。</li><li>我们生活在一个庞大的世界，但是每个人的生活就是自己的一个版本，这也就解释了为什么我们在一个公司，一个城市，一个地方，却过着不一样的生活，就是我们虽然有交集，但是不是我们全部的生活，这就是为什么人家和你年龄一样，人家是老总你却是员工，就是其实我们都是生活在不同版本里面的人。为什么同样是人，为什么大家每天都是有24小时，人和人的差别为什么比人和狗的差别还要大呢？实际上，不同的人在单位时间内创造的效益是不同的。就是为什么在同一个公司，大家的薪资不同的道理把。</li><li>赚钱有的时候不是因为我们爱钱，或是是什么，在我看来是一种能力，一种自己价值的体现。你赚多少钱，代表了你有多大的能力，不仅仅是智商，情商，财商，赚多钱是这些的外在表示而已。就像是在悬崖边的百合花，它开花并不是为了让更多人来看它，而是它展示了它可以开花的能力，我们更多的时候是为了展示自己的价值，而不是赚多少钱。爱钱的人不一定能赚更多的钱，或者是钻到钱眼里面的人也可能走向犯罪的边缘，但是那些真正想要为社会做出贡献，真正想做一些事实现自己价值的人，金钱往往追着他们跑。但是也有那些不为了钱在教育行业辛勤耕耘的老师，或许他们是清北毕业的，但是他们创造的价值是无穷的，是无法用金钱衡量的。他们赚取的应该是尊重，是社会地位。但是也有那些一边做导师，一边开公司的人。总之，你的金钱和地位或许决定了你在这个社会生活的版本。而不是你的年龄，你的生活环境，或者是你的学历决定你生活的版本，不同的人有不同的生活版本，是你这个人不同与其他人单独的个体决定了你的生活，而不是生活决定了你。</li><li>也许大家都羡慕那些不工作，四处游玩，有奢侈生活的人，但是真的让你不工作四处游玩的时候，你也会腻，人就是不断的在寻求刺激，寻求不一样的东西，就像是人吃一种东西，吃多了会腻，不论是食物，还是工作，还是生活，从起初的和以前不一样，到回归平常，就是人的一种心理，刚开始很新鲜，但是一段时间会就会觉得无趣，但是那些能坚持的人往往才是胜利的人，人都会有疲倦和厌烦还有不新鲜的时候，但是一旦感到不新鲜就去换其他吗？并不是的。人更难得的是坚持，所以我羡慕那些能坚持长跑，或者是跑马拉松的人，这样的人更能达到成功，能在一个岗位一个领域深挖，更深探索的人才能成为专家，才能更加优秀，那些浅尝辄止感到不新鲜就转化领域的人看似什么都知道什么都会，但却不精，也会和成功擦肩而过。你不能因为工作熟悉没有新鲜感就频繁的换工作把？还有就是你不能因为婚姻没有新鲜感，每天看着同样的人就频繁离婚把？你不能因为每天生活一样两点一线就不生活了把？坚持是人更难得的品格，所以人的成功更多的不是在智商更多的是你能否坚持下去，这也是马云说的，今天很残酷，明天更残酷，后天会很美好，但绝大多数人都死在明天晚上，却见不到后天的太阳，所以我们干什么都要坚持！    </li><li>创业：是真的想创业，但是为什么没有开始？没有好的构想和版图和Idea，</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人在闲的时候就不会不自觉的想好多东西。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018年总结</title>
    <link href="http://peilinghui.com/2018/12/04/2018%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2018/12/04/2018年总结/</id>
    <published>2018-12-04T07:24:02.000Z</published>
    <updated>2019-01-02T14:39:50.916Z</updated>
    
    <content type="html"><![CDATA[<p>现在是12月初，还有一个月，2018年就要过完了，看了看去年的年终总结和新年计划，只能趁着这个月把今年的还可以实现的实现一下了。<br><a id="more"></a></p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>从2017年入职了涂鸦科技以后，就开始搞RN，也看看OC和RN的交互，对于iOS的组件化、模块化有了更多的认识，把Pod打成私有库，如何拆分模块，拆分Pod，并且能够持续化集成。一直工作到了七月。我三月底毕业的。当时候因为薪资低，也因为一直在做RN的东西，期间，我接手了一个外包项目，是做纯iOS开发的。然后又重新燃起我对原生开发的热情，额，换部门不可能额，我内推的一个我的同学也要跳槽，我也想跳槽了，然后我们就一起离职了额，我跳槽到了一个区块链的初创型公司，公司只有20多人。老板给我薪资还挺高，让我做team leader，从此就开始了996的日子，于是从零开始构建APP，还有一个小弟。我们要开发做一个类似微博的区块链社区群的APP，第一期需求做了大概两三周，然后测试了一周，然后做第二期需求加IM即时通讯，这块我也是第一次接触，然后压力山大，老板有一次感觉APP太慢了，就是加载慢，而且滑动列表有点卡，也是找我问罪，实话说，压力很大，然后研究第三方融云的文档，然后开发，干了两个月，然后做了这样一个完整有雏形的APP，我感觉996撑不下额，而且任务重，时间紧，压力大，让我感觉吃不消，就又辞职了，其实还是有点后悔的。然后就迎来了裸辞的找工作。</p><h2 id="感触"><a href="#感触" class="headerlink" title="感触"></a>感触</h2><ol><li>不要干不久就跳槽，跳槽容易跳崩，刚工作要沉下心来，自己努力去专研一些东西，在繁忙的业务中思考，并且能在繁忙的业务中解脱出来，去学习新的技术。</li><li>接外包可以，但是容易分心，如果工作很忙还是不要接外包了，不然身心灵都疲倦。接外包可以利用很多的业余时间来强迫你工作，如果自制力好的话，可以利用业余时间多学习学习新的技术，如果自制力不好的话，接外包也可以让你明确自己该学习研究哪些内容，并且实现出来。但是确实是要耗费时间和精力的。</li><li>不要意气用事的裸辞，在还没有完全找到下家的时候不要裸辞！不要裸辞！不要裸辞！尤其是现在这个资本寒冬，好多公司在裁员，裸辞就意味着要在身心灵上扛得住压力，重新去投简历找工作，如果超过两周没工作的话，你就容易变得很慌，这种感觉简直太煎熬。</li><li>参加工作和在学校里面很不一样。</li></ol><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>说道学习，我就是在去年12月写论文，1月改论文，3月初答辩，3月底毕业。论文写得是RN方面的，感觉自己没有写好，也没用心写，在学校的时候还是不要边工作边写论文，不然容易两个都干不好，白天工作，晚上写论文，改论文，周末改论文，不知道是怎么熬下来的，没有完整的时间去思考去构建整个论文体系，感觉就是顺利毕业就好额。</p><p>学习方面就是：学习了下JS，ES6，</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活就是租房，然后搬家，然后再次租房。学会了做饭。<br>3月底4月初，毕业以后去马来西亚玩了一趟就当毕业旅行了。后来十一去了武功山，挑战自己，六月的时候回了趟家，然后十月的时候回了好几次家。<br>五月份的时候去了上海和同学玩，八月底的时候家里人去杭州看我，带他们去了乌镇，他们自己在杭州玩了玩，后来十月份又带他们去了上海玩了一下。其他时候基本就是自己平时周末去打球，去逛吃逛吃买买买了。生活就是这样平淡无奇的过着。期间还相亲过，同学介绍的，没有后文，吃完饭大家估计都觉得不合适，就没有再联系了。于是就躺在了微信里。</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>一年一年的真的是好快啊！<br>我总结了下今年一共赚了多少钱，到手的钱大概是12万左右。（工资加外快）房租付了大概两万五，十一奉献一万，出去玩一万。每个月大概花五千，我真的都不知道干啥了。一年差不多六万。所以就攒剩下两万了</p><h1 id="新的一年的计划"><a href="#新的一年的计划" class="headerlink" title="新的一年的计划"></a>新的一年的计划</h1><p>人生就像是马拉松，并不在于你先开始跑的快或者是慢，而在于你能够坚持不懈的跑下去，我发现了一个问题，成功的人都喜欢长跑，因为长跑可以训练一个人的毅力和持久力，而我则擅长短跑，很多时候我喜欢什么就去抱有热情去学一阵子，然后过了一阵子就失去了热情和兴趣。总是不能坚持。<br>一开始，我以为我一直能够坚持的习惯就是每天早上读经祷告，从初中开始住校的时候我就开始了每天早上看一章圣经的习惯，到高中每天看一章圣经，写一句圣经话语，到大学。可是到了研究生我就没能再坚持了。</p><ol><li>早睡早起：11点睡觉，6点半7点起床祷告，然后读经。写一节圣经。</li><li>多读励志的书籍，多打鸡血，每天告诉自己我要年薪百万，我离目标还有十倍的距离。—微信读书</li><li>读书以后要写读书感想和笔记。</li><li>多学技术，多看视频。抓紧时间学习。</li><li>每天要花一定的时间学习英语。听或者读。</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在是12月初，还有一个月，2018年就要过完了，看了看去年的年终总结和新年计划，只能趁着这个月把今年的还可以实现的实现一下了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode10遇到的问题</title>
    <link href="http://peilinghui.com/2018/11/03/%E5%8D%87%E7%BA%A7Xcode10%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2018/11/03/升级Xcode10遇到的问题/</id>
    <published>2018-11-03T07:59:27.000Z</published>
    <updated>2018-11-03T08:03:00.481Z</updated>
    
    <content type="html"><![CDATA[<p>升级Xcode10遇到的问题以及最近解决的问题。</p><a id="more"></a><p>项目升级到Xcode10 以后报错：</p><h3 id="React-Native-‘config-h’-file-not-found"><a href="#React-Native-‘config-h’-file-not-found" class="headerlink" title="React-Native ‘config.h’ file not found"></a>React-Native ‘config.h’ file not found</h3><p>解决方法：</p><p>cd node_modules/react-native/third-party/glog-0.3.4<br>../../scripts/ios-configure-glog.sh</p><h3 id="Xcode-10-libfishhook-a-cannot-be-found"><a href="#Xcode-10-libfishhook-a-cannot-be-found" class="headerlink" title="Xcode 10 libfishhook.a cannot be found"></a>Xcode 10 libfishhook.a cannot be found</h3><p>解决方法：</p><p>在LIbrary下面的RCTWebSocket中的Target中的Build Phases中的Link Binary With Libraries 中的libfishhook.a文件删了重新导入就好了。</p><h3 id="Multiple-commands-produce"><a href="#Multiple-commands-produce" class="headerlink" title="Multiple commands produce"></a>Multiple commands produce</h3><p>Showing Recent Messages</p><p>2) Target ‘YAORecordProject’ (project ‘YAORecordProject’) has process command with output ‘/Users/peilinghui/Library/Developer/Xcode/DerivedData/YAORecordProject-frlkqcmjttdqtdandttwzrmfhjnt/Build/Products/Debug-iphonesimulator/YAORecordProject.app/Info.plist’</p><p>解决方法：</p><p>This issue might occur just because of multiple Plist/other files within App-<br>Solution -&gt; Open target -&gt; Build phases &gt; Copy Bundle Resources and remove info.plist from there.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级Xcode10遇到的问题以及最近解决的问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RN与iOS的混合开发</title>
    <link href="http://peilinghui.com/2018/10/29/RN%E4%B8%8EiOS%E7%9A%84%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <id>http://peilinghui.com/2018/10/29/RN与iOS的混合开发/</id>
    <published>2018-10-29T09:16:37.000Z</published>
    <updated>2018-10-29T10:00:52.152Z</updated>
    
    <content type="html"><![CDATA[<p>以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。</p><a id="more"></a><h2 id="纯RN的APP"><a href="#纯RN的APP" class="headerlink" title="纯RN的APP"></a>纯RN的APP</h2><p>就是通过React-Native init一个项目以后，代码写好以后把代码打包成bundle文件，然后导入到Xcode里面然后打包成ipa来发布，其中在APPdelegate里面是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">NSURL</span> *jsCodeLocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index.ios" fallbackResource:nil];</span></span><br><span class="line">  jsCodeLocation = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"main"</span> withExtension:<span class="string">@"jsbundle"</span>];</span><br><span class="line"></span><br><span class="line">  RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                      moduleName:<span class="string">@"CompassRN"</span></span><br><span class="line">                                               initialProperties:<span class="literal">nil</span></span><br><span class="line">                                                   launchOptions:launchOptions];</span><br><span class="line">  rootView.backgroundColor = [[<span class="built_in">UIColor</span> alloc] initWithRed:<span class="number">1.0</span>f green:<span class="number">1.0</span>f blue:<span class="number">1.0</span>f alpha:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line">  <span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">  rootViewController.view = rootView;</span><br><span class="line">  <span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最重要的连接就是RCTRootView，的方法加载bundle文件，参数initialProperties必须是NSDictionary的一个实例。这一字典参数会在内部被转化为一个可供JS组件调用的JSON对象。</p><p>具体解析请看：<a href="https://www.jianshu.com/p/9d7dbf17daa5" target="_blank" rel="noopener">https://www.jianshu.com/p/9d7dbf17daa5</a><br>RCTBridge桥接，moduleName是CompassRN，同样在RN中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> CompassRN <span class="keyword">from</span> <span class="string">'./component/Appmain'</span>;</span><br><span class="line">AppRegistry.registerComponent(<span class="string">'CompassRN'</span>, <span class="function"><span class="params">()</span> =&gt;</span> CompassRN);</span><br></pre></td></tr></table></figure><p>在React Native中，一个“原生模块”就是一个实现了“RCTBridgeModule”协议的Objective-C类，其中RCT是ReaCT的缩写。</p><h2 id="RN和iOS混合开发"><a href="#RN和iOS混合开发" class="headerlink" title="RN和iOS混合开发"></a>RN和iOS混合开发</h2><p>需要在iOS工程中：</p><p>iOS是如何下载bundle文件，并且保证bundle文件的安全？</p><ol><li><p>TYRCTPanelViewController 的viewDidLoad中加载面板 loadDevicePanel,<br>通过TYPanelService来下载面板，<br>如果是debug模式的话，加载路径是：</p><pre><code>panelPath = [NSString stringWithFormat:@&quot;http://%@:8081/index.ios.bundle?platform=ios&amp;dev=true&amp;gwId=%@&quot;,ip, self.devId];其中IP是本机电脑的IP，</code></pre></li></ol><p>否则release模式的话：  [self loadWebView:panelPath]通过panelPath的网络请求路径来加载面板</p><p>_rootView = [[RCTRootView alloc] initWithBundleURL:[NSURL URLWithString:panelPath] moduleName:@”TYRCTApp” initialProperties:@{@”devInfo”:devInfo} launchOptions:nil];<br>_rootView.frame = self.view.bounds;<br>如果设备变更，数据，网络，蓝牙等变化的话，通过<br>[self.rootView.bridge.eventDispatcher sendAppEventWithName:@”networkStateChange”<br>                        body:@{@”state”:[NSNumber numberWithBool:state]}];<br>来通知rootView</p><ol start="2"><li><p>列表中用 TYPanelViewControllerFactory来处理具体进入到哪个面板。 isEnableDebug模式下进入 TYCommonPanelViewController,</p></li><li><p>TYPanelService.拉取面板主要是 TYPanelService 这个方法， 使用NSURLSessionDownload来下载面板，<br>如果沙盒 TPSandBox里面通过 NSFileManager来管理，如果里面存在有面板，直接加载，<br>不存在的话就去下载main.jsbundle（通过 RunLoop里面的这个方法cancelPreviousPerformRequestsWithTarget可以取消先前的请求任务）<br>下载以后的面板通过JSON解析以后放到 TYUIPanel（Model）中，删除先前的tar.gz压缩包，取消先前的任务，</p></li></ol><p>3.对于每一个panel文件，Model对象里面有 uiId， version， content， fileMd5，<br>其中 fileMd5来保证包的安全性，包解析用的工具是 TPEncryptUtils，先把 tarPath的文件转化成NSData，然后通过 DCTar来解压文件，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以前做过一个APP是纯RN开发的，还做过一个APP是RN和iOS混合开发的，现在就比较一下两者的不同。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在APP中IM使用融云</title>
    <link href="http://peilinghui.com/2018/09/21/%E5%9C%A8APP%E4%B8%ADIM%E4%BD%BF%E7%94%A8%E8%9E%8D%E4%BA%91/"/>
    <id>http://peilinghui.com/2018/09/21/在APP中IM使用融云/</id>
    <published>2018-09-21T04:43:28.000Z</published>
    <updated>2018-09-29T09:21:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。<br><a id="more"></a></p><p>首先可以参照官网：<a href="https://www.rongcloud.cn/docs/ios.html#prepare" target="_blank" rel="noopener">https://www.rongcloud.cn/docs/ios.html#prepare</a>来进行基本的融云包的导入和集成到工程中。<br>通过在控制台中API的调用<a href="https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=" target="_blank" rel="noopener">https://developer.rongcloud.cn/apitool/A0dLuQBjI8MJKehwuu0=</a>来模拟接口调用的过程。<br>集成融云，就是能用好他所提供的API，就能完成大部分的工作，用好IMKit和IMLib。IMKit主要就是页面，可以在它的基础上进行我们自己页面的自定义，IMLib就是通讯的API，通过使用它暴露的方法来实现及时通讯，单聊，群聊，以及自定义消息的发送。</p><h1 id="导入融云，连接融云"><a href="#导入融云，连接融云" class="headerlink" title="导入融云，连接融云"></a>导入融云，连接融云</h1><p>在APPDelegate中注册自定义的消息类型和做消息推送相关的内容。<br>最好是在登录APP的时候，让服务端返回userId和rongcloudToken，获取到Token以后，登录融云的服务器。可以写一个单例的工具类，来处理融云的登录，断开连接，和&lt;RCIMUserInfoDataSource, RCIMReceiveMessageDelegate,RCIMConnectionStatusDelegate&gt;用户数据源的一些方法的实现。</p><h1 id="用户信息和群组信息的数据源"><a href="#用户信息和群组信息的数据源" class="headerlink" title="用户信息和群组信息的数据源"></a>用户信息和群组信息的数据源</h1><p>因为融云已经做好了基本的聊天通讯的功能，我们要做的就是处理用户昵称，头像和群组的一些信息的处理，设置</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//设置用户信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.userInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群组信息源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupInfoDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br><span class="line">  //群成员数据源</span><br><span class="line">  <span class="string">[RCIM sharedRCIM]</span>.groupMemberDataSource = <span class="string">[JRIMDataSource shareInstance]</span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息需要通过实现RCIMUserInfoDataSource的方法"><a href="#用户信息需要通过实现RCIMUserInfoDataSource的方法" class="headerlink" title="用户信息需要通过实现RCIMUserInfoDataSource的方法"></a>用户信息需要通过实现RCIMUserInfoDataSource的方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getUserInfoWithUserId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">userId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCUserInfo *userInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>我们需要在这个方法里面调用自己的接口来获取用户的相关信息，就是头像和昵称，然后把获取到的数据放到RCUserInfo对象的userId，name，和portraitUri中，也把这个数据存到FMDB数据库中。这样在聊天列表展示聊天cell的时候，可以通过<br><code>RCUserInfo *user = [[RCIM sharedRCIM] getUserInfoCache:model.targetId];</code>这个方法，如果User存在的话，直接赋值，如果不存在的话，再次调用getUserInfoWithUserId这个来获取用户的信息，获取到以后刷新用户信息，并存到数据库中。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="name">RCIM</span> sharedRCIM] refreshUserInfoCache:user withUserId:user.userId]<span class="comment">; </span></span><br><span class="line">[[<span class="name">JRDataBaseManager</span>  shareInstance]insertUserToDB:userInfo]<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="群组信息实现RCIMGroupInfoDataSource方法"><a href="#群组信息实现RCIMGroupInfoDataSource方法" class="headerlink" title="群组信息实现RCIMGroupInfoDataSource方法"></a>群组信息实现RCIMGroupInfoDataSource方法</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">getGroupInfoWithGroupId</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">groupId</span> <span class="selector-tag">completion</span><span class="selector-pseudo">:(void</span> (^)(RCGroup *groupInfo))<span class="selector-tag">completion</span>;</span><br></pre></td></tr></table></figure><p>融云自带的群组的信息类是RCGroup，只包含groupId，groupName和portraitUri，我们如果需要更多的信息存储，只需要继承自RCGroup,<br>如果我们需要在群组名称中携带很多信息的话，只需要把相关的信息放到一个字典中然后后转化成json字符串赋值给groupName</p><h3 id="群组成员实现"><a href="#群组成员实现" class="headerlink" title="群组成员实现"></a>群组成员实现</h3><p>我们可以写个单例来实现这三个方法。在方法实现中通过调用自己的接口获取到相关的数据，然后调用融云的接口refreshGroupInfoCache存储起来。</p><h1 id="消息列表"><a href="#消息列表" class="headerlink" title="消息列表"></a>消息列表</h1><p>消息列表需要继承自RCConversationListViewController，只要继承了这个，然后通过其暴露的属性和方法来设置基本列表的样式，当有消息的时候就能展示出来融云自带的聊天cell。如果我们要自定义的消息列表的cell。主要实现的方法：</p><h3 id="重写方法：插入自定义会话model"><a href="#重写方法：插入自定义会话model" class="headerlink" title="重写方法：插入自定义会话model"></a>重写方法：插入自定义会话model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSMutableArray</span> *)willReloadTableData:(<span class="built_in">NSMutableArray</span> *)dataSource&#123;</span><br><span class="line"> [dataSource enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        RCConversationModel *model = (RCConversationModel *)obj;</span><br><span class="line">        <span class="comment">//筛选请求添加好友的系统消息，用于生成自定义会话类型的cell</span></span><br><span class="line">       <span class="keyword">if</span> (model.conversationType == ConversationType_GROUP) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (model.conversationType == ConversationType_PRIVATE) &#123;</span><br><span class="line">            model.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">     <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：在该方法内筛选数据源dataSource中具体的会话类型及消息的model，将model 类型必须修改为 model.conversationModelType=RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION</p><p>如果需要插入类似微博消息列表中的点赞、评论，关注和系统消息的自定义cell，需要在这个方法中自定义Model，并且拼接到DataSource中。</p><p>代码如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_isShowServiceSystem == <span class="keyword">NO</span>) &#123;</span><br><span class="line">        RCConversationModel *<span class="keyword">model</span> = [[RCConversationModel alloc] init];</span><br><span class="line">        <span class="keyword">model</span>.targetId = JR_Service_System_ID;</span><br><span class="line">        <span class="keyword">model</span>.conversationType = ConversationType_SYSTEM;</span><br><span class="line">        <span class="keyword">model</span>.conversationModelType = RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION;</span><br><span class="line">        [dataSource addObject:<span class="keyword">model</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重写返回-cell-高度的方法"><a href="#重写返回-cell-高度的方法" class="headerlink" title="重写返回 cell 高度的方法"></a>重写返回 cell 高度的方法</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(CGFloat)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView heightForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath;</span><br></pre></td></tr></table></figure><p>如果需要显示不同高度测自定义的cell，只需要在这个方法中，根据判断的类型返回高度值。</p><h3 id="自定义会话Cell显示时的回调"><a href="#自定义会话Cell显示时的回调" class="headerlink" title="自定义会话Cell显示时的回调"></a>自定义会话Cell显示时的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="params">(RCConversationBaseCell *)</span>rcConversationListTableView:<span class="params">(UITableView *)</span>tableView cellForRowAtIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>或者是即将显示cell的时候把用户信息和群组信息放到cell里面</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>willDisplayConversationTableCell:<span class="params">(RCConversationBaseCell *)</span>cell atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>如果使用的都是自定义的cell的话，要设置在model.conversationModelType == RC_CONVERSATION_MODEL_TYPE_CUSTOMIZATION)先区分数据模型是自定义的，再区分是单聊还是群聊conversationType。对于每一种会话类型，自定义我们需要的cell的样式，然后通过取出对应index的Model。<br>  <code>RCConversationModel *model = self.conversationListDataSource[indexPath.row];</code><br>来把Model中的头像、昵称、最近消息、时间、未读数、一些信息放到cell对应的位置。</p><h3 id="点击事件-–点击cell的回调"><a href="#点击事件-–点击cell的回调" class="headerlink" title="点击事件 –点击cell的回调"></a>点击事件 –点击cell的回调</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>onSelectedTableRow:<span class="params">(RCConversationModelType)</span>conversationModelType</span><br><span class="line">         conversationModel:<span class="params">(RCConversationModel *)</span>model</span><br><span class="line">               atIndexPath:<span class="params">(NSIndexPath *)</span>indexPath</span><br></pre></td></tr></table></figure><p>在点击事件中，根据你自定义cell类型的不同，跳转到不同的页面，如果是单聊，群聊跳转到聊天会话页面，如果是系统消息：评论回复、点赞、关注、系统消息，跳转到自己写的页面，融云提供了这种系统消息的通知的接口，我们可以通过它的接口就可以实现通知的推送，不需要接入第三方极光等来进行推送。只需要把这些通知调用发送接口，作为消息发送给用户。</p><p>例如：评论和回复页面：继承自RCConversationViewController，隐藏下面的输入栏<code>self.chatSessionInputBarControl.hidden = YES;</code><br>注册自定义的消息和数据模型：<code>[self registerClass:[JRServiceCommentCell class] forMessageClass:[JRServiceCommentModel class]];</code><br>通过接收到通知以后，在会话页面插入一条消息并展示：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//在会话页面中插入一条消息并展示</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(updateForSharedMessageInsertSuccess:)</span><br><span class="line">                                                 name:<span class="string">@"RCDSharedMessageInsertSuccess"</span></span><br><span class="line">                                               object:<span class="literal">nil</span>];</span><br><span class="line">                                               </span><br><span class="line">-(<span class="keyword">void</span>)updateForSharedMessageInsertSuccess:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    RCMessage *message = notification.object;</span><br><span class="line">    <span class="keyword">if</span> (message.conversationType == <span class="keyword">self</span>.conversationType &amp;&amp; [message.targetId isEqualToString:<span class="keyword">self</span>.targetId]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> appendAndDisplayMessage:message];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评论和回复的cell继承自RCMessageBaseCell。可以自己写这个cell的样式。再说一下这个cell的数据源，也是自己自定义的CommentModel继承自RCMessageContent，就和自定义消息类型一样的，需要把消息内容编码成JSON，然后将JSON解码成消息内容，定义消息的类型名（与融云消息不要名字一样），类似我们平时用网络请求后的JSON数据解析，把NSData的data消息解码成字典，<code>NSDictionary *dictionary = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:&amp;error];</code>然后把字典中的dictionary[@”content”]取出来，判断是字典还是字符串类型，如果是字典的话就用YYModel解析到一个Model中来使用。如果是字符串的话就用方法把JSON字符串转化为字典，</p><h1 id="消息会话"><a href="#消息会话" class="headerlink" title="消息会话"></a>消息会话</h1><h1 id="消息会话展示"><a href="#消息会话展示" class="headerlink" title="消息会话展示"></a>消息会话展示</h1><ol><li>单聊不显示对方名称：RCMessageModel的model.isDisplayNickname来设置<br>2.群聊显示身份的名称：获取到群成员数组以后，遍历数组，把身份和成员的昵称存到RCUserInfo的name中，并保存到SDK中，再把  [self.conversationMessageCollectionView reloadData];</li></ol><p>重要的方法:<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sendMessage:<span class="params">(RCMessageContent *)</span>messageContent pushContent:<span class="params">(NSString *)</span>pushContent;</span><br></pre></td></tr></table></figure></p><p>在发送自定义消息和通知的时候使用，当我在发送一个邀请好友进入聊天室的自定义cell的时候，使用</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JRInviteMessage *inviteMsg = [JRInviteMessage messageWithGroupId:<span class="literal">self</span>.<span class="keyword">group</span>Id</span><br><span class="line">                                                             WithGroupHeader:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img).length==<span class="number">0</span>?  <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>ImgAll :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Img</span><br><span class="line">                                                               WithGroupName:[<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name containsString:@<span class="string">"、"</span>] ? <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>NameAll : <span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Name</span><br><span class="line">                                                            WithGroupProflie:NSStringObject(<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct).length==<span class="number">0</span>?  @<span class="string">"暂无简介"</span> :<span class="literal">self</span>.<span class="keyword">group</span>Model.<span class="keyword">group</span>Introduct];</span><br><span class="line">           </span><br><span class="line">[[RCIM sharedRCIM]sendMessage:ConversationType_PRIVATE</span><br><span class="line">                                 targetId:selectArray[j]</span><br><span class="line">                                  content:inviteMsg</span><br><span class="line">                              pushContent:nil</span><br><span class="line">                                 pushData:nil</span><br><span class="line">                                  success:^(long messageId) &#123;&#125;</span><br><span class="line">                                    error:^(RCErrorCode nErrorCode, long messageId)&#123;&#125;]</span><br></pre></td></tr></table></figure><p>对于文字，图片和自定义的消息的cell都可以重写，文字继承自RCTextMessageCell，语音继承自RCVoiceMessageCell，图片继承自RCImageMessageCell，其他自定义邀请好友进入群聊的cell继承自RCMessageCell或者是它的父类RCMessageBaseCell，在方法中实现<br><code>- (void)setDataModel:(RCMessageModel *)model</code>来设置自己想要的属性的样式.</p><h3 id="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"><a href="#进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库" class="headerlink" title="进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库"></a>进入会话页面要从服务器获取用户或是群组的信息并更新本地数据库</h3><p>这样做的目的就是：用户换了头像或者是昵称以后，在会话页面可以更新用户的数据，</p><h3 id="自定义Cell的点击"><a href="#自定义Cell的点击" class="headerlink" title="自定义Cell的点击"></a>自定义Cell的点击</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>didTapMessageCell:<span class="params">(RCMessageModel *)</span>model</span><br></pre></td></tr></table></figure><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><p>就像上面的会话列表里面的评论和回复一样，只要在这个的地方，调用自己服务端在融云基础上开发的接口，就能把Model传过去，把需要发送的数据放在一个字典里面，然后jsonStringWithObject把字典转换成JSON字符串</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>1.修改聊天气泡以及一些图标<br>直接把要替换的图片替换RongCloud.bundle文件中的图片即可。</p><p>2.当融云SDK和BlocksKit被引入到同一工程，通过融云的聊天UI界面去选择照片、拍摄照片并发送时，无法正常选择和发送。<br>问题的本质：</p><p>UIImagePickerController代理中的方法冲突了，导致融云SDK中选择并发送照片的功能失效。</p><p>解决方法：</p><p>BlocksKit是开源方法，直接编辑UIImagePickerController+BlocksKit.m文件，注释红框部分，问题便可解决。<img src="http://rongcloud-web.qiniudn.com/39ef2374b74fb20691d28a5b6b9824d1" alt></p><p>3.//点击消息发送失败红点的回调<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="keyword">didTapmessageFailedStatusViewForResend:(RCMessageModel </span>*)model&#123;</span><br><span class="line">     RCMessageContent *resendContent = (RCMessageContent *)model.content<span class="comment">;</span></span><br><span class="line">    AlertShowMoreButtons(@[@<span class="string">"重新发送"</span>], ^(NSString *title, NSInteger moreButtonIndex) &#123;</span><br><span class="line">        if (<span class="keyword">BoolEqualToString(title, </span>@<span class="string">"重新发送"</span>)) &#123;</span><br><span class="line">            [self resendMessage:resendContent]<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目APP中接入IM的功能，有环信和融云的两种选择，在纠结以后，选择了融云进行开发。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>独立开发一个APP</title>
    <link href="http://peilinghui.com/2018/08/04/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAAPP/"/>
    <id>http://peilinghui.com/2018/08/04/独立开发一个APP/</id>
    <published>2018-08-04T07:22:24.000Z</published>
    <updated>2018-10-11T04:02:17.141Z</updated>
    
    <content type="html"><![CDATA[<p>独立开发一个社群APP，类似微博，知识星球，简书这一类的。</p><a id="more"></a><p>首先是整个项目的框架的搭建。</p><h1 id="中间层的路由跳转方案"><a href="#中间层的路由跳转方案" class="headerlink" title="中间层的路由跳转方案"></a>中间层的路由跳转方案</h1><p>抽象出一个中间层来对纷乱的引用关系进行统一的跳转。模块只和中间层耦合，模块间解耦；中间层使用runtime的形式调用模块的业务组件，不依赖具体的模块代码.两种主流方案:</p><ol><li>以<a href="https://github.com/joeldev/JLRoutes" target="_blank" rel="noopener">JLRoutes</a>为代表的URLRoute方案:以URL为key，以待执行的block为value，保存在一个全局map中，在内存中常驻;</li><li>Mediator中间人方案:把所有的调用都集合在一起，使用一个中间人管理。所有调用方都通过中间人调取另外一个模块;</li></ol><ul><li>创建Target-Action。Target对象暴露整个模块对外提供的所有服务，此外，因为Mediator和Target是通过Runtime交互的，Target暴露的方法中接收的参数是一个字典，但在方法实现中负责将传过来的字典还原成各个参数，并调用该模块具体的类和方法。</li><li>创建 CTMediator 的Category. 受限于runtime只能以字典形式传一系列参数，Mediator分类的职责就在于对外提供参数友好型的一系列方法，但在方法实现中包装成字典形式。这里涉及到key的定义必须和Target中还原时的key定义一致，因此划分给相同的开发维护。<br><a href="https://github.com/yehot/YT_TargetAction" target="_blank" rel="noopener">使用方法</a></li></ul><ol start="3"><li><a href="https://github.com/xuzhenhao/ZHMediator" target="_blank" rel="noopener">结合URLRoute和Mediator的跳转方案</a></li></ol><h1 id="整体导航条Navigation"><a href="#整体导航条Navigation" class="headerlink" title="整体导航条Navigation"></a>整体导航条Navigation</h1><p>写自定义的navigationController，主要用于处理问题：</p><ul><li>手势返回的支持和不支持。</li><li>导航栏的显示和隐藏。</li><li>底部tabBar的显示和隐藏。</li></ul><p>在一些页面对于statusBar的处理，设置statusBar的背景颜色和样式</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>在AFN上面封装，包装AFNManager，创建一个单例的HTTPClient继承自AFHTTPSessionManager，在单例中设置securityPolicy、requestSerializer、responseSerializer、和请求头，以及Content-type相关的参数，包装GET、post请求<br>没有判断网络的情况，是WIFI还是4G还是3G，还是无网络的状态</p><h1 id="tableView自适应"><a href="#tableView自适应" class="headerlink" title="tableView自适应"></a>tableView自适应</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>Sunny写的<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a><br>UITableView+FDTemplateLayoutCell</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p><a href="https://github.com/peilinghui/SDAutoLayout" target="_blank" rel="noopener">SDAutoLayout</a><br>不仅可以实现tableview和cell高度自适应，还可以实现普通view的自动布局，比用masonry代码更少，</p><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>在每个元素的模型model中添加一个height属性，实现它的get方法，在get方法中计算需要多行显示文字的高度，然后再加上其他乱七八糟的高度并返回，然后在tableview的 </p><ul><li>(CGFloat)tableView:(UITableView )tableView heightForRowAtIndexPath:(NSIndexPath )indexPath中获取到每行对应的model，取出其中的model.height属性的值返回，还要在cell中确定cell中label的高度。。。总之就是很麻烦，而且还不一定总能算的很正确，甚是受此困扰。</li></ul><p>只要你懂一定的Autolayout知识的话，原来实现这种的cell高度自适应，其实是灰常灰常简单的：<br>首先，第一步，现在自定义的cell中将高度随着内容动态改变的label的布局使用autolayout布局完成，这里有个注意点就是label和cell边界的距离要确定好，不能固定死label的高度，然后设置label的numberOfLines=0，行数设置为0即意味着label可以有任意行。<br>其次，实现以下两个tableview的delegate中的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UITableViewAutomaticDimension</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是的，只要实现这两个方法，然后运行你的项目，你会惊讶的发现，哇塞，高度完美自适应…<br>这里有几个关键点：<br>关键点1：必须重写estimatedHeightForRowAtIndexPath方法<br>这个方法是iOS7.0之后才出现的，如果不重写此方法，仅重写heightForRowAtIndexPath，那么大家会发现，cell并不会根据label的内容，自适应高度。因为系统是先获取cell的高度，再获取cell的view。也就是先调用heightForRowAtIndexPath，再调用cellForRowAtIndexPath。在cellForRowAtIndexPath被调用之前，你的label是没有被设置文本内容的，因此它获取到的高度，并不是你想要的。那么我们必须想办法让系统在获取了cell之后，再获取cell的高度。方法就是，重写estimatedHeightForRowAtIndexPath，顾名思义，它会返回一个估计高度，有了这个方法后，tableview会先调用它获取估计高度，然后获取cell，最后获取真实高度。estimatedHeightForRowAtIndexPath的返回值可以随意，返回多少都可以，只是给tableview一个安慰而已，让它延迟获取真实的高度。<br>关键点2：真实高度返回值为<br>UITableViewAutomaticDimension<br>关键点3：cell中的元素，必须相对于cell的顶部和底部布局，这样在元素中的内容动态变化的时候，才能撑开cell</p><h2 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h2><p>ASDK：AsyncDisplayKit.相关连接：<br><a href="https://draveness.me/asdk-rendering" target="_blank" rel="noopener">使用 ASDK 性能调优 - 提升 iOS 界面的渲染性能</a></p><p><a href="https://www.cnblogs.com/ludashi/p/5895725.html" target="_blank" rel="noopener">iOS开发之多种Cell高度自适应实现方案的UI流畅度分析</a></p><h2 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h2><p><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><p>YYKit的</p><h1 id="整体的方法"><a href="#整体的方法" class="headerlink" title="整体的方法"></a>整体的方法</h1><p>页面布局：masonry自动布局<br>页面的网络解析：YYModel<br>页面的网络请求：</p><p>各个模块需要注意的问题：</p><h1 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h1><p>第一次登录和再次登录</p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>图片压缩</p><h1 id="弹框处理"><a href="#弹框处理" class="headerlink" title="弹框处理"></a>弹框处理</h1><h1 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h1><h1 id="下拉刷新和上拉加载更多"><a href="#下拉刷新和上拉加载更多" class="headerlink" title="下拉刷新和上拉加载更多"></a>下拉刷新和上拉加载更多</h1><h1 id="第三方登录和第三方分享"><a href="#第三方登录和第三方分享" class="headerlink" title="第三方登录和第三方分享"></a>第三方登录和第三方分享</h1><p>第三方分享：</p><ol><li>申请微信APPKey和申请友盟APPkey</li><li>cocospod:    pod ‘UMengUShare/Social/WeChat’</li><li>在APPdelegate中设置APPkey</li></ol><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAppkey</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//友盟</span></span><br><span class="line">    [WXApi <span class="string">registerApp:</span>WXAPPID];</span><br><span class="line">    <span class="comment">//设置友盟appkey</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setUmSocialAppkey:</span>UMKey];</span><br><span class="line">    <span class="comment">//分享到微信</span></span><br><span class="line">    [[UMSocialManager defaultManager] <span class="string">setPlaform:</span>UMSocialPlatformType_WechatSession <span class="string">appKey:</span>APPKEY <span class="string">appSecret:</span>APPSECRET <span class="string">redirectURL:</span>@<span class="string">"www.com"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)<span class="string">application:</span>(UIApplication *)application <span class="string">openURL:</span>(NSURL *)url <span class="string">sourceApplication:</span>(NSString *)sourceApplication <span class="string">annotation:</span>(id)annotation</span><br><span class="line">&#123;</span><br><span class="line">    BOOL result = [UMSocialSnsService <span class="string">handleOpenURL:</span>url];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置Plis跳转的URL。URL Schemes列为白名单</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>LSApplicationQueriesSchemes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>weixin<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>创建分享信息</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建分享消息对象</span></span><br><span class="line"> UMSocialMessageObject *messageObject = [UMSocialMessageObject messageObject];</span><br><span class="line"><span class="built_in">NSString</span> *title = <span class="keyword">self</span>.shareTitle;</span><br><span class="line"><span class="built_in">NSString</span> *url = <span class="keyword">self</span>.originUrl;</span><br><span class="line"><span class="built_in">NSString</span> *text = <span class="keyword">self</span>.shareText;</span><br><span class="line"><span class="built_in">NSString</span> *imgUrl = <span class="keyword">self</span>.shareImage;</span><br><span class="line">UMShareWebpageObject *shareObject = [UMShareWebpageObject shareObjectWithTitle:title descr:text thumImage:imgUrl];</span><br><span class="line">[shareObject setWebpageUrl:url];</span><br><span class="line">messageObject.shareObject = shareObject;</span><br><span class="line">[[UMSocialManager defaultManager] shareToPlatform:UMSocialPlatformType_WechatSession</span><br><span class="line">           messageObject:messageObject</span><br><span class="line">currentViewController:<span class="literal">nil</span></span><br><span class="line">completion:^(<span class="keyword">id</span> data, <span class="built_in">NSError</span> *error) &#123;    </span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">UMSocialLogInfo(<span class="string">@"************Share fail with error %@*********"</span>,error);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;         </span><br><span class="line"><span class="keyword">if</span> ([data isKindOfClass:[UMSocialShareResponse <span class="keyword">class</span>]]) &#123;          </span><br><span class="line">  UMSocialShareResponse *resp = data; UMSocialLogInfo(<span class="string">@"response message is %@"</span>,resp.message);   UMSocialLogInfo(<span class="string">@"response originalResponse data is %@"</span>,resp.originalResponse);&#125;<span class="keyword">else</span>&#123; UMSocialLogInfo(<span class="string">@"response data is %@"</span>,data); &#125;&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h1 id="系统问题"><a href="#系统问题" class="headerlink" title="系统问题"></a>系统问题</h1><p>启动图</p><p>横屏</p><p>推送</p><p>3Dtouch</p><p>屏幕适配</p><h1 id="打包问题"><a href="#打包问题" class="headerlink" title="打包问题"></a>打包问题</h1><p>1。手动打包</p><p>2。自动化打包</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>tableView的流畅：没有网络请求结束的时候先加载占位图，然后<br><a href="https://www.jianshu.com/p/d1e6ae279dd2" target="_blank" rel="noopener">UITableView的优化策略</a><br><a href="https://didee.cn/2018/01/29/iOS-ASDK/" target="_blank" rel="noopener">iOS 开发一定要尝试的 Texture(ASDK)</a><br>UITableView的回调顺序是先多次调用tableView:heightForRowAtIndexPath:以确定 contentSize及Cell的位置,然后才会调用tableView:cellForRowAtIndexPath:,从而来显示在 当前屏幕的Cell。</li></ol><p>UITableView的滚动优化主要在于以下两个方面：</p><p>减少cellForRowAtIndexPath代理中的计算量（cell的内容计算）<br>减少heightForRowAtIndexPath代理中的计算量（cell的高度计算）</p><h3 id="减少cellForRowAtIndexPath代理中的计算量"><a href="#减少cellForRowAtIndexPath代理中的计算量" class="headerlink" title="减少cellForRowAtIndexPath代理中的计算量"></a>减少cellForRowAtIndexPath代理中的计算量</h3><p>首先要提前计算每个cell中需要的一些基本数据，代理调用的时候直接取出；<br>图片要异步加载，加载完成后再根据cell内部UIImageView的引用设置图片；<br>图片数量多时，图片的尺寸要跟据需要提前经过transform矩阵变换压缩好（直接设置图片的contentMode让其自行压缩仍然会影响滚动效率），必要的时候要准备好预览图和高清图，需要时再加载高清图。<br>图片的‘懒加载’方法，即延迟加载，当滚动速度很快时避免频繁请求服务器数据。<br>尽量手动Drawing视图提升流畅性，而不是直接子类化UITableViewCell，然后覆盖drawRect方法，因为cell中不是只有一个contentview。绘制cell不建议使用UIView，建议使用CALayer。原因要参考UIView和CALayer的区别和联系。</p><h3 id="减少heightForRowAtIndexPath代理中的计算量"><a href="#减少heightForRowAtIndexPath代理中的计算量" class="headerlink" title="减少heightForRowAtIndexPath代理中的计算量"></a>减少heightForRowAtIndexPath代理中的计算量</h3><p>由于每次TableView进行update更新都会对每一个cell调用heightForRowAtIndexPath代理取得最新的height，会大大增加计算时间。如果表格的所有cell高度都是固定的，那么去掉heightForRowAtIndexPath代理，直接设置TableView的rowHeight属性为固定的高度；<br>如果高度不固定，应尽量将cell的高度数据计算好并储存起来，代理调用的时候直接取，即将height的计算时间复杂度降到O(1)。例如：在异步请求服务器数据时，提前将cell高度计算好并作为dataSource的一个数据存到数据库供随时取用。</p><h1 id="数据刷新"><a href="#数据刷新" class="headerlink" title="数据刷新"></a>数据刷新</h1><h2 id="tableView的数据刷新"><a href="#tableView的数据刷新" class="headerlink" title="tableView的数据刷新"></a>tableView的数据刷新</h2><p>那就在每个元素的model里面加上一个高度字段，显示的时候如果高度非0，直接拿过来使用，如果是0就自适应计算一下</p><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p><h1 id="把模块拆分成Pod"><a href="#把模块拆分成Pod" class="headerlink" title="把模块拆分成Pod"></a>把模块拆分成Pod</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="UIScrollView的左右滑动与侧滑返回并存"><a href="#UIScrollView的左右滑动与侧滑返回并存" class="headerlink" title="UIScrollView的左右滑动与侧滑返回并存"></a>UIScrollView的左右滑动与侧滑返回并存</h2><p>侧滑返回效果的触发需要满足：(1) 滑动位置在屏幕左边缘;（2）向右滑动;</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 侧滑返回和控件手势冲突的解决方法</span></span><br><span class="line"><span class="comment">//是否支持多手势触发，返回YES，则可以多个手势一起触发方法，返回NO则为互斥.</span></span><br><span class="line"><span class="comment">//是否允许多个手势识别器共同识别，一个控件的手势识别后是否阻断手势识别继续向下传播，默认返回NO；如果为YES，响应者链上层对象触发手势识别后，如果下层对象也添加了手势并成功识别也会继续执行，否则上层对象识别后则不再继续传播</span></span><br><span class="line"><span class="comment">//一句话总结就是此方法返回YES时，手势事件会一直往下传递，不论当前层次是否对该事件进行响应。</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//location_X可自己定义,其代表的是滑动返回距左边的有效长度</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)panBack:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是滑动返回距左边的有效长度</span></span><br><span class="line">    <span class="keyword">int</span> location_X =<span class="number">0.15</span>*IPHONE_W;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gestureRecognizer ==<span class="keyword">self</span>.panGestureRecognizer) &#123;</span><br><span class="line">        <span class="built_in">UIPanGestureRecognizer</span> *pan = (<span class="built_in">UIPanGestureRecognizer</span> *)gestureRecognizer;</span><br><span class="line">        <span class="built_in">CGPoint</span> point = [pan translationInView:<span class="keyword">self</span>];</span><br><span class="line">        <span class="built_in">UIGestureRecognizerState</span> state = gestureRecognizer.state;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIGestureRecognizerStateBegan</span> == state ||<span class="built_in">UIGestureRecognizerStatePossible</span> == state) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> location = [gestureRecognizer locationInView:<span class="keyword">self</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这是允许每张图片都可实现滑动返回</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = location.x;</span><br><span class="line">            <span class="keyword">int</span> temp2 =IPHONE_W;</span><br><span class="line">            <span class="built_in">NSInteger</span> XX = temp1 % temp2;</span><br><span class="line">            <span class="keyword">if</span> (point.x &gt;<span class="number">0</span> &amp;&amp; XX &lt; location_X) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizerShouldBegin:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> panBack:gestureRecognizer]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取系统的UIPanGestureRecognizer的<br>(3) 侧滑手势优先，侧滑手势失效时，才触发UISrcollView的滑动</p><p><a href="https://www.jianshu.com/p/8170fea174da" target="_blank" rel="noopener">https://www.jianshu.com/p/8170fea174da</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;独立开发一个社群APP，类似微博，知识星球，简书这一类的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS底层实现</title>
    <link href="http://peilinghui.com/2018/06/25/iOS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://peilinghui.com/2018/06/25/iOS底层实现/</id>
    <published>2018-06-25T07:07:36.000Z</published>
    <updated>2018-10-14T06:49:21.814Z</updated>
    
    <content type="html"><![CDATA[<p>源于一个面试题。</p><a id="more"></a><p><img src="https://wx3.sinaimg.cn/mw690/51530583ly1fsatleo2zmj213u10caiu.jpg" alt><br>我们知道在Runtime中的swizzling:通过selector来找IMP，可以利用Runtime来实现交换原方法和目标方法的IMP，以完全代替原方法的实现，或为原实现前后相当于加一段额外的代码。</p><p>就是在分类的load方法中，通过class_getClassMethodclass_getInstanceMethod获取类方法和实例方法，然后method_exchangeImplementations(),交换方法实现，或者是其他class_addMethods、class_addIvar、class_addProtocol、class_addProperty来动态的添加方法或者成员变量。还有class_copyIvarList、class_copyMethodList获得某个类所有的成员变量和所有方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span>: <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)methodA;</span><br><span class="line">+ (<span class="keyword">void</span>)methodB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span> (<span class="title">Swizzle</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">Method originalMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(methodA));</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(swizzled_methodA));</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_methodA &#123;</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">self</span> swizzled_methodA];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>AOP的库Aspects 支持多次hook同一个方法，支持从hook返回的id<aspecttoken>对象删除对应的hook，IMP即函数指针。<br>Aspects 的大致原理：替换原方法的IMP为 消息转发函数指针 _objc_msgForward或_objc_msgForward_stret，把原方法IMP添加并对应到SEL aspects_originalSelector，将forwardInvocation:的IMP替换为参数对齐的C函数<strong>ASPECTS_ARE_BEING_CALLED</strong>(NSObject <em>self, SEL selector, NSInvocation </em>invocation)的指针。在<strong>ASPECTS_ARE_BEING_CALLED</strong>函数中，替换invocation的selector为aspects_originalSelector，相当于要发送调用原始方法实现的消息。对于插入位置在前面，替换，后面的多个block，构建新的blockInvocation，从invocation中提取参数，最后通过invokeWithTarget:block来完成依次调用。</aspecttoken></p><h1 id="libffi-简介"><a href="#libffi-简介" class="headerlink" title="libffi 简介"></a>libffi 简介</h1><p>    libffi 可以认为是实现了C语言上的runtime，简单来说，libffi 可根据 参数类型(ffi_type)，参数个数 生成一个 模板(ffi_cif)；可以输入 模板、函数指针 和 参数地址 来直接完成 函数调用(ffi_call)； 模板 也可以生成一个所谓的 闭包(ffi_closure)，并得到指针，当执行到这个地址时，会执行到自定义的void function(ffi_cif <em>cif, void </em>ret, void <strong>args, void <em>userdata)函数，在这里，我们可以获得所有参数的地址(包括返回值)，以及自定义数据userdata。当然，在这个函数里我们可以做一些额外的操作。<br>    <br>    <br>如何hook ObjC方法和实现AOP，思路：我们可以将ffi_closure关联的指针替换原方法的IMP，当对象收到该方法的消息时objc_msgSend(id self, SEL sel, …)，将最终执行自定义函数void ffi_function(ffi_cif </em>cif, void *ret, void </strong>args, void *userdata)。而实现这一切的主要工作是：设计可行的结构，存储类的多个hook信息；根据包含不同参数的方法和切面block，生成包含匹配ffi_type的cif；替换类某个方法的实现为ffi_closure关联的imp，记录hook；在ffi_function里，根据获得的参数，动态调用原始imp和block。</p><h2 id="动态调用C函数"><a href="#动态调用C函数" class="headerlink" title="动态调用C函数"></a>动态调用C函数</h2><p>使用libffi提供接口动态调用流程如下：</p><ol><li>准备好参数数据及其对应ffi_type数组、返回值内存指针、函数指针</li><li>创建与函数特征相匹配的函数原型：ffi_cif对象</li><li>使用“ffi_call”来完成函数调用<br>使用ffi，只要有函数原型cif对象，函数实现指针，返回值内存指针和函数参数数组，我们就可以实现在运行时动态调用任意C函数。</li></ol><p>所以如果想实现其他语言(譬如JS)，执行过程中动态调用C函数，只需在调用过程中加一层转换，将参数及返回值类型转换成libffi对应类型，并封装成函数原型cif对象，准备好参数数据，找到对应函数指针，然后调用即可。</p><h2 id="动态定义C函数"><a href="#动态定义C函数" class="headerlink" title="动态定义C函数"></a>动态定义C函数</h2><p>libffi还有一个特别强大的函数，通过它我们可以将任意参数和返回值类型的函数指针，绑定到一个函数实体上。那么这样我们就可以很方便的实现动态定义一个C函数了！同时这个函数在编写解释器或提供任意函数的包装器(通用block)时非常有用，此函数是：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffi_status ffi_prep_closure_loc (ffi_closure *closure,  <span class="comment">//闭包，一个ffi_closure对象</span></span><br><span class="line">       ffi_cif *cif,  <span class="comment">//函数原型</span></span><br><span class="line">       <span class="keyword">void</span> (*fun) (ffi_cif *cif, <span class="keyword">void</span> *ret, <span class="keyword">void</span> **args, <span class="keyword">void</span>*user_data), <span class="comment">//函数实体</span></span><br><span class="line">       <span class="keyword">void</span> *user_data, <span class="comment">//函数上下文，函数实体实参</span></span><br><span class="line">       <span class="keyword">void</span> *codeloc)   <span class="comment">//函数指针，指向函数实体</span></span><br></pre></td></tr></table></figure><p>通过一个简单的例子，看下如何将一个函数指针绑定到一个函数实体上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ffi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Acts like puts with the file given at time of enclosure. */</span></span><br><span class="line"><span class="comment">// 函数实体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">puts_binding</span><span class="params">(ffi_cif *cif, <span class="keyword">unsigned</span> <span class="keyword">int</span> *ret, <span class="keyword">void</span>* args[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  FILE *stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ret = <span class="built_in">fputs</span>(*(<span class="keyword">char</span> **)args[<span class="number">0</span>], stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ffi_cif cif;</span><br><span class="line">    ffi_type *args[<span class="number">1</span>];</span><br><span class="line">    ffi_closure *closure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*bound_puts)(<span class="keyword">char</span> *);  <span class="comment">//声明一个函数指针</span></span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate closure and bound_puts */</span>  <span class="comment">//创建closure</span></span><br><span class="line">    closure = ffi_closure_alloc(<span class="keyword">sizeof</span>(ffi_closure), &amp;bound_puts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (closure)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Initialize the argument info vectors */</span></span><br><span class="line">        args[<span class="number">0</span>] = &amp;ffi_type_pointer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Initialize the cif */</span>  <span class="comment">//生成函数原型</span></span><br><span class="line">        <span class="keyword">if</span> (ffi_prep_cif(&amp;cif, FFI_DEFAULT_ABI, <span class="number">1</span>,</span><br><span class="line">                         &amp;ffi_type_uint, args) == FFI_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Initialize the closure, setting stream to stdout */</span></span><br><span class="line">            <span class="comment">// 通过 ffi_closure 把 函数原型_cifPtr / 函数实体JPBlockInterpreter / 上下文对象self / 函数指针blockImp 关联起来</span></span><br><span class="line">            <span class="keyword">if</span> (ffi_prep_closure_loc(closure, &amp;cif, puts_binding,</span><br><span class="line">                                     <span class="built_in">stdout</span>, bound_puts) == FFI_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                rc = bound_puts(<span class="string">"Hello World!"</span>);</span><br><span class="line">                <span class="comment">/* rc now holds the result of the call to fputs */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deallocate both closure, and bound_puts */</span></span><br><span class="line">    ffi_closure_free(closure);   <span class="comment">//释放闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述步骤大致分为：</p><ol><li>准备一个函数实体</li><li>声明一个函数指针</li><li>根据函数参数个数/参数及返回值类型生成一个函数原型</li><li>创建一个ffi_closure对象，并用其将函数原型、函数实体、函数上下文、函数指针关联起来</li><li>释放closure</li></ol><p>通过以上这5步，我们就可以在执行过程中将一个函数指针，绑定到一个函数实体上，从而轻而易举的实现动态定义一个C函数。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.assuner.com/%E5%BC%80%E6%BA%90/2018/01/16/Stinger.html" target="_blank" rel="noopener">Hook方法的新姿势–(使用libffi实现AOP )</a></p><p><a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="noopener">如何动态调用 C 函数</a></p><p><a href="http://blog.cnbang.net/tech/3332/" target="_blank" rel="noopener">如何动态创建 block – JPBlock 扩展原理详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源于一个面试题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Effective JavaScript</title>
    <link href="http://peilinghui.com/2018/04/19/Effective-JavaScript/"/>
    <id>http://peilinghui.com/2018/04/19/Effective-JavaScript/</id>
    <published>2018-04-19T00:08:23.000Z</published>
    <updated>2018-07-19T15:05:44.675Z</updated>
    
    <content type="html"><![CDATA[<p>Effective JavaScript</p><a id="more"></a><h1 id="Accustoming-Yourself-to-JavaScript让自己习惯JS"><a href="#Accustoming-Yourself-to-JavaScript让自己习惯JS" class="headerlink" title="Accustoming Yourself to JavaScript让自己习惯JS"></a>Accustoming Yourself to JavaScript让自己习惯JS</h1><h2 id="1-知道你正在使用的JavaScript模式"><a href="#1-知道你正在使用的JavaScript模式" class="headerlink" title="1.知道你正在使用的JavaScript模式"></a>1.知道你正在使用的JavaScript模式</h2><p>是否使用严格模式？只可选择其一或者将其自身包裹在立即调用的函数表达式（IIFE）中连接多个文件。<br>获得最大兼容性： 在严格模式下，并且显式地将代码内容包裹在严格函数中。</p><h2 id="2-注意JavaScript的浮点数"><a href="#2-注意JavaScript的浮点数" class="headerlink" title="2.注意JavaScript的浮点数"></a>2.注意JavaScript的浮点数</h2><p>avaScript的数字都是双精度的浮点数。<br>JavaScript中的整数只是双精度浮点数的一个子集,而不是一个单独的数据类型。<br>位运算符把数字当做32位的有符号整数来处理。<br>注意JavaScript中浮点数的精度陷阱。</p><h2 id="3-当心隐式的强制转换"><a href="#3-当心隐式的强制转换" class="headerlink" title="3.当心隐式的强制转换"></a>3.当心隐式的强制转换</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Effective JavaScript&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React技术栈</title>
    <link href="http://peilinghui.com/2018/02/22/React%E7%9F%A5%E8%AF%86/"/>
    <id>http://peilinghui.com/2018/02/22/React知识/</id>
    <published>2018-02-22T06:26:54.000Z</published>
    <updated>2018-07-19T15:15:21.074Z</updated>
    
    <content type="html"><![CDATA[<p>主要是对阅读深入React技术栈的总结和实践。</p><a id="more"></a><p><a href="https://facebook.github.io/react/" target="_blank" rel="noopener">官网</a><br><a href="https://github.com/facebook/react" target="_blank" rel="noopener">github地址</a></p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>React基于Viral DOM实现了一个Synthetic（合成事件）层，使用stopPropagation()和preventDefault()来中断它。<br>所有事件都自动绑定到最外层，如果要访问原生事件对象，可以使用nativeEvent属性。</p><p>一、 合成事件的实现机制</p><ol><li>事件委派：把所有事件绑定到结构最外层，使用同一的事件监听器–映射所有组件内部的事件监听和处理函数。</li><li>自动绑定：手动绑定this为当前组件的方法：<ul><li>bind方法：使用::this.handleClick等同于this.handleClick.bind(this)</li><li>构造器内绑定声明，在constructor中完成</li><li>箭头函数</li></ul></li></ol><p>二、 使用原生事件<br>在ComponentDidMount中<br>this.refs.button.addEventListener(‘click’,e=&gt;{<br>    hanldeCliick(e);<br>});<br>在ComponentWillUnMount中移除<br>this.refs.button.removeEventListener(‘click’);</p><p>三、 合成事件和原生事件混用<br>比如在web页面添加移动设备扫描二维码的功能。</p><ol><li>不要把合成事件和原生事件混用</li><li>通过e.target判断来避免</li></ol><p>四、 对比React合成事件和JS的原生事件</p><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>一、 父组件向子组件通信<br>通过props</p><p>二、 子组件向父组件通信</p><ol><li>利用回调函数：this.props的function的回调</li><li>利用自定义事件机制</li></ol><p>三、 跨级组件通信<br>子组件跨级访问信息，使用context实现跨级父子组件间的通信。<br>在父组件中定义了ChildContext，在子组件中使用this.context从而调用。<br>一般只有在全局比如：界面主题、用户信息才会使用。总体原则：使用它，可以写成高阶组件。</p><p>四、 没有嵌套关系的组件通信<br>通过一个单例的EventEmitter，然后把这个实例输出到各组件中使用。</p><p>import {EventEmitter} from ‘event’;<br>export default new EventEmitter();</p><p>import emitter from ‘./events’;</p><p>在APP的类中的ComponentDidMount中emmit</p><h2 id="组件间抽象"><a href="#组件间抽象" class="headerlink" title="组件间抽象"></a>组件间抽象</h2><p>mixin和高阶组件<br>mixin:创造一种类似多重继承的效果，组合。</p><h1 id="Flux架构"><a href="#Flux架构" class="headerlink" title="Flux架构"></a>Flux架构</h1><p>不是MVC的架构，Flux三大部分组成：1. dispatcher、store、view。dispatcher负责分发事件，store负责保存数据、view负责订阅store中的数据，并使用这些数据渲染相应的页面。</p><p><strong>与MVC的主要区别：</strong><br>没有职责明确的Controller，存在一个Controller-view的角色，将view和store进行绑定，并没有Controller需要承担的复杂的逻辑。</p><ol><li><strong>dispatcher与action</strong><br>dispatcher的实现就是下面两个API:</li></ol><blockquote><p>.register(callback)方法用来注册一个监听器。<br>.dispatch(action)用来分发一个action。</p></blockquote><p>action是一个普通的JavaScript对象，一般包含type、payload字段，用于描述一个事件以及需要改变的相关数据。</p><ol start="2"><li><p><strong>store</strong><br>负责保存数据，并且修改数据的逻辑，调用dispatcher的register(callback)方法将自己注册为一个监听器。<br>当.dispatch(action)用来分发一个action时，store注册的监听器就会被调用，同时得到这个action作为参数。store之暴露getter不暴露setter，只能读取不能修改。</p></li><li><p><strong>Controller-view</strong><br>最顶层view，主要进行store与React组件(view层)之间的数据的绑定，定义数据更新以及传递的方式。会调用store保留的getter获取存储其中的数据并设置为自己的state，在render时以props的形式传给自己的子组件。</p></li><li><p><strong>view</strong><br>React组件扮演。结合Angular、Vue来发挥Flux的能力。<br>一条特殊的约定：<strong>Flux的view不能直接修改数据，如果页面操作需要修改数据，则必须使用dispatcher分发一个action。</strong></p></li></ol><ol start="5"><li><strong>actionCreator</strong><br>用来创造action的。为什么需要？因为在分发action的时候代码是冗余的。</li></ol><h1 id="Redux架构"><a href="#Redux架构" class="headerlink" title="Redux架构"></a>Redux架构</h1><h2 id="Redux简介"><a href="#Redux简介" class="headerlink" title="Redux简介"></a>Redux简介</h2><p>Redux的核心代码是一个库，类似Flux的架构思想，</p><h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><ol><li><p>单一数据源<br>一个应用永远只有唯一的一个数据源，整个应用状态都保存在一个对象中。</p></li><li><p>状态是只读的</p></li></ol><p>Flux中store没有setter只有getter，而Redux中没有store，只有reducer，根据当前触发的action对当前应用state进行迭代。</p><ol start="3"><li>状态修改均由纯函数完成</li></ol><p>Redux与Flux最大的不同。<br>在Flux中，我们在actionCreator里调用APPDispatcher.dispatch方法来触发action，直接修改了store中数据.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要是对阅读深入React技术栈的总结和实践。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://peilinghui.com/2018/01/05/2017%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2018/01/05/2017年总结/</id>
    <published>2018-01-05T13:23:18.000Z</published>
    <updated>2018-02-07T15:52:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>终于有时间写一下年终总结和新年展望了。我们总是忙着走路，却忘了当初出发的目的。勿忘初心，方得始终。</p><a id="more"></a><p>2017年过的可真快，还依稀记得16年写下的宏伟大志，但是随着被现实一点点的打磨，似乎都忘了我们最初的梦想。</p><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>先说一下工作，我从2017年的春节前辞职了上家公司，还是裸辞，年后到了学校就想一定要找BAT的实习，然后刚来学校不久就有了阿里内推的机会，然后我就投了，结果没过几天就打来电话了，那是二月上旬，然后顿时很受打击，感觉自己16年的大半年的工作里没有干过什么有价值的东西，然后开始了复习的计划，把剑指offer看了一遍，把题刷了一点，然后开始复习iOS的基础，就把effective-objectiveC和Objective-c的高级编程那本书，还看了图解HTTP，编程珠玑没看完，还有王道的那本程序员求职宝典，然后觉得C++可能也是要看一下，于是买了C++primerPlus(看了前面的一点)和effectiveC++（没看），复习了大概一个月，就开始投简历了，然后是腾讯电话面试，是QQ空间的面试官，那是3月中下旬了，腾讯面试官很认真，问了我很多iOS基础的东西都有答上来，但是C++的东西，完全都没答上来，无非是一些简单的常用的多态，继承还有虚函数，以前考研的时候有复习过，但是基本忘的差不多了，于是就面试官开始给我讲了问题，最后说了可以好好复习一下以后还有机会，第二天的中午面试官还发短信说我有个问题说错了给我指出来了，顿时感觉面试官好认真，相比之下，阿里面试官就感觉没辣么认真和你讲了。然后投了网易，网易笔试，美团也投了，然后也笔试了，然后投了华为，面试了一下，可是我觉得自己做iOS，去华为干嘛。然后投了唯品会，电话面试了一次过了，让去上海再面试一下，当时候只要有机会就开始投各大公司了，投了百度，链家，还有蜻蜓，然后去上海面试了唯品会，然后就去了北京，去了传说中的中关村，见了很多研究生的同学，两个在百度，一个在美团，然后面试了美团和百度和链家还有蜻蜓，总结：自己代码敲得不够，练手练得太少了，功夫下的不够深，基础不够扎实，iOS竞争太强了，去面试百度，面试官直接说才看我的简历，不知道到今天面试了多少个人了。最后只招一个。尴尬。然后回了趟天津，本科天津读书，回天津见了大学的好朋友，然后回本科学校看了看，遇到了很多很多本科读研的同学，聊了聊吃吃饭逛逛街，刚好清明节就回家了一趟，然后又回杭州面试了网易，但是我投的测试。。感觉自己投错了。。面试官问为什么想从开发转测试。。我顿时语塞。然后唯品会通知了就4月下旬就去上海入职了。然后就开始了从4月底到9月底在唯品会工作。工作上开始从iOS原生开发转向了RN开发。9月底离职。10月初回杭州了，差不多校招都接近尾声了。就开始投了几家公司校招和社招一起投，阿里电面了一次，挖财面试了一下，还有机会面APPLE来着，全英文面试，有点虚就没面上，面试酷家乐没去额，然后上海美团大众点评还打了两次电话让我去上海面试，但是我那个时候已经入职了杭州的一家公司了就是现在的公司涂鸦，也是继续开发React-Native，并且是做智能家居的，感觉很有趣。前景也看好。</p><h2 id="感触："><a href="#感触：" class="headerlink" title="感触："></a>感触：</h2><p>找工作就是持久战，心理和身体的坚持，感觉自己好像干了很多，但是回想又没有学到什么，尤其在第一家公司的时候，感觉自己做了一年iOS都没有完整的自己写过一个APP，真是惭愧。然后求职过程中开始总结以前工作的东西，发现自己只是在一味的加班，做代码的搬运工，其实并没有树立自己的品牌，就像现在的自媒体都在树立的自己的品牌。一直的加班让人感到疲惫，而你如果不自己再抽时间学习的话就会被淘汰，正如iOS当初年初的时候多少人说找不到工作一样。然后到了上海开始做原生也是在别人代码上再开发的，然后也是感谢领导，没有安卓，就让我开始重构那个供应商的一个APP，于是就开始边学RN边写，大概花了两个月左右，终于从0到1做出了一个自己完整做的APP，也算实现了自己的一个小目标了，也对RN有所了解了。在新公司也可以继续学习RN这块，然后有空的话开始扩展前端的领域。</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>除了面试的几本书，还有就是JavaScript高级程序设计（看完了，但是好多东西还没理解清楚），React-Native入门与实践，Linux私房菜基础学习。还有一些杂书，将来的你一定会感谢现在拼命的自己，还有leanIn还有优秀的人都敢于对自己下狠手，天才在左，疯子在右(没看完),无非是一些打鸡血的书，偶尔喝喝鸡汤。还考了一次六级。还写了开题报告。写了论文。也感觉到毕业快临近了。<br>鼓励我学习的动力就是软院的厉害的小伙伴，都是拿到大SPoffer，各种奖学金，还认识了好多比我年纪小还比我厉害好多的人，认识这些牛人的方式就是通过他们的个人博客，有个女生才大三，PAT刷分超高，代码什么都很强，算了，直接上博客：<a href="https://www.liuchuo.net" target="_blank" rel="noopener">https://www.liuchuo.net</a>,还有一些94，95，96年的都很厉害额。感觉就是比你小还比你厉害，比你厉害的人还比你努力，就是这种。。感觉大家都不仅会iOS还一直在往各个方向发展，比如学习Docker还有swift还有一些weex还有一个直接转JAVA了。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>生活上感觉在学校的时候就是和同学舍友很多，大家一起，不会无聊，很好玩，一起学习，一起鼓励，挺好的。<br>在上海的时候就是合租，三室一厅的，舍友都很好，然后有一段时间自己看到自律的文章，然后就开始早上6点半起，晚上11点半睡觉，坚持了一个半月，还学会了自己做饭，那段时间还在网上买了RN的视频和书，感觉效率很高呐，基本就是早起做饭偶尔跑步，然后洗澡，上班，然后下班也早，回家做饭，然后学习，看视频，写代码，那段时间还听怀念的，然后周末还双休，基本上周日还可以和一些教会的朋友聚一起，在上海认识了很多的朋友，感觉那段时间还挺好的。<br>之后回学校了就起晚了，睡得也迟了很多。都在12点以后睡了。早上8点多起。但是办了健身卡，坚持游泳了一个月，也差不多学会游泳了，就是50米的泳道要停一次，哈哈，也是因为一次在忽然感觉胸口很疼，就去办了健身卡在公司旁边，争取每周能去一次，偶尔还和公司的同事一起打球。至于恋爱方面额。。。我就不说了。。哈哈哈</p><p>自己都快忘了这一年去过哪里了。还好朋友圈帮你记得那些小事。去年还去过深圳和香港还有厦门鼓浪屿玩过。今年去了北京面试见了很多同学去故宫玩了下还，然后去上海工作逛了好多地方。去了ChinaJoy。大部分都是动漫游戏还有一些高科技。还有公司两次团建，一次去了苏州，一次去了南通。住的都是豪华酒店。还部门团建了几次。在上海还逛了各种的商场，不得不说上海真的是魔都呐，几步就是一个商场。各种活动都有，去听了一次简单生活音乐节。反正只要你感兴趣的，上海都能满足你。就是花费有点大。攒不下钱。后来回杭州听了一次杰伦演唱会。也算满足了我一个小目标。毕竟去唯品会就是因为自己在上面经常剁手好多。并且特别喜欢杰伦。<br>总的来说这一年的生活还是丰富多彩而且还是充实的。<br>在8月份的时候我又洗礼了一次。心里的洗礼就算是再次受洗了。就是一名基督徒。希望以后的生活神都能继续带领帮助我，赐我智慧。  </p><h1 id="新的一年的规划"><a href="#新的一年的规划" class="headerlink" title="新的一年的规划"></a>新的一年的规划</h1><ol><li>新的一年就快要毕业了，把论文再改一下，毕业。</li><li>学习上能够开始更加深入的学习JavaScript因为感觉自己JavaScript基础还是不行额。。</li><li>还对Python有了兴趣，都说Python大法好，脚本跑的溜，尤其是最近比较火的微信跳一跳，跑的都说Python的脚本，对于自动化测试APP，还有机器学习也用到了Python，恩，学起来。</li><li>多读几本书把，希望能多多点书，扩展一下视野和软技能，还有心理学还有理财方面的书希望能多读点。能及时的调节自己的心态和与人相处。提高一下自己的情商。</li><li>对于股票还有区块链希望也能有所了解了再下水。</li><li>有时间还是要研究一下一些源码，争取能写出来写东西，可以有东西开源在GitHUB上。这是很大的目标。。感觉写iOS框架的那些人一定是读了很多的书，看过很多的源码和写过很多的源码。</li><li>提高学习效率，提高工作效率，节省下来时间可以出去旅游，健身，游泳。</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>真正的年终获取只有在年终奖评定的时候你才意识到，年终奖既是对你工作的考核也是对你工作的鼓励。</p><p>一些启示：不要想着薪资多少，赚多少钱，你必须全身心的把你的工作做好。如何才能把你的工作做好呢？</p><ol><li>多接一些重大的任务和需求，并且强迫自己去完成，在唯品会的时候就是没人指导我，但是要我开始做RN，我真的什么都不会，然后去学习，然后自己思考就完成了一个初步的作品。有压力才能有动力，你不能让自己呆在一个舒适的区域。或者是你熟悉的区域，这样你不会进步，甚至在退步。</li><li>有的时候要是自己的心思不在工作上，或者是我有段时间就在忙论文，心思完全不能投入到工作上，自然工作上有很多东西都没能做好，因此年终奖也没拿到。</li><li>毕业的前三年是你拼搏奋斗的最佳时期。一定要把握住这段时间，如果是单身的话，尤其要专心在学习上，虽然走出了学校，学校只能带给你的是继续学习的习惯和持续学习不断思考的能力的培养，学校的一草一米你都带不走。</li><li>虽然是在工作也时常要有危机感，要多学习总结面试题，并且在写业务或者是做业务的时候要多思考。</li><li>社会上的人，虽然就算在同一个地方工作，也是处在不同的位置上的，这个位置可能是因为一个是老板，一个是员工，也可能是不同年限的员工，但是不要被这些束缚了你的思想，能束缚你思想限制你发展的只有你自己，你要相信只要努力从打工者也能变成老板，你要相信过去的已经成为了过去，未来才是你更应该把握的。你要相信不论你是处在社会的哪里，竞争和压力从来没有减少。不进步就代表着后退，落后就会被淘汰。6.刚工作的时候不要把薪资看的太重，不然人会变得容易浮躁，你不能真正的投入到工作中去。<br>7。那些真正创业成功或者创办大企业的人，比如BAT的CEO把，他们创业的初期绝对不是想着要赚多少钱，而是想要真正的去做一些事，想去实现自己的想做的事情，想去完成的事情，就是这种执着和坚持铸就了他们的成功。而作为一个打工的人，你不要想着自己的打工者，当你有主人翁的心态，当你真正的想去实现自己的价值，想去实现一些东西的时候，你才能够真正的去做一些事情，钱只是随之而来的东西，而不是你费劲心机获得的。<br>8.就像我有一段时间特别的想在股票中赚钱，但是我始终都没有入市，我发现在股票大涨的12月底1月份，我买的几只股票并没有赚很多，反而花费了我很多的精力。然后股票开始大跌了。尴尬。投资这个东西，没钱怎么投资。没有头脑怎么投资。不然都是被割韭菜额。<br>9.大公司和小公司的区别：大公司不论做什么事情都会有很多的流程，然后很多的审批，很多时候你需要做好你的一部分就好了。就算你真的做出来什么东西了。你报告给你的上级基本你有什么功劳领导也不会知道。但是你在小公司只要你全身心的投入工作，基本大家都能看的见，老板也看得见，如果你真的做的好有能力的话晋升很快的。<br>不论是在大公司还是小公司，是金子总会发光的，但是如果不论在哪里，如果你松懈了自己，懒惰了懈怠了，不进步了，不继续学习输入自己，你就会发现自己的能力赶不上自己的工作的要求，或者是你的认知赶不上社会公司或者是技术的发展，你就很容易被淘汰，曾经在学校的时候，我觉得竞争很大，大家都会为了成绩或者是奖学金或者是一些荣誉去竞争或者是觉得压力大，或者是看到周围的同学都很优秀，自己的压力很大，研究生那会儿大家都特别特别的拼命的努力，我感觉自己比起他们的努力还差的很多。到了社会上你更会发现压力和竞争从来就没有减少过，减少的只是你自己的观点和自己的懈怠。基本上你的思想或者是语言或者是行为很容易的表现在工作上，如果你对公司的态度一天天的不好，那你的一些怨言和情绪就会一天天的增多，累计下来就会爆发到离职，就像是夫妻相处有什么问题不及时解决的话，慢慢日积月累很容易爆发的。所以，不论你在哪里，最重要的就是说积极向上的话，你需要不断的告诉自己你所在的公司很厉害很好很棒，告诉自己，自己很棒很厉害，可以完成很多艰巨的任务。只有这样你的工作的热情才能不断的上涨。你的工作的动力才有，你也才能更好的为公司服务，也才能更好的做好自己的工作。</li></ol><p>还有一些值得我去的学习的同学和老师的博客：</p><p>雷雷老师：<a href="http://www.liqilei.com/" target="_blank" rel="noopener">http://www.liqilei.com/</a><br>小苾：<a href="http://bealin.github.io/" target="_blank" rel="noopener">http://bealin.github.io/</a><br>峰神: <a href="http://blog.csdn.net/chenyufeng1991" target="_blank" rel="noopener">http://blog.csdn.net/chenyufeng1991</a><br>松神： <a href="http://lysongzi.com/" target="_blank" rel="noopener">http://lysongzi.com/</a><br>李克西：<a href="http://www.krselee.com/" target="_blank" rel="noopener">http://www.krselee.com/</a><br>bestswifter：<a href="https://bestswifter.com/" target="_blank" rel="noopener">https://bestswifter.com/</a><br>冬瓜：<a href="http://www.desgard.com/" target="_blank" rel="noopener">http://www.desgard.com/</a><br>方春：<a href="https://www.jonyfang.com/" target="_blank" rel="noopener">https://www.jonyfang.com/</a><br>冰霜：<a href="https://www.halfrost.com/" target="_blank" rel="noopener">https://www.halfrost.com/</a><br>Joy___: <a href="https://www.jianshu.com/u/9c51a213b02e" target="_blank" rel="noopener">https://www.jianshu.com/u/9c51a213b02e</a><br>Jim ：<a href="http://kuailejim.com/" target="_blank" rel="noopener">http://kuailejim.com/</a><br>draveness: <a href="https://draveness.me" target="_blank" rel="noopener">https://draveness.me</a></p><p>还有最近比较火的区块链，可以去看看李笑来的一些书和公众号：<a href="http://zhibimo.com/read/xiaolai/reborn-every-7-years/Preface.html" target="_blank" rel="noopener">http://zhibimo.com/read/xiaolai/reborn-every-7-years/Preface.html</a></p><p>最后一句：读万卷书不如行万里路，行万里路不如阅人无数，阅人无数不如跟着成功人的脚步。希望我也能更紧成功人的脚步，早日脱贫脱单。哈哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于有时间写一下年终总结和新年展望了。我们总是忙着走路，却忘了当初出发的目的。勿忘初心，方得始终。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative中使用Redux</title>
    <link href="http://peilinghui.com/2017/12/12/ReactNative%E4%B8%AD%E4%BD%BF%E7%94%A8Redux/"/>
    <id>http://peilinghui.com/2017/12/12/ReactNative中使用Redux/</id>
    <published>2017-12-12T15:14:35.000Z</published>
    <updated>2017-12-13T14:33:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Redux也有一段时间了。总结一下。</p><a id="more"></a><p>为什么要使用Redux?<br>背景：</p><ol><li>RN的state（可变，子组件不可见）和props（不可变，子组件可见）的设计，在面对大型项目时候，容易因为不经意修改state造成状态混乱，组件渲染错误</li><li>RN使用了Virtual DOM，不需要Target绑定-&gt;Action修改UI属性，只要当状态变化，render新状态下的组件，数据单向传递，而MVC的设计模式存在双向数据流。</li><li>RN不易进行测试，Redux提供了非常方便的mock测试方式。</li></ol><h1 id="Redux开发"><a href="#Redux开发" class="headerlink" title="Redux开发"></a>Redux开发</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>安装Redux：  ‘npm install –save redux’<br>安装React Native和Redux绑定库：npm install –save react-redux<br>安装Redux Thunk异步Action中间件：npm install –save redux-thunk</p><h2 id="三个原则"><a href="#三个原则" class="headerlink" title="三个原则"></a>三个原则</h2><ul><li>单一数据源<br>  整个应用的 state 被储存在一个对象树中，对象树存在于唯一的 store 中。store中的 state 绑定到组件</li><li>State 是只读的<br>  惟一改变 state 的方法就是触发 action。action 是一个含有 type 属性的普通JS对象，type 可以用常量表示事件。</li><li>使用纯函数来执行修改<br>  编写 reducers 来描述对应action如何修改 state 。一般可以用 switch(action.type) 来处理，无副作用<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2>react-redux提供了connect和Provider。</li></ul><ol><li>Provider是顶层的分发点，属性就是Store，将State分发给所有被connect的组件<br>2.connect：接受两个参数：一个是mapStateToProps或者mapDispatchToProps，一个是要绑定的组件本身。</li></ol><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store 就是把 Reducer 和 action 联系到一起的对象。Store 有以下职责：  </p><ul><li>维持应用的 state–类似数据库，存储应用的所有state。</li><li>提供 getState() 方法。获取 所有的当前state；</li><li>提供 dispatch(action) 方法更新 state，相当于存入数据库，存入action来改变state。</li><li>通过 subscribe(listener) 注册监听器。<br>Store本质上是一个对象，它以树的形式保存了整个应用的State。并提供了一些方法。例如getState( ) 和 dispatch( )。<br>Redux应用只有惟一一个Store。<br>Store通过createStore方法来创建，根据整个应用的根Reducer的初始State。<br>代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;<span class="comment">//异步</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span>;</span><br><span class="line"><span class="keyword">const</span> Store = applyMiddleware(thunk)(createStore)(reducers);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Store;</span><br></pre></td></tr></table></figure><h3 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h3><p>Action只是描述了有事情发生了这一事实，并没有指明应用如何更新state。这是reducer要做的事情。  </p><ol><li>Reducer的本质是一个函数，并且是一个纯函数。没有任何副作用。简单来讲Reducer只负责做一件事，就是根据接收到的action和state来修改Store中的state：</li></ol><p>(state, action) =&gt; newState  </p><ol start="2"><li>一般实现的时候，通过switch(action.type) 来判断不同的Action，default为旧state。同时可以定义初始状态。</li><li>代码：</li></ol><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; <span class="keyword">from</span> 'redux';</span><br><span class="line">const newState = (<span class="keyword">state</span> = &#123;&#125;, action = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case ActionTypes.CSTATE:</span><br><span class="line">      return &#123; ...<span class="keyword">state</span>, ...action.<span class="keyword">state</span> &#125;;</span><br><span class="line">    case '_DPDATACHANGE_':</span><br><span class="line">      return &#123;...<span class="keyword">state</span>, ...action.dpState&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      return <span class="keyword">state</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//Reducer 合并</span><br><span class="line">export <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">  newState,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意:返回的是新state，如果需要保留部分旧state值，使用…state（ES7的对象展开语法，对对象会浅拷贝对应属性，这里等价于Object.assign({}, state, newState)），而如果合并state的话只会合并一层，对复杂state需要手动合并。</p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action是一个普通JS对象，至少包括一个type属性代表事件，其他属性可以用来传递数据。实践上对一个流程定义一个函数，流程可以包括网络请求，最后返回Action，这个函数叫Action Creator。<br>代码：Store可以dispatch这个Action，action的type表示标识符，state是它携带的数据。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export const newState = <span class="keyword">state</span> =&gt; &#123;</span><br><span class="line">  Store.dispatch(&#123;</span><br><span class="line">    type: ActionTypes.CSTATE,</span><br><span class="line">    <span class="keyword">state</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p>当触发action时根据其reducer key恢复数据，然后只需要在应用启动时分发action，这也很容易抽象成可配置的拓展服务，实际上三方库redux-persist已经为我们做好了这一切。<br>在Action中可以代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStorage = <span class="keyword">async</span> (key) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="keyword">await</span> AsyncStorage.getItem(key);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(d);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setStorage = <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">  AsyncStorage.setItem(key, <span class="built_in">JSON</span>.stringify(value));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>通过- 提供 getState() 方法。获取 所有的当前state<br>通过connect，绑定需要的state以及Action Creator到你的组件的props上，这样组件就可以通过props来调用Action Creator，或者根据不同props来render()不同的组件。<br>代码：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mapStateToProps(&#123; newState &#125;) &#123;</span><br><span class="line">            const <span class="keyword">value</span> = newState[<span class="keyword">name</span>];//<span class="keyword">name</span>: newState.<span class="keyword">name</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="keyword">name</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://dreampiggy.com/2016/10/26/react-nativezhi-reduxjia-gou-ru-men/" target="_blank" rel="noopener">Redux架构入门</a><br><a href="http://blog.codingplayboy.com/2017/10/31/react-native-app/comment-page-1/#Redux" target="_blank" rel="noopener">React Native App应用架构设计</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Redux也有一段时间了。总结一下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React-Native的APP</title>
    <link href="http://peilinghui.com/2017/09/24/React-Native%E7%9A%84APP/"/>
    <id>http://peilinghui.com/2017/09/24/React-Native的APP/</id>
    <published>2017-09-24T13:34:53.000Z</published>
    <updated>2018-07-18T01:43:49.649Z</updated>
    
    <content type="html"><![CDATA[<p>从7月底到9月底两个月的时间开发了一个React-Native的APP。不得不说，用RN的开发效率还是很快的。就来总结一下历程。</p><a id="more"></a><p>整个项目的逻辑大概就是： </p><ol><li>新建项目，导入项目的图片资源，APP的图标，启动图，ios的启动图在Xcode中直接设置Launch Image和icon，对于安卓的启动图要写代码实现才行。对于项目的图片资源，可以两套系统共用一套图片那就可以放在一个文件夹下，引入的时候用相对路径导入；也可以放在Xcode或者是Android Studio中进行uri:+图片名称导入。</li><li>用上一篇的第三方组件和一些基本组件大概完成了一些页面，完成了登录，手势解锁页，还有主页面的框架和主页面中一些子页面的大体显示。接下来遇到的问题大概有两个：</li></ol><p>第一：如何跳转，把这个页面都串起来，就像一些珠子如何才能串成一串：导航的使用：Navigator已经废弃，就要使用react-naviagtion来导航。</p><p>第二：如何进行数据处理：</p><ol><li>是如何从服务器获取数据.</li><li>是如何把从服务器获取的数据进行持久化存储。</li><li><p>如何在页面间进行参数的传递<br>对于数据的处理也是难点。<br>首先对于网络请求要用fetch，<br>遇到的相关问题：</p></li><li><p>获取设备ID：用第三方库，补充：JS中如何把字符串中的?替换为&amp;:<br><code>var str_replaced = str.replace(/\?/g,&quot;&amp;&quot;);//加g就是替换所有的？号</code></p></li><li>React-Natvie用RSA加密用户的密码:<br><a href="https://github.com/z-hao-wang/react-native-rsa" target="_blank" rel="noopener">react-native-rsa</a></li></ol><p><a href="https://github.com/rzcoder/node-rsa" target="_blank" rel="noopener">node-rsa</a><br>虽然有这些第三方库，但是我并没有用，这个简直搞到我头大，终于搞定了！<br>主要是参照这两个网址：<br><a href="http://www.cnblogs.com/Grart/p/5080228.html" target="_blank" rel="noopener">http://www.cnblogs.com/Grart/p/5080228.html</a></p><p><strong>node-rsa的基础库</strong><a href="http://www-cs-students.stanford.edu/~tjw/jsbn/" target="_blank" rel="noopener">http://www-cs-students.stanford.edu/~tjw/jsbn/</a><br>因为密码需要先用公钥RSA加密，然后在用base64加密，加密以后的字符串传给服务器，服务器那边再先base64解密，然后再用私钥解密。<br>在使用的时候最大的问题就是你要传一个N和E的参数来setPublic，这个问题困扰了我一天之久，终于后端的同学帮我搞定了，Java里面有方法可以根据已有的公钥来逆向出N和E的值，然后再使用下面的那个网页，网页，没错，就是下载下来那个网页，然后就有基本的JS文件了，其实RN就是JS，只怪自己前端不佳，然后把JS文件转化成RN可以用的JS组件库导入直接调用就可以加密成功了！终于加密成功了。感动哭。</p><ol start="3"><li>设置假数据显示一般来说都是容易的，与后台交互就需要用网络请求了。一般是GET和POST请求。POST的请求头：</li></ol><p>一般常见的网络请求：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> login=<span class="function"><span class="keyword">function</span>(<span class="params">data,doSuccess,doError</span>)</span>&#123;</span><br><span class="line">    fetch(<span class="string">'http://'</span>+<span class="built_in">url</span>+<span class="string">'/login'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attribute">method</span>: <span class="string">'POST'</span>,</span><br><span class="line">          <span class="attribute">headers</span>: &#123;</span><br><span class="line">            <span class="string">'Accept'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">            <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attribute">body</span>: <span class="built_in">JSON</span>.stringify(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;<span class="keyword">return</span> response.json();&#125;)</span><br><span class="line">    .then(</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">resData</span>)</span>&#123;</span><br><span class="line">        doSuccess(resData);</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .done();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而我们这个post请求头呢？是下面这样的。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'Content-Type</span><span class="symbol">':</span><span class="symbol">'application/x-www-form-urlencoded</span>'</span><br></pre></td></tr></table></figure><p>一般在post的body中是用：<br>{userName:this.state.userName,passWord:_pwd}这样的JSON传过去，再body: JSON.stringify(data)。。。<br>而我们这个呢？data是拼接起来的，我也是醉了，这我是用Charles发请求后才发现的，也是折腾了半天才明白的。也用postman还有终端httpie发现都可以请求成功，唯独用这个请求不到，后来就拼接了一下，成功了。</p><ol start="4"><li>JSON.stringify(result);和JSON.parse(result)有什么区别啊？<br>用于把JavaScript对象序列化为JSON字符串和把JSON字符串解析为原生JavaScript。<br>JSON.stringify将JavaScript对象转换为JSON文本，并将该JSON文本存储在字符串中。<br>JSON.parse将一串JSON文本转换成Javascript对象。</li></ol><p>当你在fetch请求后 .then((response)=&gt; response.json())的时候就不用解析直接用.取。。。<br>当你在fetch请求后， .then((response) =&gt; response.text())的时候就需要JSON.parse(result);</p><ol start="5"><li><p>初学者最容易犯错误的地方就是this指针了！！我是在导航跳转的时候意识到这个问题的。每个组件都是有props和states的。<br>子组件如何调用父组件：this.props。<br>父组件如何调用子组件：首先用属性ref给子组件取个名字吧，this.refs.名字.getDOMNode().</p></li><li><p>从服务返回的JSON数据的解析，有些需要遍历一下。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> brandata = result.dangqiAnalysisBrandList;</span><br><span class="line"><span class="keyword">let</span> brandeach=brandata.map(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;<span class="keyword">return</span> val[<span class="string">'dangqiAnalysisList'</span>] &#125;);</span><br></pre></td></tr></table></figure><h1 id="安卓打包"><a href="#安卓打包" class="headerlink" title="安卓打包"></a>安卓打包</h1><ol><li>生成一个签名密钥</li></ol><p><code>keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000</code></p><p>最后它会生成一个叫做my-release-key.keystore的密钥库文件</p><ol start="2"><li><p>找到路径/android/app/src/main，并在该目录下新建assets文件夹</p></li><li><p>在工程目录下将index.android.bundle下载并保存到assets资源文件夹中</p></li></ol><p><code>curl -k &quot;http://localhost:8081/index.android.bundle&quot; &gt; android/app/src/main/assets/index.android.bundle</code></p><p>这句命令是重点，如果assets目录中不存在该文件，则打包的apk在执行时显示空白。</p><p>Protocol ‘http not supported or disabled in libcurl</p><p>Windows下安装使用curl命令:<a href="http://jingyan.baidu.com/article/a681b0dec4c67a3b1943467c.html" target="_blank" rel="noopener">http://jingyan.baidu.com/article/a681b0dec4c67a3b1943467c.html</a></p><ol start="4"><li>添加gradle的android keystore配置</li></ol><p>打包的apk在未签名的情况下,在手机中（非root）是不允许安装的</p><p>在build.gradle文件中</p><p>  //签名<br><code>signingConfigs{    release {        storeFile file(&quot;/my-release-key.keystore&quot;)        storePassword &quot;密码&quot;        keyAlias &quot;keyAlias的名字&quot;        keyPassword &quot;密码&quot;    }} buildTypes {    release {        minifyEnabled false        proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;        signingConfig signingConfigs.release //添加这句话引用签名配置    }}</code></p><ol start="5"><li>启用Proguard代码混淆来缩小APK文件的大小</li></ol><p>Proguard是一个Java字节码混淆压缩工具，它可以移除掉React Native Java（和它的依赖库中）中没有被使用到的部分，最终有效的减少APK的大小。</p><p>重要：启用Proguard之后，你必须再次全面地测试你的应用。Proguard有时候需要为你引入的每个原生库做一些额外的配置。参见app/proguard-rules.pro文件。</p><p>def enableProguardInReleaseBuilds = true</p><ol start="6"><li>在/android/目录中执行gradle assembleRelease命令，打包后的文件在 android/app/build/outputs/apk目录中，例如app-release.apk。如果打包碰到问题可以先执行 gradle clean 清理一下。</li></ol><p>一定要注意：在打包的时候要运行起来安卓。<br>安装gradle工具（版本与android\gradle\wrapper下的一致），并配置环境变量，配置GRADLE_HOME到你的gradle根目录当中，然后把%GRADLE_HOME%/bin（linux或mac的是$GRADLE_HOME/bin）加到PATH的环境变量。<br>mac要配置gradle的环境变量的路径</p><p>配置完成之后，运行gradle -v，检查一下是否安装无误</p><ol start="7"><li>将apk发布到各大应用市场（BUILD SUCCESSFUL）</li></ol><h1 id="iOS打包"><a href="#iOS打包" class="headerlink" title="iOS打包"></a>iOS打包</h1><ol><li>在项目的目录下建立bundle文件夹。然后执行如下命令</li></ol><p><code>react-native bundle --entry-file index.ios.js --platform ios --bundle-output ./bundle/main.jsbundle --dev false --assets-dest ./bundle/</code><br>几分钟过后，在 bundle 文件夹里会多出个 assets 文件夹和 main.jsbundle 文件。不然会提示npm install…</p><ol start="2"><li><p>把刚刚得到的 main.jsbundle 和 assets 文件夹添加到项目中， 在 Xcode 中 assets 资源文件夹比较特殊，必须用 Create folder references 的方式添加进去，添加完后是蓝色文件夹图标.</p></li><li><p>修改 AppDelegate.m 文件<br>在XCODE里打开 APPDELEGATE.M 文件，找到代码 JSCODELOCATION = [[RCTBUNDLEURLPROVIDER SHAREDSETTINGS]，在其下方添加以下代码 </p></li></ol><p><code>jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</code><br>注意：代码里的 @”main” 和 @”jsbundle”，与之前生成的文件 main.jsbundle 对应。</p><ol start="4"><li>在XCODE里点击运行，使用模拟器测试APP能否正常运行。</li><li>和在Xcode里面打包原生应用一样的。</li></ol><h1 id="打包遇到的问题"><a href="#打包遇到的问题" class="headerlink" title="打包遇到的问题"></a>打包遇到的问题</h1><h3 id="native-echarts的组件问题-—–真机上面React-echart显示不了吗？白色的。"><a href="#native-echarts的组件问题-—–真机上面React-echart显示不了吗？白色的。" class="headerlink" title="native-echarts的组件问题 —–真机上面React-echart显示不了吗？白色的。"></a>native-echarts的组件问题 —–真机上面React-echart显示不了吗？白色的。</h3><p>主要是因为路径不对。</p><p><strong>Android</strong><br>将node_modules/native-echarts/src/components/Echarts/tpl.html拷贝到assets下需要修改node_modules/native-echarts/src/components/Echarts/index.js<br><strong>IOS</strong><br> 将tpl.html  放置  Xcode项目 下面 然后如下引用,修改源码下面的index.js<br> 为下面的：</p> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="type">WebView</span>, <span class="type">View</span>, <span class="type">StyleSheet</span> &#125; from <span class="symbol">'react</span>-native';</span><br><span class="line"><span class="keyword">import</span> renderChart from './renderChart';</span><br><span class="line"><span class="keyword">import</span> echarts from './echarts.min';</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nextProps.option !== <span class="keyword">this</span>.props.option) &#123;</span><br><span class="line">      <span class="keyword">this</span>.refs.chart.reload();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">View</span> style=&#123;&#123;flex: <span class="number">1</span>, height: <span class="keyword">this</span>.props.height || <span class="number">400</span>,&#125;&#125;&gt;</span><br><span class="line">      </span><br><span class="line">    &#123;<span class="type">Platform</span>.<span class="type">OS</span>===<span class="symbol">'io</span>s'?(</span><br><span class="line">                           &lt;<span class="type">WebView</span></span><br><span class="line">                               ref=<span class="string">"chart"</span></span><br><span class="line">                               scrollEnabled = &#123;<span class="literal">false</span>&#125;</span><br><span class="line">                               injectedJavaScript = &#123;renderChart(<span class="keyword">this</span>.props)&#125;</span><br><span class="line">                               style=&#123;&#123;</span><br><span class="line">                     height: <span class="keyword">this</span>.props.height || <span class="number">400</span>,</span><br><span class="line">                   &#125;&#125;</span><br><span class="line">                               source=&#123;&#123;uri:<span class="symbol">'tpl</span>.html'&#125;&#125;</span><br><span class="line">                           /&gt;</span><br><span class="line">                       ):(</span><br><span class="line">                           &lt;<span class="type">WebView</span></span><br><span class="line">                               ref=<span class="string">"chart"</span></span><br><span class="line">                               scrollEnabled = &#123;<span class="literal">false</span>&#125;</span><br><span class="line">                               injectedJavaScript = &#123;renderChart(<span class="keyword">this</span>.props)&#125;</span><br><span class="line">                               style=&#123;&#123;</span><br><span class="line">                     height: <span class="keyword">this</span>.props.height || <span class="number">400</span>,</span><br><span class="line">                   &#125;&#125;</span><br><span class="line">                               source=&#123;&#123;uri:<span class="symbol">'file</span>:<span class="comment">///android_asset/tpl.html'&#125;&#125;</span></span><br><span class="line">                           /&gt;</span><br><span class="line">                       )&#125;</span><br><span class="line">      &lt;/<span class="type">View</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="真机测试时候发现的问题"><a href="#真机测试时候发现的问题" class="headerlink" title="真机测试时候发现的问题"></a>真机测试时候发现的问题</h1><h3 id="react-navigation的问题："><a href="#react-navigation的问题：" class="headerlink" title="react-navigation的问题："></a>react-navigation的问题：</h3><ol><li><p>ios上面：<br>手势左边滑动就能返回到上一个页面，这样在你不需要返回的时候也返回了。<br>解决方法：<br>gesturesEnabled：是否支持滑动返回收拾，iOS默认支持，安卓默认关闭。设置为false试了一下。<br>参照文章：<a href="https://hans007.github.io/react-native/2017/06/19/react-navigation" target="_blank" rel="noopener">https://hans007.github.io/react-native/2017/06/19/react-navigation</a></p></li><li><p>Android上面：物理返回键的处理。<br>BackAndroid已经废弃了，使用BackHandler，大概思路就是添加监听，<br>之前使用Navigator的时候，可以通过下面的方法实现监听安卓的返回键，但使用了react-navigation后，会很迷茫，不知该怎么监听了。</p></li></ol><p>解决办法：集成Redux咯！集成完Redux，在跳转之后，就能获得路由的length，可以通过length来判断当前页面是第几层。</p><p><strong>Navigator的方法</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      BackAndroid.addEventListener(<span class="string">'hardwareBackPress'</span>, <span class="keyword">this</span>.onBackAndroid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">      BackAndroid.removeEventListener(<span class="string">'hardwareBackPress'</span>, <span class="keyword">this</span>.onBackAndroid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">onBackAndroid = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> nav = <span class="keyword">this</span>.navigator;</span><br><span class="line">    <span class="keyword">const</span> routers = nav.getCurrentRoutes();</span><br><span class="line">    <span class="keyword">if</span> (routers.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      nav.pop();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>react-navigation的方式</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">        BackHandler.addEventListener(<span class="string">'handwareBackPress'</span>,<span class="keyword">this</span>.onBackAndroid)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Platform.OS === <span class="string">'android'</span>) &#123;</span><br><span class="line">        BackHandler.addEventListener(<span class="string">'handwareBackPress'</span>,<span class="keyword">this</span>.onBackAndroid)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">onBackAndroid = () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> routers = nav.getCurrentRoutes();</span><br><span class="line">    <span class="keyword">if</span> (routers.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在跳转之后的页面中</span></span><br><span class="line">onBackAndroid = ()=&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;routes&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    console.log(routes);</span><br><span class="line">    <span class="comment">// alert(routes)</span></span><br><span class="line">    <span class="keyword">if</span> (routes.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 因为其他页面获得不到this.props，所以只能每个页面都写这个方法。</span></span><br><span class="line">        <span class="keyword">this</span>.props.navigation.goBack();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他小问题"><a href="#其他小问题" class="headerlink" title="其他小问题"></a>其他小问题</h3><p> 需要把服务器取过来的数字(也有可能是数字字符串)，将小数点前的数字每隔三位添加一个逗号（前面数是一个四位数的值）。比如取到的值是123456，要将其转换成123,456。搜索了一下，这叫数字分位符号。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代码量：近1万行，调通近40个接口。还有很多方面要优化，比如没有用Redux。还有一些其他方面的逻辑也有待优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从7月底到9月底两个月的时间开发了一个React-Native的APP。不得不说，用RN的开发效率还是很快的。就来总结一下历程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactNative的常用组件</title>
    <link href="http://peilinghui.com/2017/07/27/ReactNative%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
    <id>http://peilinghui.com/2017/07/27/ReactNative的常用组件/</id>
    <published>2017-07-27T02:16:21.000Z</published>
    <updated>2017-08-19T03:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发RN的时候所需用的常用开源组件。</p><a id="more"></a><h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><p>刚开始开发的时候用的是Webstrom或者是Sublime，后来发现一个超级IDE：<br><a href="https://www.decoide.org/docs" target="_blank" rel="noopener">https://www.decoide.org/docs</a>。</p><p>除了官方文档的一些常用组件，还有一些在项目开发中的常用组件。</p><h1 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h1><h2 id="获取设备相关信息"><a href="#获取设备相关信息" class="headerlink" title="获取设备相关信息"></a>获取设备相关信息</h2><p>设备deviceID：<a href="https://github.com/rebeccahughes/react-native-device-info" target="_blank" rel="noopener">react-native-device-info</a></p><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>手势解锁：<a href="https://github.com/spikef/react-native-gesture-password" target="_blank" rel="noopener">gesture-password</a></p><p>上面那个经过测试不好用,用这个：<br><strong>大小手势解锁：</strong><br><a href="https://github.com/react-native-component/react-native-smart-gesture-password" target="_blank" rel="noopener">react-native-smart-gesture-password</a></p><p>Touch id指纹解锁：<a href="https://github.com/naoufal/react-native-touch-id" target="_blank" rel="noopener">touch-id</a></p><p>搜索框：<a href="https://github.com/umhan35/react-native-search-bar" target="_blank" rel="noopener">ios可以用的搜索框</a><br><strong>好看的搜索Box：</strong>：<a href>react-native-search-box</a></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>底部tab组件：<a href="https://github.com/happypancake/react-native-tab-navigator" target="_blank" rel="noopener">react-native-tab-navigator</a></p><p><strong>侧滑栏：</strong><a href="https://github.com/react-native-community/react-native-side-menu" target="_blank" rel="noopener">side-Menu</a></p><p><strong>顶部tab的滑动</strong>：<a href="https://github.com/skv-headless/react-native-scrollable-tab-view" target="_blank" rel="noopener">scrollable-tab-view</a></p><p>提示框toast：<a href="https://github.com/magicismight/react-native-root-toast" target="_blank" rel="noopener">toast</a></p><p>下拉刷新组件 <a href="https://github.com/jsdf/react-native-refreshable-listview" target="_blank" rel="noopener">https://github.com/jsdf/react-native-refreshable-listview</a></p><p>模态框 <a href="https://github.com/brentvatne/react-native-modal" target="_blank" rel="noopener">https://github.com/brentvatne/react-native-modal</a></p><p>react-native-navbar <a href="https://github.com/react-native-fellowship/react-native-navbar" target="_blank" rel="noopener">https://github.com/react-native-fellowship/react-native-navbar</a></p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p><strong>下拉选择菜单：</strong><a href="https://github.com/WheelerLee/react-native-dropdown-menu" target="_blank" rel="noopener">dropdown-menu</a></p><p>折线图，柱状图，条形图：<a href="https://github.com/somonus/react-native-echarts" target="_blank" rel="noopener">react-native-echarts</a></p><h1 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h1><p>发现超好用还好看的日历组件：<a href="https://github.com/xgfe/react-native-datepicker" target="_blank" rel="noopener">datepicker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发RN的时候所需用的常用开源组件。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS应用APP架构</title>
    <link href="http://peilinghui.com/2017/07/14/iOS%E5%BA%94%E7%94%A8APP%E6%9E%B6%E6%9E%84/"/>
    <id>http://peilinghui.com/2017/07/14/iOS应用APP架构/</id>
    <published>2017-07-14T02:54:01.000Z</published>
    <updated>2018-07-25T08:09:54.374Z</updated>
    
    <content type="html"><![CDATA[<p>对于网络层的改造其实就相当于iOS应用的APP的架构了，然后就去查了相关的资料。</p><a id="more"></a><p>发现几篇很好的博文：</p><p><a href="http://www.infoq.com/cn/articles/ios-app-arch-part-01?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="noopener">iOS应用架构谈（一）：架构设计的方法论</a></p><p><a href="http://www.infoq.com/cn/articles/ios-app-arch-2-1?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="noopener">iOS应用架构谈（二）：View层的组织和调用方案（上）</a></p><p><a href="http://www.infoq.com/cn/articles/ios-app-arch-3-1" target="_blank" rel="noopener">iOS应用架构谈（三）：网络层设计方案(上)</a></p><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a></p><p><a href="https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/" target="_blank" rel="noopener">模块化与解耦</a></p><p><a href="https://blog.cnbluebox.com/blog/2015/05/07/architecture-ios-1/" target="_blank" rel="noopener">IOS应用架构思考一（网络层)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于网络层的改造其实就相当于iOS应用的APP的架构了，然后就去查了相关的资料。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络层的封装</title>
    <link href="http://peilinghui.com/2017/07/10/iOS%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://peilinghui.com/2017/07/10/iOS网络层的封装/</id>
    <published>2017-07-10T13:26:39.000Z</published>
    <updated>2017-07-13T09:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于项目的重构，很重要的就是对网络层的重构，其实也就是对AFN的二次封装。对于AFN的介绍在前一篇：<a href>研究AFNetworking框架</a></p><a id="more"></a><p>AFN2.0是基于NSURLConnection封装的。而AFN3.0是基于NSURLSession封装的。(NSURLSession是iOS7推出的是为了取代NSURLConnection的)。</p><h1 id="关于AFN3-0"><a href="#关于AFN3-0" class="headerlink" title="关于AFN3.0"></a>关于AFN3.0</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ol><li>客户端发给服务器的HTTP请求包含了：<br><strong>请求行</strong>：请求方法、请求资源路径、HTTP协议版本号<br>GET /index.htm HTTP/1.1</li></ol><p><strong>请求头：</strong>对客户端环境的描述，客户端请求的主机的地址。<br>HOST: 192.168.1.105：8080<br>User-Agent:MAC或者IPhone （客户端环境）<br>Accept：text/html   (客户端所能接受的数据类型)<br>Accept-Language：zh-cn   （客户端的语言）</p><p>在POST中有<strong>请求体：</strong>客户端发给服务器的具体数据</p><ol start="2"><li>服务器返回给客户端的HTTP响应包含了：（NSHTTPUELResponse）</li></ol><p><strong>状态行：</strong>协议版本、状态码、状态英文名称<br>HTTP/1.1 200 OK</p><p><strong>响应头：</strong>对服务器的描述、对返回数据的描述。<br>Server：Apache             （服务器）<br>Date: Sat,  22:07:00 GMT<br>Content-Length: 500      （返回数据长度）<br>Content-Type: text/html  (返回数据类型)  </p><p><html>…..</html></p><p><strong>实体内容：</strong>服务器返回给客户端的具体数据</p><p><img src="http://upload-images.jianshu.io/upload_images/1436896-f274db501af46b86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-11-07 下午4.44.02.png"></p><ol start="3"><li>GET与POST<br>GET：所有的请求参数都拼接在URL后面，如果访问资源，向服务器索要数据就是GET请求。URL长度有限，不能发送太多数据</li></ol><p>POST：把所有请求参数放在请求体(HTTPBody)中，发给服务器的长度没有限制，<br>200：请求成功。 400：客户端请求的语法错误，服务器无法解析。<br>404：服务器无法根据客户端的请求找到资源。<br>500：服务器内部错误，无法完成请求。</p><p>URL还要注意对中文的转码：<br>方法：<code>urlString = [urlString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</code></p><h3 id="如何使用-NSURLSession-发出-HTTP-请求"><a href="#如何使用-NSURLSession-发出-HTTP-请求" class="headerlink" title="如何使用 NSURLSession 发出 HTTP 请求"></a>如何使用 NSURLSession 发出 HTTP 请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.得到session对象</span></span><br><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://。。。/Server/login"</span>];</span><br><span class="line"><span class="comment">// 创建一个请求</span></span><br><span class="line"> <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line"><span class="comment">// 设置请求体</span></span><br><span class="line">request.HTTPBody = [<span class="string">@"username=123&amp;pwd=123"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">[request setValue:<span class="string">@"iPhone 6"</span> forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> *task = [session dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSData</span> *data, <span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">     <span class="comment">//系统的解析方法</span></span><br><span class="line">     <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="built_in">NSJSONReadingMutableLeaves</span> error:<span class="literal">nil</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"----%@"</span>, dict);</span><br><span class="line">    &#125;];</span><br><span class="line"><span class="comment">// 3.开始任务</span></span><br><span class="line">[task resume];</span><br></pre></td></tr></table></figure><h3 id="如何使用-AFNetworking-发出-HTTP-请求"><a href="#如何使用-AFNetworking-发出-HTTP-请求" class="headerlink" title="如何使用 AFNetworking 发出 HTTP 请求"></a>如何使用 AFNetworking 发出 HTTP 请求</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">manager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">[manager POST:<span class="string">@"http://baidu.com/verification/user/loginNew.htm?token=&amp;random=27289&amp;version=1.19.0"</span> parameters:dict progress:^(<span class="built_in">NSProgress</span> * _Nonnull downloadProgress) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"请求成功"</span>);</span><br><span class="line">&#125;success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">          <span class="comment">//请求返回的数据(二进制数据)</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"responseObject(二进制) = %@"</span>,responseObject);</span><br><span class="line">          <span class="comment">//转化二进制数据</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"responseObject = %@"</span>, [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">         [<span class="keyword">self</span> oaLoginSuccess];</span><br><span class="line">&#125;failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull   error) &#123;</span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,error);  <span class="comment">//这里打印错误信息</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 iOS9 中，苹果默认全局 HTTPs，如果你要发送不安全的 HTTP 请求，需要在 info.plist 中加入如下键值对才能发出不安全的 HTTP 请求.<br>还有一件事情是要注意的是，AFNetworking 默认接收 json 格式的响应（因为这是在 iOS 平台上的框架，一般不需要 text/html），如果想要返回 html，需要设置 acceptableContentTypes</p></blockquote><h3 id="AFN中的相应类"><a href="#AFN中的相应类" class="headerlink" title="AFN中的相应类"></a>AFN中的相应类</h3><h5 id="AFURLSessionManager-核心类"><a href="#AFURLSessionManager-核心类" class="headerlink" title="AFURLSessionManager(核心类)"></a>AFURLSessionManager(核心类)</h5><p>AFURLSessionManager 是 AFHTTPSessionManager 的父类<br>AFURLSessionManager 负责生成 NSURLSession 的实例，管理 AFSecurityPolicy 和 AFNetworkReachabilityManager，来保证请求的安全和查看网络连接情况，它有一个 AFJSONResponseSerializer 的实例来序列化 HTTP 响应</p><h5 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h5><p>其中 AFHTTPSessionManager 有着自己的 AFHTTPRequestSerializer 和 AFJSONResponseSerializer 来管理请求和响应的序列化，同时依赖父类提供的接口保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</p><h5 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h5><p>主要用于 AFHTTPSessionManager 中，因为它主要用于修改 HTTP 头部，提供了一些语义明确的接口设置 HTTP 头部字段。HTTP 头部字段 Accept-Language User-Agent</p><h5 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h5><p>处理响应的模块，将请求返回的数据解析成对应的格式。这个模块使用在 AFURLSessionManager 也就是核心类中</p><h3 id="为什么要对AFN进行二次封装呢？"><a href="#为什么要对AFN进行二次封装呢？" class="headerlink" title="为什么要对AFN进行二次封装呢？"></a>为什么要对AFN进行二次封装呢？</h3><p>上面这种写法可维护性差：主要是因为：</p><ol><li>地址是写死的字符串，对于一个应用来说，网络请求的地址通常是统一而且具有规律的。如果大量的请求都用这种写法，那么想要统一进行修改的话就变得很困难。</li><li>没有统一的请求和响应过滤机制。通常客户端开发当中需要对于请求和响应进行一些处理，例如在请求中加入验证字段（如 Token），以验证请求的合法性。</li><li>对 AFNetworking 产生了强依赖，如果要进行网络库的替换，成本会非常高。  </li></ol><p>随着应用复杂程度的增加，上面这种在控制层直接对网络请求层进行交互的方式，会产生越来越多的问题。因此有必要通过单独的一层把控制层（业务层）和网络请求层隔离开来，这一层我们暂时把它叫做“网络封装层”。</p><h3 id="封装的目标"><a href="#封装的目标" class="headerlink" title="封装的目标"></a>封装的目标</h3><ol><li>监测网络状态</li><li>业务层和网络层分离</li><li>处理环境的变化，开发，测试，预发布，发布</li><li>处理GET、POST、下载、上传的操作</li><li><h2 id="如何封装"><a href="#如何封装" class="headerlink" title="如何封装"></a>如何封装</h2>封装主要是把业务层和网络层分开，此次的封装分为三层：<blockquote><p>第一层：首先，从应用层ViewController获取参数，这个参数传到第二层的业务Service，在回调中利用网络请求返回的responseModel来显示在页面上。<br>第二层：设置一个BaseService，然后+LoginService。BaseService中主要是配置公有的参数。在每个业务层的Service中设置每一个的接口定义。业务层主要是暴露接口的定义，而BaseService中定义了BaseRequestModel来实现发起请求到第三层Client。<br>第三层：这层就是CLient，由ASI或者AFN充当，发起网络请求。这一层最好是个单例，</p></blockquote></li></ol><p>BaseRequestModel中定义了：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PLHRequestModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网络请求参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * serverRoot; <span class="comment">//网络请求的根地址</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * actionPath;<span class="comment">//发起响应的二级地址</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> timeout;  <span class="comment">//时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) PLHHTTPRequestType requestType;  <span class="comment">//网络请求方式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> * serviceName;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *apiVersion;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *parameters; <span class="comment">// 请求参数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) PLHHTTPServiceType serviceType;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>单例的，定义了AFURLSessionManager *sessionManager;生成并且发出网络请求。或者直接继承自AFURLSessionManager</p><h4 id="PLHHTTPRequestSerializer"><a href="#PLHHTTPRequestSerializer" class="headerlink" title="PLHHTTPRequestSerializer"></a>PLHHTTPRequestSerializer</h4><p>单例的，生成AFHTTPRequestSerializer，或者直接继承自AFHTTPRequestSerializer。为的是生成NSURLRequest</p><h4 id="PLHRequestModel"><a href="#PLHRequestModel" class="headerlink" title="PLHRequestModel"></a>PLHRequestModel</h4><h4 id="PLHResponseModel"><a href="#PLHResponseModel" class="headerlink" title="PLHResponseModel"></a>PLHResponseModel</h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://draveness.me/afnetworking1.html" target="_blank" rel="noopener">AFNetworking 概述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于项目的重构，很重要的就是对网络层的重构，其实也就是对AFN的二次封装。对于AFN的介绍在前一篇：&lt;a href&gt;研究AFNetworking框架&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目重构遇到的问题</title>
    <link href="http://peilinghui.com/2017/07/05/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://peilinghui.com/2017/07/05/项目重构遇到的问题/</id>
    <published>2017-07-05T07:12:10.000Z</published>
    <updated>2018-10-14T09:38:11.345Z</updated>
    
    <content type="html"><![CDATA[<p>在项目重构的时候难免会遇到问题。</p><a id="more"></a><p>旧项目的问题：</p><ol><li>使用老式框架 ASI，并且没有做任何封装和抽取； 如果工程是ARC的 第三方文件编译选项加上-fno-objc-arc -O0</li><li>字典转模型用的是Jastor.</li><li>没有使用 Cocoa Pods，所有框架都是拖进去的。</li><li>所有的网络请求只用了两个方法，一个同步一个异步。</li><li>所有的VC都是用的代码写的，布局用的frame，这点还好一点，上家公司一大片storyboard，新加需求能把人逼疯的那种。</li><li>一个VC的数据模型在一个类中。</li><li>代码不规范，没有用固定的前缀，Deployment Target设置为6.0.当你把target设置为8.0的时候，警告暴增，很多的方法以及过期了。</li><li>目录结构：项目中目录结构还算清晰，文件中的目录都没有，一大片.h和.m文件。</li></ol><p>有了上家公司的经验，我有个初步的计划和构想：</p><ol><li>把第三方的库可以把一些替换成Pod管理。</li><li>对于网络层以前用的ASI，如果有新的需求就要用AFN，然后对于AFN进行一些封装，写的网络请求的方法要有successBlock和failureBlock。对于数据转模型用yymodel。</li><li>可以写if debug运行环境的配置代码，来切换测试，预发和正式环境。或者我发现用SwitchHost直接切换环境开发的人比较方便，对于测试的人，就得用Charles或者是fiddler的抓包工具设置代理连到自己的电脑来切换到不同的环境测试。</li><li>打包现在是用Xcode的手工打包可以引入Jenkins来实现自动化打包的模式。这就需要搭建Jenkins服务器和配置到gitlab上面。</li><li>Jenkins也可以结合OCLint实现代码的review。</li><li>使用 fir 和 fastlane 实现 iOS 持续集成。实现iOS应用发布流程的自动化</li><li>对于推送可以使用极光推送还有一些统计崩溃率的第三方工具，还有设置埋点来统计APP的功能。</li><li>对于一些登录还有一些公共组件可以抽取成私有的Pod，然后打tag，以便可以共用。</li><li>对于业务方面就是要把数据和业务分离，对于重复出现的tableview可以写基类，然后再进行扩展。</li><li>对于页面的布局要用masonary框架。</li><li>对于一些第三方的框架和组件旧的逐步替换成新的第三方(一直有人维护和更新)的框架。</li><li>当然最最重要的就是把代码进行完善，然后实现业务需求的继续扩张。</li></ol><p>当然，上面都是我暂时的目标和想法，还有待去实践和一步步的改造。需要足够的耐心和坚持。</p><p>在这期间遇到的一些问题：</p><h1 id="错误1：clang-error-Linker-command-failed-with-exit-code-1"><a href="#错误1：clang-error-Linker-command-failed-with-exit-code-1" class="headerlink" title="错误1：clang error: Linker command failed with exit code 1"></a>错误1：clang error: Linker command failed with exit code 1</h1><h2 id="解决方法：-m文件被重复编译"><a href="#解决方法：-m文件被重复编译" class="headerlink" title="解决方法：.m文件被重复编译"></a>解决方法：.m文件被重复编译</h2><p>好好检查代码，看是不是在.m文件中的引入写成了引入.m文件。<br>看看是不是有新添加的文件跟之前文件同名<br>2，错误信息中出现了某个类的名字，去原文件中看看#import了哪些第三方库，把这些库挨个注释排除，找到出错的那个库，然后按照官方提供的步骤重新添加一遍。</p><h2 id="解决方法：使用Pod管理的时候"><a href="#解决方法：使用Pod管理的时候" class="headerlink" title="解决方法：使用Pod管理的时候"></a>解决方法：使用Pod管理的时候</h2><p>在把引入的第三方库改为Cocoapods管理的时候，遇到Linker command failed。<br>链接文件没有找到CocoaPods中的文件，</p><h3 id="解决方法1："><a href="#解决方法1：" class="headerlink" title="解决方法1："></a>解决方法1：</h3><p>找到 Build settings-&gt;Linking-&gt;Other Linker Flags<br>将此属性修改成-all_load 或者 -ObjC ，这个视情况而定。总之可以多试几次。</p><h3 id="解决方法2："><a href="#解决方法2：" class="headerlink" title="解决方法2："></a>解决方法2：</h3><ol><li>Go to project path and remove Pods folder and Podfile.lock file.</li><li>Reinstall pods again using “pod install” command.</li><li>Open xcworkspace and clean it before running.</li></ol><h3 id="解决方法3："><a href="#解决方法3：" class="headerlink" title="解决方法3："></a>解决方法3：</h3><p>如果添加的是第三方静态库（.a文件）<br>这种情况就可能是这个静态库路径混乱导致的链接错误。解决方法：Build settings-&gt;Search Path-&gt;Library Search Paths 添加静态库的相应路径。</p><h1 id="CocoaPods的相关问题"><a href="#CocoaPods的相关问题" class="headerlink" title="CocoaPods的相关问题"></a>CocoaPods的相关问题</h1><h3 id="pod-install-和-pod-update-的区别："><a href="#pod-install-和-pod-update-的区别：" class="headerlink" title="pod install 和 pod update 的区别："></a>pod install 和 pod update 的区别：</h3><p>使用 pod install，你只会安装 Podfile 中新改变的东西，并且会：优先遵循 Podfile 里指定的版本信息；其次遵循 Podfile.lock 里指定的版本信息来安装对应的依赖库。比如：下面在 Podfile 里没指定 iRate 的版本，但是 Podfile.lock 里指定了 iRate 的版本是 1.11.1，那么即使现在有最新的 1.11.4，最终也会安装 1.11.1。但是如果 Podfile 里指定了 iRate 版本是 1.11.3，那么则会安装 1.11.3，并更新 Podfile.lock 里的信息。</p><p>使用 pod update，你会根据 Podfile 的规则更新所有依赖库，不会理睬现有的 Podfile.lock，而是根据安装依赖库的情况生成新的 Podfile.lock 文件<br><a href="http://www.samirchen.com/about-podfile-lock/" target="_blank" rel="noopener">关于 Podfile.lock 带来的痛</a></p><h3 id="使用CocoaPods开发并打包静态库"><a href="#使用CocoaPods开发并打包静态库" class="headerlink" title="使用CocoaPods开发并打包静态库"></a><a href="http://www.cnblogs.com/brycezhang/p/4117180.html" target="_blank" rel="noopener">使用CocoaPods开发并打包静态库</a></h3><h3 id="用-CocoaPods-集成本地私有库"><a href="#用-CocoaPods-集成本地私有库" class="headerlink" title="用 CocoaPods 集成本地私有库"></a><a href="http://www.samirchen.com/use-cocoapods-to-manage-private-libs/" target="_blank" rel="noopener">用 CocoaPods 集成本地私有库</a></h3><h1 id="静态库-a打包成支持64位的"><a href="#静态库-a打包成支持64位的" class="headerlink" title="静态库.a打包成支持64位的"></a>静态库.a打包成支持64位的</h1><ol><li>2015年2月1日不允许不支持arm64的应用的提交；</li><li>iOS10发布后，如果你的应用中使用到了32位的类、库，没有相应支持64位机型的库，则首次启动后会弹窗式提示：“ xxx可能使iPhone变慢…”；</li><li>iOS10.3公测版发布:封杀32位应用；</li><li>苹果系统（iOS7/iOS8-iOS9）,32位的framework和64位的framework是共存的，所以如果所有的应用都是64位的话，系统就自动不加载32位的framework，这样可以少占用资源，另外对运行的速度是有好处的，也就是说，你会感觉手机运行的快了一点。应用在兼容64位系统后，内存的占用肯定会变多一点，不过性能也有相应的提升。</li></ol><blockquote><p>i386是针对intel通用微处理器32位处理器<br>x86_64是针对x86架构的64位处理器<br>模拟器32位处理器测试需要i386架构<br>模拟器64位处理器测试需要x86_64架构<br>真机32位处理器需要armv7,或者armv7s架构<br>真机64位处理器需要arm64架构。</p></blockquote><p><a href="http://www.jianshu.com/p/567d3b730608" target="_blank" rel="noopener">iOS armv7, armv7s, arm64区别与应用32位、64位配置</a></p><p>制作方法：一般只要是模拟器一运行就会生成.a的静态库，然后cd到目录下输入lipo -info XXX.a就可以打印出支持的是x86_34,还是什么了，现在一般都要求32位和64位了，如果要是某些项目要在模拟器上运行还要支持i386,所以，可以进行.a静态包的合并。用命令输入lipo -create XX.a XXX.a -output XXXX.a 就可以生成了XXXX.a的静态包。然后导入工程并且在building setting中设置支持arm7,arm7s和arm64即可。</p><p><a href="https://my.oschina.net/kaqijiang/blog/649632" target="_blank" rel="noopener">iOS静态库.a 和framework</a><br><a href="https://www.zybuluo.com/qidiandasheng/note/603907" target="_blank" rel="noopener">iOS里的动态库和静态库</a><br><a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/" target="_blank" rel="noopener">64-bit Tips</a></p><h1 id="Xib问题"><a href="#Xib问题" class="headerlink" title="Xib问题"></a>Xib问题</h1><p>由于更新手机系统iOS11以及xcode9 beta，然后项目在xcode9运行出现一些错误：Compiling IB documents for earlier than iOS 7 is no longer supported.如截图</p><p><img src="http://upload-images.jianshu.io/upload_images/1244409-5cf0c15ba87dd1f2.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt></p><p>解决办法是：Builds for更改版本7之后，我更改成9.0<br><img src="http://upload-images.jianshu.io/upload_images/1244409-e59c5cbfe0074c5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h1 id="关于APP一启动就crash"><a href="#关于APP一启动就crash" class="headerlink" title="关于APP一启动就crash"></a>关于APP一启动就crash</h1><p>由于更新手机系统iOS11以及xcode9 beta，然后项目在xcode9运行出现_runWithMainScene:transitionContext:completion错误。解决方法在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>方法中的UIWindow必须设置它的rootViewController</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目重构的时候难免会遇到问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的图表Charts</title>
    <link href="http://peilinghui.com/2017/06/30/iOS%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%A1%A8Charts/"/>
    <id>http://peilinghui.com/2017/06/30/iOS中的图表Charts/</id>
    <published>2017-06-30T12:17:16.000Z</published>
    <updated>2017-07-06T03:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS中的图表，包括：折线图，柱状图，饼图。</p><a id="more"></a><p>对于数据的展示，最常见的就是柱状图，折线图了。在的上家公司用的柱状图都是自己写的，自己封装的。现在公司接手的项目原来是用core-plot<a href="https://github.com/core-plot" target="_blank" rel="noopener">https://github.com/core-plot</a>的第三方库。现在打算尝试一下新的第三方库：<strong>Charts</strong><a href="https://github.com/danielgindi/Charts" target="_blank" rel="noopener">https://github.com/danielgindi/Charts</a>界面更加的好看了。</p><h1 id="charts的前期准备"><a href="#charts的前期准备" class="headerlink" title="charts的前期准备"></a>charts的前期准备</h1><p>可以看它那个READMe.md,就写了使用，一种共识直接拖进项目，由于是用swift写的，OC也可以使用，因此要设置桥接文件，才可以。一种是使用cocoapods，还有一种是使用Carthage安装。</p><p>我用的是cocoapods的方式：</p><h2 id="先cocoads安装："><a href="#先cocoads安装：" class="headerlink" title="先cocoads安装："></a>先cocoads安装：</h2><p>$sudo gem install -n /usr/local/bin cocoapods</p><p>$pod setup</p><h2 id="集成Charts："><a href="#集成Charts：" class="headerlink" title="集成Charts："></a>集成Charts：</h2><p>新建一个项目TestChatDemos</p><p>cd 把工程直接拖过来</p><h2 id="创建podfile文件"><a href="#创建podfile文件" class="headerlink" title="创建podfile文件"></a>创建podfile文件</h2><p>touch podfile</p><p>open -a xcode podfile </p><p>在podfile文件中输入</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform <span class="symbol">:iOS</span>, <span class="string">'8.1'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'TestCharsDemo'</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'Charts'</span></span><br><span class="line">pod <span class="string">'Charts/Realm'</span></span><br><span class="line">post_install <span class="keyword">do</span> <span class="params">|installer|</span></span><br><span class="line">    installer.pods_project.targets.each <span class="keyword">do</span> <span class="params">|target|</span></span><br><span class="line">       target.build_configurations.each <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">           config.build_settings[<span class="string">'SWIFT_VERSION'</span>] = <span class="string">'3.0'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>pod search Charts</p><p>pod install</p><h2 id="设置桥接文件"><a href="#设置桥接文件" class="headerlink" title="设置桥接文件"></a>设置桥接文件</h2><p>建立与Swift的桥接文件，建立一个以swift文件，提示是否建立桥接，点击creat bridging header</p><p>将pods——testChatDemos。frameworkios添加到 general-&gt;embedded binaries</p><p>在桥接文件中写上要引用的swift头文件 @import Charts；</p><p>用到时导入 #import “testChartDemos-bridging-header.h”的头文件，然后就可以使用Charts里的东西了</p><p>使用ChartsDemos里的东西的时候，要配置product module name 为（TestCharsDemo）系统会自动生成</p><p>“TestCharsDemo-Swift.h”导入<br>“Chart-swift.h”的文件导入</p><p>这样基本就可以运行程序看到ChartsDemo里的案例了。</p><h1 id="使用Charts"><a href="#使用Charts" class="headerlink" title="使用Charts"></a>使用Charts</h1><p>接下来就可以参照GitHUB官网上的Demo来写你需要的图形了。</p><p>使用这个库无非就是几个问题：<br>写界面，放入数据。</p><ol><li>看你的需求是需要那种图，各个图的样式的属性。</li><li>x轴，y轴的数据是从哪里获得的。</li><li>x轴和y轴的数据是否可以动态变化。</li><li>该如何把从服务器传过来的数组对应到图中。</li></ol><h2 id="LineChart折线图"><a href="#LineChart折线图" class="headerlink" title="LineChart折线图"></a>LineChart折线图</h2><h3 id="Line-Chart单折线"><a href="#Line-Chart单折线" class="headerlink" title="Line Chart单折线"></a>Line Chart单折线</h3><p>1.首先是需要LineChartView。<br>然后是ChartLimitLine-x轴的限制线。<br>ChartLimitLine-Y轴的限制线<br>ChartYAxis设置Y轴，有左边的Y轴leftAxis和右边的Y轴rightAxis。<br>BalloonMarker</p><p>设置x轴和Y轴的数据的方法.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> val = arc4random_uniform(range) + <span class="number">3</span>;</span><br><span class="line">        [values <span class="string">addObject:</span>[[ChartDataEntry alloc] <span class="string">initWithX:</span>i <span class="string">y:</span>val <span class="string">icon:</span> [UIImage <span class="string">imageNamed:</span>@<span class="string">"icon"</span>]]];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于0到Count的x轴的值，随机的产生y值，并放入数组values中，其中values是&lt;__NSArrayM 0x600000057670&gt;(<br>ChartDataEntry, x: 0.0, y 53.0,<br>ChartDataEntry, x: 1.0, y 91.0,<br>ChartDataEntry, x: 2.0, y 44.0）这样的。</p><p>然后是LineChartDataSet，每一个set对应一条折线。把上面的values放入这个set中当做这条线的各个坐标点。设置它的属性。<br>把每一个set都放入dataSets中，作为LineChartData的数据源，也就是chartView的data源了。</p><h3 id="Line-Chart-Dual-YAxis-双折线"><a href="#Line-Chart-Dual-YAxis-双折线" class="headerlink" title="Line Chart(Dual YAxis)双折线"></a>Line Chart(Dual YAxis)双折线</h3><p>ChartLegend设置图例，就是每条线Dataset的说明。<br>对于其他同上面，其中上面的values变成了三个yVals.放入三个LineChartDataSet中，设置每一个set的属性。</p><h3 id="Multiple-Lines-Chart多种折线图"><a href="#Multiple-Lines-Chart多种折线图" class="headerlink" title="Multiple Lines Chart多种折线图"></a>Multiple Lines Chart多种折线图</h3><p>设置ChartLegend，没有设置x轴和y轴。其他同上。</p><h3 id="Colored-Line-Chart彩色的折线图"><a href="#Colored-Line-Chart彩色的折线图" class="headerlink" title="Colored Line Chart彩色的折线图"></a>Colored Line Chart彩色的折线图</h3><p>设置了_chartViews的Count为4，然后对于每一个_chartViews固定了range就是高度为100.其他同上。</p><h3 id="TimeLine-Chart时间线的折线图"><a href="#TimeLine-Chart时间线的折线图" class="headerlink" title="TimeLine Chart时间线的折线图"></a>TimeLine Chart时间线的折线图</h3><p>LineChartTimeViewController</p><h3 id="Filled-Line-Chart-填充的折线图"><a href="#Filled-Line-Chart-填充的折线图" class="headerlink" title="Filled Line Chart 填充的折线图"></a>Filled Line Chart 填充的折线图</h3><h2 id="BarChart柱状条形图"><a href="#BarChart柱状条形图" class="headerlink" title="BarChart柱状条形图"></a>BarChart柱状条形图</h2><h3 id="Bar-Chart竖的条形图"><a href="#Bar-Chart竖的条形图" class="headerlink" title="Bar Chart竖的条形图"></a>Bar Chart竖的条形图</h3><p>和折线图也差不多。设置x轴ChartXAxis，设置y轴ChartYAxis的leftAxis和rightAxis，图例ChartLegend.</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *yVals = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; start + count + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mult = (range + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> val = (<span class="keyword">double</span>) (arc4random_uniform(mult));</span><br><span class="line">        <span class="keyword">if</span> (arc4random_uniform(<span class="number">100</span>) &lt; <span class="number">25</span>) &#123;</span><br><span class="line">            [yVals <span class="string">addObject:</span>[[BarChartDataEntry alloc] <span class="string">initWithX:</span>i <span class="string">y:</span>val <span class="string">icon:</span> [UIImage <span class="string">imageNamed:</span>@<span class="string">"icon"</span>]]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [yVals <span class="string">addObject:</span>[[BarChartDataEntry alloc] <span class="string">initWithX:</span>i <span class="string">y:</span>val]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>po yVals</p><p>&lt;__NSArrayM 0x60800004d4d0&gt;(<br>ChartDataEntry, x: 1.0, y 18.0,<br>ChartDataEntry, x: 2.0, y 36.0,<br>ChartDataEntry, x: 3.0, y 17.0<br>)</p><p>每一个BarChartDataSet是一个柱状图，然后放到datasets中他们会作为BarChartData的数据源。也是_chartView的data</p><h3 id="Horizontal-Bar-Chart横的条形图"><a href="#Horizontal-Bar-Chart横的条形图" class="headerlink" title="Horizontal Bar Chart横的条形图"></a>Horizontal Bar Chart横的条形图</h3><p>就是左边的Y轴是数据的X轴，下面的一条x轴是数据的Y轴。yVals是&lt;__NSArrayM 0x6100000591a0&gt;(<br>ChartDataEntry, x: 0.0, y 3.0,<br>ChartDataEntry, x: 10.0, y 20.0,<br>ChartDataEntry, x: 20.0, y 50.0,<br>ChartDataEntry, x: 30.0, y 7.0,<br>ChartDataEntry, x: 40.0, y 33.0,<br>ChartDataEntry, x: 50.0, y 19.0,<br>ChartDataEntry, x: 60.0, y 26.0）</p><h3 id="Multiple-Bars-Chart多种条形图"><a href="#Multiple-Bars-Chart多种条形图" class="headerlink" title="Multiple Bars Chart多种条形图"></a>Multiple Bars Chart多种条形图</h3><h3 id="Stack-Bar-Chart堆积的柱状条形图"><a href="#Stack-Bar-Chart堆积的柱状条形图" class="headerlink" title="Stack Bar Chart堆积的柱状条形图"></a>Stack Bar Chart堆积的柱状条形图</h3><h3 id="Stack-Bar-Chart-Negative堆积的反向柱状条形图"><a href="#Stack-Bar-Chart-Negative堆积的反向柱状条形图" class="headerlink" title="Stack Bar Chart Negative堆积的反向柱状条形图"></a>Stack Bar Chart Negative堆积的反向柱状条形图</h3><h3 id="Another-Bar-Chart干净的条形图"><a href="#Another-Bar-Chart干净的条形图" class="headerlink" title="Another Bar Chart干净的条形图"></a>Another Bar Chart干净的条形图</h3><h3 id="Sinus-Bar-Chart正弦柱状图"><a href="#Sinus-Bar-Chart正弦柱状图" class="headerlink" title="Sinus Bar Chart正弦柱状图"></a>Sinus Bar Chart正弦柱状图</h3><h3 id="BarChart-positive-negative正反向的柱状图"><a href="#BarChart-positive-negative正反向的柱状图" class="headerlink" title="BarChart positive/negative正反向的柱状图"></a>BarChart positive/negative正反向的柱状图</h3><h2 id="PieChart饼图"><a href="#PieChart饼图" class="headerlink" title="PieChart饼图"></a>PieChart饼图</h2><p>PieChartView.不再是X轴和Y轴，而是表示一共把饼图分几块和一共的百分比。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *values = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    [values <span class="string">addObject:</span>[[PieChartDataEntry alloc] <span class="string">initWithValue:</span>(arc4random_uniform(mult) + mult / <span class="number">5</span>) <span class="string">label:</span>parties[i % parties.count] <span class="string">icon:</span> [UIImage <span class="string">imageNamed:</span>@<span class="string">"icon"</span>]]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把values放入PieChartDataSet中，其中values是下面的：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">Pie entries <span class="keyword">do</span> <span class="keyword">not</span> have x <span class="built_in">values</span></span><br><span class="line">&lt;__NSArrayM <span class="number">0x610000042910</span>&gt;(</span><br><span class="line">ChartDataEntry, x: <span class="number">0.0</span>, y <span class="number">96.03017578125</span>,</span><br><span class="line">ChartDataEntry, x: <span class="number">0.0</span>, y <span class="number">118.03017578125</span>,</span><br><span class="line">ChartDataEntry, x: <span class="number">0.0</span>, y <span class="number">27.03017578125</span>,</span><br><span class="line">ChartDataEntry, x: <span class="number">0.0</span>, y <span class="number">115.03017578125</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Pie-Chart饼图、"><a href="#Pie-Chart饼图、" class="headerlink" title="Pie Chart饼图、"></a>Pie Chart饼图、</h3><h3 id="Pie-Chart-With-Value-lines带有值的饼图"><a href="#Pie-Chart-With-Value-lines带有值的饼图" class="headerlink" title="Pie Chart With Value lines带有值的饼图"></a>Pie Chart With Value lines带有值的饼图</h3><h3 id="Half-Pie-Chart一半的饼图"><a href="#Half-Pie-Chart一半的饼图" class="headerlink" title="Half Pie Chart一半的饼图"></a>Half Pie Chart一半的饼图</h3><h2 id="Scatter-Chart离散图"><a href="#Scatter-Chart离散图" class="headerlink" title="Scatter Chart离散图"></a>Scatter Chart离散图</h2><h2 id="Bubble-Chart气泡图"><a href="#Bubble-Chart气泡图" class="headerlink" title="Bubble Chart气泡图"></a>Bubble Chart气泡图</h2><h2 id="Combine-Chart结合的图"><a href="#Combine-Chart结合的图" class="headerlink" title="Combine Chart结合的图"></a>Combine Chart结合的图</h2><h2 id="Radar-Chart雷达分散图"><a href="#Radar-Chart雷达分散图" class="headerlink" title="Radar Chart雷达分散图"></a>Radar Chart雷达分散图</h2><h2 id="Candle-Stick-Chart蜡烛状的图"><a href="#Candle-Stick-Chart蜡烛状的图" class="headerlink" title="Candle Stick Chart蜡烛状的图"></a>Candle Stick Chart蜡烛状的图</h2><p>Demo地址：<a href="https://github.com/peilinghui/BokeDemo/tree/master/PLHDemo" target="_blank" rel="noopener">https://github.com/peilinghui/BokeDemo/tree/master/PLHDemo</a></p><h1 id="其他图表框架"><a href="#其他图表框架" class="headerlink" title="其他图表框架"></a>其他图表框架</h1><p>PNChart<a href="https://github.com/peilinghui/PNChart" target="_blank" rel="noopener">https://github.com/peilinghui/PNChart</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中的图表，包括：折线图，柱状图，饼图。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
