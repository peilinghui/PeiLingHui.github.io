<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2017-02-15T04:42:58.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端框架</title>
    <link href="http://peilinghui.com/2017/02/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://peilinghui.com/2017/02/15/前端框架/</id>
    <published>2017-02-15T03:08:01.000Z</published>
    <updated>2017-02-15T04:42:58.000Z</updated>
    
    <content type="html">&lt;p&gt;前端框架。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Bootstrap：&quot;&gt;&lt;a href=&quot;#Bootstrap：&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap：&quot;&gt;&lt;/a&gt;Bootstrap：&lt;/h1&gt;&lt;p&gt;简洁，直观，强悍的前端开发框架，让web开发更迅速，简单。&lt;br&gt;2.优点：&lt;br&gt;快速，简单，灵活的栅格系统，小而强大，响应式布局，跨平台等。&lt;br&gt;下载&lt;br&gt;登陆BootStrap的官方网站下载：&lt;a href=&quot;http://getbootstrap.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://getbootstrap.com/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面使用Bootstrap官方提供的模板来设计一个响应式布局。&lt;br&gt;（1）从下载的BootStrap中找出bootstrap.min.css文件复制到项目中。&lt;br&gt;（2）新建一个style.css文件，&lt;/p&gt;
&lt;h1 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h1&gt;&lt;p&gt;React.js是用于构建模块化开发的一个js库。&lt;br&gt;&lt;a href=&quot;http://reactjs.cn/react/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactjs.cn/react/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前端框架。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计读书笔记</title>
    <link href="http://peilinghui.com/2017/02/13/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</id>
    <published>2017-02-13T07:37:24.000Z</published>
    <updated>2017-02-15T12:59:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 JavaScript简介&quot;&gt;&lt;/a&gt;第一章 JavaScript简介&lt;/h1&gt;&lt;p&gt;JavaScript有下列三个不同的部分组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMA-262规定的语言组成部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法
类型
语句
关键字
保留字
操作符
对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DOM：&lt;br&gt;DOM把真个页面映射为一个多层结点结构。&lt;br&gt;DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。&lt;br&gt;DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。&lt;br&gt;DOM3级：以统一方式加载和保存文档的方法。验证文档的方法&lt;br&gt;BOM：&lt;br&gt;处理浏览器窗口和框架。&lt;/p&gt;
&lt;h1 id=&quot;第二章-在HTML中使用JavaScript&quot;&gt;&lt;a href=&quot;#第二章-在HTML中使用JavaScript&quot; class=&quot;headerlink&quot; title=&quot;第二章 在HTML中使用JavaScript&quot;&gt;&lt;/a&gt;第二章 在HTML中使用JavaScript&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;把JavaScript插入到HTML页面中要使用&amp;lt;script&amp;gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&amp;lt;script&amp;gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&amp;lt;script&amp;gt;元素中的代码之后，才会开始解析后面的&amp;lt;script&amp;gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&amp;lt;script&amp;gt;元素中的代码，然后再解析后面的内容，所以一般应该把&amp;lt;script&amp;gt;元素放在页面最后，即主要内容后面，&amp;lt;/body&amp;gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第三章-基本概念&quot;&gt;&lt;a href=&quot;#第三章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本概念&quot;&gt;&lt;/a&gt;第三章 基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript中的函数与其他语言中的函数有诸多不同之处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Undefined类型&lt;/strong&gt;&lt;br&gt;Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Null类型&lt;/strong&gt;&lt;br&gt;Null类型是第二个只有一个值的数据类型，这个特殊值时null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;br&gt;该类型只有两个字面值：true和false。&lt;br&gt;虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; messageAsBoolean&lt;/span&gt; = &lt;span class=&quot;typename&quot;&gt;Boolean&lt;/span&gt;(message);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给出各数据类型及其转换的规则：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alert(isNaN(NaN));              //true&lt;br&gt;alert(isNaN(10));               //false（10是一个数值）&lt;br&gt;alert(isNaN(“10”));             //false（可以被转换成数值10）&lt;br&gt;alert(isNaN(“blue”));           //false（不能被转换成数值）&lt;br&gt;alert(isNaN(true));             //false（可以被转换成数值1）&lt;/p&gt;
&lt;p&gt;有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&amp;quot;name&amp;quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;p&gt;一元操作符&lt;br&gt;递增操作符     ++&lt;br&gt;递减操作符     –&lt;br&gt;一元加操作符     +&lt;br&gt;一元减操作符     -&lt;br&gt;位操作符&lt;br&gt;按位非     NOT(~)&lt;br&gt;按位与     AND(&amp;amp;)&lt;br&gt;按位或     OR(|)     var result=25 | 3;alert(result);//27&lt;br&gt;按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26&lt;br&gt;左移     &amp;lt;&amp;lt;     var oldValue=2;var newValue=oldValue &amp;lt;&amp;lt; 5;//64&lt;br&gt;有符号的右移     &amp;gt;&amp;gt;     var oldValue=64;var newValue=oldValue &amp;gt;&amp;gt; 5;//2&lt;br&gt;无符号的右移     &amp;gt;&amp;gt;&amp;gt;     var oldValue=-64;var newValue=oldValue &amp;gt;&amp;gt;&amp;gt; 5;//134217726&lt;br&gt;布尔操作符&lt;br&gt;逻辑非     !     alert(!false);//true&lt;br&gt;逻辑与     &amp;amp;&amp;amp;     var result=true &amp;amp;&amp;amp; false;//false&lt;br&gt;逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true&lt;br&gt;乘性操作符（略）&lt;br&gt;加性操作符（略）&lt;br&gt;关系操作符（略）&lt;br&gt;条件操作符（略）&lt;br&gt;赋值操作符（略）&lt;br&gt;逗号操作符（略）         &lt;/p&gt;
&lt;p&gt;相等操作符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。&lt;/p&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h1 id=&quot;第四章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第四章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第四章 变量、作用域和内存问题&lt;/h1&gt;&lt;p&gt;JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。&lt;/p&gt;
&lt;h1 id=&quot;第五章-引用类型&quot;&gt;&lt;a href=&quot;#第五章-引用类型&quot; class=&quot;headerlink&quot; title=&quot;第五章 引用类型&quot;&gt;&lt;/a&gt;第五章 引用类型&lt;/h1&gt;&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;p&gt;大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。&lt;br&gt;第一种是使用new操作符后跟Object构造函数，如&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是使用对象字面量表示法，如&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;age :&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert(person[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);              &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);                 &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示方法&lt;/strong&gt;&lt;br&gt;创建数组的基本方式有两种。&lt;br&gt;第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;//空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含三个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含一个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是使用数组字面量表示法。如&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;//创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var names = []&lt;span class=&quot;comment&quot;&gt;;//创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含2或3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var options = [, , , , ,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含5或6项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;&lt;br&gt;数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测数组&lt;/strong&gt;&lt;br&gt;自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。&lt;br&gt;对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;isArray&lt;/span&gt;(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;转换方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toLocaleString() :&lt;br&gt;toString() :&lt;br&gt;valueOf() : &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈方法和队列方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。&lt;/p&gt;
&lt;p&gt;实现栈的方式（LIFO）后进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()： 栈中项插入
pop()：栈中项移除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现队列的方法（FIFO）先进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重排序方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组中已经存在两个可以直接用来重排序的方法：&lt;br&gt;reverse()和sort()方法。&lt;/p&gt;
&lt;p&gt;reverse()方法会反转数组项的顺序。&lt;/p&gt;
&lt;p&gt;默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。&lt;br&gt;另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需将其作为参数传递给sort()方法即可。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values.sort(compare);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(values);  &lt;span class=&quot;comment&quot;&gt;//0, 1, 5, 10, 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;ECMAScript为操作已经包含在数组中的项提供了很多内置方法。&lt;/p&gt;
&lt;p&gt;concat()：&lt;br&gt;该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.concat(&lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);  &lt;span class=&quot;comment&quot;&gt;//red, green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//red, green, blue, yellow, black, brown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;slice()：  &lt;/p&gt;
&lt;p&gt;该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors3&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow, purple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors3);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;splice()：&lt;br&gt;该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var removed = colors.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//删除第一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//red, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orange&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//从位置1开始插入两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, yellow, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//返回的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//插入两项，删除一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, red, purple, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//yellow, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。&lt;br&gt;这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。&lt;/p&gt;
&lt;p&gt;var person = {  name: “Nicholas” };&lt;br&gt;var people = [{ name: “Nicholas” }];&lt;/p&gt;
&lt;p&gt;var morePeople = [person];&lt;/p&gt;
&lt;p&gt;alert(people.indexOf(person));          //-1&lt;br&gt;alert(morePeople.indexOf(person));  //0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上方法都不会修改数组中的包含的值。&lt;/p&gt;
&lt;p&gt;其中，every()和filter()方法最相似。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var everyResult = numbers.every(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(everyResult);     &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var someResult = numbers.some(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(someResult);      &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var filterResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(filterResult);            &lt;span class=&quot;comment&quot;&gt;//[3, 4, 5, 4, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map()可以用来创建包含的项与另一个数组一一对应的项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var mapResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(mapResult);           &lt;span class=&quot;comment&quot;&gt;//[2, 4, 6, 8, 10, 8, 6, 4, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forEach()本质上和使用for循环迭代数组一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers.forEach(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;归并方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。&lt;br&gt;这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。&lt;br&gt;使用reduce()方法可以执行数组中所有值求和操作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var sum = values.reduce(function(prev, cur, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev + cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(sum);     &lt;span class=&quot;comment&quot;&gt;//15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Date类型&quot;&gt;&lt;a href=&quot;#Date类型&quot; class=&quot;headerlink&quot; title=&quot;Date类型&quot;&gt;&lt;/a&gt;Date类型&lt;/h2&gt;&lt;p&gt;创建日期对象，使用new操作符和Date构造函数即可。&lt;/p&gt;
&lt;p&gt;var now = new Date()&lt;/p&gt;
&lt;p&gt;根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。&lt;br&gt;Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式&lt;br&gt;var someDate = new Date(Date.parse(“May 25, 2004”));&lt;/p&gt;
&lt;p&gt;Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。&lt;/p&gt;
&lt;p&gt;//GMT时间2000年1月1日午夜零时&lt;br&gt;var y2k = new Date(Date.UTC(2000, 0));&lt;/p&gt;
&lt;p&gt;//GMT时间2005年5月5日下午5:55:55&lt;br&gt;var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));&lt;/p&gt;
&lt;p&gt;Date类型还有一些专门用于将日期格式化为字符串的方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.&lt;/p&gt;
&lt;h2 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h2&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。&lt;/p&gt;
&lt;p&gt;var expression = / pattern / flags ;&lt;/p&gt;
&lt;p&gt;其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。&lt;br&gt;关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。&lt;br&gt;另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。&lt;/p&gt;
&lt;h2 id=&quot;Function类型&quot;&gt;&lt;a href=&quot;#Function类型&quot; class=&quot;headerlink&quot; title=&quot;Function类型&quot;&gt;&lt;/a&gt;Function类型&lt;/h2&gt;&lt;p&gt;ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数声明与函数表达式&lt;/p&gt;
&lt;p&gt;解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;没有重载！&lt;/strong&gt;&lt;br&gt;由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为返回值的函数&lt;/strong&gt;&lt;br&gt;由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。&lt;br&gt;函数作为返回值是极有用的技术，是“闭包”技术的基础之一。&lt;br&gt;比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction (propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var data = [&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Zachary&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;&amp;#125;, &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据name来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Nicholas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据age来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Zachary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数内部属性（重点）&lt;/strong&gt;&lt;br&gt;在函数内部，有两个特殊的对象：arguments和this。&lt;/p&gt;
&lt;p&gt;arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//与函数名紧紧耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用arguments.callee替代函数名，消除耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * arguments.callee (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; trueFactorial = factorial;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;factorial = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(trueFactiorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));           &lt;span class=&quot;comment&quot;&gt;//120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));                    &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();             &lt;span class=&quot;comment&quot;&gt;//&quot;red&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor = sayColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor();           &lt;span class=&quot;comment&quot;&gt;//&quot;blue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。&lt;/p&gt;
&lt;p&gt;ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数属性和方法（重点）&lt;/strong&gt;&lt;br&gt;ECMAScript中函数是对象，因此也有属性和方法。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。&lt;br&gt;诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//传入arguments对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, [num1, num2]);       &lt;span class=&quot;comment&quot;&gt;//传入数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum1(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum2(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));     &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();                     &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(o);               &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; objectSayColor = sayColor.bind(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectSayColor();           &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2&lt;/span&gt; = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问s1时，访问过程处于读取模式，后台自动完成下列处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上三个步骤可以想象成下列代码&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。&lt;br&gt;引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed()：按指定小数位返回数值的字符串表示。&lt;/li&gt;
&lt;li&gt;toExponential()：返回以指数表示法表示的数值的字符串形式。&lt;/li&gt;
&lt;li&gt;toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符方法&lt;/strong&gt;&lt;br&gt;两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串操作方法&lt;/strong&gt;&lt;br&gt;concat()：&lt;br&gt;用于将一或多个字符串拼接起来，接受任意多个参数。&lt;/p&gt;
&lt;p&gt;slice()、substr()和substring()：&lt;br&gt;这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。&lt;/p&gt;
&lt;p&gt;当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串位置方法&lt;/strong&gt;&lt;br&gt;有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。&lt;br&gt;两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。&lt;br&gt;在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trim()方法&lt;/strong&gt;&lt;br&gt;该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串大小写转换方法&lt;/strong&gt;&lt;br&gt;ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串的模式匹配方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;match()：&lt;br&gt;在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。&lt;/p&gt;
&lt;p&gt;search()：&lt;br&gt;参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。&lt;/p&gt;
&lt;p&gt;replace()：&lt;br&gt;接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。&lt;/p&gt;
&lt;p&gt;split()：&lt;br&gt;该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。&lt;/p&gt;
&lt;p&gt;localeCompare()方法;&lt;br&gt;该方法比较两个字符串，并返回下列值中的一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fromCharCode()方法：&lt;/p&gt;
&lt;p&gt;String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。&lt;/p&gt;
&lt;h2 id=&quot;单体内置对象&quot;&gt;&lt;a href=&quot;#单体内置对象&quot; class=&quot;headerlink&quot; title=&quot;单体内置对象&quot;&gt;&lt;/a&gt;单体内置对象&lt;/h2&gt;&lt;p&gt;除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。&lt;/p&gt;
&lt;h3 id=&quot;Global对象&quot;&gt;&lt;a href=&quot;#Global对象&quot; class=&quot;headerlink&quot; title=&quot;Global对象&quot;&gt;&lt;/a&gt;Global对象&lt;/h3&gt;&lt;p&gt;所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()&lt;br&gt;isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI编码方法&lt;/strong&gt;&lt;br&gt;Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval()方法&lt;/strong&gt;&lt;br&gt;eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。&lt;br&gt;当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：&lt;/p&gt;
&lt;p&gt;var msg = “hello world”;&lt;br&gt;eval(“alert(msg)”);     //“hello world”&lt;/p&gt;
&lt;p&gt;变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Global对象的属性&lt;/strong&gt;&lt;br&gt;Global对象的所有属性：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window对象&lt;/strong&gt;&lt;br&gt;ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。&lt;/p&gt;
&lt;h3 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math()对象&quot;&gt;&lt;/a&gt;Math()对象&lt;/h3&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Math对象的属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Math对象的方法&lt;/strong&gt;&lt;br&gt;min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.&lt;br&gt;Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。&lt;br&gt;Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//选择一个介于2到10之间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var num = Math.&lt;span class=&quot;built_in&quot;&gt;floor&lt;/span&gt;(Math.random() * &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下函数可以直接指定随机范围（整数）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectFrom&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lowerValue, upperValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; choices = upperValue - lowerValue +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() * choices + lowerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = selectFrom(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(num);     &lt;span class=&quot;comment&quot;&gt;//介于2和10之间（包括2和10）的一个数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.abs(num)     返回num的绝对值&lt;br&gt;Math.asin(x)     返回x的反正弦值&lt;br&gt;Math.exp(num)     返回Math.E的num次幂&lt;br&gt;     Math.atan(x)     返回x的反正切值&lt;br&gt;Math.log(num)     返回num的自然对数&lt;br&gt;Math.atan2(y,x)     返回y/x的反正切值&lt;br&gt;Math.pow(num, power)     返回num的power次幂&lt;br&gt;Math.cos(x)     返回x的余弦值&lt;br&gt;Math.sqrt(num)     返回num的平方根&lt;br&gt;Math.sin(x)     返回x的正弦值&lt;br&gt;Math.acos(x)     返回x的反余弦值&lt;br&gt;Math.tan(x)     返回x的正切值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第六章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h3&gt;&lt;p&gt;ECMAScript中有两种属性：数据属性和访问器属性。&lt;br&gt;&lt;strong&gt;数据属性&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。&lt;br&gt;要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：&lt;br&gt;注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//抛出错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问器属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。&lt;br&gt;访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; book = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _year: &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edition: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(book, &lt;span class=&quot;string&quot;&gt;&quot;year&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.edition += newValue - &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;book.year = &lt;span class=&quot;number&quot;&gt;2005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(book.edition);        &lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一个属性的值会导致其他属性发生变化。&lt;br&gt;注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义多个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取属性的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。&lt;/p&gt;
&lt;p&gt;注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。&lt;/p&gt;
&lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;构造函数模式&quot;&gt;&lt;a href=&quot;#构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式&quot;&gt;&lt;/a&gt;构造函数模式&lt;/h3&gt;&lt;p&gt;像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age, job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;br&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。&lt;br&gt;创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将构造函数当做函数&lt;/strong&gt;&lt;br&gt;任何函数，只要通过new操作符来调用，那它就可以作为构造函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数的问题&lt;/strong&gt;&lt;br&gt;构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.&lt;/p&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;br&gt;创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。&lt;br&gt;如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。&lt;/p&gt;
&lt;p&gt;isPrototypeOf()：确定对象原型方法。&lt;br&gt;&lt;code&gt;alert(Person.prototype.isPrototypeOf(person1)); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; Object.getPrototypeOf()：ECMAScript 5新增方法。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt; == Person.prototype)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;  //true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt;.name)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; //&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;原型与in操作符&lt;/strong&gt;&lt;br&gt;有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;p&gt;而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function hasPrototypeProperty(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;/span&gt;name) &amp;amp;&amp;amp; (name in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。&lt;/p&gt;
&lt;p&gt;Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。&lt;/p&gt;
&lt;p&gt;如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型的动态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;h3 id=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;a href=&quot;#组合使用构造函数模式和原型模式&quot; class=&quot;headerlink&quot; title=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;/a&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。&lt;/p&gt;
&lt;h3 id=&quot;动态原型模式&quot;&gt;&lt;a href=&quot;#动态原型模式&quot; class=&quot;headerlink&quot; title=&quot;动态原型模式&quot;&gt;&lt;/a&gt;动态原型模式&lt;/h3&gt;&lt;p&gt;动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。&lt;/p&gt;
&lt;h3 id=&quot;寄生构造函数模式&quot;&gt;&lt;a href=&quot;#寄生构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;寄生构造函数模式&quot;&gt;&lt;/a&gt;寄生构造函数模式&lt;/h3&gt;&lt;p&gt;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。&lt;/p&gt;
&lt;h3 id=&quot;稳妥构造函数模式&quot;&gt;&lt;a href=&quot;#稳妥构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;稳妥构造函数模式&quot;&gt;&lt;/a&gt;稳妥构造函数模式&lt;/h3&gt;&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());    &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链的问题&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。&lt;br&gt;原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。&lt;/p&gt;
&lt;h3 id=&quot;借用构造函数&quot;&gt;&lt;a href=&quot;#借用构造函数&quot; class=&quot;headerlink&quot; title=&quot;借用构造函数&quot;&gt;&lt;/a&gt;借用构造函数&lt;/h3&gt;&lt;p&gt;在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递参数&lt;/strong&gt;&lt;br&gt;相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数的问题&lt;/strong&gt;&lt;br&gt;如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。&lt;/p&gt;
&lt;h3 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h3&gt;&lt;p&gt;组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SupType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Nicolas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayAge();         &lt;span class=&quot;comment&quot;&gt;//29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayAge();         &lt;span class=&quot;comment&quot;&gt;//27&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。&lt;br&gt;组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;/h3&gt;&lt;p&gt;借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    F.prototype = o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anttherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Rob&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yetAnotherPerosn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Linda&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Barbie&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.friends);  &lt;span class=&quot;comment&quot;&gt;//&quot;Shelby, Court, Van, Rob, Barbie&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。&lt;br&gt;ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。&lt;br&gt;object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。&lt;/p&gt;
&lt;h3 id=&quot;寄生式继承&quot;&gt;&lt;a href=&quot;#寄生式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生式继承&quot;&gt;&lt;/a&gt;寄生式继承&lt;/h3&gt;&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(original)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; = object(original);    &lt;span class=&quot;comment&quot;&gt;//通过调用函数创建一个新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;       &lt;span class=&quot;comment&quot;&gt;//以某种方式来增强这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;hi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;;                    &lt;span class=&quot;comment&quot;&gt;//返回这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson = createAnother(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.sayHi();  &lt;span class=&quot;comment&quot;&gt;//&quot;hi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。&lt;br&gt;注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。&lt;/p&gt;
&lt;h3 id=&quot;寄生组合式继承&quot;&gt;&lt;a href=&quot;#寄生组合式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生组合式继承&quot;&gt;&lt;/a&gt;寄生组合式继承&lt;/h3&gt;&lt;p&gt;组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);             &lt;span class=&quot;comment&quot;&gt;//第二次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();        &lt;span class=&quot;comment&quot;&gt;//第一次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。&lt;br&gt;而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(subType, superType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prototype = object(superType.prototype);    &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prototype.constructor = subType;                &lt;span class=&quot;comment&quot;&gt;//增强对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subType.prototype = prototype;                  &lt;span class=&quot;comment&quot;&gt;//指定对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inheritPrototype(SubType, SuperType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：&lt;br&gt;1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。&lt;br&gt;2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。&lt;br&gt;3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。&lt;br&gt;JavaScript主要使用原型链实现继承。&lt;strong&gt;原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的&lt;/strong&gt;。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。&lt;br&gt;使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。&lt;br&gt;此外，还存在下列可供选择的继承模式：&lt;br&gt;1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。&lt;br&gt;2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。&lt;br&gt;3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;h1 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h1&gt;&lt;p&gt;定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; functionName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num * arguments.callee(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var factorial = (&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;num * &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;不少开发人员总是搞不清匿名函数和闭包这两个概念。&lt;br&gt;&lt;strong&gt;闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;而匿名函数是指没有函数名称的函数。&lt;/strong&gt;&lt;br&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。&lt;br&gt;在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = compare(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 &lt;/p&gt;
&lt;p&gt;无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。&lt;br&gt;在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compare = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compare(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compareNames = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compareNames(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//解除对匿名函数的引用（以便释放内存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compareNames = null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包与变量&quot;&gt;&lt;a href=&quot;#闭包与变量&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数会返回一个函数数组，而其中的每个函数都返回10。&lt;br&gt;我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //匿名函数直接赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function(num) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于this对象&quot;&gt;&lt;a href=&quot;#关于this对象&quot; class=&quot;headerlink&quot; title=&quot;关于this对象&quot;&gt;&lt;/a&gt;关于this对象&lt;/h3&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;The Window&quot;（在非严格模式下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; that.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;My Object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(element.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//防止内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = element.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。&lt;/p&gt;
&lt;h2 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h2&gt;&lt;p&gt;JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。&lt;br&gt;用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//立即调用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里是块级作用域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数。&lt;br&gt;函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。&lt;/p&gt;
&lt;p&gt;无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outputNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(i);    &lt;span class=&quot;comment&quot;&gt;//导致一个错误！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。&lt;/p&gt;
&lt;h2 id=&quot;私有变量&quot;&gt;&lt;a href=&quot;#私有变量&quot; class=&quot;headerlink&quot; title=&quot;私有变量&quot;&gt;&lt;/a&gt;私有变量&lt;/h2&gt;&lt;p&gt;严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。&lt;br&gt;如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。&lt;br&gt;我们把有权访问私有变量和私有函数的公有方法成为&lt;strong&gt;特权方法&lt;/strong&gt;（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。&lt;br&gt;利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nihcholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。&lt;br&gt;构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。&lt;/p&gt;
&lt;h3 id=&quot;静态私有变量&quot;&gt;&lt;a href=&quot;#静态私有变量&quot; class=&quot;headerlink&quot; title=&quot;静态私有变量&quot;&gt;&lt;/a&gt;静态私有变量&lt;/h3&gt;&lt;p&gt;通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公有/特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject.prototype.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。&lt;br&gt;这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototye.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototype.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Michael&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person2.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。&lt;br&gt;以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。&lt;/p&gt;
&lt;h3 id=&quot;模块模式&quot;&gt;&lt;a href=&quot;#模块模式&quot; class=&quot;headerlink&quot; title=&quot;模块模式&quot;&gt;&lt;/a&gt;模块模式&lt;/h3&gt;&lt;p&gt;前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : value,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; : function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是方法的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权/公有方法和属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicProperty: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; application = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; components = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    components.push(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaseComponent());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公共&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getComponentCount : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; components.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerComponent : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; component == &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                components.push(component);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。&lt;br&gt;简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。&lt;/p&gt;
&lt;h3 id=&quot;增强的模块模式&quot;&gt;&lt;a href=&quot;#增强的模块模式&quot; class=&quot;headerlink&quot; title=&quot;增强的模块模式&quot;&gt;&lt;/a&gt;增强的模块模式&lt;/h3&gt;&lt;p&gt;有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。&lt;/p&gt;
&lt;h2 id=&quot;小结：&quot;&gt;&lt;a href=&quot;#小结：&quot; class=&quot;headerlink&quot; title=&quot;小结：&quot;&gt;&lt;/a&gt;小结：&lt;/h2&gt;&lt;p&gt;在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包还可以用于在对象中创建私有变量，相关概念和要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。&lt;/p&gt;
&lt;h1 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h1&gt;&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。&lt;/p&gt;
&lt;p&gt;定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。&lt;br&gt;尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，&lt;/p&gt;
&lt;h3 id=&quot;窗口关系及框架&quot;&gt;&lt;a href=&quot;#窗口关系及框架&quot; class=&quot;headerlink&quot; title=&quot;窗口关系及框架&quot;&gt;&lt;/a&gt;窗口关系及框架&lt;/h3&gt;&lt;p&gt;如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。&lt;br&gt;每个window对象都有一个name属性，其中包含框架的名称。&lt;br&gt;top对象始终指向最高（最外）层的框架，也就是浏览器窗口。&lt;br&gt;与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。&lt;/p&gt;
&lt;h3 id=&quot;窗口的位置&quot;&gt;&lt;a href=&quot;#窗口的位置&quot; class=&quot;headerlink&quot; title=&quot;窗口的位置&quot;&gt;&lt;/a&gt;窗口的位置&lt;/h3&gt;&lt;p&gt;使用如下代码可以取得窗口左边和上边的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; leftPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenY;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;moveTo():接收新位置的x,y坐标值&lt;/p&gt;
&lt;p&gt;moveBy():接收在水平和垂直方向上移动的像素数&lt;/p&gt;
&lt;h3 id=&quot;窗口大小&quot;&gt;&lt;a href=&quot;#窗口大小&quot; class=&quot;headerlink&quot; title=&quot;窗口大小&quot;&gt;&lt;/a&gt;窗口大小&lt;/h3&gt;&lt;p&gt;四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.&lt;/p&gt;
&lt;p&gt;resizeTo():接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy():接收新窗口与原窗口的宽度和高度之差&lt;/p&gt;
&lt;p&gt;innerWidth和innerHeight表示该容器中页面视图区的大小&lt;/p&gt;
&lt;h3 id=&quot;导航和打开新窗口&quot;&gt;&lt;a href=&quot;#导航和打开新窗口&quot; class=&quot;headerlink&quot; title=&quot;导航和打开新窗口&quot;&gt;&lt;/a&gt;导航和打开新窗口&lt;/h3&gt;&lt;p&gt;使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。&lt;/p&gt;
&lt;h3 id=&quot;间歇调用和超时调用&quot;&gt;&lt;a href=&quot;#间歇调用和超时调用&quot; class=&quot;headerlink&quot; title=&quot;间歇调用和超时调用&quot;&gt;&lt;/a&gt;间歇调用和超时调用&lt;/h3&gt;&lt;p&gt;javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。&lt;br&gt;超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。&lt;/p&gt;
&lt;p&gt;间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。&lt;/p&gt;
&lt;h3 id=&quot;系统对话框&quot;&gt;&lt;a href=&quot;#系统对话框&quot; class=&quot;headerlink&quot; title=&quot;系统对话框&quot;&gt;&lt;/a&gt;系统对话框&lt;/h3&gt;&lt;p&gt;浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;查询字符串参数&quot;&gt;&lt;a href=&quot;#查询字符串参数&quot; class=&quot;headerlink&quot; title=&quot;查询字符串参数&quot;&gt;&lt;/a&gt;查询字符串参数&lt;/h3&gt;&lt;p&gt;location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  &lt;/p&gt;
&lt;h3 id=&quot;位置操作&quot;&gt;&lt;a href=&quot;#位置操作&quot; class=&quot;headerlink&quot; title=&quot;位置操作&quot;&gt;&lt;/a&gt;位置操作&lt;/h3&gt;&lt;p&gt;用location对象改变浏览器位置的多种方式：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);  
window.location=&amp;quot;htttp://www.wrox.com&amp;quot;;  
location.href=&amp;quot;htttp://www.wrox.com&amp;quot;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。&lt;/p&gt;
&lt;p&gt;  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;&lt;a href=&quot;#navigator对象&quot; class=&quot;headerlink&quot; title=&quot;navigator对象&quot;&gt;&lt;/a&gt;navigator对象&lt;/h2&gt;&lt;p&gt;navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。&lt;/p&gt;
&lt;h3 id=&quot;检测插件&quot;&gt;&lt;a href=&quot;#检测插件&quot; class=&quot;headerlink&quot; title=&quot;检测插件&quot;&gt;&lt;/a&gt;检测插件&lt;/h3&gt;&lt;p&gt;navigator.plugins[]表示浏览器所用的插件的集合。&lt;br&gt;name: 插件的名字&lt;/p&gt;
&lt;p&gt;description:插件的描述&lt;/p&gt;
&lt;p&gt;filename:插件的文件名&lt;/p&gt;
&lt;p&gt;length:插件所处理的MIME类型数量&lt;/p&gt;
&lt;h3 id=&quot;注册处理程序&quot;&gt;&lt;a href=&quot;#注册处理程序&quot; class=&quot;headerlink&quot; title=&quot;注册处理程序&quot;&gt;&lt;/a&gt;注册处理程序&lt;/h3&gt;&lt;p&gt;FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。&lt;/p&gt;
&lt;p&gt;registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。&lt;/p&gt;
&lt;p&gt;navigator.registerContentHandler(‘application/rss+xml’, ‘&lt;a href=&quot;http://www.sohu.com?feed=%s’&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sohu.com?feed=%s’&lt;/a&gt;, ‘some Reader’);&lt;/p&gt;
&lt;p&gt;FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。&lt;/p&gt;
&lt;h2 id=&quot;screen对象&quot;&gt;&lt;a href=&quot;#screen对象&quot; class=&quot;headerlink&quot; title=&quot;screen对象&quot;&gt;&lt;/a&gt;screen对象&lt;/h2&gt;&lt;p&gt;screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;&lt;a href=&quot;#history对象&quot; class=&quot;headerlink&quot; title=&quot;history对象&quot;&gt;&lt;/a&gt;history对象&lt;/h2&gt;&lt;p&gt;history.go(-1) | history.back(); //后退一页&lt;/p&gt;
&lt;p&gt;history.go(1) | history.forward();//前进一页&lt;/p&gt;
&lt;p&gt;history.go(n);//前进n页&lt;/p&gt;
&lt;p&gt;history.go(‘sohu.com’);//跳转到最后的sohu页面&lt;/p&gt;
&lt;p&gt;history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。&lt;/p&gt;
&lt;h1 id=&quot;第9章，客户端检测&quot;&gt;&lt;a href=&quot;#第9章，客户端检测&quot; class=&quot;headerlink&quot; title=&quot;第9章，客户端检测&quot;&gt;&lt;/a&gt;第9章，客户端检测&lt;/h1&gt;&lt;p&gt;尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案&lt;/p&gt;
&lt;h2 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h2&gt;&lt;p&gt;检测浏览器是否具备某一能力。&lt;/p&gt;
&lt;p&gt;尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险&lt;/p&gt;
&lt;p&gt;并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。&lt;/p&gt;
&lt;h2 id=&quot;怪癖检测&quot;&gt;&lt;a href=&quot;#怪癖检测&quot; class=&quot;headerlink&quot; title=&quot;怪癖检测&quot;&gt;&lt;/a&gt;怪癖检测&lt;/h2&gt;&lt;p&gt;检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。&lt;/p&gt;
&lt;h2 id=&quot;用户代理检测&quot;&gt;&lt;a href=&quot;#用户代理检测&quot; class=&quot;headerlink&quot; title=&quot;用户代理检测&quot;&gt;&lt;/a&gt;用户代理检测&lt;/h2&gt;&lt;p&gt;通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。&lt;br&gt;识别呈现引擎&lt;/p&gt;
&lt;p&gt;注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera&lt;/p&gt;
&lt;p&gt;注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别&lt;br&gt;识别浏览器&lt;br&gt;识别平台&lt;br&gt;识别windows操作系统&lt;br&gt;识别移动设备&lt;br&gt;识别游戏系统&lt;br&gt;完整的用户代理检测代码&lt;/p&gt;
&lt;h1 id=&quot;第10章-DOM&quot;&gt;&lt;a href=&quot;#第10章-DOM&quot; class=&quot;headerlink&quot; title=&quot;第10章 DOM&quot;&gt;&lt;/a&gt;第10章 DOM&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端面试题总结</title>
    <link href="http://peilinghui.com/2017/02/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://peilinghui.com/2017/02/13/前端面试题总结/</id>
    <published>2017-02-13T02:37:41.000Z</published>
    <updated>2017-02-13T07:36:21.000Z</updated>
    
    <content type="html">&lt;p&gt;前端面试题总结。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;HTML&amp;amp;CSS：&lt;br&gt;    对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、&lt;br&gt;    HTML5、CSS3、Flexbox&lt;/p&gt;
&lt;p&gt;JavaScript：&lt;br&gt;    数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、&lt;br&gt;    DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs&lt;/p&gt;
&lt;p&gt;其他：&lt;br&gt;    移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力&lt;/p&gt;
&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;p&gt;1.Doctype作用？标准模式与兼容模式各有什么区别?&lt;br&gt;（1）&amp;lt;!DOCTYPE&amp;gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。&lt;br&gt;（2)标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。&lt;br&gt;2.HTML5 为什么只需要写 &amp;lt;!DOCTYPE HTML&amp;gt;？&lt;br&gt;HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；&lt;/html&gt;&lt;/p&gt;
&lt;p&gt; 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？&lt;br&gt;CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）行内元素有：a b span img input select strong（强调的语气）&lt;br&gt;（2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p&lt;/p&gt;
&lt;p&gt;（3）常见的空元素：&lt;br&gt;    &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;&lt;br&gt;    鲜为人知的是：&lt;br&gt;    &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;&lt;br&gt;4.页面导入样式时，使用link和@import有什么区别？&lt;br&gt;（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;&lt;/p&gt;
&lt;p&gt;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;&lt;/p&gt;
&lt;p&gt;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;&lt;br&gt;5.介绍一下你对浏览器内核的理解？&lt;br&gt;主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。&lt;br&gt;渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。&lt;/p&gt;
&lt;p&gt;JS引擎则：解析和执行javascript来实现网页的动态效果。&lt;/p&gt;
&lt;p&gt;最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。&lt;br&gt;6.常见的浏览器内核有哪些？&lt;br&gt;Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]&lt;br&gt;Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等&lt;br&gt;Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]&lt;br&gt;Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前端面试题总结。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何封装一个自定义键盘的控件</title>
    <link href="http://peilinghui.com/2016/08/04/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E7%9A%84%E6%8E%A7%E4%BB%B6/"/>
    <id>http://peilinghui.com/2016/08/04/如何封装一个自定义键盘的控件/</id>
    <published>2016-08-04T15:25:50.000Z</published>
    <updated>2016-08-04T15:37:09.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义控件，刚刚学起来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;可以封装一个键盘控件，然后作为一个pod，引入所需要使用的工程里面。&lt;br&gt;写法：&lt;br&gt;&lt;code&gt;pod &amp;quot;TDFKeyboard&amp;quot;, :git =&amp;gt; &amp;#39;git@git.....:ios/TDFKeyboard.git&amp;#39;, :branch =&amp;gt; &amp;#39;master&amp;#39;&lt;/code&gt;&lt;br&gt;对于podfile文件的格式可以参考这篇文章：&lt;a href=&quot;http://www.jianshu.com/p/8af475c4f717&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/8af475c4f717&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此键盘主要用于输入整数和浮点数还有IP地址。&lt;br&gt;主要是写了两种键盘，一种是不带“-”号的数字键盘1，一种是带“-”号的数字键盘2。如图：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E9%94%AE%E7%9B%981&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E9%94%AE%E7%9B%982&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的响应的是系统的UITextField的输入，下面的响应的是自定义的TextView。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先在ViewController的viewDidLoad方法中：&lt;br&gt;初始化键盘1，然后把键盘的responder设置为系统的textField。&lt;br&gt;然后初始化自定义的TextView，初始化键盘2，然后把自定义的inputView设置为自定义键盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个键盘的父类：Keyboard（UIView的子类）&lt;br&gt;其中用枚举设置键盘输入类型有整数，浮点型和IP地址型。&lt;br&gt;&lt;code&gt;@property(weak,nonatomic)UIView&amp;lt;UIKeyInput&amp;gt; *responder;&lt;/code&gt;&lt;br&gt;在UIKit中有UIKeyInput(是一个协议@protocol)&lt;br&gt;UIView 的首要问题就是既能从代码中初始化，也能从 xib 中初始化，两者有何不同?&lt;br&gt;UIView 是支持 NSCoding 协议的，当在 xib 或 storyboard 里存在一个 UIView 的时候，其实是将 UIView 序列化到文件里（xib 和 storyboard 都是以 XML 格式来保存的），加载的时候反序列化出来，所以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当从代码实例化 UIView 的时候，initWithFrame 会执行；
当从文件加载 UIView 的时候，initWithCoder 会执行。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置view的布局：&lt;br&gt;&lt;code&gt;self.autoresizingMask = UIViewAutoresizingNone;&lt;/code&gt;&lt;br&gt;解释：UIView中的autoresizingMask属性，枚举类型，定义如下：主要作用是自动调整子控件与父控件中间的位置，宽和高。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NS_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NSUInteger, UIViewAutoresizing)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingNone                 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//不自动调整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleLeftMargin   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,   &lt;span class=&quot;comment&quot;&gt;// 自动调整与superView左边的距离，保证与superView右边的距离不变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleWidth        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleRightMargin  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleTopMargin    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//自动调整与superView顶部的距离，保证与superView底部的距离不变。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleHeight       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//自动调整自己的高度，保证与superView顶部和底部的距离不变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleBottomMargin = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;UIViewAutoresizingFlexibleLeftMargin  |UIViewAutoresizingFlexibleRightMargin 自动调整与superView左边的距离，保证与左边的距离和右边的距离和原来距左边和右边的距离的比例不变。比如原来距离为20，30，调整后的距离应为68，102，即68/20=102/30。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类有键盘1(TDFNumbericKeyboard)和键盘2(TDFSymbolNumbericKeyboard):&lt;br&gt;在子类中实现了UIKeyInput协议方法，其中默认的方法有：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;BOOL&lt;/span&gt;)hasText;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (void)&lt;span class=&quot;symbol&quot;&gt;insertText:&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;NSString&lt;/span&gt; *)text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (void)deleteBackward;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后实现xib中的按钮的点击action事件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在自定义textView中定义协议代理并实现其方法：&lt;br&gt;其中有手势：UITapGestureRecognizer，当然这只是手势的其中一个。&lt;br&gt;下面还有几个如：&lt;br&gt;UITapGestureRecognizer&lt;br&gt;UIPinchGestureRecognizer&lt;br&gt;UIRotationGestureRecognizer&lt;br&gt;UISwipeGestureRecognizer&lt;br&gt;UIPanGestureRecognizer&lt;br&gt;UILongPressGestureRecognizer&lt;br&gt;从命名上不难了解這些类別所对应代表的手势，分別是 Tap（点一下）、Pinch（二指往內或往外拨动）、Rotation（旋转）、Swipe（滑动，快速移动）、Pan （拖移，慢速移动）以及 LongPress（长按）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; *tap = [[&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; alloc]initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(becomeFirstResponder)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; addGestureRecognizer:tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; addSubview:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.textLabel&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/peilinghui/PLHKeyboard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/PLHKeyboard&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;如何设计一个 iOS 控件?(iOS 控件完全解析) ：&lt;a href=&quot;http://blog.csdn.net/zhangao0086/article/details/45622875&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zhangao0086/article/details/45622875&lt;/a&gt;      ·&lt;br&gt;ios手势：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7c336a8301011b3e.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7c336a8301011b3e.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义控件，刚刚学起来。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RunLoop的学习</title>
    <link href="http://peilinghui.com/2016/07/19/RunLoop%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/07/19/RunLoop的学习/</id>
    <published>2016-07-19T14:45:17.000Z</published>
    <updated>2016-07-19T14:45:17.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime的学习</title>
    <link href="http://peilinghui.com/2016/07/05/Runtime%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/07/05/Runtime的学习/</id>
    <published>2016-07-05T08:22:32.000Z</published>
    <updated>2016-12-30T12:29:58.000Z</updated>
    
    <content type="html">&lt;p&gt;官方源代码地址：&lt;a href=&quot;http://opensource.apple.com//source/objc4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opensource.apple.com//source/objc4/&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是runtime？&lt;br&gt;1&amp;gt; runtime是一套比较底层的纯C语言API, 属于1个C语言库&lt;br&gt;2&amp;gt; 平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者&lt;br&gt;3&amp;gt; 举例:&lt;br&gt;OC：&lt;code&gt;[[Person alloc] init]&lt;/code&gt;&lt;br&gt;runtime: &lt;code&gt;objc_msgSend(objc_msgSend(&amp;quot;Person&amp;quot; , &amp;quot;alloc&amp;quot;), &amp;quot;init&amp;quot;)&lt;/code&gt;&lt;br&gt;OC：&lt;code&gt;[target doSomething];&lt;/code&gt;&lt;br&gt;Runtime(objc)：&lt;code&gt;msgSend(target,@selector(doSomething))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有什么用？&lt;br&gt;runtime是属于OC的底层, 可以进行一些非常底层的操作。&lt;br&gt;1&amp;gt; 动态创建一个类（比如KVO的底层实现）&lt;br&gt;2&amp;gt; 动态的为某个类添加属性\方法，修改属性\方法.遍历一个类的所有的成员变量(属性)\方法&lt;br&gt;3&amp;gt; 写代码能更加灵活，可以把消息转发给想要的对象，或者随意交换一个方法的实现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的头文件：&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt; : 成员变量、类、方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/message.h&amp;gt;: 消息机制&lt;/code&gt;&lt;br&gt; 常见的方法：&lt;br&gt; &lt;code&gt;Ivar class_copyIvarList : 获得某个类内部的所有成员变量&lt;/code&gt;（Ivar是成员变量）&lt;br&gt; &lt;code&gt;Method * class_copyMethodList : 获得某个类内部的所有方法&lt;/code&gt; （Method是成员方法）&lt;br&gt; &lt;code&gt;Method class_copyPropertyList: 获得属性列表&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_copyProtocolList: 获得协议列表&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getInstanceMethod: 获得某个实例方法（对象方法，减号-开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getClassMethod : 获得某个类方法（加号+开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;method_exchangeImplementations : 交换2个方法的具体实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;objc_msgSend(....)：给对象发送消息&lt;/code&gt;&lt;br&gt; ``&lt;br&gt;相关应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSCoding(利用runtime遍历模型对象的所有属性来归档和解档）&lt;/li&gt;
&lt;li&gt;字典–&amp;gt;模型（利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）&lt;/li&gt;
&lt;li&gt;KVO（利用runtime动态产生一个类）&lt;ul&gt;
&lt;li&gt;用于封装框架（想怎么改就怎么改）&lt;br&gt;示例第一种应用：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优秀博客学习：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Objective-C Runtime 1小时入门教程：&lt;a href=&quot;https://www.ianisme.com/ios/2019.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;Objective-C Runtime：&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;南峰子有一系列：&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;快速上手Runtime（附MJExtension的底层实现:&lt;a href=&quot;http://www.tuicool.com/articles/YzeiEna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/YzeiEna&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iOS运行时Runtime浅析：&lt;a href=&quot;http://blog.csdn.net/chenyufeng1991/article/details/51931320&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenyufeng1991/article/details/51931320&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;官方源代码地址：&lt;a href=&quot;http://opensource.apple.com//source/objc4/&quot;&gt;http://opensource.apple.com//source/objc4/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TableView的一些事</title>
    <link href="http://peilinghui.com/2016/07/02/TableView%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://peilinghui.com/2016/07/02/TableView的一些事/</id>
    <published>2016-07-02T02:32:49.000Z</published>
    <updated>2016-10-12T12:07:46.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView的基本信息&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UITableView的基本信息&quot;&gt;&lt;a href=&quot;#UITableView的基本信息&quot; class=&quot;headerlink&quot; title=&quot;UITableView的基本信息&quot;&gt;&lt;/a&gt;UITableView的基本信息&lt;/h2&gt;&lt;h3 id=&quot;初始化方法&quot;&gt;&lt;a href=&quot;#初始化方法&quot; class=&quot;headerlink&quot; title=&quot;初始化方法&quot;&gt;&lt;/a&gt;初始化方法&lt;/h3&gt;&lt;p&gt; &lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;&lt;/code&gt;&lt;br&gt;这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;// 标准的表视图风格    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStyleGrouped&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;// 分组的表视图风格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用属性&quot;&gt;&lt;a href=&quot;#常用属性&quot; class=&quot;headerlink&quot; title=&quot;常用属性&quot;&gt;&lt;/a&gt;常用属性&lt;/h3&gt;&lt;p&gt;获取表视图的风格(只读属性)&lt;br&gt;&lt;code&gt;@property(nonatomic, readonly) UITableViewStyle    style;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图代理和数据源代理(代理方法后面讨论)&lt;br&gt;&lt;code&gt;@property (nonatomic, assign)id &amp;lt;UITableViewDataSource&amp;gt; dataSource;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property(nonatomic, assign)id &amp;lt;UITableViewDelegate&amp;gt;   delegate;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图的行高(默认为44)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat rowHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat  sectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  sectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedRowHeight;&lt;/code&gt;&lt;br&gt;注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。&lt;/p&gt;
&lt;p&gt;下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的位置&lt;br&gt;&lt;code&gt;@property (nonatomic)UIEdgeInsets  separatorInset;&lt;/code&gt;&lt;br&gt;如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tab=[[&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; style:&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tab&lt;span class=&quot;variable&quot;&gt;.separatorInset&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, tab&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置tableView背景view视图&lt;br&gt;&lt;code&gt;@property(nonatomic, readwrite, retain) UIView *backgroundView;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用方法详解&quot;&gt;&lt;a href=&quot;#常用方法详解&quot; class=&quot;headerlink&quot; title=&quot;常用方法详解&quot;&gt;&lt;/a&gt;常用方法详解&lt;/h3&gt;&lt;p&gt;重载tableView&lt;br&gt;&lt;code&gt;- (void)reloadData;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重载索引栏&lt;br&gt;&lt;code&gt;- (void)reloadSectionIndexTitles;&lt;/code&gt;&lt;br&gt;这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。&lt;/p&gt;
&lt;p&gt;获取分区数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSections;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取行数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取分区的大小(包括头视图，所有行和尾视图)&lt;br&gt;&lt;code&gt;- (CGRect)rectForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区分别获取头视图，尾视图和行的高度&lt;br&gt;&lt;code&gt;- (CGRect)rectForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个点在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个cell在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过位置路径获取cell&lt;br&gt;&lt;code&gt;- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见的cell&lt;br&gt;&lt;code&gt;- (NSArray *)visibleCells;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见行的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForVisibleRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取头视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取尾视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到某一位置(行)&lt;br&gt;&lt;code&gt;- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPosition&lt;/span&gt;) &amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//同UITableViewScrollPositionTop   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的顶部        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionMiddle&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的中间      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionBottom&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView最下面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到选中行&lt;br&gt;&lt;code&gt;- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;这个函数与上面的非常相似，只是它是将表示图定位到选中的行。&lt;/p&gt;
&lt;h2 id=&quot;tableView操作刷新块的应用&quot;&gt;&lt;a href=&quot;#tableView操作刷新块的应用&quot; class=&quot;headerlink&quot; title=&quot;tableView操作刷新块的应用&quot;&gt;&lt;/a&gt;tableView操作刷新块的应用&lt;/h2&gt;&lt;p&gt;在介绍动画块之前，我们先看几个函数：&lt;br&gt;插入分区&lt;br&gt;&lt;code&gt;- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;animation参数是一个枚举，枚举的动画类型如下&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimation&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationFade&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//淡入淡出  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationRight&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从右滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationLeft&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从左滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从上滑入    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationBottom&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从下滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationNone&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//没有动画   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationMiddle&lt;/span&gt;,           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationAutomatic&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 自动选择合适的动画&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除分区&lt;br&gt;&lt;code&gt;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一个分区&lt;br&gt;&lt;code&gt;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ;&lt;/code&gt;&lt;br&gt;移动一个分区&lt;br&gt;&lt;code&gt;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;&lt;/code&gt;&lt;br&gt;插入一些行&lt;br&gt;&lt;code&gt;- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;删除一些行&lt;br&gt;&lt;code&gt;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一些行&lt;br&gt;&lt;code&gt;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;移动某行&lt;br&gt;&lt;code&gt;- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;&lt;/code&gt;&lt;br&gt;了解了上面几个函数，我们来看什么是操作刷新块：&lt;br&gt;当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。&lt;br&gt;IOS为我们提供了下面两个函数解决这个问题：&lt;br&gt;开始块标志&lt;br&gt;&lt;code&gt;- (void)beginUpdates;&lt;/code&gt;&lt;br&gt;结束快标志&lt;br&gt;&lt;code&gt;- (void)endUpdates;&lt;/code&gt;&lt;br&gt;我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下：&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab beginUpdates]&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]&lt;/span&gt;] &lt;span class=&quot;tag&quot;&gt;withRowAnimation&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:UITableViewRowAnimationLeft&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[dataArray removeObjectAtIndex:1]&lt;/span&gt;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[tab endUpdates]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：不要在这个块中调用reloadData这个方法，它会使动画失效。&lt;/p&gt;
&lt;h2 id=&quot;tableView的编辑操作&quot;&gt;&lt;a href=&quot;#tableView的编辑操作&quot; class=&quot;headerlink&quot; title=&quot;tableView的编辑操作&quot;&gt;&lt;/a&gt;tableView的编辑操作&lt;/h2&gt;&lt;p&gt;设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮)&lt;br&gt;&lt;code&gt;@property (nonatomic, getter=isEditing) BOOL editing;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)setEditing:(BOOL)editing animated:(BOOL)animated;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以被选中(默认为YES)&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell编辑模式下是否可以被选中&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑模式下是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;选中cell的相关操作&quot;&gt;&lt;a href=&quot;#选中cell的相关操作&quot; class=&quot;headerlink&quot; title=&quot;选中cell的相关操作&quot;&gt;&lt;/a&gt;选中cell的相关操作&lt;/h2&gt;&lt;p&gt;获取选中cell的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForSelectedRow;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取多选cell的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForSelectedRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码手动选中与取消选中某行&lt;br&gt;&lt;code&gt;- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;注意：这两个方法将不会回调代理中的方法。 &lt;/p&gt;
&lt;h2 id=&quot;tableView附件的相关方法&quot;&gt;&lt;a href=&quot;#tableView附件的相关方法&quot; class=&quot;headerlink&quot; title=&quot;tableView附件的相关方法&quot;&gt;&lt;/a&gt;tableView附件的相关方法&lt;/h2&gt;&lt;p&gt;设置索引栏最小显示行数&lt;br&gt;&lt;code&gt;@property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;设置索引栏字体颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏背景颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏被选中时的颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的风格&lt;br&gt;&lt;code&gt;@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle;&lt;/code&gt;&lt;br&gt;这个风格是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//无线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLine&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//有线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLineEtched&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置分割线颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor           *separatorColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线毛玻璃效果(IOS8之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic, copy) UIVisualEffect      *separatorEffect;&lt;/code&gt;&lt;br&gt;注意：这个属性是IOS8之后新的。&lt;/p&gt;
&lt;p&gt;设置tableView头视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableHeaderView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView尾视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableFooterView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池中取cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个已注册的cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池获取头视图或尾视图&lt;br&gt;&lt;code&gt;- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过xib文件注册cell&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过OC类注册cell&lt;br&gt; &lt;code&gt;- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier&lt;/code&gt;&lt;br&gt;上面两个方法是IOS6之后的方法。&lt;/p&gt;
&lt;p&gt;通过xib文件和OC类获取注册头视图和尾视图&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-UITableView的代理方法&quot;&gt;&lt;a href=&quot;#iOS-UITableView的代理方法&quot; class=&quot;headerlink&quot; title=&quot;iOS UITableView的代理方法&quot;&gt;&lt;/a&gt;iOS UITableView的代理方法&lt;/h2&gt;&lt;h3 id=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;a href=&quot;#UITableViewDataSource（数据源代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;/a&gt;UITableViewDataSource（数据源代理）&lt;/h3&gt;&lt;p&gt;1、必须实现的回调方法&lt;br&gt;返回每个分区的行数&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每一行的cell&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、可选实现的方法&lt;br&gt;返回分区数(默认为1)&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区头部的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区的尾部标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可编辑&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可以被移动&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引）&lt;br&gt;&lt;code&gt;- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题对应的分区&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;tableView接受编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyle&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//没有编辑操作  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleDelete&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//删除操作    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleInsert&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//插入操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tableView的cell被移动时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;a href=&quot;#UITableViewDelegate（tableView代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;/a&gt;UITableViewDelegate（tableView代理）&lt;/h3&gt;&lt;p&gt;cell将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;头视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尾视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的方法&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率)&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置自定义头视图和尾视图&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以高亮&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;cell高亮和取消高亮时分别调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经选中和已经取消选中后调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格&lt;br&gt;&lt;code&gt;- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义删除按钮的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。&lt;br&gt;&lt;code&gt;- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath*)indexPath ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑时背景是否缩进&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将要编辑和结束编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移动特定的某行&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;TableView性能优化&quot;&gt;&lt;a href=&quot;#TableView性能优化&quot; class=&quot;headerlink&quot; title=&quot;TableView性能优化&quot;&gt;&lt;/a&gt;TableView性能优化&lt;/h2&gt;&lt;p&gt;tableview优化两个思路：缓存操作和异步操作。&lt;br&gt;最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。&lt;/p&gt;
&lt;h3 id=&quot;cell复用机制。&quot;&gt;&lt;a href=&quot;#cell复用机制。&quot; class=&quot;headerlink&quot; title=&quot;cell复用机制。&quot;&gt;&lt;/a&gt;cell复用机制。&lt;/h3&gt;&lt;p&gt;如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先注册cell&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt; ()&amp;lt;&lt;span class=&quot;title&quot;&gt;UITableViewDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UITableViewDelegate&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tableView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *cellId = &lt;span class=&quot;string&quot;&gt;@&quot;Cell&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.delegate&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.dataSource&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第一种注册cell&amp;lt;nib文件类HomeTableViewCell&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.tableView&lt;/span&gt; registerNib:[&lt;span class=&quot;built_in&quot;&gt;UINib&lt;/span&gt; nibWithNibName:&lt;span class=&quot;string&quot;&gt;@&quot;HomeTableViewCell&quot;&lt;/span&gt; bundle:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;] forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第二种注册Cell&amp;lt;纯手工打造的HomeVC&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [self.tableView registerClass:[HomeVC class]forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重用相关API&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Cell：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forIndexPath:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Section 的 Header/Footer：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableHeaderFooterViewWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UITableViewCell *)&lt;span class=&quot;string&quot;&gt;tableView:&lt;/span&gt;(UITableView *)tableView &lt;span class=&quot;string&quot;&gt;cellForRowAtIndexPath:&lt;/span&gt;(NSIndexPath *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//获取重用池中的cell&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HomeTableViewCell *cell = [tableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果没有取到,就初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cell) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell = [[HomeTableViewCell alloc] &lt;span class=&quot;string&quot;&gt;initWithStyle:&lt;/span&gt;UITableViewCellStyleDefault &lt;span class=&quot;string&quot;&gt;reuseIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cell.cellNameLab.text = @&lt;span class=&quot;string&quot;&gt;&quot;Name&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;a href=&quot;#cell使用drawRect方法添加子控件&quot; class=&quot;headerlink&quot; title=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;/a&gt;cell使用drawRect方法添加子控件&lt;/h3&gt;&lt;p&gt;如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。&lt;/p&gt;
&lt;h3 id=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;a href=&quot;#高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot; class=&quot;headerlink&quot; title=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;/a&gt;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;- (CGSize)systemLayoutSizeFittingSize: (CGSize)targetSize&lt;/code&gt;&lt;br&gt;方法计算。&lt;/p&gt;
&lt;h3 id=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;a href=&quot;#避免快速滑动情况下开过多线程。&quot; class=&quot;headerlink&quot; title=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;/a&gt;避免快速滑动情况下开过多线程。&lt;/h3&gt;&lt;p&gt;cell中的图片开线程异步加载&lt;sdwebimage(异步操作)&gt;。但是线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; canLoad:Bool = !tableView&lt;span class=&quot;variable&quot;&gt;.dragging&lt;/span&gt; &amp;amp;&amp;amp; !tableView&lt;span class=&quot;variable&quot;&gt;.declearating&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;  canLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//开始loaddata，异步加载图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidScroll:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)sender&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//刷新tableview&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//在此刷新的是屏幕上显示的cell的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.table&lt;/span&gt; reloadData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/sdwebimage(异步操作)&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片处理&quot;&gt;&lt;a href=&quot;#图片处理&quot; class=&quot;headerlink&quot; title=&quot;图片处理&quot;&gt;&lt;/a&gt;图片处理&lt;/h3&gt;&lt;p&gt;1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。&lt;br&gt;2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示&lt;br&gt;3）避免对layer做过多的操作，尽量设置图片为不透明&lt;/p&gt;
&lt;h2 id=&quot;tableView的数据刷新&quot;&gt;&lt;a href=&quot;#tableView的数据刷新&quot; class=&quot;headerlink&quot; title=&quot;tableView的数据刷新&quot;&gt;&lt;/a&gt;tableView的数据刷新&lt;/h2&gt;&lt;p&gt;对tableView的刷新直接就是reloadData.调用这个方法之后,控制器会把数据源方法重新执行一遍,如果前面我们的数据需要保存,reloadData重新执行一遍,我们的数据都会被刷新掉,那么我改如何解决这个问题呢 ? 这就我们对其中某一个分组,或者某一个指定的Cell进行刷新.具体的代码实现如下,&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个section刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexSet *indexSet=[[NSIndexSet alloc]&lt;span class=&quot;string&quot;&gt;initWithIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableview &lt;span class=&quot;string&quot;&gt;reloadSections:&lt;/span&gt;indexSet &lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationAutomatic];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个指定cell刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexPath *indexPath=[NSIndexPath &lt;span class=&quot;string&quot;&gt;indexPathForRow:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;inSection:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableView &lt;span class=&quot;string&quot;&gt;reloadRowsAtIndexPaths:&lt;/span&gt;[NSArray &lt;span class=&quot;string&quot;&gt;arrayWithObjects:&lt;/span&gt;indexPath,nil] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationNone];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多参考资料：&quot;&gt;&lt;a href=&quot;#更多参考资料：&quot; class=&quot;headerlink&quot; title=&quot;更多参考资料：&quot;&gt;&lt;/a&gt;更多参考资料：&lt;/h3&gt;&lt;p&gt;优化UITableViewCell高度计算的那些事：&lt;a href=&quot;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&lt;/a&gt;&lt;br&gt;objc的期刊：更轻量的View Controller：&lt;a href=&quot;https://objccn.io/issue-1-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-1-1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView的基本信息&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中页面传值和页面跳转 </title>
    <link href="http://peilinghui.com/2016/07/02/iOS%E4%B8%AD%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <id>http://peilinghui.com/2016/07/02/iOS中页面传值和页面跳转/</id>
    <published>2016-07-02T02:32:09.000Z</published>
    <updated>2016-10-12T14:03:54.000Z</updated>
    
    <content type="html">&lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios的页面通信&quot;&gt;&lt;a href=&quot;#ios的页面通信&quot; class=&quot;headerlink&quot; title=&quot;ios的页面通信&quot;&gt;&lt;/a&gt;ios的页面通信&lt;/h2&gt;&lt;p&gt;开发过程中我们在页面传值时我们通常使用的方法有:属性传值法,block传值法,代理传值法,以及单例传值法,通知传值法。&lt;/p&gt;
&lt;h3 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;属性传值多用于在将前一个页面的值传到后一个页面去,也就是我们通常说的从前往后传值，  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当第一个页面push到第二个页面的时候.我们在第二个页面声明一个属性用于接受从第一个页面传递过去的值,然后在push这个事件被触发的时候进行赋值.&lt;br&gt;也就是说,先初始化创建第二个控制器(页面),然后通过创建的控制器来访问它所对应的属性,将即将传递的值赋给它,这样就完成了属性传值.于是当页面(控制器)被push到第二个页面之后我们访问它的属性的时候,也就顺便获取到了传递过来的值.&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;next:&lt;/span&gt;(UINavigationController *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ScondViewController *secondNC = [[ScondViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将第一个界面的输入框信息赋值给第二个页面的Label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondNC.tfString = _firstTF.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.navigationController &lt;span class=&quot;string&quot;&gt;pushViewController:&lt;/span&gt;secondNC &lt;span class=&quot;string&quot;&gt;animated:&lt;/span&gt;YES];   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代理传值多用于从后往前传值.只要在协议中声明一个协议方法，然后两个类一个作为委托方一个作为遵守方来调用和实现方法就可以实现传值。十分高效而且针对性很强。委托者：声明delegate属性，调用协议方法。被委托者：遵守协议，设定被委托者，覆写协议方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的.h中创建一个协议,并且设置代理属性,让其遵循该协议.&lt;br&gt;// 设置一个协议方法&lt;br&gt;@protocol SecondVCDelegate&lt;br&gt; // 代理传值    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)passValue:(NSString *)value;&lt;br&gt;@end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明代理属性进行代理传值&lt;br&gt;@property(nonatomic,weak)id delegate;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SecondViewController的导航控制器设置了右按钮(返回按钮),那么,我们只需要在其触发事件(back:)中调用代理方法去执行传值即可.&lt;br&gt;代码如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;back&lt;/span&gt;:(UINavigationController *)&lt;span class=&quot;tag&quot;&gt;sender&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[_delegate passValue:_secondTF.text]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[self.navigationController popViewControllerAnimated:YES]&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;然后在FirstViewController的next方法中为SecondNC制定其代理为其自身即可.&lt;/li&gt;
&lt;li&gt;实现其代理方法&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)passValue:(NSString *)&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;_f&lt;/span&gt;irstLab.text = &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样我们就可以在第一个页面得到第二个页面的值了.&lt;/p&gt;
&lt;h3 id=&quot;block传值&quot;&gt;&lt;a href=&quot;#block传值&quot; class=&quot;headerlink&quot; title=&quot;block传值&quot;&gt;&lt;/a&gt;block传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;block的本质就和其他OC中变量类似,只不过,block中存储的数据是函数体,但是在使用block时完全可以像调用其他函数似的,传入参数,然后得到返回值.从后往前传值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在SecondViewController中定义并声明block属性.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义有参无返回值的匿名函数(传递字符串)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^MyBlock)(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SecondViewController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)MyBlock block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的back方法中调用block,并且将在这个控制器的textField中的文字作为block的参数传递给block.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt;(_secondTF&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;FirstViewController的next方法中,也就是alloc出SecondViewController的时候调用SecondViewController的block,实现传值&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)temp = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secVC&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt; = ^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过回调将传进来的字符串赋值给label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp&lt;span class=&quot;variable&quot;&gt;.firstLab&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt; = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述代码中,因为block里面不能直接使用属性,实例变量和方法(因为会造成循环引用),所以我们重新用__weak修饰self并重新命名为temp.这样我们就实现了传值.&lt;/p&gt;
&lt;h3 id=&quot;通知传值&quot;&gt;&lt;a href=&quot;#通知传值&quot; class=&quot;headerlink&quot; title=&quot;通知传值&quot;&gt;&lt;/a&gt;通知传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类似于广播的一种传值模式，十分简单易用。一般负责在两个不同的类之间传值，且耦合度很低。这种方式中NSNotificationCenter担任一个中介者的身份，已提供观察者与被观察者相互传递信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C中使用NSNotifation表示通知，每个NSNotifation对象都具有名称name（NSNotificationCenter根据该名称检索此通知的所有观察者）、来源对象Poster-object（发布该通知的对象）和可选的userInfo字典（来源对象需要告诉观察者的额外信息NSDictionary）。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter就相当于一个俱乐部，只要一行代码一个类就能加入其中成为会员(Observer向NSNotificationCenter注册感兴趣信息)，当然这个类要告诉俱乐部它对哪些信息感兴趣，当有新的信息出现时，俱乐部会询问每一位会员这个信息是否是它们所需要的(Poster向NSNotificationCenter发送通知)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在ViewController中添加观察者&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;prepareForSegue:&lt;/span&gt;(UIStoryboardSegue *)segue &lt;span class=&quot;string&quot;&gt;sender:&lt;/span&gt;(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[NSNotificationCenter defaultCenter] &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;changeLabelText:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;改变名称&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中实现观察者接到消息之后执行的方法&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)changeLabelText:(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt;*)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.NameLabel&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;=sender&lt;span class=&quot;variable&quot;&gt;.userInfo&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在NextViewController.m中发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心发送通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSNotificationAction&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;* dic=@&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.nameTextField&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter] postNotificationName:&lt;span class=&quot;string&quot;&gt;@&quot;改变名称&quot;&lt;/span&gt; object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; userInfo:dic];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; dismissViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中要移除观察者&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除通知中心&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr_selector&quot;&gt;[[NSNotificationCenter defaultCenter]&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSNotificationCenter *)defaultCenter;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)postNotification:(NSNotification *)notification;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)removeObserver:(id)observer;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)removeObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地通知和远程推送通知&quot;&gt;&lt;a href=&quot;#本地通知和远程推送通知&quot; class=&quot;headerlink&quot; title=&quot;本地通知和远程推送通知&quot;&gt;&lt;/a&gt;本地通知和远程推送通知&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本地通知：由本应用负责调用，只能从当前设备上的iOS发出。&lt;br&gt;远程通知：由远程服务器上的程序发送至Apple Push Notification service(APNs)，再由APNs把消息推送住设备上对应的程序。&lt;/li&gt;
&lt;li&gt;本地通知是一个UILocalNotification对象，创建这个对象以后，就可以通过UIApplication的两个方法来发送通知了。&lt;br&gt;&lt;code&gt;- (void)presentLocalNotificationNow:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)scheduleLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;  // copies notification&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)cancelLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)cancelAllLocalNotifications NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程通知&lt;br&gt;UIApplication中注册远程push通知：&lt;br&gt;&lt;code&gt;- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;br&gt;调用下面方法：(重写应用程序委托类的3个方法)&lt;br&gt; &lt;code&gt;- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);&lt;/code&gt;- &lt;/p&gt;
&lt;h3 id=&quot;单例传值&quot;&gt;&lt;a href=&quot;#单例传值&quot; class=&quot;headerlink&quot; title=&quot;单例传值&quot;&gt;&lt;/a&gt;单例传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;由于单例在内存中只创建一次的并且可以全局访问的属性,我们可以在必要的时候将数据存放在单例的属性中,并且在必要的时候从单例中通过访问其属性进行调用,这样就实现值的传递&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *Str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明静态区对象的原因,希望程序运行期间,在内存中一直存在,这样对外界来说,可以随时读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DataHandle *dataHandle = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例(全局区)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; == dataHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 我们创建单例使用加号方法的原因是因为,在创建之前,无法存在一个实例对象去调用动态方法来创建它本身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataHandle = [[DataHandle alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataHandle; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只需要在需要的时候通过其类方法(+ (instancetype)sharedDataHandle)来创建出单例对象来,然后将textField的text属性以赋值的方式赋给单例的Srt属性即可.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVVM学习</title>
    <link href="http://peilinghui.com/2016/06/30/MVVM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/06/30/MVVM学习/</id>
    <published>2016-06-30T02:30:06.000Z</published>
    <updated>2016-07-01T15:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;大都APP是MVC的架构，而比如厚重的ViewController、遗失的网络逻辑（没有属于它的位置）、较差的可测试性等。。。&lt;br&gt;因此也就会有维护性较强、耦合性很低的一种新架构MVVM (MVC 引申出得新的架构)的流行。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;git地址：&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveViewModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ReactiveCocoa/ReactiveViewModel&lt;/a&gt;&lt;br&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View models are testable. Since they don’t need a view to do their work, presentation behavior can be tested without any UI automation or stubbing.&lt;/li&gt;
&lt;li&gt;View models can be used like models. If desired, view models can be copied or serialized just like a domain model. This can be used to quickly implement UI restoration and similar behaviors.&lt;/li&gt;
&lt;li&gt;View models are (mostly) platform-agnostic. Since the actual UI code lives in the view, well-designed view models can be used on the iPhone, iPad, and Mac, with only minor tweaking for each platform.&lt;br&gt;Views and view controllers are simpler. Once the important logic is moved elsewhere, views and VCs become dumb UI objects. This makes them easier to understand and redesign.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;大都APP是MVC的架构，而比如厚重的ViewController、遗失的网络逻辑（没有属于它的位置）、较差的可测试性等。。。&lt;br&gt;因此也就会有维护性较强、耦合性很低的一种新架构MVVM (MVC 引申出得新的架构)的流行。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习笔记</title>
    <link href="http://peilinghui.com/2016/06/29/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2016/06/29/ReactiveCocoa学习笔记/</id>
    <published>2016-06-29T08:24:44.000Z</published>
    <updated>2016-07-04T01:40:17.000Z</updated>
    
    <content type="html">&lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;官网文档地址：&lt;a href=&quot;https://github.com/peilinghui/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/ReactiveCocoa&lt;/a&gt;&lt;br&gt;学习一些优秀的博客地址：&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程二&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa简介&quot;&gt;&lt;a href=&quot;#ReactiveCocoa简介&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa简介&quot;&gt;&lt;/a&gt;ReactiveCocoa简介&lt;/h1&gt;&lt;p&gt;ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架.&lt;/p&gt;
&lt;p&gt;ReactiveCocoa结合了几种编程风格：&lt;/p&gt;
&lt;p&gt;函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。&lt;br&gt;响应式编程（Reactive Programming）：关注于数据流和变化传播。&lt;br&gt;ReactiveCocoa就被开发者们描述为响应式函数编程框架(FRP);使用RAC就不需要考虑调用的顺序,直接考虑结果,使得代码高聚合,方便管理.&lt;br&gt;一个优点提供了一个单一的、统一的方法去处理异步的行为，包括delegate方法,blocks回调,target-action机制,notifications和KVO.&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa使用&quot;&gt;&lt;a href=&quot;#ReactiveCocoa使用&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa使用&quot;&gt;&lt;/a&gt;ReactiveCocoa使用&lt;/h1&gt;&lt;h2 id=&quot;RACSiganl-RAC的核心类-信号类-用来数据传递&quot;&gt;&lt;a href=&quot;#RACSiganl-RAC的核心类-信号类-用来数据传递&quot; class=&quot;headerlink&quot; title=&quot;RACSiganl(RAC的核心类):信号类 用来数据传递&quot;&gt;&lt;/a&gt;RACSiganl(RAC的核心类):信号类 用来数据传递&lt;/h2&gt;&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 该信号默认是一个冷信号,当值改变了,也并不会触发改信号,只有订阅了该信号,才会触发改信号.
- 订阅信号的方法: subscribeNext:
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//1.创建一个信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RACSignal *singal = [RACSignal createSignal:^RACDisposable *(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;RACSubscriber&amp;gt; subscriber) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//2. 发送一个信号.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;Signal&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendCompleted];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [RACDisposable disposableWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//信号取消&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;信号被销毁&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//3. 订阅信号 ,激活信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [singal subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//x : 就是信号发送到数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;error:^(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;error = %@&quot;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; completed:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;completed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;a href=&quot;#RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot; class=&quot;headerlink&quot; title=&quot;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;/a&gt;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&lt;/h2&gt;&lt;p&gt;使用场景:通常用来代替代理，有了它，就不必要定义代理了。&lt;br&gt;RACReplaySubject:重复提供信号类，RACSubject的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject与RACSubject区别:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。
- 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。
- 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;RACSubject和RACReplaySubject简单使用&quot;&gt;&lt;a href=&quot;#RACSubject和RACReplaySubject简单使用&quot; class=&quot;headerlink&quot; title=&quot;RACSubject和RACReplaySubject简单使用:&quot;&gt;&lt;/a&gt;RACSubject和RACReplaySubject简单使用:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RACSubject使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
3.发送信号 sendNext:(id)value

**RACSubject:底层实现和RACSignal不一样**
1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。
2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.创建信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSubject *subject = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2.订阅信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第一个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第二个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3.发送信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;1&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSignal不一样，创建信号时没有block。
2.可以先订阅信号，也可以先发送信号。
   2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
   2.2 发送信号 sendNext:(id)value

// RACReplaySubject:底层实现和RACSubject不一样。
// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock

// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。
// 也就是先保存值，在订阅值。

// 1.创建信号
RACReplaySubject *replaySubject = [RACReplaySubject subject];

// 2.发送信号
[replaySubject sendNext:@1];
[replaySubject sendNext:@2];

// 3.订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第一个订阅者接收到的数据%@&amp;quot;,x);
}];

// 订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第二个订阅者接收到的数据%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RACSubject替换代理&lt;br&gt;    // 需求:&lt;br&gt;    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面&lt;br&gt;    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器&lt;/p&gt;
&lt;p&gt;步骤一：在第二个控制器.h，添加一个RACSubject代替代理。&lt;br&gt;@interface TwoViewController : UIViewController&lt;/p&gt;
&lt;p&gt;@property (nonatomic, strong) RACSubject *delegateSignal;&lt;/p&gt;
&lt;p&gt;@end&lt;/p&gt;
&lt;p&gt;步骤二：监听第二个控制器按钮点击&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; TwoViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)&lt;span class=&quot;attribute&quot;&gt;notice&lt;/span&gt;:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通知第一个控制器，告诉它，按钮被点了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 通知代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 判断代理信号是否有值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; (self.delegateSignal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 有值，才需要通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr_selector&quot;&gt;[self.delegateSignal sendNext:nil]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OneViewController&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)btnClick:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TwoViewController *twoVc = [[TwoViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 订阅代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;点击了通知按钮&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 跳转到第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; presentViewController:twoVc animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;替换Target和Action&quot;&gt;&lt;a href=&quot;#替换Target和Action&quot; class=&quot;headerlink&quot; title=&quot;替换Target和Action&quot;&gt;&lt;/a&gt;替换Target和Action&lt;/h2&gt;&lt;h3 id=&quot;TextField的字符变化&quot;&gt;&lt;a href=&quot;#TextField的字符变化&quot; class=&quot;headerlink&quot; title=&quot;TextField的字符变化&quot;&gt;&lt;/a&gt;TextField的字符变化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[self.textFild.rac_textSignal map:^id(id value) {
    NSLog(@&amp;quot;%@&amp;quot;, value);
    return @1;
}] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;, x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;构造的映射块value的值就是控件中的字符变化，根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回text.length，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。&lt;br&gt;&lt;strong&gt;filter&lt;/strong&gt;就是过滤，它可以帮助你筛选出你需要的信号变化。&lt;br&gt;take是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以take 2就是获取前两个信号，skip 2就是跳过前两个。repeat是重复发送信号。&lt;br&gt;&lt;strong&gt;delay&lt;/strong&gt;延时信号，顾名思义，即延迟发送信号.&lt;br&gt;&lt;strong&gt;throttle&lt;/strong&gt;搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。&lt;br&gt;&lt;strong&gt;distinctUntilChanged&lt;/strong&gt;网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。distinctUntilChanged的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。&lt;br&gt;&lt;strong&gt;timeout&lt;/strong&gt;超时信号，当超出限定时间后会给订阅者发送error信号。&lt;br&gt;&lt;strong&gt;ignore&lt;/strong&gt;忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。&lt;/p&gt;
&lt;h3 id=&quot;UIButton的事件的监听&quot;&gt;&lt;a href=&quot;#UIButton的事件的监听&quot; class=&quot;headerlink&quot; title=&quot;UIButton的事件的监听&quot;&gt;&lt;/a&gt;UIButton的事件的监听&lt;/h3&gt;&lt;p&gt;  [[button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {&lt;br&gt;        //这个x就是button,已经知道了类型就可以把id x 修改成UIButton *button&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }]; &lt;/p&gt;
&lt;h3 id=&quot;手势事件&quot;&gt;&lt;a href=&quot;#手势事件&quot; class=&quot;headerlink&quot; title=&quot;手势事件&quot;&gt;&lt;/a&gt;手势事件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UITapGestureRecognizer *tap =[[UITapGestureRecognizer alloc]init];
[[tap rac_gestureSignal] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
[self.view addGestureRecognizer:tap];   
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RAC的通知不需要移除remove observer，因为在rac_add方法中他已经写了remove&lt;/strong&gt;&lt;br&gt;[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];  &lt;/p&gt;
&lt;h3 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h3&gt;&lt;p&gt;//延迟一定时间做某事&lt;br&gt;    [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{&lt;br&gt;        NSLog(@”Ricky”);&lt;br&gt;    }];&lt;br&gt;//每个多长时间调用一次事件&lt;br&gt;    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];&lt;/p&gt;
&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;RACObserve(TARGET, KEYPATH)这种形式，TARGET是监听目标，KEYPATH是要观察的属性值&lt;br&gt;&lt;strong&gt;监听UIScrollView的contentOffset&lt;/strong&gt;&lt;br&gt;UIScrollView *scroller =[[UIScrollView alloc]initWithFrame:CGRectMake(100, 100, 100, 200)];&lt;br&gt;    [self.view addSubview:scroller];&lt;br&gt;    [RACObserve(scroller, contentOffset) subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];   &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt;
    
    </summary>
    
      <category term="RAC" scheme="http://peilinghui.com/categories/RAC/"/>
    
    
      <category term="RAC,学习笔记" scheme="http://peilinghui.com/tags/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的单元测试</title>
    <link href="http://peilinghui.com/2016/06/03/iOS%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://peilinghui.com/2016/06/03/iOS中的单元测试/</id>
    <published>2016-06-03T08:34:43.000Z</published>
    <updated>2016-06-03T10:32:01.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发中，我们不光有测试QA姐姐，还要自己测试一下自己的代码，这时测试就显得非常重要。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;软件测试有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单元测试：测试范围最小，仅仅是测试一个小单元(比如一个方法或一个函数)，对软件的稳定性有很大的帮助。&lt;/li&gt;
&lt;li&gt;集群测试：测试范围比较大，测试项目中的所有功能&lt;/li&gt;
&lt;li&gt;压力测试：模拟大批量数据\大批量用户&lt;br&gt;下面主要说一下单元测试的内容：&lt;br&gt;参考：&lt;a href=&quot;http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html&lt;/a&gt;&lt;br&gt;Xcode5以后默认有单元测试：&lt;br&gt;单元测试2大颜色:&lt;br&gt;1.红色 : 测试失败&lt;br&gt;2.绿色 : 测试通过&lt;br&gt;好处：轻量级的测试，不用完全跑程序；及时看到错误的地方；不像NSLog，不需要运行整个程序，更快；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;断言\猜测\估计：&lt;br&gt;XCTAssertEqual&lt;br&gt;XCTAssertTrue&lt;br&gt;XCTAssertFalse&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，我们不光有测试QA姐姐，还要自己测试一下自己的代码，这时测试就显得非常重要。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS调试技巧</title>
    <link href="http://peilinghui.com/2016/05/14/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://peilinghui.com/2016/05/14/iOS调试技巧/</id>
    <published>2016-05-14T09:50:17.000Z</published>
    <updated>2016-05-23T01:31:21.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;对于bug,我们要合理的假设，找原因；对原因与bug之间的因果关系进行分析。&lt;/p&gt;
&lt;h2 id=&quot;lldb的使用&quot;&gt;&lt;a href=&quot;#lldb的使用&quot; class=&quot;headerlink&quot; title=&quot;lldb的使用&quot;&gt;&lt;/a&gt;lldb的使用&lt;/h2&gt;&lt;p&gt;主要是打断点的时候使用lldb.&lt;/p&gt;
&lt;h3 id=&quot;查看值&quot;&gt;&lt;a href=&quot;#查看值&quot; class=&quot;headerlink&quot; title=&quot;查看值&quot;&gt;&lt;/a&gt;查看值&lt;/h3&gt;&lt;p&gt;1&amp;gt;非对象的值&lt;br&gt;&lt;code&gt;int a = 10;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) p a&lt;br&gt;(原始命令：p = print = expression –)&lt;br&gt;输出：(int)$0 = 10&lt;br&gt;(lldb)p 10 + 10&lt;br&gt;输出：$1 = 20  &lt;/p&gt;
&lt;p&gt;2&amp;gt;对象的值&lt;br&gt;&lt;code&gt;NSString *string = @“Hello，world”;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) po string&lt;br&gt;(原始命令：po = expression -o – = e -o –string)&lt;br&gt;输出：Hello，world  &lt;/p&gt;
&lt;p&gt;注意：清空控制台：command+K  &lt;/p&gt;
&lt;h3 id=&quot;修改变量的值&quot;&gt;&lt;a href=&quot;#修改变量的值&quot; class=&quot;headerlink&quot; title=&quot;修改变量的值&quot;&gt;&lt;/a&gt;修改变量的值&lt;/h3&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第一个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第二个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) e(代表expression表达式) a=11&lt;br&gt;输出：(int) $0 = 11  &lt;/p&gt;
&lt;h3 id=&quot;定义一个变量&quot;&gt;&lt;a href=&quot;#定义一个变量&quot; class=&quot;headerlink&quot; title=&quot;定义一个变量&quot;&gt;&lt;/a&gt;定义一个变量&lt;/h3&gt;&lt;p&gt;(lldb) e int $b = 20&lt;br&gt;(lldb) e int $b + $0&lt;br&gt;输出：(int) $1 = 31&lt;/p&gt;
&lt;h3 id=&quot;调用一个函数&quot;&gt;&lt;a href=&quot;#调用一个函数&quot; class=&quot;headerlink&quot; title=&quot;调用一个函数&quot;&gt;&lt;/a&gt;调用一个函数&lt;/h3&gt;&lt;p&gt;代码中：&lt;br&gt;&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; test]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;test&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;test被调用了&quot;&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(lldb) call [self init]&lt;br&gt;输出：test被调用了&lt;/p&gt;
&lt;h3 id=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;a href=&quot;#函数提前返回，返回一个特定值&quot; class=&quot;headerlink&quot; title=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;/a&gt;函数提前返回，返回一个特定值&lt;/h3&gt;&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; returnValue = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; testReturn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)testReturn&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) thread return 100&lt;br&gt;(lldb) p returnValue&lt;br&gt;输出：(NSInteger) $1 = 0&lt;br&gt;(NSInteger) $2 = 100&lt;/p&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;p&gt;1&amp;gt;继续运行 (相当于控制台第一个按钮)&lt;br&gt;c = continue = process continue&lt;br&gt;2&amp;gt;step over&lt;br&gt;n = next = thread step-over&lt;br&gt;3&amp;gt;step in(跳入函数)&lt;br&gt;s = thread step-in&lt;br&gt;4&amp;gt;step out(跳出函数)&lt;br&gt;finish = thread step-over&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络编程</title>
    <link href="http://peilinghui.com/2016/04/14/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://peilinghui.com/2016/04/14/iOS网络编程/</id>
    <published>2016-04-14T14:07:11.000Z</published>
    <updated>2016-07-16T00:56:39.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS网络编程知识总结&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS网络编程&quot;&gt;&lt;a href=&quot;#iOS网络编程&quot; class=&quot;headerlink&quot; title=&quot;iOS网络编程&quot;&gt;&lt;/a&gt;iOS网络编程&lt;/h1&gt;&lt;h2 id=&quot;检测网络状态&quot;&gt;&lt;a href=&quot;#检测网络状态&quot; class=&quot;headerlink&quot; title=&quot;检测网络状态&quot;&gt;&lt;/a&gt;检测网络状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;检查网络状态。&lt;br&gt;1&amp;gt;下载和添加Reachablity类.&lt;br&gt;2&amp;gt;为项目添加SystemConfiguration.framework框架。&lt;br&gt;若要手动禁用ARC源文件，输入框添加“-fno-objc-arc”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;a href=&quot;#使用CFNetwork实现TCP协议的通信&quot; class=&quot;headerlink&quot; title=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;/a&gt;使用CFNetwork实现TCP协议的通信&lt;/h2&gt;&lt;p&gt;CFNetwork对基于TCP协议的网络通信提供了良好的封装，CFNetwork使用CFSocket来代表两端的通信端口，还可以通过CFStream读/写数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IP地址是32位整数，分为A，B,C,D,E五类。用于唯一标识网络上的一个通信实体&lt;br&gt;A类：10.0.0.0~10.255.255.255&lt;br&gt;B类：172.16.0.0~172.31.255.255&lt;br&gt;C类：192.168.0.0~192.168.255.255&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;端口是16为整数，表示数据交给哪个通信程序处理，是应用程序和外界交流的出入口，包括一些数据结构和I/O。&lt;br&gt;公认端口：从0到1023，紧紧绑定一些特定的服务。&lt;br&gt;注册端口：从1024到49151，松散的绑定一些服务，适用于应用程序。&lt;br&gt;动态和/私有端口：从49152到65535.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP服务器端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个监听Socket Accept的CFSocket,并为kCFSocketAcceptCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketSetAddress()函数，将服务器的CFSocket绑定到本地IP地址和端口。&lt;br&gt;3&amp;gt;将CFSocket作为source添加到指定线程的CFRunLoop上，并运行该线程的CFRunLoop，从而保证该CFSocket能持续不断的接受来自客户端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP客户端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个不监听任何事件或监听Connection的CFSocket。如果要监听Connection，则需要为kCFSocketConnectCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketConnectionToAddress()函数，将客户端的CFSocket；连接到指定IP地址和端口的服务器上。&lt;br&gt;3&amp;gt;得到客户端CFSocket之后，既可直接使用CFSocketNativeHandle进行读/写，也可通过CFSocket获取CFReadStreamRef、CFWriteStreamRef后进行读、写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CocoaAsyncSocket实现TCP客户端&lt;br&gt;降低直接使用CFSocket编程的复杂度，另外有开发者提供了一套开源的CocoaAsyncSocket库。&lt;br&gt;CocoaAsyncSocket封装了CFNetwork底层的CFSocket和CFStream，并提供了异步操作，支持TCP和UDP。&lt;br&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞方式的读和写，而且可设置超时时长。&lt;/li&gt;
&lt;li&gt;自动的socket接受，如果调用它接受连接，它将为每个连接启动新的实例，当然也可以立即关闭这些连接。&lt;/li&gt;
&lt;li&gt;委托支持，错误、连接、接收、完整的读取、完整的写入、进度以及断开连接，都可通过代理模式调用。&lt;/li&gt;
&lt;li&gt;所有操作都封装在一个类中，开发者无需操作socket或流，该类封装了所有操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用NSURLConnection&quot;&gt;&lt;a href=&quot;#使用NSURLConnection&quot; class=&quot;headerlink&quot; title=&quot;使用NSURLConnection&quot;&gt;&lt;/a&gt;使用NSURLConnection&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用NSURLConnection从网络获取数据&lt;br&gt;方法:&lt;br&gt;&lt;code&gt;- (NSURLRequest *)originalRequest://获取该NSURLConnection最初的NSURLRequest对象的深拷贝&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSURLRequest *)currentRequest://返回该该NSURLConnection当前使用的NSURLRequest对象。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1&amp;gt;同步请求获取网络数据：&lt;br&gt;&lt;code&gt;+ sendSynchronousRequest:returningResponse:error:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;异步请求获取网络数据：&lt;br&gt;总指定一个NSURLConnectionDelegate对象，将该对象作为NSURLConnection的delegate，负责服务器响应到来的各种事件。&lt;br&gt;&lt;code&gt;+ connectionWithRequest:delegate://异步请求的方式获取数据&lt;/code&gt;&lt;br&gt;&lt;code&gt;- initWithRequest:delegate//实例方法，必须先调用alloc,再调用该方法。&lt;/code&gt;&lt;br&gt;&lt;code&gt;+ sendAsynchronousRequest:queue:CompletionHandler://表明将请求交给指定的NSOperationQueue处理&lt;/code&gt;&lt;br&gt;&lt;code&gt;- start://开始发送请求&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用使用NSURLConnection从网络获取数据的步骤：&lt;br&gt;1&amp;gt;创建NSURLRequest对象，该对象代表对远程服务器的请求。包括：请求的URL，缓存策略，超时时长等。&lt;br&gt;2&amp;gt;调用NSURLConnection的实例方法或类方法，以NSURLRequest对象为参数创建NSURLConnection即可发送请求。&lt;br&gt;3&amp;gt;以异步方式加载服务器响应，则需要为NSURLConnection对象指定delegate对象，因此还需要为delegate对象实现特定的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用NSMutableURLRequest向服务器发送请求&lt;br&gt;NSURLRequest只能想服务器发送简单的请求，不能添加请求头和请求参数，使用NSMutableURLRequest可以。&lt;br&gt;&lt;code&gt;-addValue:forHTTPHeaderField:为使用NSMutableURLRequest添加请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setAllHTTPHeaderField:通过一个NSDictionary一次性为NSMutableURLRequest设置多个请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBody:设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBodyStream:以NSInputStream为参数设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPMethod:设置提交请求方式，要么是POST，要么是GET。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPShouldHandleCookies:设置该HTTP请求是否处理Cookie。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setValue：forHTTPHeaderField：为指定的请求头设置请求值。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;XML解析&quot;&gt;&lt;a href=&quot;#XML解析&quot; class=&quot;headerlink&quot; title=&quot;XML解析&quot;&gt;&lt;/a&gt;XML解析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DOM与SAX&lt;br&gt;DOM：Document Object Model。文档对象模型、&lt;br&gt;SAX：Simple API for XML。&lt;br&gt;iOS SDK提供了NSXMLParser和libxml2两个类库，还有第三方库GDataXML，TBXML，TouchXML，KissXML等。&lt;br&gt;需要读取和修改XML文档，使用GDataXML，KissXML。&lt;br&gt;需要读取非常大的XML文档，使用libxml2或TBXML。&lt;/li&gt;
&lt;li&gt;NSXMLParser解析XML文档&lt;br&gt;步骤：&lt;ul&gt;
&lt;li&gt;创建NSXMLParser对象。&lt;/li&gt;
&lt;li&gt;为NSXMLParser对象指定delegate对象，该delegate对象必须实现NSXMLParserDelegate协议，并根据需要实现协议中特定的方法。&lt;/li&gt;
&lt;li&gt;调用NSXMLParser对象的parse方法开始解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;libxml2解析XML文档&lt;br&gt;使用C语言的库，准备步骤：&lt;ul&gt;
&lt;li&gt;为项目添加libxml2.dylib库&lt;/li&gt;
&lt;li&gt;添加头文件的搜索路径&lt;br&gt;步骤：    &lt;/li&gt;
&lt;li&gt;创建XMLTextReaderPtr对象.如果以本地XML文档来创建XMLTextReaderPtr对象，则调用XMLTextReaderFilename()函数即可。如果以内存中XML文档来创建该对象，则调用XMLReaderForMemeory（）函数即可。&lt;/li&gt;
&lt;li&gt;依次调用XMLTextReaderxxx()函数来读取XML文档的元素名，元素值，属性等各种内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML解析XML文档&lt;br&gt;第三方开源库，对libxml2的宝座，底层依赖libxml2，既支持解析XML文档 ，也支持修改XML文档，支持XPath方式查询，提供了更好的面向对象的封装。&lt;br&gt;准备步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 调用GDataXMLDocument的初始化方法根据XML文档或XML字符初始化GDataXMLDocument对象。（GDataXMLDocument对象就是XML文档转换得到的DOM树）
- 调用GDataXMLDocument对象的rootElement方法即可获取该文档的根元素
- 获取根元素后，就可以根据XML元素之间的父子关系来逐层遍历，访问该XML文档中的每一个元素，从而获取XML元素的内容。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;GDataXML生成XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法创建 GDataXMLelement对象，并以该对象作为XML文档的根元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法不断创建 GDataXMLelement对象（XML元素），并利用元素之间的父子关系组织这些XML元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLData方法获取XML文档对应的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML修改XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLDocument方法根据指定的XML文档或者XML字符串来生成对应的GDataXMLDocument对象–它代表了XML文档在内存中的形式。&lt;/li&gt;
&lt;li&gt;获取GDataXMLDocument对象的根元素，然后利用元素之间父子关系添加子元素、删除子元素或修改元素的内容。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对应的NSData 对象，调用NSdata的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;p&gt;JSON具有跨平台，跨语言的优势。两种数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 由key-value对组成的数据结构。
- 有序集合  
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;使用JSON语法创建对象&lt;br&gt;直接创建一个JavaScript对象，&lt;/li&gt;
&lt;li&gt;使用JSON语法创建数组&lt;br&gt;&lt;code&gt;var a = [&amp;#39;yeeku&amp;#39;,&amp;#39;nono&amp;#39;];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用NSJSONSerialization处理JSON数据 (系统自带)&lt;br&gt;满足条件：&lt;br&gt;顶级对象只能是NSArray或NSDictionary。&lt;br&gt;集合中包含对象只能是NSString，NSNumber，NSArray，NSDictionary或NSNull对象。&lt;br&gt;所有NSDictionary的key只能是NSString。&lt;br&gt;NSNumber保证的数值不是NaN或Infinity。  &lt;/li&gt;
&lt;li&gt;使用SBJson解析JSON数据&lt;br&gt;提供了两个工具类：SBJsonParser和SBJsonWriter.&lt;br&gt;SBJsonParser负责吧NSData或NSString形式的JSON数据转换为objective-c对象。&lt;br&gt;SBJSonWriter负责把objective-c对象转换为NSData或NSString形式的JSON数据。&lt;/li&gt;
&lt;li&gt;第三方类库解析JSON， 使用JSONKit解析JSON数据&lt;br&gt;地址：&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/johnezang/JSONKit&lt;/a&gt;&lt;br&gt;JSONKit速度快，JsonKit1.4不支持ARC，需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;JSONKit采用分类方式为已有的类增加了新方法。用于将JSON数据恢复为objective-c对象。&lt;br&gt;研究一下第三方框架就可以发现:&lt;br&gt;JSONKit用分类为NSString和NSDate增加了如下方法，&lt;br&gt;把JSON数据转换为OC对象：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JSONKit用分类为NSString、NSStringArray和NSDictionary增加了如下方法：将OC对象装潢为NSString和NSData形式的JSON数据。&lt;br&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSData&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONData&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSString&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONString&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;a href=&quot;#使用AFNetworking实现网络通信&quot; class=&quot;headerlink&quot; title=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;/a&gt;使用AFNetworking实现网络通信&lt;/h2&gt;&lt;p&gt;只是需要向web某个站点的某个简单页面提交请求并获取服务器响应，则使用NSURLConnection来完成。为了更好的处理web站点请求，包括处理Session,Cookie，可以用AFNetworking，用于发送HTTP请求，接受HTTP响应。但不会缓存服务器响应，不能执行HTML页面中嵌入的JavaScript代码，也不会对页面内容进行任何解析处理。AFNetworking还支持JSON、Plist属性文件和XML解析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提交GET请求与提交POST请求&lt;br&gt;步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建AFHTTRequestOperationManager对象。&lt;/li&gt;
&lt;li&gt;根据服务器响应内容不同，为HTTORequestOperationManager对象指定不同的解析器。（JSON或Plist数据）&lt;/li&gt;
&lt;li&gt;如果需要发送GET请求，调用AFHTTRequestOperationManager对象的GET：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;如果要发送POST请求，调用AFHTTRequestOperationManager对象的POST：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;在success：参数指定的代码块中处理服务器响应成功的正确数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理JSON和Plist响应&lt;br&gt;可以直接将JSON和Plist转化为NSArray或NSDictionary对象。  AFHTTORequestOperationManager默认可以处理JSON或Plist对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理XML响应&lt;br&gt;为AFHTTORequestOperationManager显示使用&lt;br&gt;AF X MLParserResponseSerializer响应解析器，当使用AF X MLParserResponseSerializer解析器时，服务器返回的数据是一个NSXMLParser对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传文件&lt;br&gt;AFHTTRequestOperationManager对象的POST：    parameters:constructingBodyWithBlock:success：failure：方法提交POST请求即可，多了三个参数，一个是带AFMultipartFormData形参的代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;a href=&quot;#使用ASIHTTPRequest框架实现网络编程&quot; class=&quot;headerlink&quot; title=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;/a&gt;使用ASIHTTPRequest框架实现网络编程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发送同步或异步的GET请求&lt;br&gt;准备步骤：&lt;br&gt;目前不支持ARC，应该需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用代码块&lt;br&gt;ASIHTTPRequest发送异步请求，即可使用delegate为ASIHTTPRequest设置回调处理代码，也可用代码块来设置回调处理代码。&lt;br&gt;&lt;code&gt;-setCompletionBlock:设置发送请求、获取服务器响应完成时激发的代码块。&lt;/code&gt;&lt;br&gt;`-setFailedBlock:获取发送请求失败时激发的代码块。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS网络编程知识总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>我的iOS学习之路</title>
    <link href="http://peilinghui.com/2016/04/01/%E6%88%91%E7%9A%84iOS%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    <id>http://peilinghui.com/2016/04/01/我的iOS学习之路/</id>
    <published>2016-04-01T05:01:49.000Z</published>
    <updated>2017-02-18T12:57:30.000Z</updated>
    
    <content type="html">&lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;effective-objective-c-2-0&quot;&gt;&lt;a href=&quot;#effective-objective-c-2-0&quot; class=&quot;headerlink&quot; title=&quot;effective objective-c 2.0&quot;&gt;&lt;/a&gt;effective objective-c 2.0&lt;/h1&gt;&lt;p&gt;作者网站：&lt;a href=&quot;http://www.galloway.me.uk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.galloway.me.uk/&lt;/a&gt;&lt;br&gt;英文原版：&lt;a href=&quot;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就把重点的几个摘录出来了。&lt;/p&gt;
&lt;h2 id=&quot;熟悉Objective-c&quot;&gt;&lt;a href=&quot;#熟悉Objective-c&quot; class=&quot;headerlink&quot; title=&quot;熟悉Objective-c&quot;&gt;&lt;/a&gt;熟悉Objective-c&lt;/h2&gt;&lt;h3 id=&quot;Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot;&gt;&lt;a href=&quot;#Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot; class=&quot;headerlink&quot; title=&quot;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&quot;&gt;&lt;/a&gt;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;消息结构 : 运行时所执行的代码由运行时环境决定
函数调用 : 运行时所执行的代码由编译期决定.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;code&gt;[person run];&lt;/code&gt;&lt;br&gt;给person对象发送一条run消息 : 不到程序运行的时候你都不知道他究竟会执行什么代码. 而且, person这个对象究竟是Person类的对象, 还是其他类的对象, 也要到运行时才能确定, 这个过程叫动态绑定.&lt;/p&gt;
&lt;p&gt;对象所占内存总是分配在堆空间中. 不能在栈中分配Objective-C对象.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;栈空间 : 栈空间的内存不用程序员管理.
堆空间 : 堆空间的内存需要程序员管理.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#第2条：在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;第2条：在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;p&gt;在.h文件中用@Class,在.m文件中再引入头文件。来缩短编译时间，降低彼此的依赖程度，降低类之间的耦合。&lt;/p&gt;
&lt;h3 id=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;a href=&quot;#第3条：多用字面量语法，少用与之等价的方法&quot; class=&quot;headerlink&quot; title=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;/a&gt;第3条：多用字面量语法，少用与之等价的方法&lt;/h3&gt;&lt;p&gt;字面量数值：&lt;code&gt;NSNumber *someNumber = @1;&lt;/code&gt;&lt;br&gt;字面量数组：&lt;code&gt;NSArray *animals=@[@&amp;quot;cat&amp;quot;,@&amp;quot;dog&amp;quot;,@&amp;quot;mouse&amp;quot;];&lt;/code&gt;  取某个下标所对应的对象更方便：&lt;code&gt;NSString *dog = animals[1]&lt;/code&gt;&lt;br&gt;字面量字典：&lt;code&gt;NSDictionary *personData = @{
                @&amp;quot;firstname&amp;quot;: @&amp;quot;pei&amp;quot;,
                @&amp;quot;lastname&amp;quot;: @&amp;quot;linghui&amp;quot;,
                @&amp;quot;age&amp;quot;: @&amp;quot;21&amp;quot;;
     };&lt;/code&gt;取值：&lt;code&gt;mutableDictionary[@&amp;quot;firstname&amp;quot;] = @&amp;quot;pei&amp;quot;;&lt;/code&gt;&lt;br&gt;使用字面量语法创建出来的字符串、数组、字典对象都是不可变的，若想变成可变的需在后面添加mutableCopy;&lt;/p&gt;
&lt;p&gt;我用们字面量语法替代传统的alloc-init来创建对象的好处 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方便直观
更加安全
更利于debug
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;局限性 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只有NSString, NSArray, NSDictionary, NSNumber支持字面量语法
若想用字面量语法创建出可变对象, 则需要再次调用mutableCopy方法复制多一份(多调用了一个方法, 多创建了一个对象. 不必要)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;p&gt;一般在工程中，会把常量定义在prefix.pch或者是一些接口常量定义在Constants.h文件中。更好的方法是在.m文件中用static与const来声明&lt;code&gt;static const NSTimeInterval Duration = 0.3&lt;/code&gt;&lt;br&gt;若是全局变量，则在.h中用extern关键字修饰，在.m文件中赋值。&lt;br&gt;&lt;code&gt;extern NSString *const TDFConstants&lt;/code&gt;&lt;br&gt;&lt;code&gt;NSString *const TDFConstants = @&amp;quot;VALUE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高.  &lt;/p&gt;
&lt;p&gt;宏能做到const不能办到的事.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;宏能定义函数
OC的单例模式用到宏
宏还能根据传入的参数生成字符串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么少用#define预处理指令?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用预处理指令定义的常量不含类型信息
编译时只会进行简单查找与替代操作, 会分配多次内存
如果有人重新定义了常量值, 则会导致程序中常量值不一致
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么多用类型常量?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在实现文件中使用static const定义只在该文件内可见的常量, 其他文件无法使用(无需给常量名称加前缀)
在头文件中使用extern来声明全局常量, 并在实现文件中定义其值, 可以供整个程序使用(需要给常量名称加前缀)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;a href=&quot;#第5条：用枚举表示状态、选项、状态码&quot; class=&quot;headerlink&quot; title=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;/a&gt;第5条：用枚举表示状态、选项、状态码&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CASH&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;现金&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CARD&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;银行卡&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CREDIT_ACCOUNT&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,   &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;挂账&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;constant&quot;&gt;KindPay_Kind&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项不需要组合使用, 则用NS_ENUM&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransition&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionNone&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromLeft&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromRight&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlUp&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlDown&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项可能组合使用, 则用NS_OPTIONS&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NS_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NSUInteger, UIViewAutoresizing)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingNone                 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleLeftMargin   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleWidth        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleRightMargin  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleTopMargin    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleHeight       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleBottomMargin = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码为苹果源码.&lt;strong&gt;使用NS_ENUM和NS_OPTIONS来替代C语言的enum的好处&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可以自定义枚举的底层数据类型
在C中使用C的语法, 在OC中使用OC的语法, 保持语法的统一
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外, 在处理枚举的switch语句中, 不要使用default分支, 因为以后你加入新枚举之后, 编译器会提示开发者 : switch语句没有处理所有枚举(没使用default的情况下).&lt;/p&gt;
&lt;h2 id=&quot;对象、消息、运行期&quot;&gt;&lt;a href=&quot;#对象、消息、运行期&quot; class=&quot;headerlink&quot; title=&quot;对象、消息、运行期&quot;&gt;&lt;/a&gt;对象、消息、运行期&lt;/h2&gt;&lt;h3 id=&quot;第6条：属性&quot;&gt;&lt;a href=&quot;#第6条：属性&quot; class=&quot;headerlink&quot; title=&quot;第6条：属性&quot;&gt;&lt;/a&gt;第6条：属性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;@property, @synthesize, @dynamic&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;@property&lt;/strong&gt;可以自动创建存取方法，帮我们分解成setter和getter方法声明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@synthesize firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上代码相当于给Person类添加一个_firstName的实例变量并为该实例变量生成setter和getter方法的实现(存取方法).&lt;br&gt;手动调用@synthesize可以用来修改实例变量的名称&lt;br&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@dynamic firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该代码会告诉编译器 : 不要自动创建实现属性(property)所用的实例变量(_property)和存取方法实现(setter和getter).&lt;br&gt;也就是说, 实例变量不存在了, 因为编译器不会自动帮你创建了. 而且如果你不手动实现setter和getter, 使用者用点语法或者对象方法调用setter和getter时, 程序会直接崩溃, 崩溃原因很简单 : unrecognized selector sent to instance&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 原子性：nonatomic不使用同步锁。
- 读写权限：readwrite(读写)有setter和getter由@synthesize自动实现；readonly(只读)只有getter方法
- 内存管理：assign：简单赋值(纯量)；strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。unsafe_retained:在属性所指对象遭到摧毁时，属性值不会清空，与assign类似，不过只用于对象。copy：与strong类似，但是不保留新值，而是拷贝，用于NSString。
- 方法名：getter=&amp;lt;name&amp;gt;;  setter=&amp;lt;name&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;a href=&quot;#第7条：在对象内部尽量直接访问实例变量&quot; class=&quot;headerlink&quot; title=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;/a&gt;第7条：在对象内部尽量直接访问实例变量&lt;/h3&gt;&lt;p&gt;为什么呢? 使用点语法不好吗? 这里说说区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接用_xxx访问实例变量而不用点语法可以绕过OC的&amp;quot;方法派发&amp;quot;, 效率比用点语法来访问快
直接用_xxx访问实例变量而不用点语法不会调用setter方法, 所以不会触发KVO(Key Value Observing), 同时如果你访问的该属性是声明为copy的属性, 则不会进行拷贝, 而是直接保留新值, 释放旧值.
使用点语法访问有助于debug, 因为可以在setter或getter中增加断点来监控方法的调用
属性使用懒加载时, 必须使用点语法, 否则实例变量永远不会初始化(因为懒加载实际就是调用getter方法, 直接访问实例变量绕过了该方法, 所以该变量则永远为nil)
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;在&lt;strong&gt;读取&lt;/strong&gt;实例变量的时候采用&lt;strong&gt;直接访问&lt;/strong&gt;的形式，在&lt;strong&gt;设置&lt;/strong&gt;实例变量的时候采用通过&lt;strong&gt;属性&lt;/strong&gt;。 &lt;/li&gt;
&lt;li&gt;在初始化方法以及dealloc方法中，直接通过实例变量来读写数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第8条：对象等同性&quot;&gt;&lt;a href=&quot;#第8条：对象等同性&quot; class=&quot;headerlink&quot; title=&quot;第8条：对象等同性&quot;&gt;&lt;/a&gt;第8条：对象等同性&lt;/h3&gt;&lt;p&gt;比较两个对象是否相同.&lt;br&gt;我们可以重写isEqual方法自定义对象等同的条件&lt;/p&gt;
&lt;h3 id=&quot;第9条：类族模式&quot;&gt;&lt;a href=&quot;#第9条：类族模式&quot; class=&quot;headerlink&quot; title=&quot;第9条：类族模式&quot;&gt;&lt;/a&gt;第9条：类族模式&lt;/h3&gt;&lt;p&gt;Objective-C的系统框架中普遍使用此模式, 用子类来隐藏”抽象基类”的内部实现细节.&lt;br&gt;我们肯定使用过UIButton的这个类方法&lt;/p&gt;
&lt;p&gt; &lt;code&gt;+ (UIButton *)buttonWithType:(UIButtonType)type;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这就是UIButton类实现的”工厂方法”, 根据传入的枚举创建并返回合乎条件的子类.&lt;/p&gt;
&lt;p&gt;Foundation框架中大部分容器类都是类族, 如NSArray与NSMutableArray, NSSet与NSMutableSet, NSDictionary与NSMutableDictionary.&lt;/p&gt;
&lt;p&gt;用isKindOfClass方法可以判断对象所属的类是否位于类族之中.&lt;/p&gt;
&lt;p&gt;在类族中实现子类时所需遵循的规范一般都会定义于基类的文档之中, 使用前应先看看.&lt;/p&gt;
&lt;p&gt;具体类族的使用方法大家请看书~~&lt;/p&gt;
&lt;h3 id=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;a href=&quot;#第10条：在既有类中使用关联对象存放自定义数据&quot; class=&quot;headerlink&quot; title=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;/a&gt;第10条：在既有类中使用关联对象存放自定义数据&lt;/h3&gt;&lt;p&gt;在类的内部利用哈希表映射技术, 关联一个与该类毫无耦合的对象.&lt;br&gt;使用场景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为现有的类添加私有变量以帮助实现细节
为现有的类添加公有属性
为KVO创建一个关联的观察者
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;鉴于书中所说, 容易出现循环引用, 以及关联对象释放和移除不同步等缺陷,&lt;/p&gt;
&lt;h3 id=&quot;第11条：理解objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#第11条：理解objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;第11条：理解objc_msgSend的作用&quot;&gt;&lt;/a&gt;第11条：理解objc_msgSend的作用&lt;/h3&gt;&lt;p&gt;消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。&lt;br&gt;OC的消息机制&lt;br&gt;&lt;code&gt;[someObject messageName: parameter]&lt;/code&gt;&lt;br&gt;&lt;code&gt;id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&amp;quot;方法列表&amp;quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&amp;quot;消息转发&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一些函数：&lt;br&gt;objc_msgSend_stret:待发送的消息要返回结构体&lt;br&gt;objc_msgSend_fpret:消息返回的是浮点数&lt;br&gt;objc_msgSendSuper:要给超类发送消息&lt;/p&gt;
&lt;h3 id=&quot;第12条：消息转发机制&quot;&gt;&lt;a href=&quot;#第12条：消息转发机制&quot; class=&quot;headerlink&quot; title=&quot;第12条：消息转发机制&quot;&gt;&lt;/a&gt;第12条：消息转发机制&lt;/h3&gt;&lt;p&gt;消息转发分为两大阶段：第一阶段：征询接受者，动态方法解析。&lt;br&gt;第二阶段：完整的消息转发机制，请接收者看看有没有其他对象能处理这条消息，若有，则把消息转给那个对象。若没有，则启动完整的消息转发机制，会把消息有关的细节全都封装到NSInvocation中去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析：对象收到无法解读的消息后，调用类方法：&lt;br&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)selector&lt;/code&gt;&lt;br&gt;要访问CoreData框架中的NSManagedObjects对象时，用resolveInstanceMethod来实现@dynamic属性。  &lt;/li&gt;
&lt;li&gt;备援接收者：能不能把这条消息传给其他接收者来处理&lt;br&gt;&lt;code&gt;-(id)forwardingTargetForSelector:(SEL)selctor;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完整的消息转发：首先，创建NSInvocation对象，把选择子，目标(target)及参数都封装于其中，在触发NSInvocation对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。&lt;br&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消息转发的全流程：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;以完整的例子演示动态方法解析&lt;br&gt;由开发者来添加属性定义，并将其声明为@dynamic，而类则会自动处理相关属性值的存放于获取操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第13条：用method-swizzling调试黑盒方法&quot;&gt;&lt;a href=&quot;#第13条：用method-swizzling调试黑盒方法&quot; class=&quot;headerlink&quot; title=&quot;第13条：用method swizzling调试黑盒方法&quot;&gt;&lt;/a&gt;第13条：用method swizzling调试黑盒方法&lt;/h3&gt;&lt;p&gt;method swizzling：与给定的选择子名称相对应得方法也可以在运行期改变。（不需要源码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能）可用在本类的所有实例中。&lt;strong&gt;使用另一份实现来替换原有的方法实现&lt;/strong&gt;&lt;br&gt;IMP指针：id(*IMP)(id,SEL,….)类的方法列表会吧选择子的名称映射到相关方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示。&lt;br&gt;互换两个方法的实现：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互换两个已经写好方法实现：(两个参数为待交换的两个方法实现)&lt;br&gt;&lt;code&gt;void method_exchangeImplementations(Method m1,Method m2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获得方法实现：&lt;br&gt;&lt;code&gt;Method class_getInstanceMethod(Class aClass,SEL aselector)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 来为既有的方法添加新功能，新方法添加在NSString的一个“分类”中，在方法中实现所需的附加功能，并调用原有的实现。
- 为完全不知道其具体实现的黑盒方法增加日志记录，有助于程序调试。不宜乱用
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;a href=&quot;#第14条：理解“类对象”的用意&quot; class=&quot;headerlink&quot; title=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;/a&gt;第14条：理解“类对象”的用意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Objective-c对象的本质：都是指向某块内存数据的指针，所以声明变量时，类型后面要加“&lt;em&gt;”字符。`NSString &lt;/em&gt;point= @“string”；&lt;code&gt;id类型本身就是指针。可以改写为&lt;/code&gt;id point= @“string”;`&lt;br&gt;描述objective-c对象所用的数据结构定义在runtime.h文件中，对于id，Class，还有is a 指针，涉及到runtime的机制，可以看这篇文章：&lt;a href=&quot;https://www.ianisme.com/ios/2019.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在类继承体系中查询类型信息&lt;br&gt;“isMemberOfClass”:能够判断出对象是否为某个特定类的实例。&lt;br&gt;“isKindOfClass”:能够判断出对象是否为某类或某派生类的实例。&lt;br&gt;通过使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。
如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。
尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;接口与API设计&quot;&gt;&lt;a href=&quot;#接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;接口与API设计&quot;&gt;&lt;/a&gt;接口与API设计&lt;/h2&gt;&lt;h3 id=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;a href=&quot;#第15条：用前缀避免命名空间的冲突&quot; class=&quot;headerlink&quot; title=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;/a&gt;第15条：用前缀避免命名空间的冲突&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;选择与你公司、应用程序或者二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。
若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。
Apple宣称保留使用所有两字母前缀的权利，所以自己所选用的前缀最好是三字母的。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;a href=&quot;#第16条：提供“全能初始化方法”&quot; class=&quot;headerlink&quot; title=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;/a&gt;第16条：提供“全能初始化方法”&lt;/h3&gt;&lt;h3 id=&quot;第17条：实现description方法&quot;&gt;&lt;a href=&quot;#第17条：实现description方法&quot; class=&quot;headerlink&quot; title=&quot;第17条：实现description方法&quot;&gt;&lt;/a&gt;第17条：实现description方法&lt;/h3&gt;&lt;p&gt;调试程序时，LLDB调试，在封装的JSONHelper中看到了这样的方法：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//对象转换为json对象.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSString *) &lt;span class=&quot;string&quot;&gt;transJson:&lt;/span&gt;(Jastor *) obj&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *returnDic = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *array =[JastorRuntimeHelper &lt;span class=&quot;string&quot;&gt;propertyNames:&lt;/span&gt;[obj &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;NSString&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;description&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;debugDescription&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;superclass&quot;&lt;/span&gt;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [returnDic &lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;[obj &lt;span class=&quot;string&quot;&gt;valueForKey:&lt;/span&gt;key] &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *returnString = [returnDic JSONString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中description在Foundation框架的NSString.h中&lt;br&gt;&lt;code&gt;@property (readonly, copy) NSString *description;&lt;/code&gt;&lt;br&gt;在objc的NSObject.h中&lt;br&gt;`+ (NSString *)description;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(NSString *)debugDescription;`&lt;br&gt;在Foundation框架的NSproxy.h中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;a href=&quot;#第18条：尽量使用不可变对象&quot; class=&quot;headerlink&quot; title=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;/a&gt;第18条：尽量使用不可变对象&lt;/h3&gt;&lt;h3 id=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;a href=&quot;#第19条：使用清晰而协调的命名方式&quot; class=&quot;headerlink&quot; title=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;/a&gt;第19条：使用清晰而协调的命名方式&lt;/h3&gt;&lt;h3 id=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;a href=&quot;#第20条：为私有方法名加前缀&quot; class=&quot;headerlink&quot; title=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;/a&gt;第20条：为私有方法名加前缀&lt;/h3&gt;&lt;p&gt;便于修改方法名或方法签名，可以使用- (void)p_private{};私有方法只在实现的时候声明。&lt;br&gt;不要单用一个下划线做私有方法的前缀，因为这种做法的预留给苹果公司用的。&lt;/p&gt;
&lt;h3 id=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;a href=&quot;#第21条：理解Objective-C错误模型&quot; class=&quot;headerlink&quot; title=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;/a&gt;第21条：理解Objective-C错误模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ARC下,想生成“异常安全”的代码，需要打开的编译器标志叫做-fobjc-arc-exception.&lt;/li&gt;
&lt;li&gt;objective-c所采用的方法：只在极其罕见的情况下抛出异常，异常抛出后，无需考虑恢复问题，而且应用程序此时也应该退出。最好的方法：在那些子类必须覆写的超类方法里抛出异常。令方法返回nil/0.或是使用NSError，以表明其中有错误发生。如：  &lt;/li&gt;
&lt;li&gt;初始化方法无法根据传入的参数来初始化当前实例，那么就可以令其返回nil/0。&lt;/li&gt;
&lt;li&gt;NSError：&lt;ul&gt;
&lt;li&gt;Error domain（类型为字符串）：用全局变量定义，在从URL中解析或取得数据时出错了，就使用NSURLErrorDomain来表示错误范围。&lt;/li&gt;
&lt;li&gt;Error code（类型为整数）：用enum定义，当HTTP请求出错时，可能会把HTTP状态码设置为错误码。&lt;/li&gt;
&lt;li&gt;User Info（类型为字典）：可将错误串成“错误链”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NSError的用法：&lt;ul&gt;
&lt;li&gt;通过委托协议来传递此错误。NSURLConnection在NSURLConnectionDelegate中定义了：&lt;code&gt;-(void)connection:(NSURLConnection *)connection didFail WithError:(NSError *)error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;经由方法的“输出参数”返回给调用者&lt;code&gt;-(BOOL)doSomething:(NSError **)error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结：&lt;br&gt; 只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;br&gt; 在错误不那么严重的情况下，可以指派委托方法来处理错误，也可把错误信息放在NSError对象里，经由输出参数返回给调用者。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;a href=&quot;#第22条：理解NSCopying协议&quot; class=&quot;headerlink&quot; title=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;/a&gt;第22条：理解NSCopying协议&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;若想令自己所写的对象具有拷贝功能，则需遵循NSCopying协议。&lt;br&gt;实现方法：&lt;code&gt;-(id)copyWithZone:(NSZone *)zone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。&lt;/li&gt;
&lt;li&gt;深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。&lt;br&gt;浅拷贝：在拷贝对象时，只拷贝容器对象本身，而不复制其中每个对象。（Foundation框架中的所有collection类在默认情况下执行浅拷贝）&lt;br&gt;复制对象时，一般执行浅拷贝。&lt;/li&gt;
&lt;li&gt;如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;协议与分类&quot;&gt;&lt;a href=&quot;#协议与分类&quot; class=&quot;headerlink&quot; title=&quot;协议与分类&quot;&gt;&lt;/a&gt;协议与分类&lt;/h2&gt;&lt;h3 id=&quot;第23条：通过delegate与data-source协议进行对象间通信&quot;&gt;&lt;a href=&quot;#第23条：通过delegate与data-source协议进行对象间通信&quot; class=&quot;headerlink&quot; title=&quot;第23条：通过delegate与data source协议进行对象间通信&quot;&gt;&lt;/a&gt;第23条：通过delegate与data source协议进行对象间通信&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Delegate pattern：定义一套接口，某对象若想接受另一个对象的委托，需遵从该接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。    &lt;/li&gt;
&lt;li&gt;好处：可将数据与业务解耦，如：页面有个显示一系列数据所用的视图，此视图只需要包含显示数据所需的逻辑代码，而不应该决定要显示何种数据以及数据之间如何交互。  &lt;/li&gt;
&lt;li&gt;委托协议名要在相关类名@protocol后面加Delegate，类中用一个用一个属性来存放其委托对象，&lt;code&gt;@property(nonatomic,weak)id&amp;lt;TDFNetworkingDelegate&amp;gt;delegate;&lt;/code&gt;必须设置为weak或unsafe_unretained（使用strong容易引入“保留环”）&lt;br&gt;委托协议常用@option来标注大部分或全部方法。&lt;/li&gt;
&lt;li&gt;委托模式：对象把应对某个行为的责任委托给另外一个类了。&lt;/li&gt;
&lt;li&gt;数据源模式：信息从data source流向Class再流向delegate。&lt;/li&gt;
&lt;li&gt;若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;a href=&quot;#第24条：将类的实现代码分散到便于管理的数个分类之中&quot; class=&quot;headerlink&quot; title=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;/a&gt;第24条：将类的实现代码分散到便于管理的数个分类之中&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用category机制把类的实现代码划分成易于管理的小块。&lt;/li&gt;
&lt;li&gt;将应该视为私有的方法归入名叫Private的分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;a href=&quot;#第25条：总是为第三方类的分类名称加前缀&quot; class=&quot;headerlink&quot; title=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;/a&gt;第25条：总是为第三方类的分类名称加前缀&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其名称加上你专用的前缀。&lt;/li&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;a href=&quot;#第26条：勿在分类中声明属性&quot; class=&quot;headerlink&quot; title=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;/a&gt;第26条：勿在分类中声明属性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;把封装数据所用的全部属性都定义在主接口里。&lt;/li&gt;
&lt;li&gt;在class-continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。&lt;/li&gt;
&lt;li&gt;如果需要在分类中为该属性实现存取方法，可以把存取方法声明为@dynamic。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;a href=&quot;#第27条：使用class-continuation分类隐藏实现细节&quot; class=&quot;headerlink&quot; title=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;/a&gt;第27条：使用class-continuation分类隐藏实现细节&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;class-continuation分类与普通分类不同，它必须定义在其所接续的那个类的实现文件中，唯一能声明实例变量的分类。&lt;/li&gt;
&lt;li&gt;作用：定义方法和实例变量。&lt;/li&gt;
&lt;li&gt;可以实现OC和C++的混编，如：网页浏览器的框架WebKit，大部分代码是C++，而对外显示的却是OC代码，CoreAnimation里面后端代码使用C++，对外公布却是OC接口。&lt;/li&gt;
&lt;li&gt;将public接口中声明为“只读”的属性扩展为“可读写”以便在类的内部使用其属性。（我们通常不直接访问实例变量，而是通过设置访问方法来做，因为这样能触发KVO通知，其他对象有可能监听此事件）&lt;h3 id=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;a href=&quot;#第28条：通过协议提供匿名对象&quot; class=&quot;headerlink&quot; title=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;/a&gt;第28条：通过协议提供匿名对象&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;第29条：理解引用计数&quot;&gt;&lt;a href=&quot;#第29条：理解引用计数&quot; class=&quot;headerlink&quot; title=&quot;第29条：理解引用计数&quot;&gt;&lt;/a&gt;第29条：理解引用计数&lt;/h3&gt;&lt;h3 id=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;a href=&quot;#第30条：以ARC简化引用计数&quot; class=&quot;headerlink&quot; title=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;/a&gt;第30条：以ARC简化引用计数&lt;/h3&gt;&lt;h3 id=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;a href=&quot;#第31条：在dealloc方法中只释放引用并解除监听&quot; class=&quot;headerlink&quot; title=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;/a&gt;第31条：在dealloc方法中只释放引用并解除监听&lt;/h3&gt;&lt;h3 id=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;a href=&quot;#第32条：编写异常安全代码时留意内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;/a&gt;第32条：编写异常安全代码时留意内存管理问题&lt;/h3&gt;&lt;h3 id=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;a href=&quot;#第33条：以弱引用避免重复引用&quot; class=&quot;headerlink&quot; title=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;/a&gt;第33条：以弱引用避免重复引用&lt;/h3&gt;&lt;h3 id=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;a href=&quot;#第34条：以自动释放池块降低内存峰值&quot; class=&quot;headerlink&quot; title=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;/a&gt;第34条：以自动释放池块降低内存峰值&lt;/h3&gt;&lt;h3 id=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;a href=&quot;#第35条：用“僵尸对象”调试内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;/a&gt;第35条：用“僵尸对象”调试内存管理问题&lt;/h3&gt;&lt;h3 id=&quot;第36条：不要使用retainCount&quot;&gt;&lt;a href=&quot;#第36条：不要使用retainCount&quot; class=&quot;headerlink&quot; title=&quot;第36条：不要使用retainCount&quot;&gt;&lt;/a&gt;第36条：不要使用retainCount&lt;/h3&gt;&lt;h2 id=&quot;block与GCD&quot;&gt;&lt;a href=&quot;#block与GCD&quot; class=&quot;headerlink&quot; title=&quot;block与GCD&quot;&gt;&lt;/a&gt;block与GCD&lt;/h2&gt;&lt;h3 id=&quot;第37条：理解block的概念&quot;&gt;&lt;a href=&quot;#第37条：理解block的概念&quot; class=&quot;headerlink&quot; title=&quot;第37条：理解block的概念&quot;&gt;&lt;/a&gt;第37条：理解block的概念&lt;/h3&gt;&lt;h3 id=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;a href=&quot;#第38条：为常用的block类型创建typedef&quot; class=&quot;headerlink&quot; title=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;/a&gt;第38条：为常用的block类型创建typedef&lt;/h3&gt;&lt;h3 id=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;a href=&quot;#第39条：用handler块降低代码分散程度&quot; class=&quot;headerlink&quot; title=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;/a&gt;第39条：用handler块降低代码分散程度&lt;/h3&gt;&lt;h3 id=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;a href=&quot;#第40条：用block引用其所属对象时不要出现循环引用&quot; class=&quot;headerlink&quot; title=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;/a&gt;第40条：用block引用其所属对象时不要出现循环引用&lt;/h3&gt;&lt;h3 id=&quot;第41条：多用派发队列，少用同步锁&quot;&gt;&lt;a href=&quot;#第41条：多用派发队列，少用同步锁&quot; class=&quot;headerlink&quot; title=&quot;第41条：多用派发队列，少用同步锁&quot;&gt;&lt;/a&gt;第41条：多用派发队列，少用同步锁&lt;/h3&gt;&lt;h3 id=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;a href=&quot;#第42条：用GCD，少用performSelector系列方法&quot; class=&quot;headerlink&quot; title=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;/a&gt;第42条：用GCD，少用performSelector系列方法&lt;/h3&gt;&lt;h3 id=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;a href=&quot;#第43条：掌握GCD及操作队列的使用时机&quot; class=&quot;headerlink&quot; title=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;/a&gt;第43条：掌握GCD及操作队列的使用时机&lt;/h3&gt;&lt;h3 id=&quot;第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot;&gt;&lt;a href=&quot;#第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot; class=&quot;headerlink&quot; title=&quot;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&quot;&gt;&lt;/a&gt;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&lt;/h3&gt;&lt;h3 id=&quot;第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot;&gt;&lt;a href=&quot;#第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot; class=&quot;headerlink&quot; title=&quot;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&quot;&gt;&lt;/a&gt;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&lt;/h3&gt;&lt;h3 id=&quot;第46条：不要使用dispatch-get-current-queue&quot;&gt;&lt;a href=&quot;#第46条：不要使用dispatch-get-current-queue&quot; class=&quot;headerlink&quot; title=&quot;第46条：不要使用dispatch_get_current_queue&quot;&gt;&lt;/a&gt;第46条：不要使用dispatch_get_current_queue&lt;/h3&gt;&lt;h2 id=&quot;系统框架&quot;&gt;&lt;a href=&quot;#系统框架&quot; class=&quot;headerlink&quot; title=&quot;系统框架&quot;&gt;&lt;/a&gt;系统框架&lt;/h2&gt;&lt;h3 id=&quot;第47条：熟悉系统框架&quot;&gt;&lt;a href=&quot;#第47条：熟悉系统框架&quot; class=&quot;headerlink&quot; title=&quot;第47条：熟悉系统框架&quot;&gt;&lt;/a&gt;第47条：熟悉系统框架&lt;/h3&gt;&lt;h3 id=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;a href=&quot;#第48条：多用块枚举，少用for循环&quot; class=&quot;headerlink&quot; title=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;/a&gt;第48条：多用块枚举，少用for循环&lt;/h3&gt;&lt;h3 id=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;a href=&quot;#第49条：队自定义其内存管理语义的collection使用无缝桥接&quot; class=&quot;headerlink&quot; title=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;/a&gt;第49条：队自定义其内存管理语义的collection使用无缝桥接&lt;/h3&gt;&lt;h3 id=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;a href=&quot;#第50条：构建缓存是选用NSCachae而非NSDictionary&quot; class=&quot;headerlink&quot; title=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;/a&gt;第50条：构建缓存是选用NSCachae而非NSDictionary&lt;/h3&gt;&lt;h3 id=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;a href=&quot;#第51条：精简initialize与load的实现代码&quot; class=&quot;headerlink&quot; title=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;/a&gt;第51条：精简initialize与load的实现代码&lt;/h3&gt;&lt;h3 id=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;a href=&quot;#第52条：别忘了NSTimer会保留其目标对象&quot; class=&quot;headerlink&quot; title=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;/a&gt;第52条：别忘了NSTimer会保留其目标对象&lt;/h3&gt;&lt;h1 id=&quot;Objective-C高级编程&quot;&gt;&lt;a href=&quot;#Objective-C高级编程&quot; class=&quot;headerlink&quot; title=&quot;Objective-C高级编程&quot;&gt;&lt;/a&gt;Objective-C高级编程&lt;/h1&gt;&lt;h2 id=&quot;ARC自动引用计数&quot;&gt;&lt;a href=&quot;#ARC自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;ARC自动引用计数&quot;&gt;&lt;/a&gt;ARC自动引用计数&lt;/h2&gt;&lt;p&gt;  Automatic Reference Counting，降低了程序崩溃、内存泄露的风险，很大程度上减少了开发程序的工作量。&lt;br&gt; 使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Xcode4.2或以上版本&lt;/li&gt;
&lt;li&gt;使用LLVM编译器3.0或以上版本&lt;/li&gt;
&lt;li&gt;编译器选项中设置ARC为有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或release代码&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存管理的思考方式&lt;br&gt;1&amp;gt; 自己生成的对象，自己持有&lt;br&gt;alloc,new,copy,mutablecopy(copy方法利用NSCopying方法约定，由各类实现copyWithZone：方法生成并持有不可变对象的副本)&lt;br&gt;2&amp;gt; 非自己生成的对象，自己持有&lt;br&gt;NSMutableArray类的array方法。使用retain方法可以持有&lt;br&gt;&lt;code&gt;id obj = [NSMutableArray array];
 [obj retain];&lt;/code&gt;&lt;br&gt;3&amp;gt;不再需要自己持有的对象时释放&lt;br&gt;用alloc\new\copy\mutableCopy方法生成并持有的对象，或用retain方法持有的对象，一旦不再需要，务必要用release进行释放。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4&amp;gt;无法释放非自己持有的对象&lt;br&gt;&lt;strong&gt;程序崩溃情况&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 再度释放已经释放了的对象
- 访问已经释放的对象时。
- 释放了非自己持有的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;alloc/retain/release/dealloc在GUNstep中的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在objective-c的对象中存有引用计数这一整数值&lt;/li&gt;
&lt;li&gt;调用alloc或是retain方法后，引用计数值加1.&lt;/li&gt;
&lt;li&gt;调用release后，引用计数值减1.&lt;/li&gt;
&lt;li&gt;引用计数值为0时，调用dealloc方法废弃对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GNUstep将用内存块头部管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;少量代码即可完成&lt;/li&gt;
&lt;li&gt;能够统一管理引用计数用内存块与对象用内存块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;苹果实现通过引用技术表来管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象用内存块的分配无需考虑内存块头部&lt;/li&gt;
&lt;li&gt;引用计数表各记录中存有内存块地址，可以从各个记录追溯到各对象的内存块。（在调试的时候，只要内存技术表没有被破坏，就可以确认各内存块的位置；使用工具检测内存泄露时，引用计数表的各记录也有助于检测各对象的持有者是否存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease的具体使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象。&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法。&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;RunLoop开始 -&amp;gt; 创建autoreleasepool -&amp;gt; 线程处理事件循环 -&amp;gt; 废弃autoreleasepool -&amp;gt; RunLoop结束 -&amp;gt; 等待下一个Loop开始&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;autorelease简介&lt;br&gt;1&amp;gt;autorelease方法的基本作用&lt;br&gt;给对象发送一条autorelease消息, 会将对象放到一个自动释放池中&lt;br&gt;当自动释放池被销毁时，会对池子里面的所有对象做一次release操作&lt;br&gt;会返回对象本身&lt;br&gt;调用完autorelease方法后，对象的计数器不变&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;autorelease的好处&lt;br&gt;不用再关心对象释放的时间&lt;br&gt;不用再关心什么时候调用release&lt;/p&gt;
&lt;p&gt;3&amp;gt;autorelease的使用注意&lt;br&gt;占用内存较大的对象不要随便使用autorelease&lt;br&gt;占用内存较小的对象使用autorelease，没有太大影响&lt;br&gt; &lt;strong&gt;release和autorelease区别&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;release立即释放，autorelease不立即释放，先放到autoreleasepool中，当pool结束后自动调用release。&lt;/p&gt;
&lt;p&gt;一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;autorelease的实现&lt;br&gt;autorelease实例方法的本质就是调用了NSAutoreleasePool对象的addObjective类方法。&lt;br&gt;可通过objc4库的runtime/objc-arr.mm来确认苹果中autorelease的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存不足的产生的例子？如何解决？&lt;br&gt;在for循环中读入大量图片的同时，改变其尺寸。图像文件读入到NSData对象，并从中产生UIImage对象，改变该尺寸后生成新的UIImage对象，这种情况就会产生大量的autorelease的对象。不废弃NSAutoreleasePool对象，那么生成的对象就不能释放，就会产生内存不足。&lt;br&gt;解决：在适当的地方生成、持有或废弃NSAutoreleasePool对象；&lt;br&gt;返回NSMutableArray类的arrayWithCapcity方法。来返回autorelease对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有权修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__strong
__weak
__unsafe_unretained
__autoreleasing
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;__strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARC中, id及其他对象默认就是&lt;strong&gt;strong修饰符修饰&lt;br&gt;MRC中, 使用&lt;/strong&gt;strong修饰符, 不必再次键入retain/release. 持有强引用的变量超出其作用域时被废弃, 随着强引用的失效, 引用的对象会随之释放.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__weak&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决循环引用问题. 并且弱引用的对象被废弃时, 则此弱引用将自动失效并等于nil&lt;/p&gt;
&lt;p&gt;通过__weak变量访问对象实际上必定是访问注册到autoreleasepool的对象, 因为该修饰符只持有对象的弱引用, 在访问对象的过程中, 该对象可能被废弃, 如果把要访问的对象注册到autoreleasepool中, 那么在block结束之前都能确保该对象存在.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不安全的修饰符, 附有该修饰符的变量不属于编译器的内存管理对象. 该修饰符与__weak一样, 是弱引用, 并不能持有对象.并且访问该修饰符的变量时如果不能确保其确实存在, 则应用程序会崩溃!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__autoreleasing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象赋值给&lt;strong&gt;autoreleasing修饰的变量相当于MRC下手动调用autorelease方法.可理解为, ARC下用@autoreleasepool block代替NSAutoreleasePool类, 用&lt;/strong&gt;autoreleasing修饰符的变量代替autorelease方法.&lt;br&gt;但是, 显式使用&lt;strong&gt;autoreleasing修饰符跟&lt;/strong&gt;strong一样罕见,&lt;/p&gt;
&lt;p&gt;ps : id的指针或者对象的指针会被隐式附上__autoreleasing修饰符, 如 :&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == id __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;ARC的规则&quot;&gt;&lt;a href=&quot;#ARC的规则&quot; class=&quot;headerlink&quot; title=&quot;ARC的规则&quot;&gt;&lt;/a&gt;ARC的规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置ARC有效的编译方法：&lt;ul&gt;
&lt;li&gt;使用clang（LLVM编译器）3.0或以上版本&lt;/li&gt;
&lt;li&gt;指定编译器属性为“-fobjc-arc”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有权修饰符&lt;br&gt;变量类型定义为id类型和各种对象类型。&lt;br&gt;对象类型：指向NSobject这样的OC指针，如：“NSObject &lt;em&gt;”&lt;br&gt;id类型：用于隐藏对象类型的类名部分，相当于C语言的“void &lt;/em&gt;”&lt;br&gt;1&amp;gt;&lt;strong&gt;strong修饰符（默认的）强引用，适用于普通对象,相当于MRC中的retain&lt;br&gt;2&amp;gt;&lt;/strong&gt;weak修饰符，弱引用，解决循环引用(很容易发生内存泄露), 相当于MRC中的assign.&lt;br&gt;3&amp;gt;&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符，和&lt;strong&gt;weak一样，自己生成并持有的对象不能继续为自己所有，所以生成的对象会立即释放。&lt;br&gt;4&amp;gt;&lt;/strong&gt;autorelease修饰符。&lt;br&gt;在ARC有效时，用@autorelease块代替NSAutoreleasePool类，用附有__autorelease修饰符的变量代替autorelease方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能使用retain/release/retainCount/autorelease&lt;/li&gt;
&lt;li&gt;不能使用NSAllocateObject/NSDeallocateObject(alloc实现实际上是通过直接调用NSAllocateObject函数来生成并持有对象, ARC下禁止使用NSAllocateObject函数与NSDeallocateObject函数)&lt;/li&gt;
&lt;li&gt;需遵循内存管理的方法命名规则&lt;/li&gt;
&lt;li&gt;不要显示调用dealloc(可以重写dealloc，但是不能调用[super dealloc])&lt;/li&gt;
&lt;li&gt;使用@autoreleasepool块代替NSAutoreleasePool&lt;/li&gt;
&lt;li&gt;不能使用区域（NSZone）&lt;/li&gt;
&lt;li&gt;对象型变量不能作为C语言结构体(struct/union)的成员(可强制转换为void *或者是添加&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符)&lt;/li&gt;
&lt;li&gt;显示转换id和“void &lt;em&gt;”（通过__bridge可以id和void &lt;/em&gt;相互转换，&lt;strong&gt;bridge&lt;/strong&gt;retain可使要转换赋值的变量也持有所赋值的对象相当于retain，&lt;strong&gt;bridge&lt;/strong&gt;transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放相当于release）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;br&gt;&lt;strong&gt; bridge_retained转换与retain类似, &lt;/strong&gt; bridge_transfer转换与release类似. 该两种转换多用于Foundation对象与Core Foundation对象之间的转换.&lt;br&gt;在ARC下, 以下可作为这种属性声明中使用的属性来用.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%888.13.46.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中.&lt;/p&gt;
&lt;h3 id=&quot;ARC的实现&quot;&gt;&lt;a href=&quot;#ARC的实现&quot; class=&quot;headerlink&quot; title=&quot;ARC的实现&quot;&gt;&lt;/a&gt;ARC的实现&lt;/h3&gt;&lt;p&gt;ARC是由编译器+运行时库共同完成的.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行. 它是用来持有返回注册在autoreleasepool中对象的方法.这个函数是成对的, 另外一个objc_autoreleaseReturnValue函数则用于alloc/new/copy/mutableCopy方法以外的类方法返回对象的实现上, 如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autoreleaseReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数有什么用?&lt;/p&gt;
&lt;p&gt;可以这样来总结 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果调用autorelease之后又紧接着调用retain的话, 这两部就显得多余, 所以以上两个函数就发挥其作用了.
用objc_autoreleaseReturnValue函数替代autorelease, 该函数检测如果对象紧接着会调用retain, 他就不调用autorelease了(并设置一个标志)
用objc_retainAutoreleasedReturnValue函数来替代retain, 该函数会检测对象的标志是否被设置, 如被设置, 则不调用retain; 反之则调用retain方法.
通过这两个函数能优化程序, 减少不必要的多余的操作.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;__weak修饰符&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;若附有__weak修饰符的变量所引用的对象被废弃, 则将nil赋值给该变量.
使用附有__weak修饰符的变量, 即是使用注册到autoreleasepool中的对象.
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id __weak obj1 = obj&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1 = 0&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, 0)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;访问__weak变量时, 相当于访问注册到autoreleasepool的对象&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = objc_loadWeakRetained(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objc_loadWeakRetained函数取出附有__weak修饰符变量所引用对象并retain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是, 通过&lt;strong&gt;weak变量访问所引用的对象几次, 对象就被注册到autoreleasepool里几次. (将附有&lt;/strong&gt;weak修饰符的变量赋值给附有&lt;strong&gt;strong修饰符的变量后再使用可避免此问题)
&lt;/strong&gt;autoreleasing修饰符&lt;/p&gt;
&lt;p&gt;将对象赋值给附有__autoreleasing修饰符的变量等同于MRC下调用对象的autorelease方法.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么调用alloc/new/&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;/mutableCopy以外的方法会怎样呢?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见注册autorelease的方法没有改变, 仍是objc_autorelease函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何获取引用计数值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取引用数值的函数&lt;br&gt;uinptr_t _objc_rootRetainCount(id obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSUInteger)retainCount;
该方法返回的引用计数不一定准确, 因为有时系统会优化对象的释放行为, 在保留计数为1的时候就把它回收. 所以你用这个方法打印出来的引用计数可能永远不会出现0. 我们不应该根据retainCount来调试程序!!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在的工程几乎都运行在ARC下, 所以大部分内存管理代码都不需要我们自己写, 而由编译器帮我们搞定. 所以在ARC下我们只需要怎样不要去破坏这个生态即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;避免循环引用(使用__weak修饰符)
遵循ARC方法命名规则
适时清空指针(赋值nil即可, 避免野指针错误)
如用到Core Foundation对象, 则在dealloc方法中释放
在dealloc方法中只释放引用并移除监听(不能在dealloc中开启异步任务)
对于内存开销较大的资源, 如file descriptor, socket, 大块内存等应在不需要使用的时候调用close方法释放掉而不是在dealloc中处理.
适当使用@autoreleasepool block来降低内存峰值(之前我写的一篇文章中有demo)
必要时开启&amp;quot;僵尸对象&amp;quot;调试内存管理问题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Block&quot;&gt;&lt;a href=&quot;#Block&quot; class=&quot;headerlink&quot; title=&quot;Block&quot;&gt;&lt;/a&gt;Block&lt;/h2&gt;&lt;h3 id=&quot;Block的概要&quot;&gt;&lt;a href=&quot;#Block的概要&quot; class=&quot;headerlink&quot; title=&quot;Block的概要&quot;&gt;&lt;/a&gt;Block的概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Block是带有自动变量(局部变量)的匿名函数(不带名称的函数)。Blocks 是闭包在 OC 语言中的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同而已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block语法：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;^void&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt; event)&lt;/span&gt;&lt;span class=&quot;collection&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	print&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;buttonId:%d event = %d\n&quot;&lt;/span&gt;,i,event)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特点：a.没有函数名  b.带有“^”号&lt;br&gt;&lt;code&gt;^  返回值类型  参数列表  表达式&lt;/code&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可代替 Delegate 完成回调，而不需要像 Delegate 那样繁琐
在某些方面，可代替 selector（如 NSNotificationCenter 在 addObserver 的时候，可以使用 block，而不用单独定义方法）
延长对象的生命周期（Block 会自动持有对象）
提高代码的复用性和可读性
常用于：View 动画、GCD、网络异步请求
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Block模式—block特性&quot;&gt;&lt;a href=&quot;#Block模式—block特性&quot; class=&quot;headerlink&quot; title=&quot;Block模式—block特性&quot;&gt;&lt;/a&gt;Block模式—&lt;strong&gt;block特性&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;截获自动变量值&quot;&gt;&lt;a href=&quot;#截获自动变量值&quot; class=&quot;headerlink&quot; title=&quot;截获自动变量值&quot;&gt;&lt;/a&gt;截获自动变量值&lt;/h4&gt;&lt;p&gt;“带有自动变量值”在Block中表现为“截获自动变量值”&lt;/p&gt;
&lt;p&gt;1&amp;gt; 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的. 也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 10&lt;/p&gt;
&lt;p&gt;2&amp;gt; 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 18&lt;/p&gt;
&lt;p&gt;第一种情况block内部不允许修改变量的值, 第二种情况下可以. (有例外, 静态变量, 静态全局变量, 全局变量即使不使用&lt;strong&gt;block修饰符也可以在block内部修改其值)&lt;br&gt;附有&lt;/strong&gt;block说明符的自动变量可在Block中赋值，该变量成为__block变量。&lt;/p&gt;
&lt;h4 id=&quot;截获对象&quot;&gt;&lt;a href=&quot;#截获对象&quot; class=&quot;headerlink&quot; title=&quot;截获对象&quot;&gt;&lt;/a&gt;截获对象&lt;/h4&gt;&lt;p&gt;对象不同于自动变量, 就算对象不加上&lt;strong&gt;block修饰符, 在block内部能够修改对象的属性.&lt;br&gt;block截获对象与截获自动变量有所不同.&lt;br&gt;堆块会持有对象, 而不会持有&lt;/strong&gt;block修饰的对象, 而栈块永远不会持有对象, 为什么呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;堆块作用域不同于栈块, 堆块可以超出其作用域地方使用, 所以堆块结构体内部会保留对象的强指针, 保证堆块在生命周期结束之前都能访问对象. 而对于__block对象为什么不会持有呢? 原因很简单, 因为__block对象会跟随block被复制到堆中, block再去引用堆中的__对象(后面会讲这个过程)..
栈块只能在当前作用域下使用, 所以其内部不会持有对象. 因为不存在在作用域之外访问对象的可能(栈离开当前作用域立马被销毁)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Block的实现&quot;&gt;&lt;a href=&quot;#Block的实现&quot; class=&quot;headerlink&quot; title=&quot;Block的实现&quot;&gt;&lt;/a&gt;Block的实现&lt;/h3&gt;&lt;h4 id=&quot;Block的实质&quot;&gt;&lt;a href=&quot;#Block的实质&quot; class=&quot;headerlink&quot; title=&quot;Block的实质&quot;&gt;&lt;/a&gt;Block的实质&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Blocks 的数据结构&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.35.54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应的结构体定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *dst, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *src);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*dispose)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_layout &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*invoke)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *, ...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor *descriptor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Imported variables. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过该图，我们可以知道，一个 Block 实例实际上由 6 部分构成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isa 指针: 所有对象都有该指针，用于实现对象相关的功能

flags: 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用；

reserved: 保留变量；

invoke: 函数指针，指向具体的 block 实现的函数调用地址；

descriptor: 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针；

variables: capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中；
copy : 用于保留捕获的对象
dispose : 用于释放捕获的对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Objective-C 中的 Stack 和 Heap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先所有的 Objective-C 对象都是分配在 Heap(堆) 的。 在 OC 最典型的内存分配与初始化就是这样的：&lt;/p&gt;
&lt;p&gt;NSObject *obj = [[NSObject alloc] init];&lt;/p&gt;
&lt;p&gt;一个对象在 alloc 的时候，就在 Heap 分配了内存空间。&lt;/p&gt;
&lt;p&gt;Stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 Heap 的呢？ 原因在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 Stack Frame（栈帧）就会被销毁。那么此时返回的对象也会一并销毁。这个时候我们去 retain 这个对象是无效的。因为整个 Stack Frame 都已经被销毁了。简单而言，就是 Stack 对象的生命周期不适合 OC 的引用计数内存管理方法。

Stack 对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的 Stack Frame。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Block-存储域&quot;&gt;&lt;a href=&quot;#Block-存储域&quot; class=&quot;headerlink&quot; title=&quot;Block 存储域&quot;&gt;&lt;/a&gt;Block 存储域&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;全局块(_NSConcreteGlobalBlock)程序的数据区域(.data区)
栈块(_NSConcreteStackBlock)
堆块(_NSConcreteMallocBlock)

全局块存在于全局内存中, 相当于单例.
栈块存在于栈内存中, 超出其作用域则马上被销毁
堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;全局块(_NSConcreteGlobalBlock)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block定义在全局变量的地方
block没有截获任何自动变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两个情况满足任意一个则该block为全局块, 全局块的生命周期贯穿整个程序, 相当于单例.全局的静态 Block，不会访问任何外部变量。&lt;br&gt;简单地讲，如果一个block钟没有引用外部变量并且没有被其他对象持有，就是NSConcreteGlobalBlock。NSConcreteGlobalBlock是全局的block，在编译期间就已经决定了，如同宏一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈块(_NSConcreteStackBlock)&lt;/strong&gt;&lt;br&gt;保存在栈中的 Block，当函数返回时会被销毁。（ARC 中系统实现了自动 copy, 将创建在栈上的 Block 自动拷贝到堆上，所以不存在此类型的 Block）NSConcreteStackBlock就是引用了外部变量的block，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆块(_NSConcreteMallocBlock)&lt;/strong&gt;&lt;br&gt;栈块copy之后就变成堆块，一个block被copy时，将生成NSConcreteMallocBlock（block没有retain）&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.51.44.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;只要这个NSConcreteMallocBlock存在，内部对象的引用计数就会+1。&lt;/p&gt;
&lt;h4 id=&quot;block变量的存储域&quot;&gt;&lt;a href=&quot;#block变量的存储域&quot; class=&quot;headerlink&quot; title=&quot;__block变量的存储域&quot;&gt;&lt;/a&gt;__block变量的存储域&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%8811.14.42.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;block的copy操作究竟做了什么呢?&lt;/p&gt;
&lt;p&gt;由上图可知, 对一个栈块进行copy操作会连同block与&lt;strong&gt;block变量(不管有没有使用)在内一同copy到堆上, 并且block会持有&lt;/strong&gt;block变量(使用).&lt;br&gt;ps : 堆上的block及__block变量均为对象, 都有各自的引用计数&lt;/p&gt;
&lt;p&gt;当然, 当block被销毁时, block持有的__block也会被释放&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;到这里我们能知道, 此思考方式与Objective-C的引用计数内存管理完全相同.&lt;/p&gt;
&lt;p&gt;那么有人就会问了, 既然&lt;strong&gt;block变量也被复制到堆上去了, 那么访问该变量是访问栈上的还是堆上的呢?? &lt;/strong&gt;forwarding 终于要闪亮登场了.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.19.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过&lt;strong&gt;forwarding, 无论实在block中, block外访问&lt;/strong&gt;block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量. &lt;/p&gt;
&lt;p&gt;那么Blocks提供的复制方法究竟是什么？&lt;br&gt;ARC有效的时候，大多数轻型下编译器会恰当的进行判断，自动生成将Block从栈上复制到堆上的代码。&lt;br&gt;ARC下, 以下几种情况下, 编译器会帮我们把栈上的block复制到堆中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block作为函数返回值返回时
将block赋值给__strong修饰符id类型或block类型成员变量时
在方法名中含有usingBlock的Cocoa框架方法或GCD的API中传递block时
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用Block的copy实例方法时&lt;br&gt;&lt;strong&gt;此外的情况需要手动对block调用copy方法&lt;/strong&gt;&lt;br&gt;把block作为函数/方法的参数传入时才需要对block进行copy操作.&lt;br&gt;我们对不同地方的block调用copy会产生什么效果呢?&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%883.12.58.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以, 不管block是什么类型, 在什么地方, 用copy方法都不会引起任何问题.如下表格所示. 就算是反复多次调用copy方法, 如&lt;/p&gt;
&lt;p&gt; &lt;code&gt;blk = [[[[blk copy] copy] copy] copy];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该源码可解释如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; tmp = [blk copy]; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blk = tmp; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// tmp超出作用域, 其指向的&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;也被释放, &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; tmp = [blk copy]; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blk = tmp; // blk指向的旧&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;释放, 并强引用新&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;, 最终&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// tmp超出作用域, 其指向的&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;也被释放, &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...下面不断重复该过程&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们知道, 这只是一个循环的过程, block被tmp持有 -&amp;gt; block被tmp和blk持有 -&amp;gt; block被blk持有 -&amp;gt; block被tmp和blk持有 -&amp;gt; ……&lt;/p&gt;
&lt;p&gt;由此可得知, 在ARC下该代码也没有任何问题. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结 : 如果block需要给作用域外的地方使用, 但是你不知道需不需要copy, 那就copy吧. 反正不会错&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Block-循环引用&quot;&gt;&lt;a href=&quot;#Block-循环引用&quot; class=&quot;headerlink&quot; title=&quot;Block 循环引用&quot;&gt;&lt;/a&gt;Block 循环引用&lt;/h4&gt;&lt;p&gt;如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，该对象为 Block 所持有，于是便导致了循环引用的产生。&lt;br&gt;self 持有 Block，Block 持有 self，这正是循环引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面对使用 block 变量避免循环引用的方法和使用 weak 修饰符及 __unsafe_unretained 修饰符避免循环引用的方法做个比较。  &lt;/p&gt;
&lt;p&gt;使用 __block 变量的优点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过 __block 变量可控制对象的持有期间

在不能使用 __weak 修饰符的环境中不使用 __unsafe_unretained 修饰符即可（不必担心 悬垂指针 ）

在执行 Block 时可动态地决定是否将 nil 或其他对象赋值在 __block 变量中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 __block 变量的缺点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为避免循环引用必须执行 Block

存在执行了 Block 语法，却不执行 Block 的路径时，无法避免循环引用。若由于 Block 引发了循环引用时，根据 Block 的用途选择使用 __block 变量、 __weak 修饰符或 __unsafe_unretained 修饰符来避免循环引用。

MRC下用__block可以避免循环引用(原因见上面block特性之截获自动变量值)
ARC下用__weak来避免循环引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要提醒大家的是, 只有堆块(_NSConcreteMallocBlock)才可能会造成循环引用, 其他两种block不会&lt;/p&gt;
&lt;h3 id=&quot;要点总结&quot;&gt;&lt;a href=&quot;#要点总结&quot; class=&quot;headerlink&quot; title=&quot;要点总结&quot;&gt;&lt;/a&gt;要点总结&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Block 执行的代码其实在编译的时候就已经准备好了

本身 Block 就是一个普通的 OC 对象。正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值

__block 修饰符在 MRC 下不会进行引用计数加 1，而 ARC 下则会加 1

对于 Block 外的变量引用，Block 默认是将其复制到其数据结构中来实现访问的

对于用 __block 修饰的外部变量引用，Block 是复制其引用地址来实现访问的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;br&gt;&lt;http: 28=&quot;&quot; 2013=&quot;&quot; blog.devtang.com=&quot;&quot; 07=&quot;&quot; a-look-inside-blocks=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/abeb5848b57a#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/abeb5848b57a#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;/http:&gt;&lt;/p&gt;
&lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;h3 id=&quot;GCD概要&quot;&gt;&lt;a href=&quot;#GCD概要&quot; class=&quot;headerlink&quot; title=&quot;GCD概要&quot;&gt;&lt;/a&gt;GCD概要&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;异步执行的技术之一，开发者只需要定义向执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(queue,^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(),^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//主线程可以执行的处理：用户页面更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程, 并发&lt;/strong&gt;&lt;br&gt; 一个应用就相当于一个进程, 而一个进程可以同时分发几个线程同时处理任务.而并发正是一个进程开启多个线程同时执行任务的意思, 主线程专门用来刷新UI,处理触摸事件等 而子线程呢, 则用来执行耗时的操作, 例如访问数据库, 下载数据等..&lt;br&gt;1个CPU执行的CPU命令列为一条无分叉路径，即为“线程”。&lt;br&gt;由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU能够并列执行多个线程一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的优势&lt;/strong&gt;&lt;br&gt;说到优势, 当然有比较, 才能显得出优势所在. 事实上, iOS中我们能使用的多线程管理技术有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pthread(来自Clang, 纯C语言, 需要手动创建线程, 销毁线程, 手动进行线程管理. 而且代码极其恶心, )
NSThread(Foundation框架下的OC对象, 依旧需要自己进行线程管理，线程同步。 线程同步对数据的加锁会有一定的开销。)
GCD(两个字, 牛逼, 虽然是纯C语言, 但是它用难以置信的非常简洁的方式实现了极其复杂的多线程编程, 而且还支持block内联形式进行制定任务. 简洁! 高效! 而且我们再也不用手动进行线程管理了.)
NSOperationQueue(相当于Foundation框架的GCD, 以面向对象的语法对GCD进行了封装. 效率一样高)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;GCD的API&quot;&gt;&lt;a href=&quot;#GCD的API&quot; class=&quot;headerlink&quot; title=&quot;GCD的API&quot;&gt;&lt;/a&gt;GCD的API&lt;/h3&gt;&lt;p&gt;在介绍GCD的API之前, 我们先搞清楚四个名词: 串行, 并行, 同步, 异步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;串行 : 一个任务执行完, 再执行下一个任务
并行 : 多个任务同时执行
同步 : 在当前线程中执行任务, 不具备开启线程的能力
异步 : 在新的线程中执行任务, 具备开启线程的能力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Dispatch Queue&lt;/strong&gt;&lt;br&gt;Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.队列分两种.&lt;br&gt;一种是串行队列(Serial Dispatch Queue),&lt;br&gt;一种是并行队列(Concurrent Dispatch Queue).  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch Queue的种类            说明  
Serial Dispatch Queue            等待现在执行中处理结束  
Concurrent Dispatch Queue       不等待现在执行中处理结束
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并发队列 : 让多个任务同时执行(自动开启多个线程执行任务)&lt;br&gt;并发功能只有在异步函数(dispatch_async)下才有效(想想看为什么?)&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%885.08.16.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建队列&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)&lt;/code&gt;&lt;br&gt; 手动创建一个队列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label : 队列的标识符, 日后可用来调试程序
attr : 队列类型
DISPATCH_QUEUE_CONCURRENT : 并发队列
DISPATCH_QUEUE_SERIAL 或 NULL : 串行队列
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是, 通过dispatch_queue_create函数生成的queue在使用结束后需要通过dispatch_release函数来释放.(只有在MRC下才需要释放)&lt;/p&gt;
&lt;p&gt;并不是什么时候都需要手动创建队列, 事实上系统给我们提供2个很常用的队列. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主队列&lt;/strong&gt;&lt;br&gt;dispatch_get_main_queue();&lt;br&gt;该方法返回的是主线程中执行的同步队列. 用户界面的更新等一些必须在主线程中执行的操作追加到此队列中.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局并发队列&lt;/strong&gt;&lt;br&gt;dispatch_get_global_queue(long identifier, unsigned long flags);&lt;br&gt;该方法返回的是全局并发队列. 使用十分广泛.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;identifier : 优先级
DISPATCH_QUEUE_PRIORITY_HIGH : 高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT : 默认优先级
DISPATCH_QUEUE_PRIORITY_LOW : 低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND : 后台优先级
flags : 暂时用不上, 传 0 即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 : 对Main Dispatch Queue和Global Dispatch Queue执行dispatch_release和dispatch_retain没有任何问题. (MRC)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_sync(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下同步执行block&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_async(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下异步执行block(开启新线程)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_time(dispatch_time_t when, int64_t delta);&lt;/code&gt;&lt;br&gt;根据传入的时间(when)和延迟(delta)计算出一个未来的时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;when :
DISPATCH_TIME_NOW : 现在
DISPATCH_TIME_FOREVER : 永远(别传这个参数, 否则该时间很大)
delta : 该参数接收的是纳秒, 可以用一个宏NSEC_PER_SEC来进行转换, 例如你要延迟3秒, 则为 3 * NSEC_PER_SEC.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;延迟执行&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_after(dispatch_time_t when, dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有了上述获取时间的函数, 则可以直接把时间传入, 然后定义该延迟执行的block在哪一个queue队列中执行.&lt;br&gt;苹果还给我们提供了一个在主队列中延迟执行的代码块, 如下&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;, &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;delayInSeconds&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            code to be executed after a specified delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要传入需要延迟的秒数(delayInSeconds)和执行的任务block就可以直接调用了, 方便吧~&lt;/p&gt;
&lt;p&gt;注意 : 延迟执行不是在指定时间后执行任务处理, 而是在指定时间后将处理追加到队列中, 这个是要分清楚的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列组&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_group_create();&lt;/code&gt;&lt;br&gt;有时候我们想要在队列中的多个任务都处理完毕之后做一些事情, 就能用到这个Group. 同队列一样, Group在使用完毕也是需要dispatch_release掉的(MRC).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栅栏&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dispatch_barrier_async(dispatch_queue_t queue, ^(void)block)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在访问数据库或文件时, 为了提高效率, 读取操作放在并行队列中执行. 但是写入操作必须在串行队列中执行(避免资源抢夺问题). 为了避免麻烦, 此时dispatch_barrier_async函数作用就出来了, 在这函数里进行写入操作, 写入操作会等到所有读取操作完毕后, 形成一道栅栏, 然后进行写入操作, 写入完毕后再把栅栏移除, 同时开放读取操作. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // code here
});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行10次代码, index顺序不确定. dispatch_apply会等待全部处理执行结束才会返回. 意味着dispatch_apply会阻塞当前线程. 所以dispatch_apply一般用于异步函数的block中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次性代码&lt;/strong&gt;&lt;br&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 只执行1次的代码(这里面默认是线程安全的)
});&lt;/code&gt;&lt;br&gt;该代码在整个程序的生命周期中只会执行一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂起和恢复&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_suspend(queue)&lt;/code&gt;&lt;br&gt;挂起指定的queue队列, 对已经执行的没有影响, 追加到队列中尚未执行的停止执行.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_resume(queue)&lt;/code&gt;&lt;br&gt;恢复指定的queue队列, 使尚未执行的处理继续执行. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的注意点&lt;/strong&gt;&lt;br&gt;因为在ARC下, 不需要我们释放自己创建的队列, 所以GCD的注意点就剩下死锁&lt;br&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;dispatch_sync&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;222&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;333&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三行代码将输出什么?&lt;br&gt;111&lt;br&gt;222&lt;br&gt;333 ?&lt;br&gt;还是&lt;br&gt;111&lt;br&gt;333 ?&lt;br&gt;其实都不对, 输出结果是&lt;br&gt;111&lt;br&gt;无疑问会先输出111, 然后在当前队列下调用dispatch_sync函数, dispatch_sync函数会把block追加到当前队列上, 然后等待block调用完毕该函数才会返回, 不巧的是, block在队列的尾端, 而队列正在执行的是dispatch_sync函数. 现在的情况是, block不执行完毕, dispatch_sync函数就不能返回, dispatch_sync不返回, 就没机会执行block函数. 这种你等我, 我也等你的情况就是死锁, 后果就是大家都执行不了, 当前线程卡死在这里.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免死锁?&lt;/strong&gt;&lt;br&gt;不要在当前队列使用同步函数, 在队列嵌套的情况下也不允许. 如下图,&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AD%BB%E9%94%81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;队列嵌套调用同步函数引发死锁&lt;/p&gt;
&lt;p&gt;大家可以想象, 队列1执行完NSLog后到队列2中执行NSLog, 队列2执行完后又跳回队列1中执行NSLog, 由于都是同步函数, 所以最内层的NSLog(“333”); 追加到队列1中, 实际上最外层的dispatch_sync是还没返回的, 所以它没有执行的机会. 也形成死锁. 运行程序, 果不其然, 打印如下 :&lt;br&gt;111&lt;br&gt;222&lt;/p&gt;
&lt;h3 id=&quot;GCD实现-GCD的使用场景&quot;&gt;&lt;a href=&quot;#GCD实现-GCD的使用场景&quot; class=&quot;headerlink&quot; title=&quot;GCD实现.(GCD的使用场景)&quot;&gt;&lt;/a&gt;GCD实现.(GCD的使用场景)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是GCD最常用的使用场景了, 如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 执行耗时操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;()&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 回到主线程作刷新UI等操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不阻塞主线程, 我们总是在后台线程中发送网络请求, 处理数据, 然后再回到主线程中刷新UI界面.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例&lt;/strong&gt;&lt;br&gt;     &lt;br&gt;单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了dispatch_once函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列和锁&lt;/strong&gt;&lt;br&gt;利用队列, 实现getter方法可以并发执行, 而setter方法串行执行并且setter和getter不能并发执行呢??? 没错, 我们这里用到了dispatch_barrier_async函数.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; )myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; localMyString = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        localMyString = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; localMyString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setMyString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_barrier_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _myString = myString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里利用了栅栏块必须单独执行, 不能与其他块并行的特性, 写入操作就必须等当前的读取操作都执行完毕, 然后单独执行写入操作, 等待写入操作执行完毕后再继续处理读取. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;它是BSD系内核惯有功能kqueue的包装. kqueue的CPU负荷非常小, 可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种. &lt;/p&gt;
&lt;h1 id=&quot;objective-c编程之道ios设计模式解析&quot;&gt;&lt;a href=&quot;#objective-c编程之道ios设计模式解析&quot; class=&quot;headerlink&quot; title=&quot;objective-c编程之道ios设计模式解析&quot;&gt;&lt;/a&gt;objective-c编程之道ios设计模式解析&lt;/h1&gt;&lt;h2 id=&quot;第七章-单例模式&quot;&gt;&lt;a href=&quot;#第七章-单例模式&quot; class=&quot;headerlink&quot; title=&quot;第七章 单例模式&quot;&gt;&lt;/a&gt;第七章 单例模式&lt;/h2&gt;&lt;p&gt;单例模式：它可以保证某个类创建出来的对象永远只有1个。类的一个对象成为系统中的唯一实例。&lt;strong&gt;一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;br&gt;定义包含三层含义：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须向整个系统提供这个实例。&lt;/p&gt;
&lt;h3 id=&quot;何时使用单例&quot;&gt;&lt;a href=&quot;#何时使用单例&quot; class=&quot;headerlink&quot; title=&quot;何时使用单例&quot;&gt;&lt;/a&gt;何时使用单例&lt;/h3&gt;&lt;p&gt;1.类只能有一个实例。&lt;br&gt;2.这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。&lt;/p&gt;
&lt;h3 id=&quot;单例模式的实现&quot;&gt;&lt;a href=&quot;#单例模式的实现&quot; class=&quot;headerlink&quot; title=&quot;单例模式的实现&quot;&gt;&lt;/a&gt;单例模式的实现&lt;/h3&gt;&lt;p&gt;在Objective-C中实现单例模式，需要完成如下四个步骤：&lt;/p&gt;
&lt;p&gt;第一步：定义一个静态实例变量mySingleton(名字可以自己取)，初始化为nil，代码如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static MySingleton *mySingleton = nil;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：实现一个类方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// mySingleton = [[super allocWithZone:NULL]init];    如果在self中重载了基本的对象分配方法，就需要借用父类(NSObject)的功能，来帮助处理底层内存分配的杂务   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; dispatch_once函数是GCD中的API，它保证应用程序即使在多线程环境下，也只执行一次。当然，也可以使用@synchronize来达到线程安全的目的，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三步：重写allocWithZone方法，用来保证使用alloc和init试图获得一个新实例的时候不产生新实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:zone];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四步：适当实现copyWithZone，release和autorelease等方法。代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果有其他初始化操作，可在这里进行初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 防止外界拷贝造成多个实例，保证实例的唯一性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)copyWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，所以retain不能增加引用计数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)retain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，设置默认引用计数。这里是取的NSUinteger的最大值，当然也可以设置成1或其他值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)retainCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UINT_MAX&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// denotes an object that cannot be released&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// oneway是用于多线程编程中，表示单向执行，不能“回滚”，即原子操作。该方法是空的,不让用户release掉这个对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;oneway&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//除了返回单例外，什么也不做。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)autorelease&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 该方法永远不会被调用,因为在程序的生命周期内容，该单例一直都存在。（所以该方法可以不实现）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; dealloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;子类化Singleton&quot;&gt;&lt;a href=&quot;#子类化Singleton&quot; class=&quot;headerlink&quot; title=&quot;子类化Singleton&quot;&gt;&lt;/a&gt;子类化Singleton&lt;/h3&gt;&lt;p&gt;【补充】说明，对于第二步和第三步可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过返回当前的sharedInstance实例，就能防止实例化一个新的对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sharedInstance] retain];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;alloc调用被转发给super，意味着NSObject晖处理对象分配，如果不做修改的子类化Singleton，返回的实例总是Single。因为Singleton重载了所以实例化相关的方法，实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonSon&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton *shareSingleton=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//向上转型，重定义自己的sharedsingleton类变量，不与父类共享。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(SingletonSon *) shareInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(sharedSingleton==&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//不调用父类alloc方法，在此调用父类alloc方法可能回调此方法，从而产生死循环，我们直接创建对象。(重点下面函数)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     sharedSingleton=[&lt;span class=&quot;built_in&quot;&gt;NSAllocateObject&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;// 子类可以重写一下retain copy release autorelease进行合适的内存管理。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;单例模式在IOS中的应用&quot;&gt;&lt;a href=&quot;#单例模式在IOS中的应用&quot; class=&quot;headerlink&quot; title=&quot;单例模式在IOS中的应用&quot;&gt;&lt;/a&gt;单例模式在IOS中的应用&lt;/h3&gt;&lt;p&gt;单例模式在IOS中的应用非常广泛，如&lt;br&gt;　　[NSNotificationCenter defaultCenter]、&lt;br&gt;　　[UIApplication sharedApplication]、&lt;br&gt;　　[NSFileManager defaultManager]&lt;br&gt;　　[UIAccelerometer sharedAccelerometer]接收来自单例实例的加速度数据等。
　　
　　
　　
　　
　　
　　
　　
　　&lt;/p&gt;
&lt;h1 id=&quot;精通iOS开发&quot;&gt;&lt;a href=&quot;#精通iOS开发&quot; class=&quot;headerlink&quot; title=&quot;精通iOS开发&quot;&gt;&lt;/a&gt;精通iOS开发&lt;/h1&gt;&lt;h3 id=&quot;响应者链&quot;&gt;&lt;a href=&quot;#响应者链&quot; class=&quot;headerlink&quot; title=&quot;响应者链&quot;&gt;&lt;/a&gt;响应者链&lt;/h3&gt;&lt;p&gt;以UIResponder作为超类的任何类都是响应者。&lt;br&gt;iOS中的响应者链的概念:&lt;br&gt;每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。&lt;br&gt; 例子:&lt;/p&gt;
&lt;p&gt;我用SingleView模板创建了一个新的工程，它的主Window上只有一个UIViewController，其View之上有一个Button。这个项目中所有UIResponder的子类所构成的N叉树为这样的结构:&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/responseder.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;事件传递机制：  &lt;/p&gt;
&lt;p&gt;1.当iOS程序中发生触摸事件后，系统会将事件加入到UIApplication管理的一个任务队列中&lt;br&gt;2.UIApplication将处于任务队列最前端的事件向下分发。即UIWindow。&lt;br&gt;3.UIWindow将事件向下分发，即UIView。&lt;br&gt;4.UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。&lt;br&gt;5.遍历子控件，重复以上两步。&lt;br&gt;6.如果没有找到，那么自己就是事件处理者。&lt;br&gt;7.如果自己不能处理，那么不做任何处理。&lt;br&gt;其中 UIView不接受事件处理的情况主要有以下三种&lt;br&gt;1）alpha &amp;lt;0.01&lt;br&gt;2)userInteractionEnabled = NO&lt;br&gt;3).hidden ＝ YES&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://peilinghui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常用算法</title>
    <link href="http://peilinghui.com/2016/03/28/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://peilinghui.com/2016/03/28/常用算法/</id>
    <published>2016-03-28T14:31:18.000Z</published>
    <updated>2016-04-25T06:40:15.000Z</updated>
    
    <content type="html">&lt;p&gt;常用的算法题总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;h3 id=&quot;排序题与sort函数的应用&quot;&gt;&lt;a href=&quot;#排序题与sort函数的应用&quot; class=&quot;headerlink&quot; title=&quot;排序题与sort函数的应用&quot;&gt;&lt;/a&gt;排序题与sort函数的应用&lt;/h3&gt;&lt;p&gt;用C++中的sort来实现排序，定义结构体struct存放学生信息；cmp函数的编写，提供cmp函数实现的排序规则；排名的实现：主要是分数相同的占用同一个排位。&lt;/p&gt;
&lt;h4 id=&quot;A1025-PAT排序&quot;&gt;&lt;a href=&quot;#A1025-PAT排序&quot; class=&quot;headerlink&quot; title=&quot;A1025.PAT排序&quot;&gt;&lt;/a&gt;A1025.PAT排序&lt;/h4&gt;&lt;p&gt;题意：n个考场，每个考场有若干数量的考生，给出考生的准考证号和成绩然后按顺序输出所以考生的准考证号，排名、考场号、考场内排名。&lt;br&gt;Sample Input:&lt;br&gt;2&lt;br&gt;5&lt;br&gt;1234567890001 95&lt;br&gt;1234567890005 100&lt;br&gt;1234567890003 95&lt;br&gt;1234567890002 77&lt;br&gt;1234567890004 85&lt;br&gt;4&lt;br&gt;1234567890013 65&lt;br&gt;1234567890011 25&lt;br&gt;1234567890014 100&lt;br&gt;1234567890012 85&lt;/p&gt;
&lt;p&gt;Sample Output:&lt;br&gt;9&lt;br&gt;1234567890005 1 1 1&lt;br&gt;1234567890014 1 2 1&lt;br&gt;1234567890001 3 1 2&lt;br&gt;1234567890003 3 1 2&lt;br&gt;1234567890004 5 1 4&lt;br&gt;1234567890012 5 2 2&lt;br&gt;1234567890002 7 1 5&lt;br&gt;1234567890013 8 2 3&lt;br&gt;1234567890011 9 2 4&lt;br&gt;思路：1.按考场读入各个考生的信息，对当前考场所有考生进行排序，将排名写入结构体中。2.对所有考生进行排序。3.一边计算总排名，一边输出考生信息。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; student&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; id[&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//准考证号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; grade;&lt;span class=&quot;comment&quot;&gt;//分数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location;&lt;span class=&quot;comment&quot;&gt;//考场号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location_rank;&lt;span class=&quot;comment&quot;&gt;//考场内排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rank;&lt;span class=&quot;comment&quot;&gt;//排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;stu[&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(student a,student b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a.grade != b.grade)  &lt;span class=&quot;comment&quot;&gt;//分数从高到低排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.grade &amp;gt;b.grade;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;//分数相同按准考证号从小到大排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(a.id,b.id) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,k,m=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//num为总考生数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;span class=&quot;comment&quot;&gt;//考场数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;k);&lt;span class=&quot;comment&quot;&gt;//考场内人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;k;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d&quot;&lt;/span&gt;,stu[m].id,&amp;amp;stu[m].grade);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[m].location = i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            m++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(stu+m-k,stu+m,cmp);&lt;span class=&quot;comment&quot;&gt;//将该考场的考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stu[m-k].location_rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//该考场的第一名学生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=m-k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;m;j++)&lt;span class=&quot;comment&quot;&gt;//对该考生剩余的考生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[j].grade == stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;span class=&quot;comment&quot;&gt;//分数相同排名也相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].location_rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//分数不同，排名为该考生前的人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-(m-k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(stu,stu+m,cmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stu[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将所有考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[i].grade == stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d %d %d\n&quot;&lt;/span&gt;,stu[i].id,stu[i].rank,stu[i].location,stu[i].location_rank);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;应用：&lt;ul&gt;
&lt;li&gt;对数据的某种性质进行统计&lt;/li&gt;
&lt;li&gt;使用hash函数H(key)=value将一个元素映射为一个整数，其中哈希函数的选取需要利用元素分布的特点使得值value比较唯一。&lt;br&gt;将较大数据范围的元素（数据个数不多）映射到较小的数据范围内，或者是吧非整数类型的元素映射为整数类型，使得增删改查变得高效。O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用hash进行统计&lt;blockquote&gt;
&lt;p&gt;题目：给出N个正整数，再给出M个正整数，问这M个正整数中的每个数分别是否在N个正整数中出现过。(M,N&amp;lt;=10^5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：遍历所有N个数，看是否有一个数与x相等，时间复杂度O(MN)太大。&lt;/p&gt;
&lt;p&gt;用hash：开一个bool型数组hashtable[N+1],其中hashtable[x]==true表示正整数x在N个正整数中出现过。时间复杂度O(M+N)&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; hashTable[maxn]=&amp;#123;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,m,x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hashTable[x]=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//数字x出现过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;m; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hashTable[x]==&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;YES\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;NO\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;哈希法的应用：对数据的某种性质进行统计。对图进行DFS遍历时就需要设置bool型数组VIS[maxn]来记录结点是否已经被访问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用哈希进行区间映射&lt;br&gt;使用hash函数H(key)=value将一个元素映射为一个整数。&lt;br&gt;一个例子：如何将一个二维整点P坐标映射为一个整数，是整点P可以由该整数唯一的代表。P(x,y)x&amp;gt;=0,y&amp;lt;=range,可以设计hash函数H(p)=x*range+y,用H(p)来唯一的代表坐标。&lt;br&gt;一个例子：字符串hash是将一个字符串S映射为一个整数，使该整数可以唯一的代表字符串S。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h3&gt;&lt;p&gt;分治：将原问题划分成k个规模较小而结构与原问题相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。&lt;br&gt;步骤：  复杂度O（nlogn）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 分解  
- 解决
- 合并  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决的问题必须满足最优子结构.&lt;br&gt;递归来实现分治思想，（1）递归边界（2）递归式&lt;br&gt;例子1：使用递归求解n的阶乘&lt;/p&gt;
&lt;p&gt;例子2：求斐波那契数列的第N项&lt;/p&gt;
&lt;h3 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h3&gt;&lt;h4 id=&quot;月饼-PATB&quot;&gt;&lt;a href=&quot;#月饼-PATB&quot; class=&quot;headerlink&quot; title=&quot;月饼 (PATB)&quot;&gt;&lt;/a&gt;月饼 (PATB)&lt;/h4&gt;&lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;br&gt;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。&lt;br&gt;输入样例：&lt;br&gt;3 20&lt;br&gt;18 15 10&lt;br&gt;75 72 45&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;94.50&lt;br&gt;思路：此为贪心算法。如何获得最大收益，先根据库存量和总售价算出每种月饼的单价，然后从单价高的开始枚举，全部卖出足够需求量，则提供需求量就够了；如果不够需求量，则收益值增加需求量×单价，需求量-这种库存，再看单价第二高的月饼；&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mooncake&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; store;&lt;span class=&quot;comment&quot;&gt;//库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sell;&lt;span class=&quot;comment&quot;&gt;//总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; price;&lt;span class=&quot;comment&quot;&gt;//单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;cake[&lt;span class=&quot;number&quot;&gt;1010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mooncake a,mooncake b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//按单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.price&amp;gt;b.price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;span class=&quot;comment&quot;&gt;//月饼种类数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; D;&lt;span class=&quot;comment&quot;&gt;//需求量同上用浮点数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%lf&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;D);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//先输入每种月饼的库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].store);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//再输入每种月饼的总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].sell);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cake[i].price = cake[i].sell/cake[i].store;&lt;span class=&quot;comment&quot;&gt;//计算单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(cake, cake+n, cmp);&lt;span class=&quot;comment&quot;&gt;//单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; ans=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//收益&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cake[i].store&amp;lt;=D) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量小于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            D-=cake[i].store;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].sell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量大于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].price*D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;组个最小数-PATB&quot;&gt;&lt;a href=&quot;#组个最小数-PATB&quot; class=&quot;headerlink&quot; title=&quot;组个最小数 (PATB)&quot;&gt;&lt;/a&gt;组个最小数 (PATB)&lt;/h4&gt;&lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。&lt;/p&gt;
&lt;p&gt;现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，&lt;strong&gt;顺序表示我们拥有数字0、数字1、……数字9的个数&lt;/strong&gt;。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;在一行中输出能够组成的最小的数。&lt;br&gt;输入样例：&lt;br&gt;2 2 0 0 0 3 0 0 1 0&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;10015558&lt;br&gt;思路：此为贪心算法。就是从最高位开始输出，先从1到9中选择个数不为0的最小数输出，然后从0到9输出数字，每个数字输出次数为剩余个数。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//记录数字0-9的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;count[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从1-9中选择Count不为0的最小数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count[i]&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            count[i]--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从0-9输出对应个数的数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;count[i]; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：贪心算法用来解决最优化问题，希望由局部最优策略来推得全局最优结果，贪心算法适用的问题一定满足最优子结构性质。（组成原问题最优解的子问题的解也是最优的）&lt;/p&gt;
&lt;h3 id=&quot;二分&quot;&gt;&lt;a href=&quot;#二分&quot; class=&quot;headerlink&quot; title=&quot;二分&quot;&gt;&lt;/a&gt;二分&lt;/h3&gt;&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;在有序序列中。时间复杂度O(logn)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A[mid]==x,查找成功，退出查询。
- A[mid]&amp;gt;x,说明x一定在中间位置的左边，在[left,mid-1]继续查找
- A[mid]&amp;lt;x，说明x一定在中间位置的右边，在[mid+1,right]继续查找
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归：  &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = n,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (left&amp;lt;=right) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]==x) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]&amp;gt;x)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d\n&quot;&lt;/span&gt;,binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;),binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际更多的是使用非递归。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;序列中哟重复数字，求序列中第一个x的位置。&lt;/li&gt;
&lt;li&gt;序列中第一个大于x的数的位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;a href=&quot;#扩展（求根号2的近似值）&quot; class=&quot;headerlink&quot; title=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;/a&gt;扩展（求根号2的近似值）&lt;/h4&gt;&lt;p&gt;F(x)=x*x；比较F(x)与2 的大小。&lt;br&gt;若F(x)&amp;gt;2,则令right=mid;&lt;br&gt;若F(x)&lt;2,则令left=mid; 代码：=&quot;&quot; &lt;figure=&quot;&quot; class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; eps=&lt;span class=&quot;number&quot;&gt;1e-5&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//精度为10的-5次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x*x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calSql&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; left =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (right - left &amp;gt; eps) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left + right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f(mid)&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/2,则令left=mid;&gt;&lt;/p&gt;
&lt;h3 id=&quot;two-pointers&quot;&gt;&lt;a href=&quot;#two-pointers&quot; class=&quot;headerlink&quot; title=&quot;two pointers&quot;&gt;&lt;/a&gt;two pointers&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目：给定一个&lt;strong&gt;递增&lt;/strong&gt;的正整数序列和一个正整数M,求序列中的两个不同位置的数a和b,使他们的和恰好为M，输出所有满足条件的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：令下标i的初值为0，下标j的初值为n-1，令i，j分别指向序列的第一个元素和最后一个元素，接下来根据a[i]+a[j]与M的大小来进行下面三种选择，i向右移动，j向左移动，直到i&amp;gt;=j成立。&lt;br&gt;1&amp;gt;如果a[i]+a[j]==M，令i=i+1，j=j-1;&lt;br&gt;2&amp;gt;如果a[i]+a[j]&amp;gt;M,j=j-1;&lt;br&gt;3&amp;gt;如果a[i]+a[j]&amp;lt;M,i=i+1; &lt;/p&gt;
&lt;p&gt;代码：时间复杂度O(n)&lt;br&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]==M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;,i,j)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]&amp;lt;M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目：假设有两个递增序列A和B，要求将它们合并为一个递增序列C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：两个下标i和j，初值均为0，表示分别指向序列A的第一个元素和序列B的第一个元素，然后根据A[i]和B[j]的大小来决定哪一个放入序列C。&lt;br&gt;1&amp;gt;A[i]&lt;b[j],a[i]加入到序列c，i加1. 2=&quot;&quot;&gt;A[i]&amp;gt;B[j],B[i]加入到序列C，j加1.&lt;br&gt;3&amp;gt;A[i]==B[j],任选一个加入到序列C，下标加1.&lt;/b[j],a[i]加入到序列c，i加1.&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;br&gt;&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; merge(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; B[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;m) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=B[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//序列A或B的剩余元素加入序列C&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;m) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回C的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;例如：归并排序和快速排序&lt;/p&gt;
&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;一种用来解决最优化问题的思想。动态规划将一个复杂的问题分解成若干个简单的子问题，通过综合子问题的求解结果来得到原问题的解。&lt;br&gt;本质:通过记录曾经计算过的内容，来避免重复计算。&lt;br&gt;1&amp;gt;递归&lt;br&gt;斐波那契数列&lt;/p&gt;
&lt;p&gt;2&amp;gt;递推&lt;br&gt;数塔DP问题：将一些数字排成数塔形状，其中第一层有一个数字，第二层有两个数字。。。。。第N层有N个数字，形状要从第一层走到第N层，每次只能走向下一层连接的两个数字中的一个，问最后将路径上所以数字相加后得到的和最大是多少？&lt;/p&gt;
&lt;h4 id=&quot;最大练习子序列和&quot;&gt;&lt;a href=&quot;#最大练习子序列和&quot; class=&quot;headerlink&quot; title=&quot;最大练习子序列和&quot;&gt;&lt;/a&gt;最大练习子序列和&lt;/h4&gt;&lt;p&gt;题目：输入一个数字序列a1,a2,求i,j（1&amp;lt;=i&amp;lt;=j&amp;lt;=n）,使得ai+…….aj最大，输出最大和。&lt;/p&gt;
&lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h4&gt;&lt;p&gt;题目：有N件物品，每件物品的重量为W[i],价值为C[i],现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的价值最大，其中每种物品都只有一件。&lt;/p&gt;
&lt;h4 id=&quot;最长不下降子序列&quot;&gt;&lt;a href=&quot;#最长不下降子序列&quot; class=&quot;headerlink&quot; title=&quot;最长不下降子序列&quot;&gt;&lt;/a&gt;最长不下降子序列&lt;/h4&gt;&lt;h4 id=&quot;最长公共子序列（LCS）&quot;&gt;&lt;a href=&quot;#最长公共子序列（LCS）&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列（LCS）&quot;&gt;&lt;/a&gt;最长公共子序列（LCS）&lt;/h4&gt;&lt;p&gt;题目：给定两个字符串A和B，求一个字符串，使得这个字符串是A和B的最长公共部分&lt;/p&gt;
&lt;h4 id=&quot;最长回文字串&quot;&gt;&lt;a href=&quot;#最长回文字串&quot; class=&quot;headerlink&quot; title=&quot;最长回文字串&quot;&gt;&lt;/a&gt;最长回文字串&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常用的算法题总结一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题</title>
    <link href="http://peilinghui.com/2016/03/27/iOS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://peilinghui.com/2016/03/27/iOS面试题/</id>
    <published>2016-03-27T06:37:29.000Z</published>
    <updated>2017-02-17T08:45:10.000Z</updated>
    
    <content type="html">&lt;p&gt;总结一下一些面试题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一组正整数数字，如何找出两个数加为100的组合；&lt;br&gt;（首先要排序）然后two pointers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;http和https的区别；抓包的时候有什么区别；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头     - HTTP 是不安全的，而 HTTPS 是安全的 &lt;/li&gt;
&lt;li&gt;HTTP 标准端口是80 ，而 HTTPS 的标准端口是443&lt;/li&gt;
&lt;li&gt;在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层 &lt;/li&gt;
&lt;li&gt;HTTP 无法加密，而HTTPS 对传输的数据进行加密 &lt;/li&gt;
&lt;li&gt;HTTP无需证书，而HTTPS需要CA机构wosign的颁发的SSL证书 &lt;/li&gt;
&lt;li&gt;HTTP无安全锁，HTTPS有安全锁&lt;/li&gt;
&lt;li&gt;HTTP不能防钓鱼网站，HTTPS可以预防钓鱼网站&lt;/li&gt;
&lt;li&gt;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,要比http协议安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;get和post的区别，其他还有哪些请求方式；&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AF%94%E8%BE%83get%E5%92%8Cpost.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%85%B6%E4%BB%96%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统中的进程的存储结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图文混合的新闻中，如何获取图片的位置；&lt;br&gt;1&amp;gt;纯文字排版文字排版开发组件：CoreText。CoreText库中提供了很多的工具来对文本进行操作，例如CTFont、CTLine、CTFrame等。利用这些工具可以对文字字体每一行每一段落进行操作。&lt;br&gt;2&amp;gt;UIwebview去实现的,内容拼接的好处就是数据显示比较同步&lt;br&gt;过网络请求获得相关的信息,再通过手机端进行拼HTML,然后在WebView进行展示，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Tableview的优化，如果卡顿如何处理；&lt;ul&gt;
&lt;li&gt;复用单元格&lt;/li&gt;
&lt;li&gt;使用不透明的视图，单元格中尽量少使用动画&lt;/li&gt;
&lt;li&gt;图片加载使用异步加载，并且设置图片加载的并发数&lt;/li&gt;
&lt;li&gt;滑动时不加载图片，停止滑动开始加载&lt;/li&gt;
&lt;li&gt;文字图片可以直接drawInRect绘制&lt;/li&gt;
&lt;li&gt;如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths&lt;/li&gt;
&lt;li&gt;如果cell是动态行高，计算出高度后缓存&lt;/li&gt;
&lt;li&gt;cell高度固定的话直接用cell.rowHeight设置高度&lt;br&gt;&lt;a href=&quot;http://www.mamicode.com/info-detail-1125512.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mamicode.com/info-detail-1125512.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/36b6537250ca&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/36b6537250ca&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;autolayout中的优先级；&lt;br&gt;&lt;a href=&quot;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.cnbluebox.com/blog/2014/12/13/autolayout1/&lt;/a&gt;&lt;br&gt;设置Constraint的过程其实就是做算术题的过程，这里提醒大家， xib中有Suggest Constraint的功能，但是大家不要用，特别是在学习Autolayout阶段，Suggest Constraint自动补全的Constraint一般不能直接用，除非你view很少。&lt;br&gt;如果设置Constraint来确定一个view的frame呢，你可以里面想到:  1&amp;gt;frame法,像定义frame一样定义约束，就是设置view.left view.top view.width view.height. 但是实际中很少这样用。&lt;br&gt;2&amp;gt;edge法， 设置 view.left view.top view.bottom view.right。&lt;br&gt;3&amp;gt;居中法， 设置 centerX centerY width height等等方法，然而事实使用中你可能不是只有一个view，有可能有很多的view，相互直接会有很多的约束，约束一多就会容易发生逻辑冲突，这个时候就会发现Constraint优先级的作用了。&lt;br&gt;Constraint还有个属性叫priority， 即优先级，一般是0 ~ 1000之间的整数。 1000代表是必需的， 0则不会生效。理解和使用好优先级是熟练使用Autolayout所必备的。&lt;/li&gt;
&lt;li&gt;三个View并排放置，左右间距固定且相等，两两之间距离相等，如何使用Autolayout实现；&lt;br&gt;&lt;a href=&quot;https://lvwenhan.com/ios/431.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://lvwenhan.com/ios/431.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;View里面放置ScrollView，ScrollView里面再放置View，如何用Autolayout实现；&lt;br&gt;&lt;a href=&quot;http://small.qiang.blog.163.com/blog/static/978493072015292522113/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://small.qiang.blog.163.com/blog/static/978493072015292522113/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件结构是用哪种数据结构实现的，树还是图，&lt;br&gt;答案是B+树；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面之间的数据传递方式；&lt;br&gt;使用SharedApplication,定义一个变量来传递.&lt;br&gt;使用文件，或者NSUserdefault来传递&lt;br&gt;通过一个单例的class来传递&lt;br&gt;通过Delegate来传递。&lt;br&gt;1）采用代理模式 子viewcontroller设计 代理协议，定义协议接口，父viewcontroller 实现协议接口，实现子viewcontroller 退出时将相关数据更新到父视图。&lt;br&gt;2）采用ios的消息机制 父viewcontroller注册消息 子viewcontroller 发送消息，触发父viewcontroller的消息处理。&lt;br&gt;3）采用database做为数据中间的存储媒介，子viewcontroller将状态数据存入DB，父viewcontroller从DB获取数据更新view。&lt;br&gt;4）采用ios的NSDefault 存储&lt;br&gt;5）通过AppDelegate 中定义全局变量实现中间数据的存储。&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/lianbaixue/article/details/8670533&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lianbaixue/article/details/8670533&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面的跳转的两种方式；&lt;br&gt;一种直接跳,一种通过导航.&lt;br&gt;第一种 直接跳转 思路大致就是new一个目的页面，然后设置下页面跳转动画 中间还可以做点目的页面的数据初始化:&lt;br&gt;第二种:利用UINavigationController，调用pushViewController，进行跳转；这种采用压栈和出栈的方式，进行Controller的管理。调用popViewControllerAnimated方法可以返回。&lt;br&gt;&lt;a href=&quot;http://blog.it985.com/13090.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.it985.com/13090.html&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;属性修饰符retain、assign、copy等等之间的区别；&lt;/li&gt;
&lt;li&gt;讲讲block；&lt;/li&gt;
&lt;li&gt;详解runtime，OC为什么是动态的语言，内部机制；&lt;/li&gt;
&lt;li&gt;Tableview要实现哪两个协议；&lt;/li&gt;
&lt;li&gt;category和extension的区别；&lt;br&gt;Category；&lt;ul&gt;
&lt;li&gt;用于给class及其subclass添加新的方法&lt;/li&gt;
&lt;li&gt;有自己单独的 .h 和 .m 文件&lt;/li&gt;
&lt;li&gt;用于添加新方法，而不能添加新属性（property）&lt;br&gt;Extension&lt;/li&gt;
&lt;li&gt;Extension常被称为是匿名的Category&lt;/li&gt;
&lt;li&gt;用于给类添加新方法，但只作用于原始类，不作用于subclass&lt;/li&gt;
&lt;li&gt;只能对有implementation源代码的类写Extension，对于没有implementation源代码的类，比如framework class，是不可以的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Extension可以给原始类添加新方法，以及新属性&lt;/strong&gt;&lt;br&gt;category 与extension不同在于后者可以添加属性，后者添加的方法也必须是要实现的。extension是私有的category。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多线程有哪几种实现方式，GCD的具体使用；&lt;/li&gt;
&lt;li&gt;GCD中的数据不安全是怎么处理的；&lt;/li&gt;
&lt;li&gt;dispatch_main,同步和异步如何使用;&lt;/li&gt;
&lt;li&gt;讲讲最近你的项目；&lt;/li&gt;
&lt;li&gt;KVO如何实现，内部机制；&lt;/li&gt;
&lt;li&gt;Core Animation /Core Graphics&lt;br&gt;CoreGraphics是底层绘制框架，我们实际会用到的也就是CG开头的一些底层绘制函数和变量，这是一个纯C语言框架。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;QuartzCore也就是你说的包含了CoreAnimation的框架，是iOS系统的基本渲染框架，是一个OC语言框架，是一套基于CoreGraphics的OC语言封装，封装出了基本渲染类CALayer。&lt;/p&gt;
&lt;p&gt;**一面电面：15min；&lt;br&gt;1.算法：数组中（无序的正整数数）如何找到第n大的数；&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_54f82cc201013tke.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_54f82cc201013tke.html&lt;/a&gt;&lt;br&gt;2.算法：数组中1—100的无序数字如何找到第n大的数；（遍历计数）&lt;br&gt;思路：&lt;br&gt;1&amp;gt;假设数组中有n个元素，a1~an，而我们要求第k大的数字，就相当于求排序后的第m = n - k + 1个数字。&lt;br&gt;2&amp;gt;假设一次快速排序之后，如果枢纽的是第x个（1~n）。&lt;br&gt;3&amp;gt;如果x = m，则这个枢纽ax就是我们要求的第k大的数字，结束；如果x &amp;lt; m，则对a0 ~ ax-1进行一次快速排序，重复第2）步；如果x &amp;gt; m，则对ax+1 ~ an 进行一次快速排序，重复第2）步。&lt;br&gt; 快速选择的代码如下：&lt;br&gt; &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//a[] - 要排序的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//b - 要排序的子区间的开始索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//e - 要排序的子区间的结束索引&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//k - 求出排序后第k个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickselect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; e, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = b ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = e + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[++i] &amp;lt; x &amp;amp;&amp;amp; i &amp;lt; j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[--j] &amp;gt; x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i &amp;gt;= j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      swap(a[i], a[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[b] = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[j] = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; == j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(k - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quickselect(a, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, e, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quickselect(a, b, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：快速选择可以用于这类面试题：&lt;br&gt;       1）求出无序数组中第k大的数&lt;br&gt;       2）求出无序数组中最大/小的k个数&lt;br&gt;3.讲一讲OC中的运行时，动态性；&lt;br&gt;4.OC中是如何找到一个方法的，通过函数名key的方式找到的，每一个函数名肯定是不一样的；&lt;br&gt;5.OC中有没有函数重载（没有）；Swift中有没有函数重载（有的）；&lt;br&gt;6.内存管理，MRC，ARC的区别；&lt;br&gt;7.releasepool被释放了，里面的对象都会被释放吗？过程是怎样的。&lt;/p&gt;
&lt;h2 id=&quot;二面：&quot;&gt;&lt;a href=&quot;#二面：&quot; class=&quot;headerlink&quot; title=&quot;二面：  &quot;&gt;&lt;/a&gt;二面：  &lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;C++和OC 的内存管理比较，以及实现方式；&lt;br&gt;在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。&lt;br&gt;管理方式：&lt;br&gt;对于栈来讲，是由编译器自动管理，无需我们手工控制；&lt;br&gt;对于堆来说，释放工作由程序员控制，容易产生memory leak。&lt;br&gt;碎片问题：&lt;br&gt;对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。&lt;br&gt;对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。&lt;br&gt;生长方向：&lt;br&gt;对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；&lt;br&gt;对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。&lt;br&gt;malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。  它们都可用于申请动态内存和释放内存。&lt;br&gt;Objective-C内存管理：&lt;br&gt;引用计数是实例对象的内存回收唯一参考。&lt;br&gt;引用计数(retainCount)是Objective-C管理对象引用的唯一依据。调用实例的release方法后，此属性减一，减到为零时对象的dealloc方法被自动调用，进行内存回收操作，也就是说我们永不该手动调用对象的dealloc方法。&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7583358801014usx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7583358801014usx.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个数组，一个有100万的数据，另一个有1亿的数据，如何找出相同的数据，时间复杂度是什么？&lt;br&gt;hash统计：先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数的HashTable，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；&lt;br&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/v-July-v/archive/2012/03/22/2413055.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/v-July-v/archive/2012/03/22/2413055.html&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;OC的MRC，ARC；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C++和OC有哪些区别；&lt;br&gt;1&amp;gt;c++中的对象可以是动态创建的（使用new来创建，返回对象的地址），也可以是直接的创建对象，在c++中就有了 值传递 与指针传递的区别。。&lt;br&gt;在oc中只能动态的创建内存，这也是oc的动态特性之一。&lt;br&gt;2&amp;gt;在C++中，下面三种对象需要调用拷贝构造函数（有时也称“复制构造函数”）：&lt;br&gt;1) 一个对象作为函数参数，以值传递的方式传入函数体；&lt;br&gt;2) 一个对象作为函数返回值，以值传递的方式从函数返回；&lt;br&gt;3) 一个对象用于给另外一个对象进行初始化（常称为复制初始化).&lt;br&gt;务必要注意区分这3种情况与OC种的区别，在OC中是根本不存在这3种情况的。因为oc中只能创建对象的指针，是不能直接创建对象的。&lt;br&gt;c++中的默认拷贝构造函数就类似oc中的浅拷贝，也就是指针拷贝。&lt;br&gt;3&amp;gt;oc中虽然不能直接的创建对象，但是oc中函数调用，以及返回的时候，传入的参数一样会拷贝一份出来，只不过这个拷贝是一个指针，而不是拷贝的一个对象。返回的时候一样是拷贝的一个副本，这个副本是指针。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正是因为c++中有直接创建对象与创建对象指针的区别。所以才产生了值传递，与地址传递的区别。它可以传递一个对象，也可以传递这个对象的地址。如果传递的是对象本身，就是值传递。如果传递的是对象的指针，就是指针传递。其实指针传递也是传递的值，传递的是变量的地址值。这个地址值是一个对象的首地址。&lt;/p&gt;
&lt;p&gt;但是在oc与java中，只能传递对象的地址。所以就不用区分上面的情况了。&lt;br&gt;参考：&lt;a href=&quot;http://blog.csdn.net/itianyi/article/details/9046231&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/itianyi/article/details/9046231&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7583358801014usx.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7583358801014usx.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Swift与OC有哪些区别；&lt;br&gt;Swift没有地址/指针的概念&lt;br&gt;泛型&lt;br&gt;类型严谨 对比oc的动态绑定&lt;br&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/dsxniubility/p/4294658.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/dsxniubility/p/4294658.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/34718b0fc910&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/34718b0fc910&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;网易：&quot;&gt;&lt;a href=&quot;#网易：&quot; class=&quot;headerlink&quot; title=&quot;网易：&quot;&gt;&lt;/a&gt;网易：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍一下GCD&lt;/li&gt;
&lt;li&gt;如果没有GCD，你怎样实现多线程&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSthread的缺点是什么？使用NSthread怎么实现数据同步？&lt;br&gt;缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销&lt;br&gt;两种锁，一种NSCondition ，一种是：NSLock。我们可以使用指令 @synchronized 来简化 NSLock的使用，这样我们就不必显示编写创建NSLock,加锁并解锁相关代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍protocol？&lt;br&gt;protocol（协议）类似java中的接口，定义了一些类需要公用到的方法，只要遵守这个协议，就可以拥有这些方法并可以去实现它们，这样可以避免许多重复的代码。@required代表协议里的方法必须实现，否则编译器会警告，不写默认是@required，@optional代表协议里的方法是选择实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;protocol，category和继承的区别？&lt;br&gt;protocol的作用是为一些列类仅仅提供一套公用的接口，而完全没 有办法也没可能去提供具体的一些实现情况；&lt;br&gt;category则是为一个已有的类提供一些额外的接口和具体实现；&lt;br&gt;而继承则基于两者之间，既可以想 protocol一样提供只是纯粹提供接口，也可以像Category一样提供完整的实现，而且继承还能对类以后的功能进行改写，所以说继承的力量是最强 大的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;block和delegate你更倾向于用哪个？为什么？&lt;br&gt;Block.&lt;br&gt;block使代码更紧凑,便于阅读,delegate可以设置必选和可选的方法实现.&lt;br&gt;block可以访存局部变量. 不需要像以前的回调一样，把在操作后所有需要用到的数据封装成特定的数据结构, 你完全可以直接访问局部变量.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UIalertviewcontroller的内部实现？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何理解MVC设计模式&lt;br&gt;MVC是一种架构模式，M表示MOdel，V表示视图View，C表示控制器Controller： &lt;/p&gt;
&lt;p&gt; Model负责存储、定义、操作数据；&lt;br&gt; View用来展示给用户，和用户进行操作交互；&lt;br&gt; Controller是Model和View的协调者，Controller把Model中的数据拿过来给View用。Controller可以直接与Model和View进行通信，而View不能和Controller直接通信。View与Controller通信需要利用代理协议的方式，当有数据更新时，MOdel也要与Controller进行通信，这个时候就要用Notification和KVO，这个方式就像一个广播一样，MOdel发信号，Controller设置监听接受信号，当有数据更新时就发信号给Controller，Model和View不能直接进行通信，这样会违背MVC设计模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何理解MVVM设计模式&lt;br&gt;M:模型 V:视图+控制器 VM:视图模型&lt;br&gt;模型(M):保存视图数据。&lt;br&gt;视图+控制器(V):展示内容 + 如何展示&lt;br&gt;视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。&lt;br&gt;MVVM是View和ViewModel相关联，这样做到真正的数据与逻辑跟界面相分离，我们所要关心的地方都在ViewModel里面，控制器和View里面就只需要做很少的事情，&lt;br&gt; ViewModel层，就是View和Model层的粘合剂，他是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他各种各样的代码的极好的地方。说白了，就是把原来ViewController层的业务逻辑和页面逻辑等剥离出来放到ViewModel层。&lt;br&gt; View层，就是ViewController层，他的任务就是从ViewModel层获取数据，然后显示。&lt;br&gt;&lt;a href=&quot;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&lt;/a&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;自定义控件怎么做的？&lt;/li&gt;
&lt;li&gt;加密算法？&lt;br&gt;常见的加解密方式(rsa,aes,md5）&lt;br&gt;RSA：基于公钥和私钥的非对程加密算法。适用范围广。&lt;br&gt;AES：是一种对程加密的流行方式。加密涉及矩阵运算。&lt;br&gt;MD5:将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，&lt;/li&gt;
&lt;li&gt;ios应用的调试技巧&lt;br&gt;1&amp;gt;如遇到crash，分析崩溃日志（symbolicatedrash工具的适用）保留崩溃版本的.dSYM文件&lt;br&gt;2&amp;gt;在 XCode 中进入断点管理窗口；然后点击右下方的 +，增加新的 Exception Breakpoint。&lt;br&gt;3&amp;gt;如遇到EXC_BAD_ACCESS，打开Scheme选项选择EditScheme。然后按图勾上Enable Zombie Objects和Malloc Stack那两项。&lt;br&gt;4&amp;gt;有效的日志管理。NSLog和加入一些开源的日志管理框架。&lt;br&gt;5&amp;gt;程序断点debug模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;网易二面：&quot;&gt;&lt;a href=&quot;#网易二面：&quot; class=&quot;headerlink&quot; title=&quot;网易二面：&quot;&gt;&lt;/a&gt;网易二面：&lt;/h2&gt;&lt;p&gt;学习oc对你有什么提升？&lt;br&gt;nsdictionary如何实现深拷贝？&lt;br&gt;如果有多层，怎样实现？&lt;br&gt;autolayout？&lt;br&gt;主线程可以执行下载任务吗？为什么？&lt;br&gt;主线程使用数据库，想在其他线程也访问数据库，怎么实现？&lt;br&gt;有没有写过category？里面能不能加属性？为什么？&lt;br&gt;谈一下你对mvc模式的理解？&lt;br&gt;ARC和MRC ：&lt;br&gt;ARC是依靠什么实现的？&lt;br&gt;&lt;a href=&quot;https://onevcat.com/2012/06/arc-hand-by-hand/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://onevcat.com/2012/06/arc-hand-by-hand/&lt;/a&gt;&lt;br&gt;release如何实现对象释放？autorelease如何实现？两者的区别与联系？release能做的事情autorelease都能做，那么release可不可以舍弃？为什么？&lt;br&gt;weak和assign的区别？&lt;br&gt;谈一下运行时？&lt;br&gt;kvo的底层实现？&lt;/p&gt;
&lt;p&gt;网易一面：&lt;br&gt;1.UIview中的俩个label的自适应代码。&lt;br&gt;2.项目：音乐播放器，后台实现除了有音乐播放器，还有什么？&lt;br&gt;3.我回答的是通知，通知你用过吗？本地通知和远程通知，有什么区别，远程通知是从哪里获取的。&lt;br&gt;4.音乐播放的数据库是怎么实现的。&lt;br&gt;5.怎么学习iOS的。&lt;br&gt;6.学过JS，JS学的怎么样？JS和OC实现热点会吗？&lt;/p&gt;
&lt;h2 id=&quot;网易其他面试题：&quot;&gt;&lt;a href=&quot;#网易其他面试题：&quot; class=&quot;headerlink&quot; title=&quot;网易其他面试题：&quot;&gt;&lt;/a&gt;网易其他面试题：&lt;/h2&gt;&lt;p&gt;内存管理基础&lt;br&gt;多线程介绍&lt;br&gt;SDWebImage介绍&lt;br&gt;图片下载，缓存是同步还是异步&lt;br&gt;Objective的对象结构&lt;br&gt;ISA指针是指向什么&lt;br&gt;block在MRC下如何解决循环引用&lt;br&gt;NSCache的优点，使用字典可不可以，优缺点分析&lt;br&gt;JAVA和OC的区别，不同，在哪些上最明显&lt;br&gt;UItableView的优化，为什么这么优化&lt;br&gt;CEll如何计算&lt;br&gt;dealloc里做哪些操作&lt;br&gt;NOtification哪些使用场景，同步还是异步？主线程还是子线程&lt;br&gt;dealloc不remove通知会怎么样&lt;br&gt;KVO的实现原理&lt;br&gt;消息转发原理&lt;br&gt;何时用到串行队列&lt;/p&gt;
&lt;p&gt;越狱后APP的安全&lt;br&gt;动态更新&lt;br&gt;链式反应&lt;br&gt;UIbutton的多次点击&lt;/p&gt;
&lt;h2 id=&quot;网易笔试：&quot;&gt;&lt;a href=&quot;#网易笔试：&quot; class=&quot;headerlink&quot; title=&quot;网易笔试：&quot;&gt;&lt;/a&gt;网易笔试：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;用户点击某按钮时下载一张图片，当用户再次点击此按钮是下载时取消，为了保证尽量节省用户流量，请尽快取消真实的下载请求。&lt;br&gt;请描述解决此问题的方法和思路。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;实现多线程有哪些方式，各有什么优势？&lt;/li&gt;
&lt;li&gt;请使用category实现NSMutableDictionary的深度拷贝？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用Autolayout实现UIView包含两个子元素[UILabel不定字数]和[UILabel不定字数文字]：&lt;ul&gt;
&lt;li&gt;Label1和Label2横向排布，间距5pt.&lt;/li&gt;
&lt;li&gt;Label需要宽度自适应&lt;/li&gt;
&lt;li&gt;Label1和Label2纵向居中对齐&lt;/li&gt;
&lt;li&gt;两个Label文字不可重叠&lt;/li&gt;
&lt;li&gt;文字过长的时候，优先保证Label2显示完整。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：用autolayout的masonry框架.&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UILabel *label1 = [[UILabel alloc]init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 sizeToFit]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label1.backgroundColor = [UIColor grayColor]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UILabel *label2 = [[UILabel alloc]init]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 sizeToFit]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label2.backgroundColor = [UIColor purpleColor]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:label1]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:label2]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label1.text = @&quot;UIlayout的约束&quot;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    label2.text = @&quot;文字过长的时候，优先保证Label2&quot;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 mas_makeConstraints:^(MASConstraintMaker *make)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.centerY.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.left.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label1 setContentCompressionResistancePriority:UILayoutPriorityDefaultLow    forAxis:UILayoutConstraintAxisVertical]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 mas_makeConstraints:^(MASConstraintMaker *make)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.centerY.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.left.equalTo(label1.mas_right).offset(5)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        make.right.equalTo(self.view)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [label2 setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 效果：&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UILabel%E6%95%88%E6%9E%9C.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他公司面试题：&quot;&gt;&lt;a href=&quot;#其他公司面试题：&quot; class=&quot;headerlink&quot; title=&quot;其他公司面试题：&quot;&gt;&lt;/a&gt;其他公司面试题：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;UIView和CALayer的区别？&lt;br&gt;每一个 UIView 的身后对应一个 Core Animation 框架中的 CALayer. 每一个 UIView 都是 CALayer 的代理.&lt;br&gt;UIView 实际上就是对 CALayer 的轻量级的封装. UIView 继承自 UIResponder, 用来处理来自用户的事件;&lt;br&gt;CALayer 继承自 NSObject 主要用于处理图层的渲染和动画. 这么设计有以下几个原因:&lt;br&gt;你可以通过操作 UIView 在一个更高的层级上处理与用户的交互, 触摸, 点击, 拖拽等事件, 这些都是在 UIKit 这个层级上完成的.&lt;br&gt;UIView 和 NSView(AppKit) 的实现极其不同, 而使用 Core Animation 可以实现底层代码地重用, 在 Mac 和 iOS 平台上都使用着近乎相同的 Core Animation 代码, 这样我们可以对这个层级进行抽象在两种平台上产生 UIKit 和 AppKit 用于不同平台的框架.&lt;/li&gt;
&lt;li&gt;UIView继承自哪个父类？&lt;/li&gt;
&lt;li&gt;自动释放池底层是如何实现的？&lt;/li&gt;
&lt;li&gt;runtime 的运行机制？&lt;/li&gt;
&lt;li&gt;宏定义和const关键字的区别？&lt;/li&gt;
&lt;li&gt;GCD和NSOperation的区别？NSOperation并发有顺序吗？&lt;/li&gt;
&lt;li&gt;沙盒的目录，NSUserDefault是存在什么目录下的？哪种形式？&lt;/li&gt;
&lt;li&gt;Runloop的机制？&lt;/li&gt;
&lt;li&gt;SDWebImage的源码研究过吗？&lt;/li&gt;
&lt;li&gt;Git和SVN的区别？&lt;/li&gt;
&lt;li&gt;静态库和动态库的区别？&lt;/li&gt;
&lt;li&gt;H5,JS和网页，Native与iOS开发结合用过吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;腾讯面试题：&quot;&gt;&lt;a href=&quot;#腾讯面试题：&quot; class=&quot;headerlink&quot; title=&quot;腾讯面试题：&quot;&gt;&lt;/a&gt;腾讯面试题：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如何绘制一个三角形？&lt;br&gt;1.1 如何绘制大量三角形？&lt;br&gt;1.2 一定要重写drawRect吗？&lt;br&gt;1.3 如何刷新View界面？&lt;br&gt;1.4 Layer好在哪？&lt;/li&gt;
&lt;li&gt;assign和weak的区别&lt;/li&gt;
&lt;li&gt;线程和RunLoop的关系&lt;br&gt;3.1 一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）&lt;/li&gt;
&lt;li&gt;NSTimer有什么需注意的以及和RunLoop的关系？&lt;/li&gt;
&lt;li&gt;NSString copy 和 NSString mutableCopy 的区别&lt;/li&gt;
&lt;li&gt;线程加锁原理（信号量，临界区，自选锁）&lt;/li&gt;
&lt;li&gt;iOS7 - iOS9的区别&lt;/li&gt;
&lt;li&gt;GCD指向了野指针了怎么办&lt;/li&gt;
&lt;li&gt;用HTTP传数据，丢包严重怎么办&lt;/li&gt;
&lt;li&gt;iOS中广播的种类&lt;/li&gt;
&lt;li&gt;app slying&lt;/li&gt;
&lt;li&gt;runtime如何实现weak变量的自动置nil？&lt;/li&gt;
&lt;li&gt;AFNetworking的内部实现原理？&lt;/li&gt;
&lt;li&gt;block循环引用了如何解决？&lt;/li&gt;
&lt;li&gt;如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;/li&gt;
&lt;li&gt;UIKit的框架结构？&lt;br&gt;腾讯面试题：&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;app上架流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程和进程区别 及之间通信&lt;br&gt;&lt;a href=&quot;http://1108038.blog.51cto.com/1098038/420330&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://1108038.blog.51cto.com/1098038/420330&lt;/a&gt;&lt;br&gt;进程是表示资源分配的基本单位，又是调度运行的基本单位。&lt;br&gt;线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。&lt;br&gt;进程间通信—&amp;gt;管道(pipe)、信号(signal)、消息队列、共享内存、信号量、套接字；&lt;br&gt;线程间通信—&amp;gt;信号量、消息、事件event&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tableview cell 缓存机制&lt;br&gt;在UITableView内部有一个缓存池，初始化时使用initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)方法指定一个可重用标识，就可以将这个cell放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的cell然后修改cell内容即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tableview cell高度优化：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;深入理解runloop&lt;br&gt;&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/05/18/runloop/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主线程runloop(mainRunloop)主要执行事件：&lt;br&gt;负责创建Autoreleasepool和释放autoreleasepool,  周期大概是event loop(事件循环)；&lt;br&gt;事件响应—&amp;gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;手势识别—&amp;gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;界面更新—&amp;gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NSTimer事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PerformSelecter—&amp;gt;performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease 具体释放时机：&lt;br&gt;通常在下一次事件循环(event loop)时释放，如果是手动创建的自动释放池则在这个池的外层释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟内存：&lt;br&gt;当应用程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;红黑树&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;QQ小红点动画的实现原理&lt;/li&gt;
&lt;li&gt;设计一个网络图片缓存器(SDWebImage实现原理必需要了解)&lt;/li&gt;
&lt;li&gt;PNG和JPG的区别&lt;/li&gt;
&lt;li&gt;如何压缩JPG&lt;/li&gt;
&lt;li&gt;TCP/IP协议&lt;br&gt;自己面试题：&lt;/li&gt;
&lt;li&gt;GCD有何缺点？&lt;/li&gt;
&lt;li&gt;CocosPods?&lt;/li&gt;
&lt;li&gt;项目重构的一些规范和命名规范？&lt;/li&gt;
&lt;li&gt;如何push到某个特定的controller？&lt;/li&gt;
&lt;li&gt;SDWebImage框架是如何实现的？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;腾讯面试：&quot;&gt;&lt;a href=&quot;#腾讯面试：&quot; class=&quot;headerlink&quot; title=&quot;腾讯面试：&quot;&gt;&lt;/a&gt;腾讯面试：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;看简历说一下你的项目经验，讲解一下你最拿手的项目？其中各个部分的功能是如何实现的？&lt;/li&gt;
&lt;li&gt;属性ARC下有什么？&lt;/li&gt;
&lt;li&gt;属性中weak和strong的区别？&lt;br&gt;strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。&lt;/li&gt;
&lt;li&gt;assign为何不能修饰对象？如果修饰了会怎么样？&lt;/li&gt;
&lt;li&gt;copy在哪里用？&lt;br&gt;NSString&lt;/li&gt;
&lt;li&gt;Block在栈中还是堆中？全局变量是在栈还是在堆中？成员变量呢？&lt;/li&gt;
&lt;li&gt;怎么定义一个类的属性？写代码。&lt;/li&gt;
&lt;li&gt;——#import与#include的区别？&lt;/li&gt;
&lt;li&gt;如果自己实现一个setter方法，该如何写代码？&lt;/li&gt;
&lt;li&gt;oc中有什么容器？&lt;/li&gt;
&lt;li&gt;写一个数组初始化的代码。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;arc、跟property有关的关键字、多线程（GCD、NSOperation、NSThread）、runloop、runtime、图片渲染、事件处理机制、mvc模型&lt;/p&gt;
&lt;h2 id=&quot;一-搜狐快站&quot;&gt;&lt;a href=&quot;#一-搜狐快站&quot; class=&quot;headerlink&quot; title=&quot;一.搜狐快站&quot;&gt;&lt;/a&gt;一.搜狐快站&lt;/h2&gt;&lt;p&gt;1.谈谈你做过的项目；&lt;br&gt;2.项目中最有成就感的部分；&lt;br&gt;3.倒计时如何实现？（NSTimer，还有其他的实现方式吗）；&lt;br&gt;4.UIButton的继承关系？&lt;br&gt;5.iOS中可以进行输入的控件？（UITextView,UITextField）;&lt;br&gt;6.快排的实现原理；&lt;br&gt;7.短信验证码会有倒计时功能吗?第一次验证失败后还可以再进行验证吗？&lt;br&gt;8.Android开发和iOS开发的区别； &lt;/p&gt;
&lt;h2 id=&quot;二-搜狐社交产品中心&quot;&gt;&lt;a href=&quot;#二-搜狐社交产品中心&quot; class=&quot;headerlink&quot; title=&quot;二.搜狐社交产品中心&quot;&gt;&lt;/a&gt;二.搜狐社交产品中心&lt;/h2&gt;&lt;p&gt;1.我们项目中用到的缓存方式；用的是数据库还是归档？&lt;br&gt;2.我们项目中使用的网络库是什么？&lt;br&gt;3.TableView的优化和重用；比如不等高的cell如何重用？不同的cell里面包含的UI不同如何重用？滑动太卡如何优化？&lt;br&gt;4.图片缓存如何优化？圆角图片如何优化？&lt;br&gt;5.JSON等数据格式如何模型化？使用哪些第三方库？&lt;br&gt;6.MVC，MVVM？&lt;br&gt;7.开发中用到的设计模式？单例、MVC、delegate。&lt;br&gt;8.数据结构堆与栈的区别；栈与队列的区别；&lt;br&gt;9.用OC如何实现栈与队列；&lt;br&gt;10.如何防止死锁；&lt;br&gt;11.GCD如何实现同步任务，即如何执行完一段代码后再去执行另一段代码；（线程组，barrier，信号量）&lt;br&gt;12.block如何解除循环引用；&lt;br&gt;13.block的原理是什么，如何去找到这个block；（函数指针）&lt;br&gt;14.运行时替换系统的设置颜色的方法，但是在某几处还是要使用系统的方法，如何使用运行时实现；&lt;br&gt;15.OC和Java的区别；&lt;br&gt;16.面向对象的三大特性，iOS开发时如何体现面向对象的；&lt;br&gt;17.你们UI使用什么开发方式；&lt;br&gt;18.H5混编：OC如何调用js的代码；js调用OC的代码；分别是如何进行调用的；&lt;br&gt;19.分享功能你们是如何实现的；&lt;br&gt;20.应用之间如何唤起，如何把scheme加入白名单；&lt;/p&gt;
&lt;h2 id=&quot;三-蚂蚁金服&quot;&gt;&lt;a href=&quot;#三-蚂蚁金服&quot; class=&quot;headerlink&quot; title=&quot;三.蚂蚁金服&quot;&gt;&lt;/a&gt;三.蚂蚁金服&lt;/h2&gt;&lt;p&gt;1.在第一家实习公司时做的项目，完成了哪些模块；&lt;br&gt;2.在当前公司时做的项目，完成了哪些模块；&lt;br&gt;3.序列化与反序列化；JSON怎么转化为模型；&lt;br&gt;4.iOS中的数据库，CoreData；&lt;br&gt;5.开源项目中OnceNote中的技术闪亮点；&lt;br&gt;6.数学建模时做的题目，是怎么建模的，使用了什么工具；&lt;br&gt;7.Java和OC的优缺点，与Android中的Java有什么区别；&lt;br&gt;8.NSString为什么用的copy，copy和strong有什么区别；&lt;br&gt;9.NSCopying,NSCoding,讲讲这两个东西；&lt;br&gt;10.面向对象的三大特性，讲讲多态；&lt;br&gt;11.类A想调用类C的方法，类C继承自类B，需要如何实现；&lt;br&gt;12.一个类实现的功能是越多越好还是越少越好？单一职责原则； &lt;/p&gt;
&lt;p&gt;1.在两家公司做的项目介绍；&lt;br&gt;2.内联函数是什么？&lt;br&gt;3.堆和栈的区别；如何优化堆和栈！！！；哪一种会造成内存碎片；block分配在哪里；&lt;br&gt;4.block的循环引用；block的代码实现；为什么会造成循环引用；block是如何强引用self的；&lt;br&gt;5.如何去自己实现一个自动释放池；自动释放池的作用；自动释放池是如何管理对象的；&lt;br&gt;6.static的作用；static const为什么要加static；static const与#define的区别；&lt;br&gt;7.项目中做的比较好的部分；&lt;br&gt;8.block在传递的时候，是否会改变存储位置？比如是否会从栈复制到堆；原来的block是否会被释放； &lt;/p&gt;
&lt;h2 id=&quot;四-微店&quot;&gt;&lt;a href=&quot;#四-微店&quot; class=&quot;headerlink&quot; title=&quot;四.微店&quot;&gt;&lt;/a&gt;四.微店&lt;/h2&gt;&lt;p&gt;1.Block的实现内部机制，外部的变量是怎么传到Block中去的；&lt;br&gt;2.快速排序的实现，复杂度；有其他哪些排序算法；&lt;br&gt;3.判断单向链表中是否有环；&lt;br&gt;4.iOS的内存管理机制，和GC有什么区别；&lt;br&gt;5.Runtime；&lt;br&gt;6.C++中函数是如何调用的；&lt;br&gt;7.如果不使用UICollectionView，那么如何实现瀑布流，如何设计数据结构，讲讲思路；&lt;br&gt;8.如果有一个比内存大的大文件，那么如何实现排序；&lt;br&gt;9.http和https的区别，https使用了什么加密算法；&lt;br&gt;10.https的效率一定比http低吗，是每一次都低吗？&lt;br&gt;11.storyboard到手机UI显示，整个过程是怎样的？&lt;br&gt;12.xib、nib需要被编译吗？它们分别是什么类型的文件？&lt;/p&gt;
&lt;h2 id=&quot;五-网易金融&quot;&gt;&lt;a href=&quot;#五-网易金融&quot; class=&quot;headerlink&quot; title=&quot;五.网易金融&quot;&gt;&lt;/a&gt;五.网易金融&lt;/h2&gt;&lt;p&gt;1.实习期间做的工作，以下问题都是基于实习项目展开的；&lt;br&gt;2.简单说说你实现哪些功能模块？&lt;br&gt;3.Autolayout的使用，几个View如何布局，如何设置cell的高度，几个并列的View如何居中？&lt;br&gt;4.项目中你使用了哪些设计模式？&lt;br&gt;5.你们项目中是怎样架构的（MVC？MVVM？）；&lt;br&gt;6.你们项目中的多线程是如何实现的？&lt;br&gt;7.队列有哪些？队列和线程的关系？&lt;br&gt;8.说说列表功能的实现（涉及cell的自定义等）；&lt;br&gt;9.Block中的循环引用；Block的复制；Block的存储位置；Block如何改变外面的变量；__block修饰符的内部机制！！！；&lt;br&gt;10.简单的需求：几个任务执行完以后再去做某项任务，如何实现？（GCD线程组？）&lt;br&gt;11.你是如何进行持续学习的？你是学习方式是怎样的？&lt;br&gt;12.最近你在学习哪些技术，现在你感兴趣的是哪方面？&lt;br&gt;13.聊了聊iOS安全方面的内容；&lt;br&gt;14.Swift中的Protocol。。。；&lt;br&gt;15.你们的项目用的是OC还是Swift；&lt;br&gt;16.Category和Extension；Category的缺点和优点；如何克服或者弥补这个缺点（不能添加实例变量，用Runtime实现？）；&lt;br&gt;17.属性修饰符：copy，weak。。。&lt;br&gt;18.NSNotification是同步的还是异步的？？？（貌似是同步的）&lt;br&gt;19.NSNotification的使用需要注意什么？（不用时要移除通知？）&lt;br&gt;20.Block的嵌套使用；&lt;br&gt;21.iOS安全，如何在客户端实现一些安全措施。比如如何做用户输入密码时的键盘输入安全。&lt;/p&gt;
&lt;h2 id=&quot;六-腾讯&quot;&gt;&lt;a href=&quot;#六-腾讯&quot; class=&quot;headerlink&quot; title=&quot;六.腾讯&quot;&gt;&lt;/a&gt;六.腾讯&lt;/h2&gt;&lt;p&gt;1.算法：一棵多叉树，每个节点上有个值，求一条路径上值的和为sum的路径有哪些；&lt;br&gt;2.在网络请求中，如何来处理网络速度慢、网络中断网络抖动等等网络问题；&lt;br&gt;3.你做的项目的难点在哪里？&lt;br&gt;4.你未来三年的规划是什么？ &lt;/p&gt;
&lt;h2 id=&quot;七-百度&quot;&gt;&lt;a href=&quot;#七-百度&quot; class=&quot;headerlink&quot; title=&quot;七.百度&quot;&gt;&lt;/a&gt;七.百度&lt;/h2&gt;&lt;p&gt;1.用过哪些设计模式，用代码实现单例模式，讲讲代理模式的优点，画出代理模式的类结构图；&lt;br&gt;2.手写二插搜索树的查找，分别用循环和递归实现，哪一种的效率高，递归的空间复杂度是多少；&lt;br&gt;3.App端的数据缓存；&lt;br&gt;4.有哪些查找算法，复杂度分别是多少；&lt;br&gt;5.哈希查找的时间复杂度是多少，如何解决冲突，如何优化哈希；&lt;br&gt;6.有哪些进程调度或内存管理的算法？（比如先来先服务，高优先级服务，最近最久未使用等等）；&lt;br&gt;7.使用什么数据结构来实现LRU最近最久未使用，画图来模拟一下；&lt;br&gt;8.Linux命令行，搜索某个文件的命令； &lt;/p&gt;
&lt;p&gt;1.项目中的图片上传功能如何实现，为什么使用队列上传，为什么不用异步上传；&lt;br&gt;2.安卓开发与iOS开发的区别和优缺点；&lt;br&gt;3.转到后台的应用如何保持活跃，而不被系统kill；应用转到后台的整个过程是怎样的？&lt;br&gt;4.iOS中如何实现单例，用GCD来实现一下；&lt;br&gt;5.GCD的全拼；&lt;br&gt;6.Xcode开发中如何创建一个代码块（代码片）；&lt;br&gt;7.iOS10中的新特性，聊了聊WWDC；&lt;br&gt;8.对项目中用到的图片选择器的优化和自定义，包括图片多选功能；&lt;br&gt;9.GCD中如何创建异步线程，GCD中是否能stop一个线程执行； &lt;/p&gt;
&lt;p&gt;1.讲讲iOS系统；&lt;br&gt;2.你们有没有用到什么新的技术；&lt;br&gt;3.你算法怎么样？&lt;br&gt;4.讲讲体现你学习能力的事情？&lt;br&gt;5.为什么从上一家公司实习离职？ &lt;/p&gt;
&lt;h2 id=&quot;八-小红书&quot;&gt;&lt;a href=&quot;#八-小红书&quot; class=&quot;headerlink&quot; title=&quot;八.小红书&quot;&gt;&lt;/a&gt;八.小红书&lt;/h2&gt;&lt;p&gt;1.你实习的项目中哪些是你做的？&lt;br&gt;2.你觉得我们小红书的App怎么样？&lt;br&gt;3.手写代码：给定一个字符串，同时给定两个字符，求出包含这两个字符的最小子串的长度；&lt;br&gt;比如输入：addcddabc    ,a  ,c&lt;br&gt;那么包含的子串为：addc,   cdda,   abc  —&amp;gt;最小的子串长度为3;&lt;br&gt;4.说说iOS和Android开发的区别； &lt;/p&gt;
&lt;h2 id=&quot;九-网易杭研&quot;&gt;&lt;a href=&quot;#九-网易杭研&quot; class=&quot;headerlink&quot; title=&quot;九.网易杭研&quot;&gt;&lt;/a&gt;九.网易杭研&lt;/h2&gt;&lt;p&gt;1.你们的iOS应用是如何来提高安全性的；&lt;br&gt;2.应用的砸壳过程；&lt;br&gt;3.https的秘钥协商过程，证书交换过程；&lt;br&gt;4.讲讲Runtime，以及消息转发过程；&lt;br&gt;5.讲讲iOS的内存管理；&lt;br&gt;6.你们APP中的一些方案选型问题：如网路库选型，页面路由选型；&lt;br&gt;7.页面的动画或者渲染的优化如何做？讲讲CoreAnimation；&lt;br&gt;8.讲讲Foundation和CoreFoundation之间的区别；CoreFoundation是不支持ARC的，如何与Foundation之间进行转化。&lt;br&gt;9.如何实现界面栈的重构，如何移除栈中的界面；&lt;br&gt;10.如何对UITableView进行优化，你们的cell都是等高的么；&lt;br&gt;11.如果让你自己实现下拉刷新的功能，你如何实现；&lt;br&gt;12.MVVM以及代码臃肿问题；&lt;br&gt;13.简单聊聊ReactiveCocoa以及数据刷新问题； &lt;/p&gt;
&lt;h2 id=&quot;十-图片社交in&quot;&gt;&lt;a href=&quot;#十-图片社交in&quot; class=&quot;headerlink&quot; title=&quot;十.图片社交in&quot;&gt;&lt;/a&gt;十.图片社交in&lt;/h2&gt;&lt;p&gt;1.项目中的alert sheet的层级，是添加到哪里？以及key window的层级结构；&lt;br&gt;2.应用中的安全机制；有哪些对称加密、非对称加密算法；&lt;br&gt;3.进行直播，使用字典存储观众，观众有进入和离开，人数比较多，如何实现这样一个功能；以及如何实现排序；&lt;br&gt;4.字典中是如何去进行查找的？并发查找；&lt;br&gt;5.笔记在更新的时候进行修改，如何处理这种情况，如何防止脏数据；&lt;br&gt;6.GCD中有哪些方法？&lt;br&gt;7.讲讲runloop；&lt;br&gt;8.讲讲runtime；&lt;br&gt;9.本地化持久方案；&lt;br&gt;10.在什么时候我们需要使用autoreleasepool；什么时候需要我们手动去写一个autoreleasepool；&lt;br&gt;11.单例的作用，什么场景下才需要使用单例；&lt;br&gt;12.ARC是一种编译时特性还是运行时特性； &lt;/p&gt;
&lt;h2 id=&quot;十一-墨迹天气&quot;&gt;&lt;a href=&quot;#十一-墨迹天气&quot; class=&quot;headerlink&quot; title=&quot;十一.墨迹天气&quot;&gt;&lt;/a&gt;十一.墨迹天气&lt;/h2&gt;&lt;p&gt;1.模块化开发框架有哪些用过？&lt;br&gt;2.weak的作用；&lt;br&gt;3.有哪些属性修饰符；&lt;br&gt;4.混合开发中如何传递数据，即js和oc如何传递数据、参数；&lt;br&gt;5.做过那些优化？&lt;br&gt;6.说说我们的App中有哪些需要改进的；&lt;br&gt;7.讲讲MVC，MVVM；&lt;br&gt;8.atomic一定是线程安全的吗？&lt;br&gt;9.iOS中多线程的实现方式；&lt;br&gt;10.碰到过内存泄露吗？如何查看或者检测内存泄露；&lt;br&gt;11.你们是如何封装网络请求库的；&lt;/p&gt;
&lt;h2 id=&quot;十二-同花顺&quot;&gt;&lt;a href=&quot;#十二-同花顺&quot; class=&quot;headerlink&quot; title=&quot;十二.同花顺&quot;&gt;&lt;/a&gt;十二.同花顺&lt;/h2&gt;&lt;p&gt;1.KVO的实现原理；&lt;br&gt;2.UITableView的复用，如果UITableView的高度很高，即frame的高度超过屏幕高度，会怎么进行复用；&lt;br&gt;3.weak、assign的区别；&lt;br&gt;4.什么是死锁；&lt;br&gt;5.二叉树的搜索，搜索二叉树中所有值为2的节点，并返回，代码实现；&lt;br&gt;6.讲讲runtime；&lt;br&gt;7.weak为什么比assign安全，其实现原理是怎样的；&lt;br&gt;8.消息推送如何实现，整个过程是怎样的；&lt;br&gt;9.缓存图片如何实现，缓存到哪里；如果图片显示有破损，可能是什么原因造成的；&lt;/p&gt;
&lt;h2 id=&quot;十三-华为&quot;&gt;&lt;a href=&quot;#十三-华为&quot; class=&quot;headerlink&quot; title=&quot;十三.华为&quot;&gt;&lt;/a&gt;十三.华为&lt;/h2&gt;&lt;p&gt;1.算法：str = “4213523…..54”很长的数字字符串，如何判断是否能被6整除；&lt;/p&gt;
&lt;h2 id=&quot;十四-搜狐集团&quot;&gt;&lt;a href=&quot;#十四-搜狐集团&quot; class=&quot;headerlink&quot; title=&quot;十四.搜狐集团&quot;&gt;&lt;/a&gt;十四.搜狐集团&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;iOS做过哪些渲染优化；&lt;/li&gt;
&lt;li&gt;二叉树非递归中序遍历代码实现；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合并两个已经有序的链表代码实现； &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android应用是否可以读取本机号码；iOS应用是否可以读取本机号码；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;使用位运算符实现两个整型加法代码实现，不考虑溢出； &lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;十五-今日头条&quot;&gt;&lt;a href=&quot;#十五-今日头条&quot; class=&quot;headerlink&quot; title=&quot;十五.今日头条&quot;&gt;&lt;/a&gt;十五.今日头条&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;算法：二叉树的左右子树交换代码实现；&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pi&quot;&gt;// 交换左右子树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void ReverseLeftRightChild(BiTNode **T)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //&lt;/span&gt; 如果是叶子节点，则递归结束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*T == NULL)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    swap&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;((*T)-&amp;gt;lChild, (*T)-&amp;gt;rChild)&lt;/span&gt;; // 直接使用&lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;交换函数比较方便，直接交换指针；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;ReverseLeftRightChild&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&amp;amp;((*T)-&amp;gt;lChild))&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;ReverseLeftRightChild&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&amp;amp;((*T)-&amp;gt;rChild))&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;页面路由如何实现，如何去维护一张路由表；页面是如何去进行跳转的（runtime）；路由表中的键和值分别是什么？如何根据服务器下发的数据加载页面；&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;js和OC如何调用；（js是怎样调用oc的）；&lt;br&gt;在xcode中的viewDidLoad方法中加载webView方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.webView&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *webView = [[&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    webView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    webView&lt;span class=&quot;variable&quot;&gt;.delegate&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt; addSubview:webView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.加载网页&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *url = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle] URLForResource:&lt;span class=&quot;string&quot;&gt;@&quot;test&quot;&lt;/span&gt; withExtension:&lt;span class=&quot;string&quot;&gt;@&quot;html&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; *request = [&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; requestWithURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [webView loadRequest:request];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;加载到网页后再script标签中的JS代码中，如果点击button按钮，在onclick点击事件function函数中改变window&lt;span class=&quot;variable&quot;&gt;.loction&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.href&lt;/span&gt;的值，然后到Xcode中的下面方法中，取出方法名，转成SEL，然后调用OC中对应的方法名。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;webView每当发送一个请求之前，都会先调用这个方法（能拦截所有请求）&lt;br&gt;*/&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(BOOL)webView:(UIWebView &lt;em&gt;)webView shouldStartLoadWithRequest:(NSURLRequest &lt;/em&gt;)request navigationType:(UIWebViewNavigationType)navigationType&lt;br&gt;{&lt;br&gt;NSString &lt;em&gt;url = request.URL.absoluteString;&lt;br&gt;NSRange range = [url rangeOfString:@”hm://“];&lt;br&gt;NSUInteger loc = range.location;&lt;br&gt;if (loc != NSNotFound) { // url的协议头是hm&lt;br&gt;  // 方法名&lt;br&gt;  NSString &lt;/em&gt;method = [url substringFromIndex:loc + range.length];&lt;/p&gt;
&lt;p&gt;  // 转成SEL&lt;br&gt;  SEL sel = NSSelectorFromString(method);&lt;br&gt;  [self performSelector:sel withObject:nil];&lt;br&gt;}&lt;br&gt;return YES;&lt;br&gt;}&lt;br&gt;```&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GCD和NSOperation的区别；哪一个的复用性更好；NSOperation的队列可以cancel吗，里面的任务可以cancel吗；  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;block和self的循环引用；到底是如何循环引用的；&lt;br&gt;笔记关于Block的循环引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SDWebImage的缓存策略，是如何从缓存中hit一张图片的；使用了几级缓存；缓存如何满了如何处理，是否要设置过期时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;讲讲RunLoop；&lt;/li&gt;
&lt;li&gt;讲讲iOS动画，比如CoreAnimation；&lt;br&gt;9.屏幕上点击一个View，事件是如何去响应的；&lt;br&gt;10.深拷贝与浅拷贝；&lt;br&gt;11.有哪几种类型的block；什么情况下block会从栈区复制到堆区；&lt;br&gt;12.在一个函数中的局部变量，需要return，那么这个局部变量什么时候会被释放；它是分配在哪里？&lt;br&gt;13.CALayer和UIView的区别；动画可以作用于CALayer和UIView吗？&lt;br&gt;14.讲讲runtime，以及hook，以及如何进行方法交换；&lt;br&gt;15.讲讲逆向工程； &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.算法:double power(double  x, int n)函数实现，最好是O(long)复杂度；&lt;br&gt;2.使用关联对象把属性添加到category中，具体步骤是怎样的；&lt;br&gt;3.如何去手动触发KVO，如何让KVO去监听一个方法；&lt;br&gt;4.weak和assign的区别；&lt;br&gt;5.weak在它指向的对象被释放后，会被置为nil，该机制是如何实现的；&lt;br&gt;6.NSString为什么要修饰成copy；block为什么要修饰为copy；&lt;br&gt;7.哪些属性需要修饰为weak；&lt;br&gt;8.NSMutableArray在block中修改时，是否要修饰为__block;   int类型呢； &lt;/p&gt;
&lt;p&gt;1.讲讲JSPatch；使用了iOS的什么原理；&lt;br&gt;2.讲讲MVC，MVVM，MVP；MVP是哪三个单词的缩写；&lt;br&gt;3.操作系统进程间通讯的方式；&lt;br&gt;4.讲讲共享锁和互斥锁；&lt;/p&gt;
&lt;p&gt;6.UIViewController的生命周期；&lt;br&gt;7.UITableView滑动卡顿如何解决优化；&lt;br&gt;8.iOS多线程有哪几种方式；&lt;br&gt;9.让你印象深刻的学到的技术；安全？&lt;br&gt;10.Linux和Unix相关知识；&lt;/p&gt;
&lt;p&gt;13.非对称加密方式有哪些，数字签名如何实现； &lt;/p&gt;
&lt;h2 id=&quot;十六-中国移动杭研&quot;&gt;&lt;a href=&quot;#十六-中国移动杭研&quot; class=&quot;headerlink&quot; title=&quot;十六.中国移动杭研&quot;&gt;&lt;/a&gt;十六.中国移动杭研&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;群面题目：移动支付安全；&lt;/li&gt;
&lt;li&gt;实习中的开发流程；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当前手头offer情况； &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;bad_access这个bug是如何出现的？&lt;br&gt;野指针。正在使用的对象被释放了，导致野指针，访问野指针导致程序崩溃。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;NSString为什么用weak修饰，如果使用strong修饰会怎样？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;讲讲单例设计模式，在什么情况下使用单例模式？&lt;br&gt;在读书笔记的单例模式。&lt;/li&gt;
&lt;li&gt;iOS响应链&lt;br&gt;读书笔记&lt;/li&gt;
&lt;li&gt;&lt;p&gt;isa指针的作用；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.每一个对象都包含一个isa指针.这个指针指向当前对象所属的类。
2.[d bark];表示给d所指向的对象发送一条bark消息,调用对象的bark方法,此时对象会顺着内部的isa指针找到存储于类中的方法并执行。        
3.isa是对象中的隐藏指针,指向创建这个对象的类。
4.通过isa指针我们可以在运行的时候知道当前对象是属于那个类。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表中图片缓存与内存优化，有没有出现过OOM的情况；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.遇到图片较多且不需要缓存的情况下，不要用imageNamed方法，用initWithContentOfFile加载图片
2.UITableView的cell复用：把界面上看不见的cell放入缓存池中，要创建新的cell时先判断缓存池中有无相同identifier可以循环利用的，没有的话再进行创建
3.打包发布时去掉所有的NSLog：NSLog打印比较耗费性能，特别是打印字符串的拼接，解决方法可以在pch文件中定义一个宏来替换NSLog，用自己定义的log函数，等到发布之前将自己的定义注释掉
4.不要让主线程承担大量的数据处理任务：可以把比较费时的加载图片等任务放到子线程中来做，做好之后在主线程中更新UI界面，iOS中的三种多线程方法NSThread、GCD、NSOperation；
5.当创建了大量的临时对象时，最好加入autorelesaepool保证对象及时的释放
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多面试总结题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/ab4e96bcf26a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/ab4e96bcf26a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/e453b28c3222#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e453b28c3222#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/5d2163640e26#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/5d2163640e26#&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/xieyupeng520/article/details/50832701&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xieyupeng520/article/details/50832701&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;招聘一个靠谱的 iOS：&lt;br&gt;题目：&lt;a href=&quot;http://blog.sunnyxx.com/2015/07/04/ios-interview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/07/04/ios-interview/&lt;/a&gt;&lt;br&gt;答案：&lt;a href=&quot;http://www.cocoachina.com/ios/20150803/12872.html（上）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150803/12872.html（上）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20150825/13195.html（下）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cocoachina.com/ios/20150825/13195.html（下）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;总结一下一些面试题。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://peilinghui.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://peilinghui.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://peilinghui.com/2016/03/25/%E5%89%91%E6%8C%87offer/"/>
    <id>http://peilinghui.com/2016/03/25/剑指offer/</id>
    <published>2016-03-25T01:46:37.000Z</published>
    <updated>2016-04-06T08:24:24.000Z</updated>
    
    <content type="html">&lt;p&gt;这本书很不错，在其中还发现了阿里面试的时候所问的问题。值得好好研究一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-赋值运算符函数&quot;&gt;&lt;a href=&quot;#1-赋值运算符函数&quot; class=&quot;headerlink&quot; title=&quot;1.赋值运算符函数&quot;&gt;&lt;/a&gt;1.赋值运算符函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目：如下为类型CMyString的声明，请为该类型添加赋值运算符函数。&lt;br&gt;注意：1.是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（返回引用才可以连续赋值）&lt;br&gt;2.是否把传入的参数类型声明为常量引用const。&lt;br&gt;3.是否释放实例自身已有的内存，防止内存泄露。&lt;br&gt;4.是都判断传入的参数和当前的实例(*this)是不是同一个实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CMyString&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMyString(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* pData=&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMyString(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString &amp;amp;str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~CMyString(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMyString&amp;amp; &lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString::CMyString(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *pData)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (pData==&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m_pData=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m_pData[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;string&quot;&gt;&#39;\0&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length=&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m_pData=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[length+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;strcpy&lt;/span&gt;(m_pData, pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString::CMyString(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; str)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = &lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(str.m_pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_pData=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[length+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;strcpy&lt;/span&gt;(m_pData,str.m_pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString::~CMyString()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;[] m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//赋值运算符函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString&amp;amp; CMyString::&lt;span class=&quot;keyword&quot;&gt;operator&lt;/span&gt;=(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; str)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;==&amp;amp;str) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; []m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_pData=&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    m_pData=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[&lt;span class=&quot;built_in&quot;&gt;strlen&lt;/span&gt;(str.m_pData)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;strcpy&lt;/span&gt;(m_pData, str.m_pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; *&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//测试代码，把一个类的实例赋值给另外一个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; CMyString::Print()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s&quot;&lt;/span&gt;,m_pData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Test1 begins:\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* text=&lt;span class=&quot;string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;CMyString &lt;span class=&quot;title&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMyString str2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str2=str1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;the expected result is%s.\n&quot;&lt;/span&gt;,text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str2.Print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//赋值给自己&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Test2 begins:\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* text=&lt;span class=&quot;string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;CMyString &lt;span class=&quot;title&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str1=str1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;the expected result is%s.\n&quot;&lt;/span&gt;,text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str1.Print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//连续赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Text3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Test3 begins:\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* text =&lt;span class=&quot;string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;CMyString &lt;span class=&quot;title&quot;&gt;str1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CMyString str2,str3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str3=str2=str1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;the expected result is:%s.\n&quot;&lt;/span&gt;,text);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str2.Print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;the actual result is: &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    str3.Print();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc,_TCHAR* argv[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Test1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Test2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Text3();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;2-实现Singleton模式&quot;&gt;&lt;a href=&quot;#2-实现Singleton模式&quot; class=&quot;headerlink&quot; title=&quot;2.实现Singleton模式&quot;&gt;&lt;/a&gt;2.实现Singleton模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目：设计一个类，只能生成该类的一个实例。&lt;br&gt;&lt;a href=&quot;http://www.lxway.com/491084104.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;答案&lt;/a&gt;&lt;br&gt;1&amp;gt;在单线程的时候工作正常，但在多线程的情况下多个线程都会创建一个自己的实例，无法保证单例模式的要求。&lt;br&gt;//单例模式，懒汉式（在用的时候实例化），线程不安全&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;sealed class Singleton1&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton1()&amp;#123;&amp;#125;&amp;#10;    private static Singleton1 Instance&amp;#123;&amp;#10;        get&amp;#123;&amp;#10;            if(instance==null)&amp;#10;                instance = new Singleton1();&amp;#10;                return instance;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2&amp;gt;虽然在多线程环境中能工作但效率不高&lt;br&gt;//懒汉式，线程安全&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;sealed class Singleton2&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton2()&amp;#123;&amp;#125;&amp;#10;    private static readonly object synObj = new object();&amp;#10;    public static Singleton2 Instance&amp;#123;&amp;#10;        get&amp;#123;//&amp;#27599;&amp;#20010;&amp;#32447;&amp;#31243;&amp;#26469;&amp;#20043;&amp;#21069;&amp;#20808;&amp;#31561;&amp;#24453;&amp;#38145;&amp;#10;            lock(syncObj)&amp;#123;&amp;#10;                if(instance==null)&amp;#10;                    instance = new Singleton1();&amp;#10;            &amp;#125;&amp;#10;            return instance;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;保证了我们在多线程环境中也只能得到一个实例，但是加锁是一个非常耗时的操作，在没有必要的时候我们应该尽量避免。&lt;br&gt;3&amp;gt;可行的解法：加同步锁前后两次判断实例是否已存在&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;sealed class Singleton3&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton3()&amp;#123;&amp;#125;&amp;#10;    &amp;#10;    private static object synObj = new object();&amp;#10;    private static Singleton3 instance=null;&amp;#10;    public static Singleton3 Instance&amp;#123;&amp;#10;        get&amp;#123;&amp;#10;            // Double-Check &amp;#21452;&amp;#37325;&amp;#21028;&amp;#26029;&amp;#36991;&amp;#20813;&amp;#19981;&amp;#24517;&amp;#35201;&amp;#30340;&amp;#21152;&amp;#38145;&amp;#10;            if(instance==null)&amp;#123;// &amp;#30830;&amp;#23450;&amp;#23454;&amp;#20363;&amp;#20026;&amp;#31354;&amp;#26102;&amp;#20877;&amp;#31561;&amp;#24453;&amp;#21152;&amp;#38145;&amp;#10;                lock(syncObj)&amp;#123;//&amp;#30830;&amp;#23450;&amp;#21152;&amp;#38145;&amp;#21518;&amp;#23454;&amp;#20363;&amp;#20173;&amp;#28982;&amp;#26410;&amp;#21019;&amp;#24314;&amp;#10;                    if (instance==null)&amp;#10;                        instance = new Singleton1();&amp;#125;&amp;#10;            &amp;#125;&amp;#10;            return instance;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4&amp;gt;强烈推荐：利用静态函数构造函数&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;sealed class Singleton4&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private Singleton4()&amp;#123;&amp;#125;&amp;#10;    // &amp;#22312;&amp;#22823;&amp;#22810;&amp;#25968;&amp;#24773;&amp;#20917;&amp;#19979;&amp;#65292;&amp;#38745;&amp;#24577;&amp;#21021;&amp;#22987;&amp;#21270;&amp;#26159;&amp;#22312;.NET&amp;#20013;&amp;#23454;&amp;#29616;Singleton&amp;#30340;&amp;#39318;&amp;#36873;&amp;#26041;&amp;#27861;&amp;#10;    private static Singleton4 = new Singleton4();&amp;#10;    public static Singleton3 Instance&amp;#123;&amp;#10;        get&amp;#123;&amp;#10;            return instance;&amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5&amp;gt;强烈推荐：实现按需创建实例&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;sealed class Singleton5&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#10;    private Singleton5() &amp;#123; &amp;#125;&amp;#10;    public static Singleton5 Instance&amp;#10;    &amp;#123;&amp;#10;        get&amp;#10;        &amp;#123;&amp;#10;            return Nested.instance;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;    // &amp;#20351;&amp;#29992;&amp;#20869;&amp;#37096;&amp;#31867;+&amp;#38745;&amp;#24577;&amp;#26500;&amp;#36896;&amp;#20989;&amp;#25968;&amp;#23454;&amp;#29616;&amp;#24310;&amp;#36831;&amp;#21021;&amp;#22987;&amp;#21270;&amp;#10;    class Nested&amp;#10;    &amp;#123;&amp;#10;        static Nested() &amp;#123; &amp;#125;&amp;#10;        internal static readonly Singleton5 instance = new Singleton5();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.myexception.cn/program/1901772.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;答案&lt;/a&gt;&lt;br&gt;//饿汗模式(使用之前就创建了)&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;class A&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private static A SingleInstance=new A();&amp;#10;    private A()&amp;#123;&amp;#125;;&amp;#10;    public static A getInstance()&amp;#123;&amp;#10;        return SingleInstance();&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;//懒汉模式(使用时候才创建)&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;class A&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    private static A SingleInstance=null;&amp;#10;    private A()&amp;#123;&amp;#125;;&amp;#10;    public static A getInstance()&amp;#123;&amp;#10;        if (SinletonInstance==null) &amp;#123;&amp;#10;            lock(syncObj)&amp;#123;&amp;#10;                    if (instance==null)&amp;#10;                    instance = new A();&amp;#125;&amp;#10;        &amp;#125;&amp;#10;        return SingletonInstance;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;3-二维数组中的查找&quot;&gt;&lt;a href=&quot;#3-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;3.二维数组中的查找&quot;&gt;&lt;/a&gt;3.二维数组中的查找&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;输入：输入可能包含多个测试样例，对于每个测试案例，&lt;br&gt;  输入的第一行为两个整数m和n(1&amp;lt;=m,n&amp;lt;=1000)：代表将要输入的矩阵的行数和列数。&lt;br&gt;    输入的第二行包括一个整数t(1&amp;lt;=t&amp;lt;=1000000)：代表要查找的数字。&lt;br&gt;    接下来的m行，每行有n个数，代表题目所给出的m行n列的矩阵(矩阵如题目描述所示，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;br&gt;输出:&lt;br&gt;    对应每个测试案例&lt;br&gt;    输出”Yes”代表在二维数组中找到了数字t。&lt;br&gt;    输出”No”代表在二维数组中没有找到数字t。&lt;br&gt;样例输入：&lt;br&gt;    3 3&lt;br&gt;    5&lt;br&gt;    1 2 3&lt;br&gt;    4 5 6&lt;br&gt;    7 8 9&lt;br&gt;样例输出：&lt;br&gt;    Yes&lt;br&gt;思路：首先选取数组中右上角的数字，如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。&lt;br&gt;代码：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[][&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j= n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;m &amp;amp;&amp;amp; j&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i][j]==key) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Yes&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i][j]&amp;lt;key) i++;&lt;span class=&quot;comment&quot;&gt;//i行往下移动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; j--;&lt;span class=&quot;comment&quot;&gt;//j列向左移动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;NO&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d&quot;&lt;/span&gt;,&amp;amp;m,&amp;amp;n)!=EOF) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;m; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;n; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;a[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; search(a, m, n, key) &amp;lt;&amp;lt; endl;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;4-替换空格&quot;&gt;&lt;a href=&quot;#4-替换空格&quot; class=&quot;headerlink&quot; title=&quot;4.替换空格&quot;&gt;&lt;/a&gt;4.替换空格&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目描述：&lt;br&gt;    请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;5-从尾到头打印链表&quot;&gt;&lt;a href=&quot;#5-从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;5.从尾到头打印链表&quot;&gt;&lt;/a&gt;5.从尾到头打印链表&lt;/h1&gt;&lt;h1 id=&quot;6-重建二叉树&quot;&gt;&lt;a href=&quot;#6-重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;6.重建二叉树&quot;&gt;&lt;/a&gt;6.重建二叉树&lt;/h1&gt;&lt;h1 id=&quot;7-用俩个栈实现队列&quot;&gt;&lt;a href=&quot;#7-用俩个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;7.用俩个栈实现队列&quot;&gt;&lt;/a&gt;7.用俩个栈实现队列&lt;/h1&gt;&lt;h1 id=&quot;8-旋转数组的最小数字&quot;&gt;&lt;a href=&quot;#8-旋转数组的最小数字&quot; class=&quot;headerlink&quot; title=&quot;8.旋转数组的最小数字&quot;&gt;&lt;/a&gt;8.旋转数组的最小数字&lt;/h1&gt;&lt;h1 id=&quot;9-斐波那契数列&quot;&gt;&lt;a href=&quot;#9-斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;9.斐波那契数列&quot;&gt;&lt;/a&gt;9.斐波那契数列&lt;/h1&gt;&lt;h1 id=&quot;10-二进制中1的个数&quot;&gt;&lt;a href=&quot;#10-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;10.二进制中1的个数&quot;&gt;&lt;/a&gt;10.二进制中1的个数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有两位是1.如果输入9，则输出2.&lt;br&gt;解法：为避免死循环，可以不右移输入的数字n。首先把n和1做与运算，判断n的最低位是不是1.接着把1左移一位得到2，再和n做与运算，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;51-数组中重复的数字&quot;&gt;&lt;a href=&quot;#51-数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;51.数组中重复的数字&quot;&gt;&lt;/a&gt;51.数组中重复的数字&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;题目：在一个长度为n的数组里的所有数字都在0到n-1范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复数字。&lt;br&gt;例如：如果输入长度为7的数组{2，3，1，0，2，5，3}。那么对应的输出是重复数字2或者3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解法一：先把输入的数组排序，从排好序的数组中找出重复数字。O(nlogn)时间。&lt;br&gt;解法二：哈希表，从头到尾扫描数组中每个数，用O(1)时间来判断哈希表中是否包含了该数字，如果没有该数字，加入哈希表。如果有，就找到了重复的数字。时间复杂度：O(n).&lt;br&gt;解法三：所有数字都在0到n-1范围内，假设这个数组没有重复数字，那么数组排序之后数字i就会出现在下标为i的位置。但有重复数字，有些位置据肯存在多个数字，有些位置没有。&lt;br&gt;数组{2，3，1，0，2，5，3}，数组第0个数字是2与下标不等，把它和下标为2的1交换，交换后{1，3，2，0，2，5，3}，不等，再交换{3，1，2，0，2，5，3}，不等，再交换{0，1，2，3，2，5，3}。扫描到下标为4的数字2再比较它和下标为2的数字，发现相等，就找到了一个重复数字。时间复杂度：O(n).空间复杂度O(1)。&lt;br&gt;代码：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;duplicate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numbers[], &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* duplication)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers == &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; || length &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length; ++i) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers[i] &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || numbers[i] &amp;gt; length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; length; ++i) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(numbers[i] != i) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(numbers[i] == numbers[numbers[i]]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;                 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                *duplication = numbers[i];             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// swap numbers[i] and numbers[numbers[i]]             &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = numbers[i];             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            numbers[i] = numbers[temp];             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            numbers[temp] = temp;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这本书很不错，在其中还发现了阿里面试的时候所问的问题。值得好好研究一下。&lt;br&gt;
    
    </summary>
    
      <category term="笔试" scheme="http://peilinghui.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="读书笔记" scheme="http://peilinghui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PAT练习(Advanced Level)</title>
    <link href="http://peilinghui.com/2016/03/15/PAT%E7%BB%83%E4%B9%A0-Advanced-Level/"/>
    <id>http://peilinghui.com/2016/03/15/PAT练习-Advanced-Level/</id>
    <published>2016-03-15T03:31:10.000Z</published>
    <updated>2016-03-27T11:20:08.000Z</updated>
    
    <content type="html">&lt;p&gt;PAT练习(Advanced Level)&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1020树的遍历（25）&quot;&gt;&lt;a href=&quot;#1020树的遍历（25）&quot; class=&quot;headerlink&quot; title=&quot;1020树的遍历（25）&quot;&gt;&lt;/a&gt;1020树的遍历（25）&lt;/h3&gt;&lt;p&gt;假设在二叉树所有的按键是不同的正整数。考虑到后序和中序遍历序列，你应该输出相应的二叉树的层次序遍历序列。&lt;/p&gt;
&lt;p&gt;输入规格：&lt;br&gt;每个输入文件包含一个测试用例。对于每一种情况下，第一行给出一个正整数N（&amp;lt;= 30），在该二进制树的节点的总数。第二行给出了后序序列和第三行给出的序序列。在一条线上所有的号码都用空格隔开。&lt;/p&gt;
&lt;p&gt;输出规格：&lt;br&gt;对于每一个测试的情况下，打印一行相应的二进制树的级别顺序遍历顺序。在一条线的所有数字，必须通过一个空格分开，并且必须有在该行的末尾没有额外的空间。&lt;/p&gt;
&lt;p&gt;样品输入：&lt;br&gt;7&lt;br&gt;2 3 1 5 7 6 4&lt;br&gt;1 2 3 4 5 6 7&lt;br&gt;示例输出：&lt;br&gt;4 1 6 3 5 7 2&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *lchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *rchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; post[maxn],in[maxn];&lt;span class=&quot;comment&quot;&gt;//中序，后序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;span class=&quot;comment&quot;&gt;//结点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//当前二叉树的后序序列区间[postL,postR],中序序列区间[inL,inR]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//create函数返回构建出的二叉树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;node *&lt;span class=&quot;title&quot;&gt;creat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; postL,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; postR,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; inL,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; inR)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(postL &amp;gt; postR)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node * root = (node *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(node));&lt;span class=&quot;comment&quot;&gt;//根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;data = post[postR];&lt;span class=&quot;comment&quot;&gt;//根节点值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(k=inL;k&amp;lt;=inR;k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(in[k] == root-&amp;gt;data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numLeft = k - inL;&lt;span class=&quot;comment&quot;&gt;//左子树节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回左子树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;lchild = creat(postL,postL+numLeft-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,inL,k-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回右子树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;rchild = creat(postL+numLeft,postR-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,inR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//已输出的结点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BFS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(node *root)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;node *&amp;gt; q;&lt;span class=&quot;comment&quot;&gt;//注意队列里是存地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    q.push(root);&lt;span class=&quot;comment&quot;&gt;//将根节点地址入队&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node *top = q.front();&lt;span class=&quot;comment&quot;&gt;//取出队首元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        q.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num != n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,top-&amp;gt;data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,top-&amp;gt;data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(top-&amp;gt;lchild != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//左子树非空,左子树入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q.push(top-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(top-&amp;gt;rchild != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//右子树非空,右子树入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q.push(top-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;post[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;in[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root = creat(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BFS(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;1059-Prime-Factors-25&quot;&gt;&lt;a href=&quot;#1059-Prime-Factors-25&quot; class=&quot;headerlink&quot; title=&quot;1059. Prime Factors (25)&quot;&gt;&lt;/a&gt;1059. Prime Factors (25)&lt;/h1&gt;&lt;p&gt;Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p1^k1 &lt;em&gt; p2^k2 &lt;/em&gt;…*pm^km.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;br&gt;Each input file contains one test case which gives a positive integer N in the range of long int.&lt;/p&gt;
&lt;p&gt;Output Specification:&lt;br&gt;Factor N in the format N = p1^k1 &lt;em&gt; p2^k2 &lt;/em&gt;…*pm^km, where pi’s are prime factors of N in increasing order, and the exponent ki is the number of pi – hence when there is only one pi, ki is 1 and must NOT be printed out.&lt;/p&gt;
&lt;p&gt;Sample Input:&lt;br&gt;97532468&lt;/p&gt;
&lt;p&gt;Sample Output:&lt;br&gt;97532468=2^2&lt;em&gt; 11 &lt;/em&gt; 17 &lt;em&gt; 101 &lt;/em&gt; 1291&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn = &lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//判断n是否为素数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sqr = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;*n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=sqr;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n%i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; prime[maxn],pNum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Find_Prime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//求素数表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;maxn;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isPrime(i))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            prime[pNum++] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; factor&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,cn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;fac[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Find_Prime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,num = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//num为不同质因子的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1=1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d=&quot;&lt;/span&gt;,n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sqr = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;*n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//枚举根号n以内的质因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;pNum &amp;amp;&amp;amp; prime[i] &amp;lt;= sqr;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n%prime[i] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;span class=&quot;comment&quot;&gt;//是质因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fac[num].x = prime[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fac[num].cn = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(n%prime[i] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//计算出质因子prime[i]的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    fac[num].cn++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    n /= prime[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                num++;&lt;span class=&quot;comment&quot;&gt;//不同质因子个数加1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n != &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fac[num].x = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fac[num++].cn = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;num;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,fac[i].x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(fac[i].cn &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;^%d&quot;&lt;/span&gt;,fac[i].cn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PAT练习(Advanced Level)&lt;br&gt;
    
    </summary>
    
      <category term="算法编程" scheme="http://peilinghui.com/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PAT" scheme="http://peilinghui.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://peilinghui.com/2016/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://peilinghui.com/2016/03/14/数据结构/</id>
    <published>2016-03-14T14:10:13.000Z</published>
    <updated>2016-04-25T05:45:57.000Z</updated>
    
    <content type="html">&lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;黑盒测试：&lt;br&gt;1&amp;gt;单点测试(PAT)&lt;br&gt;该组数据通过测试&lt;br&gt;2&amp;gt;多点测试(ACM)&lt;br&gt;程序一次能运行所有数据，并要求输出的结果必须正确。&lt;br&gt;while(scanf(“%d %d”, &amp;amp;n, &amp;amp;a) != EOF){}EOF为end of file返回值为-1.&lt;/p&gt;
&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;h3 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义 ：&lt;br&gt;静态分配:&lt;br&gt;#define MaxSize 50&lt;br&gt;typedef  struct{//静态分配&lt;br&gt; ElemType data[MaxSize];//顺序表元素&lt;br&gt; int length;//当前长度&lt;br&gt;}SqList;&lt;br&gt;动态分配:&lt;br&gt;#define InitSize 100&lt;br&gt;typedef  struct{//动态分配&lt;br&gt; ElemType *data;//指示动态分配数组的指针&lt;br&gt; int MaxSize,length;//数组最大容量和当前个数&lt;br&gt;}SeqList;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;//初始动态分配&lt;br&gt;&lt;code&gt;L.data=(ElemType *)malloc(sizeof(Elemtype)*InitSize);&lt;/code&gt;&lt;br&gt;//C++动态分配&lt;br&gt;&lt;code&gt;L.data=new ElemType[InitSize];&lt;/code&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作&lt;br&gt;顺序表最主要的特点就是随机访问特性&lt;br&gt;1&amp;gt;插入&lt;br&gt;bool ListInsert(SqList &amp;amp;L,int i,Element e){&lt;br&gt; if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length+1) return false;&lt;br&gt; if (L.length&amp;gt;=MaxSize) return false;&lt;br&gt; //将第i个位置以及以后的元素后移&lt;br&gt; for (int j=L.length; j&amp;gt;=i; j–)&lt;pre&gt;&lt;code&gt;L.data[j]=L.data[j-1];
&lt;/code&gt;&lt;/pre&gt; L.data[i-1]=e;//在位置i处放入e&lt;br&gt; l.length++;//表长加1&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;删除&lt;br&gt;bool ListDelete(SqList &amp;amp;L,int i,int &amp;amp;e){&lt;br&gt;    if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length) return false;&lt;br&gt;    e=L.data[i-1];&lt;br&gt;    //将第i个位置以后的元素前移&lt;br&gt;    for (int j=i; j&amp;lt;L.length; j++)&lt;br&gt;        L.data[j-1]=L.data[j];&lt;br&gt;    L.length–;&lt;br&gt;    return true;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/p&gt;
&lt;p&gt;3&amp;gt;按值查找&lt;br&gt;int LocateElem(SqList L,ElemType e){&lt;br&gt;    int i;&lt;br&gt;    for (i=0; i&amp;lt;L.length; i++)&lt;br&gt;        if (L.data[i]==e) return i+1;&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
&lt;h3 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;br&gt;typedef struct LNode{&lt;br&gt; ElemType data;//数据域&lt;br&gt; struct LNode &lt;em&gt;next;//指针域&lt;br&gt;}LNode,&lt;/em&gt;LinkList;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头插法建立单链表&lt;br&gt;LinkList CreateList1(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; LNode *s;int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; L-&amp;gt;next= NULL;//初始为空链表&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
s-&amp;gt;next=L-&amp;gt;next;
L-&amp;gt;next=s;
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; return L;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尾插法建立单链表&lt;br&gt;LinkList CreateList2(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; LNode &lt;em&gt;s,&lt;/em&gt;r=L;&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
r-&amp;gt;next=s;
r=s;//r指向新的表尾结点
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; r-&amp;gt;next=NUll;&lt;br&gt; return L;&lt;br&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;按序号查找表结点值&lt;br&gt;LNode &lt;em&gt;GetElem(LinkList L,int i){&lt;br&gt; int j=1;&lt;br&gt; LNode &lt;/em&gt;p=L-&amp;gt;next;&lt;br&gt; if(i==0)return L;&lt;br&gt; if (i&amp;lt;1)return NUll;&lt;br&gt; while (p&amp;amp;&amp;amp;j&amp;lt;i) {&lt;pre&gt;&lt;code&gt;p=p-&amp;gt;next;
j++;
&lt;/code&gt;&lt;/pre&gt; }&lt;br&gt; return p;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;双链表&quot;&gt;&lt;a href=&quot;#双链表&quot; class=&quot;headerlink&quot; title=&quot;双链表&quot;&gt;&lt;/a&gt;双链表&lt;/h3&gt;&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;顺序栈 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void InitStack(&amp;amp;S){&lt;br&gt; s.top=-1;//将栈顶指针置为空&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;判断栈空&lt;br&gt;bool empty(S){&lt;br&gt; if (s.top==-1) return true;//栈空&lt;br&gt; else return false;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;进栈&lt;br&gt;bool push(x){&lt;br&gt; if (S.top==MaxSize-1) return false;//栈满，报错&lt;br&gt; S.data[++S.top]=x;//指针先加1，再入栈&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;出栈&lt;br&gt;bool pop(x){&lt;br&gt; if (S.top==-1) return false;//栈空，报错&lt;br&gt; x=S.data[S.top–];//先出栈，指针再减1&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;读栈顶元素&lt;br&gt;void GetTop(x){&lt;br&gt; if (S.top==-1)return false;//栈空，报错&lt;br&gt; x= S.data[S.top];//x记录栈顶元素&lt;br&gt; return false;&lt;br&gt;}&lt;h4 id=&quot;简单计算器（ACM）&quot;&gt;&lt;a href=&quot;#简单计算器（ACM）&quot; class=&quot;headerlink&quot; title=&quot;简单计算器（ACM）&quot;&gt;&lt;/a&gt;简单计算器（ACM）&lt;/h4&gt;读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入&lt;br&gt;测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。&lt;/p&gt;
&lt;p&gt;样例输入&lt;br&gt;30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 &lt;em&gt; 6 + 51 / 29 + 79 &lt;/em&gt; 87 + 57 * 92&lt;br&gt;0&lt;br&gt;样例输出&lt;br&gt;12178.21&lt;br&gt;思路：题目给出的是中缀表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 中缀表达式转后缀表达式 
 1&amp;gt;设立一个操作符栈，存放操作符，设立一个队列，存放后缀表达式
 2&amp;gt;扫描中缀表达式，遇到操作数放入后缀表达式。
 3&amp;gt;遇到操作符op，则将其优先级与操作符栈顶操作符优先级比较; 
 若高于，则压入栈，若低于，则弹出到后缀表达式。
 4&amp;gt;重复直到扫描完，若仍有，放到后缀表达式
- 计算后缀表达式
扫描后缀表达式，若是操作数，就压入栈，若是操作符，就弹出两个操作数，进行计算，计算后的数压入栈。直到扫描完，栈中只有一个数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答案：&lt;a href=&quot;http://blog.csdn.net/ccj2020/article/details/7749450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/ccj2020/article/details/7749450&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &amp;lt;iostream&amp;gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node &amp;#123;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; num;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; op;	&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; flag;&amp;#125;;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;node&amp;gt; s;&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;node&amp;gt; q;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; op;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node temp;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;str.length();)&amp;#123;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			temp.num = str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;			i++;			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;str.length() &amp;amp;&amp;amp; str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;				temp.num = temp.num * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;				i++;			&amp;#125;			q.push(temp);		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;			temp.op = str[i];			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty() &amp;amp;&amp;amp; op[temp.op] &amp;lt;= op[s.top().op])&amp;#123;				q.push(s.top());				s.pop();			&amp;#125;			s.push(temp);			i++;		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty())&amp;#123;		q.push(s.top());		s.pop();	&amp;#125;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node cur,temp;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; temp1,temp2;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&amp;#123;		cur = q.front();		q.pop();		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.flag == &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)			s.push(cur);		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp2 = s.top().num;			s.pop();			temp1 = s.top().num;			s.pop();			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;)				temp.num = temp1 + temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;)				temp.num = temp1 - temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;)				temp.num = temp1 * temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;)				temp.num = temp1 / temp2;			s.push(temp);		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s.top().num;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	op[&lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;	op[&lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;	str = &lt;span class=&quot;string&quot;&gt;&quot;1+1*9-2+1&quot;&lt;/span&gt;;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ni hao&quot;&lt;/span&gt;);	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(getline(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;,str))&amp;#123;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;_______&quot;&lt;/span&gt;);		change();		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,cal());	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;循环队列&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void Initqueue(&amp;amp;Q){&lt;br&gt; Q.rear=Q.front=0;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;判队空&lt;br&gt;bool isEmpty(Q){&lt;br&gt; if (Q.rear==Q.front) return true;&lt;br&gt; else return false;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;入队&lt;br&gt;bool EnQueue(Queue &amp;amp;Q,x){&lt;br&gt; if ((Q.rear+1)%MaxSize==Q.front) return false;//队满&lt;br&gt; Q.data[Q.rear]=x;&lt;br&gt; Q.rear=(Q.rear+1)%MaxSize;//队尾指针加1取模&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;出队&lt;br&gt;bool DeQueue(Queue &amp;amp;Q,&amp;amp;x){&lt;br&gt; if (Q.rear==Q.front)return false;&lt;br&gt; x=Q.data[Q.front];&lt;br&gt; Q.front=(Q.front+1)%MaxSize;&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;树与二叉树&quot;&gt;&lt;a href=&quot;#树与二叉树&quot; class=&quot;headerlink&quot; title=&quot;树与二叉树&quot;&gt;&lt;/a&gt;树与二叉树&lt;/h2&gt;&lt;p&gt;满二叉树和完全二叉树用顺序存储。&lt;br&gt;一般二叉树都用链式存储&lt;br&gt;struct node{&lt;br&gt;    typename data;&lt;br&gt;    node &lt;em&gt;lchild,&lt;/em&gt;rchild;&lt;br&gt;};&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的遍历&lt;br&gt;1.先序遍历&lt;br&gt;2.中序遍历&lt;br&gt;3.后序遍历&lt;br&gt;4.层序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;排序（内排）&quot;&gt;&lt;a href=&quot;#排序（内排）&quot; class=&quot;headerlink&quot; title=&quot;排序（内排）&quot;&gt;&lt;/a&gt;排序（内排）&lt;/h2&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h3&gt;&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h4&gt;&lt;p&gt;思想：表长L[1…..N],有序序列L[1..i-1],L(i),无序序列L[n+1……N],将L(i)插入有序L[1..i-1]。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 找出L(i)插入有序L[1..i-1]的位置k。  
- 将L[k..i-1]中所有元素后移一位  
- 将L(i)复制给L(k)。  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间效率：O（1）&lt;br&gt;时间效率：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InsertSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp=A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j=i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; temp&amp;lt;A[j]; j--) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从后往前查找待插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=A[j];&lt;span class=&quot;comment&quot;&gt;//向后移一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//复制到插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;折半插入排序&quot;&gt;&lt;a href=&quot;#折半插入排序&quot; class=&quot;headerlink&quot; title=&quot;折半插入排序&quot;&gt;&lt;/a&gt;折半插入排序&lt;/h4&gt;&lt;h4 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h4&gt;&lt;h3 id=&quot;交换排序&quot;&gt;&lt;a href=&quot;#交换排序&quot; class=&quot;headerlink&quot; title=&quot;交换排序&quot;&gt;&lt;/a&gt;交换排序&lt;/h3&gt;&lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;思想：表长n，从前往后或（从后往前）两两比较相邻元素的值，逆序则交换，这是第一趟，需要n-1趟。&lt;br&gt;空间效率：O（1）&lt;br&gt;时间效率：平均和最坏都是：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]= &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-i; j++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//第i趟时从a[0]到a[n-i]都与他们的下一个数比较&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123;&lt;span class=&quot;comment&quot;&gt;//如果左边的数更大，则交换a[j]和a[j+1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j] = a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,a[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h4&gt;&lt;p&gt;是所有排序算法中平均时间最好的一种算法，O(nlogn)思想是基于分治法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调整序列中的元素，使得当前序列最左短的元素在调整后满足左侧所以元素均不超过该元素、右侧所有元素均大于该元素。  &lt;/li&gt;
&lt;li&gt;对该元素的左侧和右侧分别递归进行1的调整，直到当前调整区间的长度不超过1.&lt;br&gt;时间复杂度：O(n2)&lt;br&gt;空间复杂度：O(logn)&lt;br&gt;递归实现：&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int temp = &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将表中第一个元素设为枢轴值，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]&amp;gt;temp) &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值小的元素移动到左边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]&amp;lt;=temp) &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值大的元素移动到右边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//枢轴放到最终位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int pos = &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//将[left,right]按A[left]一分为二&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;, pos);&lt;span class=&quot;comment&quot;&gt;//对左子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, pos+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//对右子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;h4 id=&quot;简单选择排序&quot;&gt;&lt;a href=&quot;#简单选择排序&quot; class=&quot;headerlink&quot; title=&quot;简单选择排序&quot;&gt;&lt;/a&gt;简单选择排序&lt;/h4&gt;&lt;p&gt;思想：表长N[1…..N],第i趟排序则从[i……N]中选择关键字最小的元素与i交换，每一趟确定一个元素的最终位置，需要n-1趟。&lt;br&gt;空间效率：O(1)&lt;br&gt;时间效率：平均和最坏都是：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight glsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; selectSort()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = i;&lt;span class=&quot;comment&quot;&gt;//记录最小元素的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=i; j&amp;lt;=n; j++) &lt;span class=&quot;comment&quot;&gt;//从i...n中选择最小元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[j]&amp;lt;A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;]) &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = A[i];&lt;span class=&quot;comment&quot;&gt;//最小元素与A[i]交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[i] = A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;] = A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h4&gt;&lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;含义：将两个或俩个以上的有序表合并成为一个新的有序表。&lt;br&gt;2-路归并排序   递归实现：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将数组A的[L1,R1]与[L2,R2]区间合并为有序区间L2=R1+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L2,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=L1,j=L2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp[maxn],index=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//temp存放合并后的数组，index为其下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1&amp;amp;&amp;amp;j&amp;lt;=R2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=A[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将A[i]加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1)temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将区间[L1,R1]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;=R2)temp[index++]=A[j++];&lt;span class=&quot;comment&quot;&gt;//将区间[L2,R2]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;index; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[L1+i]=temp[i]; &lt;span class=&quot;comment&quot;&gt;//将合并后的序列赋值回数组A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将Array数组当前区间[left,right]进行归并排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (left&amp;lt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, left, mid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        merge(A, left, mid, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;非递归：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;mergeSort(int A[])&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    //step&amp;#20026;&amp;#32452;&amp;#20869;&amp;#20803;&amp;#32032;&amp;#20010;&amp;#25968;&amp;#10;    for (int step= 2; step/2 &amp;#60;= n; step*=2) &amp;#123;&amp;#10;        //&amp;#27599;step&amp;#20010;&amp;#20803;&amp;#32032;&amp;#19968;&amp;#32452;&amp;#65292;&amp;#32452;&amp;#20869;&amp;#36827;&amp;#34892;&amp;#25490;&amp;#24207;&amp;#10;        for (int i =1; i&amp;#60;=n; i+=step) &amp;#123;&amp;#10;            int mid = i +step/2 -1;&amp;#10;            if (mid +1&amp;#60;=n) &amp;#123;&amp;#10;                merge(A,mid,mid+1,min(i+step-1,n));&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者是：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step为组内元素个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; step/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= n; step*=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//每step个元素一组，组内进行排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i+=step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sort(A+i,A+min(i+step,n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h2&gt;&lt;h3 id=&quot;线性结构&quot;&gt;&lt;a href=&quot;#线性结构&quot; class=&quot;headerlink&quot; title=&quot;线性结构&quot;&gt;&lt;/a&gt;线性结构&lt;/h3&gt;&lt;h4 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h4&gt;&lt;h4 id=&quot;折半查找&quot;&gt;&lt;a href=&quot;#折半查找&quot; class=&quot;headerlink&quot; title=&quot;折半查找&quot;&gt;&lt;/a&gt;折半查找&lt;/h4&gt;&lt;p&gt;适用于：有序的顺序表&lt;br&gt;时间复杂度：O(logn)&lt;/p&gt;
&lt;h4 id=&quot;分块查找&quot;&gt;&lt;a href=&quot;#分块查找&quot; class=&quot;headerlink&quot; title=&quot;分块查找&quot;&gt;&lt;/a&gt;分块查找&lt;/h4&gt;&lt;h3 id=&quot;树形结构&quot;&gt;&lt;a href=&quot;#树形结构&quot; class=&quot;headerlink&quot; title=&quot;树形结构&quot;&gt;&lt;/a&gt;树形结构&lt;/h3&gt;&lt;h4 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h4&gt;&lt;h4 id=&quot;二叉平衡数&quot;&gt;&lt;a href=&quot;#二叉平衡数&quot; class=&quot;headerlink&quot; title=&quot;二叉平衡数&quot;&gt;&lt;/a&gt;二叉平衡数&lt;/h4&gt;&lt;h4 id=&quot;B树，B-树&quot;&gt;&lt;a href=&quot;#B树，B-树&quot; class=&quot;headerlink&quot; title=&quot;B树，B+树&quot;&gt;&lt;/a&gt;B树，B+树&lt;/h4&gt;&lt;h3 id=&quot;散列结构&quot;&gt;&lt;a href=&quot;#散列结构&quot; class=&quot;headerlink&quot; title=&quot;散列结构&quot;&gt;&lt;/a&gt;散列结构&lt;/h3&gt;&lt;h4 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://peilinghui.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://peilinghui.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ACM练习</title>
    <link href="http://peilinghui.com/2016/03/14/ACM%E7%BB%83%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/03/14/ACM练习/</id>
    <published>2016-03-14T07:59:15.000Z</published>
    <updated>2016-03-28T14:37:23.000Z</updated>
    
    <content type="html">&lt;p&gt;做一些简单的ACM题。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1928-日期差值&quot;&gt;&lt;a href=&quot;#1928-日期差值&quot; class=&quot;headerlink&quot; title=&quot;1928. 日期差值&quot;&gt;&lt;/a&gt;1928. 日期差值&lt;/h3&gt;&lt;p&gt;有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。&lt;br&gt;输入&lt;br&gt;有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;每组数据输出一行，即日期差值&lt;/p&gt;
&lt;p&gt;样例输入&lt;br&gt;20130101&lt;br&gt;20130105&lt;br&gt;样例输出&lt;br&gt;5&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//预先存好每个月的天数，第一列为平年的天数，第二列为闰年的天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m[&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断某一年是不是闰年&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;leap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (y%&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;amp;&amp;amp;y%&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)||(y%&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//计算某个日期在本年已经过了多少天&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Y,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; D)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i,d;&lt;span class=&quot;comment&quot;&gt;//k为标识平年还是闰年，闰年为1，i为月份，d为天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(Y)) k=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (d=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;M;i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d+=m[i][k];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d+=D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Y1,M1,D1,Y2,M2,D2,i,d1,d2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%4d%2d%2d&quot;&lt;/span&gt;,&amp;amp;Y1,&amp;amp;M1,&amp;amp;D1)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//读取第一个日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%4d%2d%2d&quot;&lt;/span&gt;,&amp;amp;Y2,&amp;amp;M2,&amp;amp;D2);&lt;span class=&quot;comment&quot;&gt;//读取第二个日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d1 = day(Y1, M1, D1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d2 = day(Y2, M2, D2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//选一个基准从0年1月1日到Y1-1年的12月31日一共有多少天，并累加到d1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Y1; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(i))d1 +=&lt;span class=&quot;number&quot;&gt;366&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; d1 +=&lt;span class=&quot;number&quot;&gt;365&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//选一个基准从0年1月1日到Y2-1年的12月31日一共有多少天，并累加到d1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Y2; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(i))d2 +=&lt;span class=&quot;number&quot;&gt;366&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; d2 +=&lt;span class=&quot;number&quot;&gt;365&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//最后俩个天数做差绝对值加1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(d1-d2)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;1933-输出梯形&quot;&gt;&lt;a href=&quot;#1933-输出梯形&quot; class=&quot;headerlink&quot; title=&quot;1933. 输出梯形&quot;&gt;&lt;/a&gt;1933. 输出梯形&lt;/h3&gt;&lt;p&gt;输出一个高度h，输出一个高为h，上底边为h的梯形。&lt;br&gt;输入&lt;br&gt;一个整数h(1&amp;lt;=h&amp;lt;=1000)&lt;br&gt;输出&lt;br&gt;h所对应的梯形。&lt;br&gt;样例输入&lt;br&gt;5&lt;br&gt;样例输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    *****
  *******
*********
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h,i,j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;h)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//当题目没有说明有多少数据需要读入时，用这种方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= h; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ; j &amp;lt;=(h-i)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++)&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j&amp;gt;(h-i)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j &amp;lt;=h+(h-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++) &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;1934-找x&quot;&gt;&lt;a href=&quot;#1934-找x&quot; class=&quot;headerlink&quot; title=&quot;1934.找x&quot;&gt;&lt;/a&gt;1934.找x&lt;/h3&gt;&lt;p&gt;题目：输入一个数n&lt;strong&gt;(1=&amp;lt;n&amp;lt;=200)&lt;/strong&gt;,然后输入n个数值各不相同的数，再输入一个值x,输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）&lt;br&gt;样例输入：&lt;br&gt;4&lt;br&gt;1 2 3 4&lt;br&gt;3&lt;br&gt;样例输出：2&lt;br&gt;思路：遍历查找，找到x的时候就停止&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,x,i,a[&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//当题目没有说明有多少数据需要读入时，用这种方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;a[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i]==x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i == n)  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-1&quot;&lt;/span&gt;);           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;做一些简单的ACM题。&lt;br&gt;
    
    </summary>
    
      <category term="算法编程" scheme="http://peilinghui.com/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ACM" scheme="http://peilinghui.com/tags/ACM/"/>
    
  </entry>
  
</feed>
