<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2017-05-10T11:33:29.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS打包和发布流程</title>
    <link href="http://peilinghui.com/2017/05/10/iOS%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B/"/>
    <id>http://peilinghui.com/2017/05/10/iOS打包和发布流程/</id>
    <published>2017-05-10T08:56:16.000Z</published>
    <updated>2017-05-10T11:33:29.000Z</updated>
    
    <content type="html">&lt;p&gt;学习iOS的打包和发布流程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;证书&quot;&gt;&lt;a href=&quot;#证书&quot; class=&quot;headerlink&quot; title=&quot;证书&quot;&gt;&lt;/a&gt;证书&lt;/h1&gt;&lt;h2 id=&quot;两种证书&quot;&gt;&lt;a href=&quot;#两种证书&quot; class=&quot;headerlink&quot; title=&quot;两种证书&quot;&gt;&lt;/a&gt;两种证书&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;由 apple 官方颁发, 用以证明开发者身份的特殊文件, 在 iOS 开发中主要用于代码签名, 保障 iOS 生态的健康安全, 分为&lt;strong&gt;开发者证书&lt;/strong&gt;和&lt;strong&gt;发布者证书&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;什么时候需要证书：只有在本机模拟器调试时无需代码签名, 当 App 需要在真机运行和发布时需要使用相应证书进行签名&lt;/li&gt;
&lt;li&gt;证书如何获得：首先需要拥有相应权限的开发者帐号, 通过在本地生成配对的密钥, 向 provisioning portal 提交公钥后换取, 后续证书在使用时会验证本地私钥。&lt;/li&gt;
&lt;li&gt;如何对代码进行签名：在 xcode 中, 使用描述文件(provision profile 包含调试者证书, 授权设备清单, 应用ID), 在 Build Settings 中选择存于 Keychain Access 中的证书文件设置调试和发布任务时的代码签名。&lt;/li&gt;
&lt;li&gt;我生成的私钥如何共享给团队成员：在 Keychain Access 中找到导入的证书, 右击导出为包含私钥的 Personal Information Exchange(.p12)文件(导出时可以创建密码), 团队成员再导入 p12 证书后就完整包含了证书和私钥&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;每种license 都有两种安装方式：dev 和 release&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;真机运行-dev&quot;&gt;&lt;a href=&quot;#真机运行-dev&quot; class=&quot;headerlink&quot; title=&quot;真机运行(dev)&quot;&gt;&lt;/a&gt;真机运行(dev)&lt;/h3&gt;&lt;p&gt;真机调试指 mac 连上 iphone, xcode 可以直接以这台 iphone 设备为 build target, 能在 iphone 里执行编译结果&lt;/p&gt;
&lt;p&gt;分为拥有独立开发者帐号(也包括公司帐号或企业帐号成员)和共享开发者帐号两种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;拥有独立开发者帐号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在 provisioning portal 新建应用, 配置授权设备等
开发机上导入证书
在 xcode 上登录开发者帐号, 不需要准备描述文件, xcode 会自动生成(如果是公司帐号可以自动生成 iOS Team Provisioning Profile)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;共享开发者帐号&lt;br&gt;如果无法在 xcode 登录一个开发者帐号, 也可以通过他人对你手机和应用 id 的授权, 得到 .mobileprovision 描述文件再导入其含私钥的证书(p12) 即可, 具体步骤如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获得手机的 udid (可以连上 mac, 在 itunes 中查看)
告知对方 udid (用以设备授权) 和 应用 id
得到对方生成的证书和描述文件后, 先导入 p12 证书, 再双击 mobileprovision 文件
连接手机, 在 xcode 中选择 build target 为已连接的手机
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;发布方式&quot;&gt;&lt;a href=&quot;#发布方式&quot; class=&quot;headerlink&quot; title=&quot;发布方式&quot;&gt;&lt;/a&gt;发布方式&lt;/h1&gt;&lt;p&gt;四种发布方式：&lt;/p&gt;
&lt;h2 id=&quot;苹果应用商店发布AppStore&quot;&gt;&lt;a href=&quot;#苹果应用商店发布AppStore&quot; class=&quot;headerlink&quot; title=&quot;苹果应用商店发布AppStore&quot;&gt;&lt;/a&gt;苹果应用商店发布AppStore&lt;/h2&gt;&lt;h2 id=&quot;苹果应用商店批量购买发布（Volume-Purchase-Program）&quot;&gt;&lt;a href=&quot;#苹果应用商店批量购买发布（Volume-Purchase-Program）&quot; class=&quot;headerlink&quot; title=&quot;苹果应用商店批量购买发布（Volume Purchase Program）&quot;&gt;&lt;/a&gt;苹果应用商店批量购买发布（Volume Purchase Program）&lt;/h2&gt;&lt;h2 id=&quot;Ad-Hoc应用发布方式&quot;&gt;&lt;a href=&quot;#Ad-Hoc应用发布方式&quot; class=&quot;headerlink&quot; title=&quot;Ad Hoc应用发布方式.&quot;&gt;&lt;/a&gt;Ad Hoc应用发布方式.&lt;/h2&gt;&lt;p&gt;Ad Hoc方式发布应用，应用的具体内容也不需要经过苹果的评审，但限制每个应用不能发布到超过100个设备上。如果应用需要小规模的测试或者企业规模很小可以采用这种方式发布企业应用.&lt;/p&gt;
&lt;h2 id=&quot;In-House企业应用发布&quot;&gt;&lt;a href=&quot;#In-House企业应用发布&quot; class=&quot;headerlink&quot; title=&quot;In-House企业应用发布&quot;&gt;&lt;/a&gt;In-House企业应用发布&lt;/h2&gt;&lt;p&gt;In-House企业应用是不能提交到App Store,发布应用的具体内容也是不需要苹果官方审核.安装设备的数量目前也没有任何限制.所以权限最为开放，适合针对支持开放大批量对外用户测试使用.所以你看到很多第三方开放渠道下载IPA其实基于其他企业账号来支持的.&lt;/p&gt;
&lt;h3 id=&quot;内网OTA&quot;&gt;&lt;a href=&quot;#内网OTA&quot; class=&quot;headerlink&quot; title=&quot;内网OTA&quot;&gt;&lt;/a&gt;内网OTA&lt;/h3&gt;&lt;p&gt;OTA即Over-the-Air，是Apple在 iOS4 中新加的一项技术，目的是让开发者能够脱离Appstore，实现从自己的服务器下载并安装iOS应用。简单地说，就是用户只需要在Safari中点开一条链接，就能直接在主界面中安装App。&lt;/p&gt;
&lt;h4 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;用Xcode打包release版本&lt;/li&gt;
&lt;li&gt;搭建本地Web服务器&lt;/li&gt;
&lt;li&gt;开启HTTPS&lt;/li&gt;
&lt;li&gt;编写好对应的.plist文件&lt;/li&gt;
&lt;li&gt;上传ipa、.plist、ca证书到Web服务器，配置好index.html&lt;/li&gt;
&lt;li&gt;在手机上用Safari打开链接，完成下载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更多参考：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/35ca63ec0d8e&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;一步一步实现无线安装iOS应用(内网OTA)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/close_marty/article/details/38559673&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jenkins中集成OTA发布&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;更多参考：&quot;&gt;&lt;a href=&quot;#更多参考：&quot; class=&quot;headerlink&quot; title=&quot;更多参考：&quot;&gt;&lt;/a&gt;更多参考：&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.qcloud.com/community/article/673429&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iOS 程序从开发完到上 AppStore 那点事儿&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/mddblog/p/4718228.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;苹果企业账号打包发布APP流程详解&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;学习iOS的打包和发布流程。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习iOS中JS与OC相互调用的方式</title>
    <link href="http://peilinghui.com/2017/05/05/%E5%AD%A6%E4%B9%A0iOS%E4%B8%ADJS%E4%B8%8EOC%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://peilinghui.com/2017/05/05/学习iOS中JS与OC相互调用的方式/</id>
    <published>2017-05-05T06:50:42.000Z</published>
    <updated>2017-05-10T12:08:22.000Z</updated>
    
    <content type="html">&lt;p&gt;Web App即是HTML5 APP框架开发模式，使用HTML5,CSS3以及JavaScript以及服务器端语言来完成开发，Web App具有跨平台的优势。那么就来学习一下iOS中JS与OC相互调用的方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;目前JS与OC相互调用的方式&quot;&gt;&lt;a href=&quot;#目前JS与OC相互调用的方式&quot; class=&quot;headerlink&quot; title=&quot;目前JS与OC相互调用的方式&quot;&gt;&lt;/a&gt;目前JS与OC相互调用的方式&lt;/h1&gt;&lt;p&gt;目前主要的JS与OC相互调用方式主要有如下6种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在JS 中做一次URL跳转，然后在OC中拦截跳转。（这里分为UIWebView 和 WKWebView两种，UIWebView兼容iOS 6）&lt;/li&gt;
&lt;li&gt;利用WKWebView 的MessageHandler。(有坑)&lt;/li&gt;
&lt;li&gt;利用系统库JavaScriptCore，来做相互调用。（iOS 7推出）&lt;/li&gt;
&lt;li&gt;利用第三方库WebViewJavascriptBridge。&lt;/li&gt;
&lt;li&gt;利用第三方cordova库，以前叫PhoneGap。（这是一个库平台的库）&lt;/li&gt;
&lt;li&gt;当下盛行的React Native。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8A%E5%8D%8811.49.52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;拦截URL&quot;&gt;&lt;a href=&quot;#拦截URL&quot; class=&quot;headerlink&quot; title=&quot;拦截URL&quot;&gt;&lt;/a&gt;拦截URL&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8A%E5%8D%8811.55.32.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;UIWebView&quot;&gt;&lt;a href=&quot;#UIWebView&quot; class=&quot;headerlink&quot; title=&quot;UIWebView&quot;&gt;&lt;/a&gt;UIWebView&lt;/h2&gt;&lt;p&gt;在以前我们只能通过UIWebView的UIWebViewDelegate协议来实现oc与js的通信交互就是发送消息，也即函数调用。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)stringByEvaluatingJavaScriptFromString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)script;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;UIWebViewDelegate&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@optional&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)webView:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView shouldStartLoadWithRequest:(&lt;span class=&quot;built_in&quot;&gt;NSURLRequest&lt;/span&gt; *)request navigationType:(&lt;span class=&quot;built_in&quot;&gt;UIWebViewNavigationType&lt;/span&gt;)navigationType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webViewDidStartLoad:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webViewDidFinishLoad:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)webView:(&lt;span class=&quot;built_in&quot;&gt;UIWebView&lt;/span&gt; *)webView didFailLoadWithError:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;oc–&amp;gt;js stringByEvaluatingJavaScriptFromString,其参数是一NSString 字符串内容是js代码（这又可以是一个js函数、一句js代码或他们的组合），当js函数有返回值或一句js代码有值返回可通过stringByEvaluatingJavaScriptFromString的返回值获取&lt;/li&gt;
&lt;li&gt;js–&amp;gt;oc 利用webView的重定向原理（即重新在js中指定document.location的值，此为一url），只要在这个url字符串中按自定义的规则指定好所需调用oc中的函数和参数，然后通过OC中的shouldStartLoadWithRequest函数去捕获处理请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;WKWebView&quot;&gt;&lt;a href=&quot;#WKWebView&quot; class=&quot;headerlink&quot; title=&quot;WKWebView&quot;&gt;&lt;/a&gt;WKWebView&lt;/h2&gt;&lt;p&gt;由于UIWebView比较耗内存，性能上不太好，而苹果在iOS8中推出了WKWebView。同样的用WKWebView也可以拦截URL，做JS与OC交互。WKWebView与UIWebView拦截URL的处理方式基本一样。除了代理方法和WKWebView的使用不太一样。&lt;/p&gt;
&lt;!--在framework的webKit中：--&gt;
&lt;a href=&quot;!--![](http://7xr8q7.com1.z0.glb.clouddn.com/WKWebView.png)
--&quot;&gt;!--![](http://7xr8q7.com1.z0.glb.clouddn.com/WKWebView.png)
--&lt;/a&gt;
&lt;h3 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;更多的支持HTML5的特性
官方宣称的高达60fps的滚动刷新率以及内置手势
将UIWebViewDelegate与UIWebView拆分成了14类与3个协议,以前很多不方便实现的功能得以实现。文档
Safari相同的JavaScript引擎
占用更少的内存
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;WKWebView的创建有几点不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化多了configuration参数，当然这个参数也可以不传，直接使用默认的设置。&lt;/li&gt;
&lt;li&gt;WKWebView的代理有两个navigationDelegate和UIDelegate。我们要拦截URL，就要通过navigationDelegate的一个代理方法来实现。如果在HTML中要使用alert等弹窗，就必须得实现UIDelegate的相应代理方法。&lt;/li&gt;
&lt;li&gt;在iOS9之前，WKWebView加载本地HTML会有一些问题。（不能加载本地HTML，或者部分CSS/本地图片加载不了等）&lt;/li&gt;
&lt;li&gt;注意加载HTTP和HTTPS的时候要在文件设置App Transport Security Settings的Allow Arbitrary Loads设置为YES。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;WKNavigationDelegate&quot;&gt;&lt;a href=&quot;#WKNavigationDelegate&quot; class=&quot;headerlink&quot; title=&quot;WKNavigationDelegate&quot;&gt;&lt;/a&gt;WKNavigationDelegate&lt;/h4&gt;&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pp&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;webView:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKWebView&lt;/span&gt; *)&lt;/span&gt;webView decidePolicyForNavigationAction:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKNavigationAction&lt;/span&gt; *)&lt;/span&gt;navigationAction decisionHandler:&lt;span class=&quot;params&quot;&gt;(void (^)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;WKNavigationActionPolicy&lt;/span&gt;)&lt;/span&gt;)decisionHandler&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现这个代理方法，必须得调用decisionHandler这个block，否则会导致app 崩溃。block参数是个枚举类型，WKNavigationActionPolicyCancel代表取消加载，相当于UIWebView的代理方法return NO的情况；WKNavigationActionPolicyAllow代表允许加载，相当于UIWebView的代理方法中return YES的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WKWebView中OC直接调用JS方法&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *js = &lt;span class=&quot;string&quot;&gt;@&quot;callJsAlert()&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.webView&lt;/span&gt; evaluateJavaScript:js completionHandler:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; _Nullable response, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;response: %@ error: %@&quot;&lt;/span&gt;, response, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;call js alert by native&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;evaluateJavaScript:completionHandler:&lt;/strong&gt;没有返回值，JS 执行成功还是失败会在completionHandler 中返回。所以使用这个API 就可以避免执行耗时的JS，或者alert 导致界面卡住的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WKWebView中JS调用OC原生方法&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;MessageHandler&quot;&gt;&lt;a href=&quot;#MessageHandler&quot; class=&quot;headerlink&quot; title=&quot;MessageHandler&quot;&gt;&lt;/a&gt;MessageHandler&lt;/h2&gt;&lt;p&gt;利用WKWebView的新特性MessageHandler来实现JS调用原生方法。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-05-08%20%E4%B8%8B%E5%8D%881.58.58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;MessageHandler的好处&quot;&gt;&lt;a href=&quot;#MessageHandler的好处&quot; class=&quot;headerlink&quot; title=&quot;MessageHandler的好处&quot;&gt;&lt;/a&gt;MessageHandler的好处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在JS中写起来简单，不用再用创建URL的方式那么麻烦了。&lt;/li&gt;
&lt;li&gt;JS传递参数更方便。使用拦截URL的方式传递参数，只能把参数拼接在后面，如果遇到要传递的参数中有特殊字符，如&amp;amp;、=、?等，必须得转换，否则参数解析肯定会出错。&lt;/li&gt;
&lt;li&gt;使用MessageHandler就可以避免特殊字符引起的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h3&gt;&lt;p&gt;WKWebView初始化时，有一个参数叫configuration，它是WKWebViewConfiguration类型的参数，而WKWebViewConfiguration有一个属性叫userContentController，它又是WKUserContentController类型的参数。WKUserContentController对象有一个方法- addScriptMessageHandler:name:，我把这个功能简称为MessageHandler。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- addScriptMessageHandler:name:&lt;/code&gt;有两个参数，第一个参数是userContentController的代理对象，第二个参数是JS里发送postMessage的对象。&lt;/p&gt;
&lt;p&gt;所以要使用MessageHandler功能，就必须要实现WKScriptMessageHandler协议。&lt;br&gt;在OC文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;config.userContentController = [[WKUserContentController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 注入JS对象名称AppModel，当JS通过AppModel来调用时，我们可以在WKScriptMessageHandler代理中接收到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[config.userContentController &lt;span class=&quot;string&quot;&gt;addScriptMessageHandler:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;AppModel&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//WKScriptMessageHandler协议&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;userContentController:&lt;/span&gt;(WKUserContentController *)userContentController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;      didReceiveScriptMessage:&lt;/span&gt;(WKScriptMessage *)message &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([message.name &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;AppModel&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;%@&quot;&lt;/span&gt;, message.body);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现协议方法。&lt;br&gt;这里实现了两个协议&amp;lt; WKUIDelegate,WKScriptMessageHandler &amp;gt;，WKUIDelegate是因为需要在JS中弹出alert。WKScriptMessageHandler是用来处理JS调用OC方法的请求。&lt;strong&gt;名字替换AppModel&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在JS文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// AppModel是我们所注入的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.webkit&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.messageHandlers&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.AppModel&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.postMessage&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attribute&quot;&gt;body&lt;/span&gt;: response&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;JavaScriptCore&quot;&gt;&lt;a href=&quot;#JavaScriptCore&quot; class=&quot;headerlink&quot; title=&quot;JavaScriptCore&quot;&gt;&lt;/a&gt;JavaScriptCore&lt;/h2&gt;&lt;p&gt;JavaScriptCore自iOS7之后出现，用Objective-C把WebKit的JavaScript引擎封装了一下，提供了简单快捷的方式与JavaScript交互。&lt;/p&gt;
&lt;p&gt;特点： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS中调用OC方法更简单，参数的传递也更加简单 &lt;/li&gt;
&lt;li&gt;支持iOS7以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用-1&quot;&gt;&lt;a href=&quot;#使用-1&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;使用前需要先导入JavaScriptCore.framework&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSVirtualMachine直译是JS虚拟机，也就是说JavaScript是在一个虚拟的环境中执行，而JSVirtualMachine为其执行提供底层资源。&lt;/li&gt;
&lt;li&gt;JSContext是为JavaScript的执行提供运行环境，所有的JavaScript的执行都必须在JSContext环境中。JSContext也管理JSVirtualMachine中对象的生命周期。每一个JSValue对象都要强引用关联一个JSContext。当与某JSContext对象关联的所有JSValue释放后，JSContext也会被释放。&lt;/li&gt;
&lt;li&gt;JSValue都是通过JSContext返回或者创建的，并没有构造方法。JSValue包含了每一个JavaScript类型的值，通过JSValue可以将Objective-C中的类型转换为JavaScript中的类型，也可以将JavaScript中的类型转换为Objective-C中的类型。&lt;/li&gt;
&lt;li&gt;JSManagedValue主要用途是解决JSValue对象在Objective-C堆上的安全引用问题。把JSValue保存进Objective-C堆对象中是不正确的，这很容易引发循环引用，而导致JSContext不能释放。但是不常用。&lt;/li&gt;
&lt;li&gt;JSExport是一个协议类，但是该协议并没有任何属性和方法。可以自定义一个协议类，继承自JSExport。无论在JSExport里声明的属性、实例方法还是类方法，继承的协议都会自动的提供给任何JavaScript代码。因此，只需要在自定义的协议类中，添加上属性和方法就可以了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;WKWebVIew中的坑&quot;&gt;&lt;a href=&quot;#WKWebVIew中的坑&quot; class=&quot;headerlink&quot; title=&quot;WKWebVIew中的坑&quot;&gt;&lt;/a&gt;WKWebVIew中的坑&lt;/h1&gt;&lt;h2 id=&quot;WKWebView导致ViewController不调用dealloc方法&quot;&gt;&lt;a href=&quot;#WKWebView导致ViewController不调用dealloc方法&quot; class=&quot;headerlink&quot; title=&quot;WKWebView导致ViewController不调用dealloc方法&quot;&gt;&lt;/a&gt;WKWebView导致ViewController不调用dealloc方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;webview不设置 delegate，可以正常dealloc&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;webview.UIDelegate和 navigationDelegate 设置为 self，可以正常&lt;br&gt;dealloc&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;webview.configuration.userContentController addScriptMessageHandler 为 self之后，无法正常dealloc，该方法引起ViewController内存泄漏。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;4.使用 ScriptMessageHandler 作为 webview.scriptMessageHandler，当前viewController 可以正常释放。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5.当前 viewController dealloc 方法中，通过 removeScriptMessazgeHanlder 释放掉&lt;br&gt;scriptMessageHandler&lt;/p&gt;
&lt;p&gt;解决方法：&lt;br&gt;(1)WeakScriptMessageDelegate&lt;br&gt;可以创建一个新的类WeakScriptMessageDelegate，也可以将@interface-@end写在ViewController.h中，@implementation-@end写在ViewController.m中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeakScriptMessageDelegate&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;WKScriptMessageHandler&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt; scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithDelegate:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt;)scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WeakScriptMessageDelegate&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithDelegate:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;WKScriptMessageHandler&amp;gt;)scriptDelegate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _scriptDelegate = scriptDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.scriptDelegate&lt;/span&gt; userContentController:userContentController didReceiveScriptMessage:message];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(2)使用&lt;/p&gt;
&lt;figure class=&quot;highlight pf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_webView = [[WKWebView alloc] initWithFrame:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;.view.bounds configuration:configuration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; _webView.UIDelegate = &lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; _webView.navigationDelegate = &lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController = [WKUserContentController new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//无法正常dealloc[configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController addScriptMessageHandler:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt; name:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//使用代理来实现可以调用dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[configuration.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;] name:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; - (void)dealloc &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;literal&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt;ContentController removeScriptMessageHandlerForName:@&lt;span class=&quot;string&quot;&gt;&quot;myHandler&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHWebViewDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHWebViewDemo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/9513d101e582#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WKWebView使用及注意点(keng)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;扩展&quot;&gt;&lt;a href=&quot;#扩展&quot; class=&quot;headerlink&quot; title=&quot;扩展&quot;&gt;&lt;/a&gt;扩展&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://imciel.com/2016/06/18/oc-js-communication/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用 JavaScriptCore 实现 JS和OC间的通信&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.brighttj.com/ios/ios-user-safari-debug-webview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;使用safari对webview进行调试&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Web App即是HTML5 APP框架开发模式，使用HTML5,CSS3以及JavaScript以及服务器端语言来完成开发，Web App具有跨平台的优势。那么就来学习一下iOS中JS与OC相互调用的方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习NSURLProtocol</title>
    <link href="http://peilinghui.com/2017/04/30/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0NSURLProtocol/"/>
    <id>http://peilinghui.com/2017/04/30/深入学习NSURLProtocol/</id>
    <published>2017-04-30T04:59:56.000Z</published>
    <updated>2017-04-30T09:18:27.000Z</updated>
    
    <content type="html">&lt;p&gt;研究一下NSURLProtocol.h。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;NSURLProtocol是什么？&quot;&gt;&lt;a href=&quot;#NSURLProtocol是什么？&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol是什么？&quot;&gt;&lt;/a&gt;NSURLProtocol是什么？&lt;/h1&gt;&lt;p&gt;NSURLProtocol是URL Loading System的重要组成部分。&lt;br&gt;首先虽然名叫NSURLProtocol，但它却不是协议。它是一个抽象类。我们要使用它的时候需要创建它的一个子类。&lt;br&gt;NSURLProtocol在iOS系统中大概处于这样一个位置。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-30%20%E4%B8%8B%E5%8D%882.12.33.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果开发者自定义的一个NSURLProtocol并且注册到app中，那么在这个自定义的NSURLProtocol中我们可以拦截UIWebView，基于系统的NSURLConnection或者NSURLSession进行封装的网络请求，然后做到自定义的response返回。非常强大。&lt;/p&gt;
&lt;h1 id=&quot;NSURLProtocol能拦截哪些网络请求&quot;&gt;&lt;a href=&quot;#NSURLProtocol能拦截哪些网络请求&quot; class=&quot;headerlink&quot; title=&quot;NSURLProtocol能拦截哪些网络请求&quot;&gt;&lt;/a&gt;NSURLProtocol能拦截哪些网络请求&lt;/h1&gt;&lt;p&gt;URL Loading System&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-30%20%E4%B8%8B%E5%8D%882.13.34.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以，可以拦截的网络请求包括NSURLSession，NSURLConnection以及UIWebVIew。&lt;br&gt;基于CFNetwork的网络请求，以及WKWebView的请求是无法拦截的。&lt;/p&gt;
&lt;p&gt;现在主流的iOS网络库，例如AFNetworking，Alamofire等网络库都是基于NSURLSession或NSURLConnection的，所以这些网络库的网络请求都可以被NSURLProtocol所拦截 。&lt;br&gt;还有一些年代比较久远的网络库，例如ASIHTTPRequest，MKNetwokit等网路库都是基于CFNetwork的，所以这些网络库的网络请求无法被NSURLProtocol拦截。&lt;/p&gt;
&lt;h1 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h1&gt;&lt;p&gt;NSURLProtocol是一个抽象类。我们要使用它的时候需要创建它的一个子类。&lt;br&gt;&lt;code&gt;@interface PLHHTTPProtocol : NSURLProtocol&lt;/code&gt;&lt;br&gt;使用NSURLProtocol的主要可以分为5个步骤：&lt;br&gt;注册—&amp;gt;拦截—&amp;gt;转发—&amp;gt;回调—&amp;gt;结束&lt;/p&gt;
&lt;h2 id=&quot;注册：&quot;&gt;&lt;a href=&quot;#注册：&quot; class=&quot;headerlink&quot; title=&quot;注册：&quot;&gt;&lt;/a&gt;注册：&lt;/h2&gt;&lt;p&gt;在系统加载的时候，把自定义的PLHHTTPProtocol注册到URL加载系统中，这样 所有的URL请求都有机会进入我们自定义的PLHHTTPProtocol进行拦截处理。&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (BOOL)&lt;span class=&quot;tag&quot;&gt;application&lt;/span&gt;:(UIApplication *)&lt;span class=&quot;tag&quot;&gt;application&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;didFinishLaunchingWithOptions&lt;/span&gt;:(NSDictionary *)&lt;span class=&quot;tag&quot;&gt;launchOptions&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[NSURLProtocol registerClass:[PLHHTTPURLProtocol class]&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于基于NSURLSession的网络请求，需要通过配置NSURLSessionConfiguration对象的protocolClasses属性。&lt;/p&gt;
&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sessionConfiguration.protocolClasses = @&lt;span class=&quot;string&quot;&gt;[[NSClassFromString(@&quot;CustomURLProtocol&quot;) class]]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;拦截：&quot;&gt;&lt;a href=&quot;#拦截：&quot; class=&quot;headerlink&quot; title=&quot;拦截：&quot;&gt;&lt;/a&gt;拦截：&lt;/h2&gt;&lt;p&gt;在拦截到网络请求后，NSURLProtocol会依次执行下列方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (BOOL)canInitWithRequest:(NSURLRequest *)request&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方法会拿到request的对象，我们可以通过该方法的返回值来筛选request是否需要被NSURLProtocol做拦截处理。&lt;br&gt;如果返回YES则进入该自定义加载器进行处理，如果返回NO则不进入该自定义选择器，使用系统默认行为进行处理。&lt;/p&gt;
&lt;p&gt;重新设置NSURLRequest的信息:&lt;br&gt;&lt;code&gt;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request&lt;/code&gt;&lt;br&gt;比如请求重定向或者添加头部信息等等。如果没有特殊需求，直接返回request就可以了。但是因为这个方法在会在一次请求中被调用多次（暂时我也不知道什么原因为什么需要回调多洗），所以request重定向和添加头部信息也可以在开始加载中startLoading方法中重新设置。&lt;/p&gt;
&lt;h2 id=&quot;转发&quot;&gt;&lt;a href=&quot;#转发&quot; class=&quot;headerlink&quot; title=&quot;转发&quot;&gt;&lt;/a&gt;转发&lt;/h2&gt;&lt;p&gt;在拦截到网络请求，并且对网络请求进行定制处理以后。我们需要将网络请求重新发送出去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (id)initWithRequest:(NSURLRequest *)request cachedResponse:(NSCachedURLResponse *)cachedResponse client:(id&amp;lt;NSURLProtocolClient&amp;gt;)client&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该方法会创建一个NSURLProtocol实例，这里每一个网络请求都会创建一个新的实例。被拦截的请求开始执行的地方.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)startLoading&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接下来就是转发的核心方法startLoading。在该方法中，我们把处理过的request重新发送出去。至于发送的形式，可以是基于NSURLConnection，NSURLSession甚至CFNetwork。&lt;/p&gt;
&lt;h2 id=&quot;回调&quot;&gt;&lt;a href=&quot;#回调&quot; class=&quot;headerlink&quot; title=&quot;回调&quot;&gt;&lt;/a&gt;回调&lt;/h2&gt;&lt;p&gt;既是面向切面的编程，就不能影响到原来网络请求的逻辑。所以上一步将网络请求转发出去以后，当收到网络请求的返回，还需要再将返回值返回给原来发送网络请求的地方。&lt;br&gt;主要需要需要调用到&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didFailWithError:error]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocolDidFinishLoading:&lt;span class=&quot;keyword&quot;&gt;self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self.client &lt;/span&gt;URLProtocol:&lt;span class=&quot;keyword&quot;&gt;self &lt;/span&gt;didLoadData:&lt;span class=&quot;preprocessor&quot;&gt;data&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这四个方法来回调给原来发送网络请求的地方。&lt;br&gt;这里假设我们在转发过程中是使用NSURLSession发送的网络请求，那么在NSURLSession的回调方法中，我们做相应的处理即可。并且我们也可以对这些返回，进行定制化处理。&lt;/p&gt;
&lt;h2 id=&quot;结束：&quot;&gt;&lt;a href=&quot;#结束：&quot; class=&quot;headerlink&quot; title=&quot;结束：&quot;&gt;&lt;/a&gt;结束：&lt;/h2&gt;&lt;p&gt;在一个网络请求完全结束以后，NSURLProtocol回调用到.结束加载URL请求&lt;br&gt;&lt;code&gt;- (void)stopLoading&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;p&gt;既然NSURLProtocol功能非常强大，那么在具体开发中，会有哪些应用呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义请求和响应&lt;/li&gt;
&lt;li&gt;网络的缓存处理（H5离线包 和 网络图片缓存）&lt;/li&gt;
&lt;li&gt;重定向网络请求&lt;/li&gt;
&lt;li&gt;为测试提供数据Mocking功能，在没有网络的情况下使用本地数据返回。&lt;/li&gt;
&lt;li&gt;过滤掉一些非法请求&lt;/li&gt;
&lt;li&gt;快速进行测试环境的切换&lt;/li&gt;
&lt;li&gt;拦截图片加载请求，转为从本地文件加载&lt;/li&gt;
&lt;li&gt;可以拦截UIWebView，基于系统的NSURLConnection或者NSURLSession进行封装的网络请求。目前WKWebView无法被NSURLProtocol拦截。&lt;/li&gt;
&lt;li&gt;当有多个自定义NSURLProtocol注册到系统中的话，会按照他们注册的反向顺序依次调用URL加载流程。当其中有一个NSURLProtocol拦截到请求的话，后续的NSURLProtocol就无法拦截到该请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DEMO地址：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHHTTPDNSDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHHTTPDNSDemo&lt;/a&gt;      &lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/02781c0bbca9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NSURLProtocol全攻略&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/55f5ac1ab817&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WKWebView 不支持 NSURLProtocol 吗&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;研究一下NSURLProtocol.h。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>学习React Native</title>
    <link href="http://peilinghui.com/2017/04/25/%E5%AD%A6%E4%B9%A0React-Native/"/>
    <id>http://peilinghui.com/2017/04/25/学习React-Native/</id>
    <published>2017-04-25T09:51:37.000Z</published>
    <updated>2017-04-27T06:20:52.000Z</updated>
    
    <content type="html">&lt;p&gt;抽时间学习一下&lt;a href=&quot;https://github.com/facebook/react-native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;React-Native-简介&quot;&gt;&lt;a href=&quot;#React-Native-简介&quot; class=&quot;headerlink&quot; title=&quot;React Native 简介&quot;&gt;&lt;/a&gt;React Native 简介&lt;/h1&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;安装Node.js&lt;br&gt;下载node.js：&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt;&lt;br&gt;或者安装brew来安装node.js.&lt;br&gt;&lt;code&gt;node -v&lt;/code&gt;最新的版本&lt;/li&gt;
&lt;li&gt;安装React Native&lt;br&gt;先通过HomeBrew安装watchman和flow&lt;br&gt;&lt;code&gt;brew install watchman&lt;/code&gt;&lt;br&gt;&lt;code&gt;brew install flow&lt;/code&gt;&lt;br&gt;再通过npm安装react-native-cli的工具&lt;br&gt;&lt;code&gt;sudo npm install -g react-native-cli&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用NVM来管理node.js版本&lt;br&gt;&lt;code&gt;git clone https://github.com/creationix/nvm&lt;/code&gt;或者&lt;code&gt;git clone https://github.com/cnpm/nvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建项目&lt;br&gt;创建项目Hello：用react-native init命令&lt;code&gt;react-native init Hello&lt;/code&gt;，打开Xcode文件后运行，自动启动终端和模拟器。然后模拟器就出现了字，显示成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;debug的方式&quot;&gt;&lt;a href=&quot;#debug的方式&quot; class=&quot;headerlink&quot; title=&quot;debug的方式&quot;&gt;&lt;/a&gt;debug的方式&lt;/h2&gt;&lt;p&gt;在模拟器上点击commend+D，出现下面的界面。开始调试。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-25%20%E4%B8%8B%E5%8D%887.11.44.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;reload：刷新页面，只有修改了JS文件的时候刷新有效。&lt;/li&gt;
&lt;li&gt;Debug Remote JS主要是在chrome上，开发者工具(Commod)&lt;br&gt;APPdelegate中改bug，打开注释，进行debug。或者使用工具nuclide。&lt;/li&gt;
&lt;li&gt;Enable Live Reload：自动刷新，&lt;h1 id=&quot;React-Native组件&quot;&gt;&lt;a href=&quot;#React-Native组件&quot; class=&quot;headerlink&quot; title=&quot;React Native组件&quot;&gt;&lt;/a&gt;React Native组件&lt;/h1&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/hello-world.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React JS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://facebook.github.io/react-native/docs/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://nuclide.io/docs/quick-start/getting-started/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nuclide插件&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Render-amp-JSX&quot;&gt;&lt;a href=&quot;#Render-amp-JSX&quot; class=&quot;headerlink&quot; title=&quot;Render&amp;amp;JSX&quot;&gt;&lt;/a&gt;Render&amp;amp;JSX&lt;/h2&gt;&lt;figure class=&quot;highlight dust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;render() &lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;variable&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;txt&lt;/span&gt; = &#39;&lt;span class=&quot;variable&quot;&gt;Hello&lt;/span&gt;&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;variable&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;say&lt;/span&gt;(&lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;return&lt;/span&gt; &#39;&lt;span class=&quot;variable&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;am&lt;/span&gt; &#39;+&lt;span class=&quot;variable&quot;&gt;name&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;This is a title!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;txt&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Image&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;source&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;require&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/img&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/bg.png&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Image&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;source&lt;/span&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;require&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/img&lt;/span&gt;&lt;span class=&quot;end-block&quot;&gt;/icon.png&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;expression&quot;&gt;&amp;#123;&lt;span class=&quot;variable&quot;&gt;say&lt;/span&gt;(&#39;&lt;span class=&quot;variable&quot;&gt;React&lt;/span&gt;&#39;)&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;View&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;组件生命周期&quot;&gt;&lt;a href=&quot;#组件生命周期&quot; class=&quot;headerlink&quot; title=&quot;组件生命周期&quot;&gt;&lt;/a&gt;组件生命周期&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;初始化&lt;ul&gt;
&lt;li&gt;getDefaultProps&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getInitialState&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;render&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentDidMount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;componentWillReceiveProps&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shouldComponentUpdate // return true|false&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;shouldComponentUpdate(nextProps, nextState) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;command&quot;&gt;return&lt;/span&gt; nextProps.&lt;span class=&quot;property&quot;&gt;id&lt;/span&gt; !== this.props.&lt;span class=&quot;property&quot;&gt;id&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentWillUpdate //not called for the initial render&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidUpdate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销毁&lt;ul&gt;
&lt;li&gt;componentWillUnmount&lt;br&gt;更多：&lt;a href=&quot;https://race604.com/react-native-component-lifecycle/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://race604.com/react-native-component-lifecycle/&lt;/a&gt;&lt;h2 id=&quot;Props-amp-States&quot;&gt;&lt;a href=&quot;#Props-amp-States&quot; class=&quot;headerlink&quot; title=&quot;Props &amp;amp; States&quot;&gt;&lt;/a&gt;Props &amp;amp; States&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Props:properties属性，在初始化的时候传入并且可以显示不同的状态。&lt;br&gt;props不可变&lt;br&gt;states不可变&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;React-Native的常用组件和API&quot;&gt;&lt;a href=&quot;#React-Native的常用组件和API&quot; class=&quot;headerlink&quot; title=&quot;React Native的常用组件和API&quot;&gt;&lt;/a&gt;React Native的常用组件和API&lt;/h1&gt;&lt;h2 id=&quot;flexbox布局&quot;&gt;&lt;a href=&quot;#flexbox布局&quot; class=&quot;headerlink&quot; title=&quot;flexbox布局&quot;&gt;&lt;/a&gt;flexbox布局&lt;/h2&gt;&lt;h1 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;headerlink&quot; title=&quot;学习资料&quot;&gt;&lt;/a&gt;学习资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/reactnativecn/react-native-guide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React-Native学习指南&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.gitbook.com/book/unbug/react-native-training/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gitbook&lt;/a&gt;—–&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLC_rYRxEnwQGLQqrHR0aho33U6DCeJamC&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;对应的视频&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/crazycodeboy/react-native-awesome&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React Native学习资源精选仓库&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.devio.org/tags/#React Native&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;抽时间学习一下&lt;a href=&quot;https://github.com/facebook/react-native&quot;&gt;React Native&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIView的Frame和bounds区别</title>
    <link href="http://peilinghui.com/2017/04/21/UIView%E7%9A%84Frame%E5%92%8Cbounds%E5%8C%BA%E5%88%AB/"/>
    <id>http://peilinghui.com/2017/04/21/UIView的Frame和bounds区别/</id>
    <published>2017-04-21T10:48:21.000Z</published>
    <updated>2017-04-22T06:19:05.000Z</updated>
    
    <content type="html">&lt;p&gt;UIView的相关重点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/UIview.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;frame和bounds简介&quot;&gt;&lt;a href=&quot;#frame和bounds简介&quot; class=&quot;headerlink&quot; title=&quot;frame和bounds简介&quot;&gt;&lt;/a&gt;frame和bounds简介&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/frame%E5%92%8Cbounds.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;frame: 该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;br&gt;bounds：该view在本地坐标系统中的位置和大小。（参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）&lt;br&gt;center：该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;/p&gt;
&lt;h1 id=&quot;实际例子&quot;&gt;&lt;a href=&quot;#实际例子&quot; class=&quot;headerlink&quot; title=&quot;实际例子&quot;&gt;&lt;/a&gt;实际例子&lt;/h1&gt;&lt;p&gt;Demo：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/FrameAndBoundsDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/FrameAndBoundsDemo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;旋转一个自定义View&quot;&gt;&lt;a href=&quot;#旋转一个自定义View&quot; class=&quot;headerlink&quot; title=&quot;旋转一个自定义View&quot;&gt;&lt;/a&gt;旋转一个自定义View&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark --   例子1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//旋转一个自定义view后，frame改变了，而bounds没有改变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *View1 = [[&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;built_in&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;View1&lt;span class=&quot;variable&quot;&gt;.backgroundColor&lt;/span&gt; = [&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt; addSubview:View1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;自定义子view的self.view.frame = %@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自定义子view的self.view.frame = &amp;#123;&amp;#123;100, 100&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;自定义子view的self.view.bounds=%@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//自定义子view的self.view.bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; transitionWithView:View1 duration:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; options:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    View1&lt;span class=&quot;variable&quot;&gt;.transform&lt;/span&gt; = &lt;span class=&quot;built_in&quot;&gt;CGAffineTransformMakeRotation&lt;/span&gt;(M_PI_4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;completion:^(&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; finished)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (finished)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;旋转后子view的self.view.frame = %@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//旋转后子view的self.view.frame = &amp;#123;&amp;#123;89.644660940672622, 89.644660940672622&amp;#125;, &amp;#123;70.710678118654755, 70.710678118654755&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;旋转后子view的self.view.bounds=%@&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;NSStringFromCGRect&lt;/span&gt;(View1&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//旋转后子view的self.view.bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.09.35.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.09.00.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;在旋转动画后，frame发生改变，bounds依然没变。下面的结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;frame的位置是根据父容器来计算的，正方形在动画开始前的x=100,y=100是相对于self.view的坐标系统而言的，从而确定当前视图在父视图中的位置。&lt;/li&gt;
&lt;li&gt;bounds的x,y是根据自己的坐标系统而言的。没错，每个view都有自己的坐标系。以自己左上角点为坐标原点。所以bounds的x,y默认为(0,0),除非调用setBounds方法；&lt;/li&gt;
&lt;li&gt;frame的size不一定等于bounds的size，在旋转后它们的size就不一样了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把frame理解为占用区域，把bounds理解为边界。View在旋转过程中，其实自己的坐标系统并没有发生改变，bounds中的origin只能通过setBounds方法修改。&lt;/p&gt;
&lt;h3 id=&quot;把一个子View放到父View中，改变父View的bounds&quot;&gt;&lt;a href=&quot;#把一个子View放到父View中，改变父View的bounds&quot; class=&quot;headerlink&quot; title=&quot;把一个子View放到父View中，改变父View的bounds&quot;&gt;&lt;/a&gt;把一个子View放到父View中，改变父View的bounds&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; *fatherView = [[&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; alloc]&lt;span class=&quot;symbol&quot;&gt;initWithFrame:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatherView.backgroundColor = [&lt;span class=&quot;constant&quot;&gt;UIColor&lt;/span&gt; yellowColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.view &lt;span class=&quot;symbol&quot;&gt;addSubview:&lt;/span&gt;fatherView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; *sunView = [[&lt;span class=&quot;constant&quot;&gt;UIView&lt;/span&gt; alloc]&lt;span class=&quot;symbol&quot;&gt;initWithFrame:&lt;/span&gt;&lt;span class=&quot;constant&quot;&gt;CGRectMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sunView.backgroundColor = [&lt;span class=&quot;constant&quot;&gt;UIColor&lt;/span&gt; redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[fatherView &lt;span class=&quot;symbol&quot;&gt;addSubview:&lt;/span&gt;sunView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;NSLog&lt;/span&gt;(@&lt;span class=&quot;string&quot;&gt;&quot;父view的frame = %@,bounds=%@,中心点=：%@&quot;&lt;/span&gt;,&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(fatherView.frame),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(fatherView.bounds),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGPoint&lt;/span&gt;(fatherView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;父view的frame = &lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,bounds=&lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,中心点=：&amp;#123;&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;NSLog&lt;/span&gt;(@&lt;span class=&quot;string&quot;&gt;&quot;子view的frame = %@,bounds=%@,中心点=：%@&quot;&lt;/span&gt;,&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(sunView.frame),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGRect&lt;/span&gt;(sunView.bounds),&lt;span class=&quot;constant&quot;&gt;NSStringFromCGPoint&lt;/span&gt;(sunView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;子view的frame = &lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,bounds=&lt;span class=&quot;expansion&quot;&gt;&amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;,中心点=：&amp;#123;&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&lt;span class=&quot;regexp&quot;&gt;/1. 改变父View的bounds的位置,父view的bounds改变了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateWithDuration:4 animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [fatherView setBounds:CGRectMake(30, 30, 200, 200)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;completion:^(BOOL finished)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;改变父坐标bounds的位置后父view的frame = %@,bounds=%@,中心点=：%@&quot;,NSStringFromCGRect(fatherView.frame),NSStringFromCGRect(fatherView.bounds),NSStringFromCGPoint(fatherView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/ 改变父坐标bounds的位置后父view的frame = &amp;#123;&amp;#123;100, 100&amp;#125;, &amp;#123;200, 200&amp;#125;&amp;#125;,bounds=&amp;#123;&amp;#123;30, 30&amp;#125;, &amp;#123;200, 200&amp;#125;&amp;#125;,中心点=：&amp;#123;200, 200&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	NSLog(@&quot;改变父坐标bounds的位置后子view的frame = %@,bounds=%@,中心点=：%@&quot;,NSStringFromCGRect(sunView.frame),NSStringFromCGRect(sunView.bounds),NSStringFromCGPoint(sunView.center));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/改变父坐标bounds的位置后子view的frame = &amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;,bounds=&amp;#123;&amp;#123;0, 0&amp;#125;, &amp;#123;50, 50&amp;#125;&amp;#125;,中心点=：&amp;#123;25, 25&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.22.30.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.21.21.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.24.15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;setBounds 强制将自己坐标系的左上角点改为（30，30）。那么真正的原点(0,0)自然向右上角偏移(30,30);&lt;br&gt;若是setBounds设为（-30，-30） ，则子view向右下角移动，偏移(30,30)。&lt;br&gt;注意：setBounds中的(x,y)只改变自己的坐标系统。子view的bounds和frame并不会改变。&lt;br&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;setBounds中的(x,y)只改变自己的坐标系统，子View的bounds和frame并不会改变；&lt;/li&gt;
&lt;li&gt;setBounds是修改自己坐标系的原点位置，进而影响到子View的显示位置；&lt;/li&gt;
&lt;li&gt;bounds改变位置时，改变的是子视图的位置，自身没有影响，其实就是改变了自身的坐标系原点，默认原点在左上角。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;改变父View的bounds的大小&quot;&gt;&lt;a href=&quot;#改变父View的bounds的大小&quot; class=&quot;headerlink&quot; title=&quot;改变父View的bounds的大小&quot;&gt;&lt;/a&gt;改变父View的bounds的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setBounds:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.11.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.22.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;使用setBounds方法减小了父View的bounds.size ,可以看到把frame也改变了。总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改bounds的大小，bounds的大小代表当前视图的长和宽，修改长宽后，中心点继续保持不变，长宽进行改变，通过bounds修改长宽就像是以中心点为基准点对长宽两边同时进行缩放。&lt;/li&gt;
&lt;li&gt;center是根据父容器的相对位置来计算的，无论是修改父容器的bounds还是自身的bounds，都不会改变center。况且使用bounds来缩放view，都是根据center中心点来缩放的，所以center不会改变。&lt;/li&gt;
&lt;li&gt;setBounds也可以修改view的大小，进而修改frame。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;改子视图的bounds的位置&quot;&gt;&lt;a href=&quot;#改子视图的bounds的位置&quot; class=&quot;headerlink&quot; title=&quot;改子视图的bounds的位置&quot;&gt;&lt;/a&gt;改子视图的bounds的位置&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[sunView setBounds:CGRectMake(-&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, -&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;图像没有变化，与把一个子View放到父View中那个图一样的。&lt;/p&gt;
&lt;h3 id=&quot;修改子视图的bounds的大小&quot;&gt;&lt;a href=&quot;#修改子视图的bounds的大小&quot; class=&quot;headerlink&quot; title=&quot;修改子视图的bounds的大小&quot;&gt;&lt;/a&gt;修改子视图的bounds的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[sunView setBounds:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.48.46.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.53.04.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;修改子视图的bounds的大小，只是把子视图以中心点为中心扩大了，改变了子视图的frame的位置和bounds，父view不受影响。&lt;/p&gt;
&lt;h3 id=&quot;改变父view的frame的位置&quot;&gt;&lt;a href=&quot;#改变父view的frame的位置&quot; class=&quot;headerlink&quot; title=&quot;改变父view的frame的位置&quot;&gt;&lt;/a&gt;改变父view的frame的位置&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.01.36.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.01.43.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从效果图上可以看到，我们改变了父View的位置和大小（坐标系原点仍然是(0,0),但是实际位置已经改变了，坐标系改变），子View的位置也改变了。但是子View的frame和bounds并没有改变。因为子View.origin是相对于父View的而言的，这并没有改变。&lt;/p&gt;
&lt;h3 id=&quot;改变父view的frame的大小&quot;&gt;&lt;a href=&quot;#改变父view的frame的大小&quot; class=&quot;headerlink&quot; title=&quot;改变父view的frame的大小&quot;&gt;&lt;/a&gt;改变父view的frame的大小&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%888.34.11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.12.26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[fatherView setFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.13.02.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-21%20%E4%B8%8B%E5%8D%889.13.26.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;setFrame改变大小和setBounds改变大小是完全不一样的，setFrame改变长宽是从左上角原点进行缩放的，固定的是原点。而setBounds则固定的是center。&lt;/p&gt;
&lt;p&gt;一句话说：使用frame改变view大小，center改变，因为缩放参考点为左上角。使用bounds改变view大小，center不变，因为缩放参考点为center。&lt;br&gt;frame是参考父view的坐标系来设置自己左上角的位置。&lt;br&gt;设置bounds可以修改自己坐标系的原点位置，进而影响到其“子view”的显示位置。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果想修改view的位置而不影响其他，修改自身frame的位置；想修改view的大小，修改frame的大小或者bounds的大小（考虑相对位置的改变）。&lt;/li&gt;
&lt;li&gt;如果想修改view的所有子view的位置，修改view的bounds的位置（父容器坐标系）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;bounds使用场景&quot;&gt;&lt;a href=&quot;#bounds使用场景&quot; class=&quot;headerlink&quot; title=&quot;bounds使用场景&quot;&gt;&lt;/a&gt;bounds使用场景&lt;/h1&gt;&lt;p&gt;其实bounds我们一直在使用，就是我们使用scrollview的时候。&lt;br&gt;为什么我们滚动scrollview可以看到超出显示屏的内容。就是因为scrollview在不断改变自己的bounds，从而改变scrollview上的子view的frame，让他们的frame始终在最顶级view（window）的frame内部，这样我们就可以始终看到内容了。&lt;/p&gt;
&lt;p&gt;向上滚动scrollview，我们就不断增加scrollview的bounds的y值，也就是不断把scrollview的本地坐标系原点向下偏移（相对于scrollview的父view的坐标系，y值越大，越向下偏移）。那么此时scrollview的子控件的frame设置的(0,0)就是不断向上偏移&lt;/p&gt;
&lt;p&gt;假设某一时刻scrollview的坐标系原点为(0,100)，那么scrollview的(0,0)位置就是相对于坐标系原点向上偏移100的距离，设置scrollview的子控件的frame为(0,0)，就是设置子控件左上角在scrollview中的(0,0)位置，那么子控件就会向上偏移100，你也就看到scrollview的内容（子控件）向上滚动的效果。&lt;/p&gt;
&lt;p&gt;我们可以不断增加fatherView的bounds的y值，来看看是不是可以达到同样的效果：fatherView不动，Sunview在不断向上滚动&lt;br&gt;理解 Scroll Views:&lt;a href=&quot;https://objccn.io/issue-3-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-3-2/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UIView的相关重点。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动化测试</title>
    <link href="http://peilinghui.com/2017/02/16/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>http://peilinghui.com/2017/02/16/自动化测试/</id>
    <published>2017-02-16T11:17:25.000Z</published>
    <updated>2017-04-17T11:50:25.000Z</updated>
    
    <content type="html">&lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;测试基础&quot;&gt;&lt;a href=&quot;#测试基础&quot; class=&quot;headerlink&quot; title=&quot;测试基础&quot;&gt;&lt;/a&gt;测试基础&lt;/h1&gt;&lt;h2 id=&quot;按测试手段分&quot;&gt;&lt;a href=&quot;#按测试手段分&quot; class=&quot;headerlink&quot; title=&quot;按测试手段分&quot;&gt;&lt;/a&gt;按测试手段分&lt;/h2&gt;&lt;h3 id=&quot;黑盒测试和白盒测试-按可见度分&quot;&gt;&lt;a href=&quot;#黑盒测试和白盒测试-按可见度分&quot; class=&quot;headerlink&quot; title=&quot;黑盒测试和白盒测试(按可见度分)&quot;&gt;&lt;/a&gt;黑盒测试和白盒测试(按可见度分)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;黑盒测试&lt;/strong&gt;&lt;br&gt;黑盒测试主要是通过相关的暴露的接口，接收输入，然后看是否能够输出正确。  &lt;/p&gt;
&lt;p&gt;优点：容易实施，不需要关注内部实现，主要关注的是用户需求。&lt;/p&gt;
&lt;p&gt;缺点：测试覆盖率低，不到40%，自动化测试覆盖率低，维护成本高，&lt;/p&gt;
&lt;p&gt;测试内容：是否有不正确或遗漏的功能？接口上输入是否能正确接受，输出是否能输出正确的结果？性能上是否能满足？&lt;/p&gt;
&lt;p&gt;测试方法：等价类划分法、流程分析法、边界值分析、状态迁移图、正交试验法、因果图法、错误推测法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白盒测试&lt;/strong&gt;&lt;br&gt;内部结构对测试人员透明，用逻辑覆盖率(语句，判断，条件，分支，路径)&lt;/p&gt;
&lt;p&gt;优点：迫使测试人员思考软件的实现，理解原理。&lt;br&gt;可以检测代码的每条分支和路径。揭示隐藏在代码中的错误。对代码的测试比较彻底。&lt;/p&gt;
&lt;p&gt;缺点：昂贵。无法检测代码中遗漏的路径和数据敏感性错误。不能直接验证需求的正确性。&lt;/p&gt;
&lt;p&gt;测试方法：代码检测法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径法&lt;/p&gt;
&lt;h3 id=&quot;静态测试和动态测试&quot;&gt;&lt;a href=&quot;#静态测试和动态测试&quot; class=&quot;headerlink&quot; title=&quot;静态测试和动态测试&quot;&gt;&lt;/a&gt;静态测试和动态测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态测试&lt;/strong&gt;&lt;br&gt;不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程，评审软件文档或代码。只做静态检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态测试&lt;/strong&gt;&lt;br&gt;运行被测试的程序，检查运行结果和预期结果的差异，并分析运行效率和健壮性等性能。这种方法由三部分组成:构造测试实例、执行程序、分析程序癿输出结果。软件的动态测试，就是通过运行软件来检验软件的动态行为和运行结构的正确性。目前，动态测试也是公司的测试工作的主要方式。 根据动态测试在软件开发过程中所处的阶段和作用。动态测试可分为如下几个步骤:1、单元测试 2、集成测试 3、系统测试 4、验收测试 5、回归测试。&lt;br&gt;单元测试：&lt;br&gt;JUnit、OCUnit、GHUnit、GTM&lt;br&gt;集成测试：&lt;br&gt;API接口测试和iOS功能集成测试。&lt;br&gt;系统测试：&lt;/p&gt;
&lt;h3 id=&quot;手工测试和自动化测试&quot;&gt;&lt;a href=&quot;#手工测试和自动化测试&quot; class=&quot;headerlink&quot; title=&quot;手工测试和自动化测试&quot;&gt;&lt;/a&gt;手工测试和自动化测试&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;手工测试&lt;/strong&gt;&lt;br&gt;测试人员从用户视角来满足设计要求，深度测试和主观判断的测试，分为众包测试和探索式测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动化测试&lt;/strong&gt;&lt;br&gt;借助单独的测试工具软件，控制测试的自动化执行以及对预期和结果进行自动检查。主要分为：单元测试，接口测试和性能测试。&lt;/p&gt;
&lt;h2 id=&quot;按测试模式来分类&quot;&gt;&lt;a href=&quot;#按测试模式来分类&quot; class=&quot;headerlink&quot; title=&quot;按测试模式来分类&quot;&gt;&lt;/a&gt;按测试模式来分类&lt;/h2&gt;&lt;p&gt;瀑布模式，敏捷测试，基于脚本的测试，基于风险的测试，探索式测试。&lt;br&gt;&lt;strong&gt;瀑布模型&lt;/strong&gt;&lt;br&gt;项目计划–需求分析–软件设计–程序开发–软件测试–集成维护&lt;/p&gt;
&lt;p&gt;扩展模型：&lt;br&gt;V模型，W 模型、H 模型、X 模型和前置模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敏捷测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;强调从客户角度，重点关注迭代测试新功能。尽早测试，不间断测试。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;&lt;a href=&quot;#性能测试&quot; class=&quot;headerlink&quot; title=&quot;性能测试&quot;&gt;&lt;/a&gt;性能测试&lt;/h2&gt;&lt;p&gt;负载测试，压力测试和稳定性的测试&lt;/p&gt;
&lt;p&gt;考虑并发用户数(VU)和每秒事务数(TPS)&lt;br&gt;来看系统响应时间和设备的性能。&lt;/p&gt;
&lt;p&gt;测试工具：LoadRunner，&lt;/p&gt;
&lt;h1 id=&quot;ios中自动化测试UI-Automation&quot;&gt;&lt;a href=&quot;#ios中自动化测试UI-Automation&quot; class=&quot;headerlink&quot; title=&quot;ios中自动化测试UI Automation&quot;&gt;&lt;/a&gt;ios中自动化测试UI Automation&lt;/h1&gt;&lt;p&gt;UI Automation不但支持脚本编写方式的自动化测试，还支持录制回放方式的自动化测试，是一款功能强大的自动化测试工具。&lt;br&gt;Instruments工具还自带了UI Automation脚本的录制功能。用户只需开启录制功能，然后在真是的设备或模拟器上进行操作即可。操作的动作会被翻译成自动化脚本显示在脚本的编辑区，等待用户确认。在脚本录制完成以后，可以通过选择来编辑脚本，如果选项中没有我们需要的操作选项，则只能删除手动写脚本。&lt;/p&gt;
&lt;h1 id=&quot;Selenium&quot;&gt;&lt;a href=&quot;#Selenium&quot; class=&quot;headerlink&quot; title=&quot;Selenium&quot;&gt;&lt;/a&gt;Selenium&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SeleniumHQ/selenium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SeleniumHQ/selenium&lt;/a&gt;&lt;br&gt;Web自动化测试中，Selenium是最成熟且应用最广泛的Web自动化测试工具。WebDriver的原理结构：&lt;br&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server&lt;/p&gt;
&lt;p&gt;WebDriver API：这一层表示WebDriver提供给使用者的最外层接口，使用者可以使用这些API进行自动化脚本的编辑。例如：&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;diver.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;findElement&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(By.name(&lt;span class=&quot;string&quot;&gt;&quot;q&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;)或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;element.&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Json Wire Protocol:是WebDriver的开发者们制定并命名的一种协议，使用REST风格的，并且以Json方法进行传输，协议传输测试脚本需要控制的控件，并且通知Selenium Server。&lt;/p&gt;
&lt;p&gt;Selenium Server：接受Json Wire Protocol协议并且解析，可以控制启动或者停止某一款浏览器，也可以完成对某一个控件的具体操作。&lt;/p&gt;
&lt;h1 id=&quot;Appium&quot;&gt;&lt;a href=&quot;#Appium&quot; class=&quot;headerlink&quot; title=&quot;Appium&quot;&gt;&lt;/a&gt;Appium&lt;/h1&gt;&lt;p&gt;适用于iOS，Android和Windows应用的自动化。&lt;br&gt;GitHub地址：&lt;a href=&quot;https://github.com/appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/appium&lt;/a&gt;&lt;br&gt;API:&lt;a href=&quot;http://appium.io/slate/cn/master/?ruby#about-appium&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://appium.io/slate/cn/master/?ruby#about-appium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Appium简介&quot;&gt;&lt;a href=&quot;#Appium简介&quot; class=&quot;headerlink&quot; title=&quot;Appium简介&quot;&gt;&lt;/a&gt;Appium简介&lt;/h2&gt;&lt;p&gt;Appium使用WebDriver的json wire协议，来驱动Apple系统的UIAutomation库、Android系统的UIAutomator框架。  &lt;/p&gt;
&lt;p&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Appium在不同平台中使用了标准的自动化APIs，所以在跨平台时，不需要重新编译或者修改自己的应用。&lt;/li&gt;
&lt;li&gt;Appium支持Selenium WebDriver支持的所有语言，如java、Object-C、JavaScript、Php、Python、Ruby、C#、Clojure，或者Perl语言，更可以使用Selenium WebDriver的Api。Appium支持任何一种测试框架。&lt;br&gt;如果只使用Apple的UIAutomation，我们只能用javascript来编写测试用例，而且只能用Instruction来运行测试用例。&lt;br&gt;如果只使用Google的UIAutomation，我们就只能用java来编写测试用例。Appium实现了真正的跨平台自动化测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;p&gt;提供各个语言的第三方库，将测试脚本转化成 WebDriver 协议下的 URL，通过 Node 服务发送到各个平台上的代理工具，代理工具在运行过程中不断接收 URL，根据 WebDriver 协议解析出要执行的操作，然后调用各个平台上的原生测试框架完成测试，再将测试结果返回给 Node 服务器。&lt;/p&gt;
&lt;p&gt;WebDriver Client–&amp;gt;Json Wire Protocol–&amp;gt;Selenium Server–&amp;gt;UI Automation&lt;/p&gt;
&lt;h2 id=&quot;mac下搭建appium环境&quot;&gt;&lt;a href=&quot;#mac下搭建appium环境&quot; class=&quot;headerlink&quot; title=&quot;mac下搭建appium环境&quot;&gt;&lt;/a&gt;mac下搭建appium环境&lt;/h2&gt;&lt;p&gt;使用node.js实现的，首先确定有没有安装node,可以用HomeBrew安装。再看node解释器是否安装npm,然后下载并启动Appium.&lt;br&gt;参考文章：&lt;a href=&quot;http://www.15yan.com/story/4GbuTwXQKDU/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.15yan.com/story/4GbuTwXQKDU/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;windows-环境搭建Java和Android开发环境&quot;&gt;&lt;a href=&quot;#windows-环境搭建Java和Android开发环境&quot; class=&quot;headerlink&quot; title=&quot;windows 环境搭建Java和Android开发环境&quot;&gt;&lt;/a&gt;windows 环境搭建Java和Android开发环境&lt;/h2&gt;&lt;p&gt;参考书:&lt;a href=&quot;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://anikikun.gitbooks.io/appium-girls-tutorial/content/index.html&lt;/a&gt;&lt;br&gt;英文版：&lt;a href=&quot;https://nishantverma.gitbooks.io/appium-for-android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nishantverma.gitbooks.io/appium-for-android/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS的持续集成&quot;&gt;&lt;a href=&quot;#iOS的持续集成&quot; class=&quot;headerlink&quot; title=&quot;iOS的持续集成&quot;&gt;&lt;/a&gt;iOS的持续集成&lt;/h1&gt;&lt;p&gt;持续集成工具可以对代码库进行监测，一旦发现有代码变动，该工具会自动编译和测试应用程序。如果出现错误，会立即通知开发人员。&lt;/p&gt;
&lt;p&gt;持续集成可以提供更快的反馈，从而降低项目风险。是集成和回归问题更快、更流畅，出现的错误更少。通过部署过程自动化，持续集成可以帮助软件测试人员更快、更可靠地、更省力地搭建测试环境和执行自动化测试。&lt;/p&gt;
&lt;h2 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Jenkins&quot;&gt;&lt;/a&gt;Jenkins&lt;/h2&gt;&lt;p&gt;Jenkins易于安装，不需要数据库的支持，直接通过Web界面进行配置，而且集成了RSS/Email的通知机制，支持分布式构建，具有丰富的插件，这些都是Jenkins相比其他持续集成服务器的优势所在。&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的安装&quot;&gt;&lt;a href=&quot;#Jenkins的安装&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的安装&quot;&gt;&lt;/a&gt;Jenkins的安装&lt;/h3&gt;&lt;p&gt;在Jenkins的官网&lt;a href=&quot;https://jenkins.io/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://jenkins.io/index.html&lt;/a&gt;下载war包，并且执行 ‘java -jar jenkins.war’正确配置Java环境。&lt;/p&gt;
&lt;p&gt;mac下直接下载mac版本的Jenkins安装程序&lt;/p&gt;
&lt;h3 id=&quot;Jenkins的相关插件&quot;&gt;&lt;a href=&quot;#Jenkins的相关插件&quot; class=&quot;headerlink&quot; title=&quot;Jenkins的相关插件&quot;&gt;&lt;/a&gt;Jenkins的相关插件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Xcode integration&lt;br&gt;通过对Xcode integration的简单设置，即可完成iOS项目的编译打包，还可以修改iOS应用的Technical Version和Marketing Version。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Git Plugin&lt;br&gt;通过Git Plugin，用户可以很方便的下载项目的源代码，不是默认安装，需要用户手动安装。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Junit test result report&lt;br&gt;是Jenkins默认安装的插件之一。只需指定测试工具生成的XML形式的report文件，插件会自动解析XML，并且以更易查看的方式展现测试结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;a href=&quot;#iOS测试策略以及测试方法&quot; class=&quot;headerlink&quot; title=&quot;iOS测试策略以及测试方法&quot;&gt;&lt;/a&gt;iOS测试策略以及测试方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;功能测试：根据产品需求、用户的使用场景和代码实现方式等设计测试用例。&lt;/li&gt;
&lt;li&gt;兼容性测试：硬件、软件、数据兼容性。iOS设备的多样化兼容测试&lt;/li&gt;
&lt;li&gt;网络流量的测试：根据不同的网络状况测试，网速，弱网环境的测试。&lt;/li&gt;
&lt;li&gt;升级测试：老版本升级到新版本的测试、&lt;/li&gt;
&lt;li&gt;性能测试：服务器端性能测试。客户端性能测试：大数据测试，显示速度。&lt;/li&gt;
&lt;li&gt;稳定性测试：检测应用程序长期稳定的运行能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Instrument&quot;&gt;&lt;a href=&quot;#Instrument&quot; class=&quot;headerlink&quot; title=&quot;Instrument&quot;&gt;&lt;/a&gt;&lt;strong&gt;Instrument&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;网络流量监测数据，监控电量、监控GPS和WIFI是否开启等状态。丽日：在一些音乐APP和一些FM的APP中是否支持自动同步喜欢的歌曲到设备上。当网络接入点只选择了在WiFi情况下同步，就必须保证用户的流量不被使用。Net Activity运行库图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能测试：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;快速启动测试：用instruments中TimeProfile来分析启动时的CPU消耗，并且以消耗CPU的数据为依据进行优化。&lt;/li&gt;
&lt;li&gt;内存泄露的检查：用Xcode分析（Analyze）代码。静态分析器可以根据经验猜测执行代码后可能发生的情况并报告问题，这些问题中可以存在内存泄露问题。静态分析器在检查代码时会枚举所有的代码路径，分别检查所以的函数和方法。为了看到静态分析的结构，在Recipes项目中可以随意找到几处release或者autorelease的调用项并删除，然后运行静态分析，用Instrument的两个组件来组合查看内存泄露的问题：Allocations和Leaks.&lt;/li&gt;
&lt;li&gt;Allocations：是监控对象调用了alloc方法申请内存以后的内存使用情况，可以记录对象这个生命周期内的内存引用计数的变化，在对象被正常释放后，Allocations 不再继续追踪。Leaks会监控内存泄露，一般和Allocations一起使用，因为在监控到内存泄露时需要定位问题。可以得到详细的内存泄露信息。&lt;/li&gt;
&lt;li&gt;稳定性测试：猴子测试，直接在instruments中运行UI Automation脚本。考虑在一些零界条件下对应用程序进行稳定性测试。考虑：1.频繁收到内存警告。2.电池电量低。3.3G网络不稳定时断时续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;及时响应用户交互和优秀的内存管理。通过测试定位并且解决问题。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;国内首家移动测试的社区网站：&lt;a href=&quot;https://testerhome.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://testerhome.com/&lt;/a&gt;&lt;br&gt;构建基于Jenkins + Github的持续集成环境 &lt;a href=&quot;http://blog.csdn.net/john_cdy/article/details/7738393&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/john_cdy/article/details/7738393&lt;/a&gt;&lt;br&gt;电子书：&lt;a href=&quot;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://files.cnblogs.com/files/itech/Jenkins%E5%85%A5%E9%97%A8.pdf&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不仅得会开发，也得懂得测试的相关东西。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计读书笔记</title>
    <link href="http://peilinghui.com/2017/02/13/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</id>
    <published>2017-02-13T07:37:24.000Z</published>
    <updated>2017-02-15T12:59:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 JavaScript简介&quot;&gt;&lt;/a&gt;第一章 JavaScript简介&lt;/h1&gt;&lt;p&gt;JavaScript有下列三个不同的部分组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMA-262规定的语言组成部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法
类型
语句
关键字
保留字
操作符
对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DOM：&lt;br&gt;DOM把真个页面映射为一个多层结点结构。&lt;br&gt;DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。&lt;br&gt;DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。&lt;br&gt;DOM3级：以统一方式加载和保存文档的方法。验证文档的方法&lt;br&gt;BOM：&lt;br&gt;处理浏览器窗口和框架。&lt;/p&gt;
&lt;h1 id=&quot;第二章-在HTML中使用JavaScript&quot;&gt;&lt;a href=&quot;#第二章-在HTML中使用JavaScript&quot; class=&quot;headerlink&quot; title=&quot;第二章 在HTML中使用JavaScript&quot;&gt;&lt;/a&gt;第二章 在HTML中使用JavaScript&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;把JavaScript插入到HTML页面中要使用&amp;lt;script&amp;gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&amp;lt;script&amp;gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&amp;lt;script&amp;gt;元素中的代码之后，才会开始解析后面的&amp;lt;script&amp;gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&amp;lt;script&amp;gt;元素中的代码，然后再解析后面的内容，所以一般应该把&amp;lt;script&amp;gt;元素放在页面最后，即主要内容后面，&amp;lt;/body&amp;gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第三章-基本概念&quot;&gt;&lt;a href=&quot;#第三章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本概念&quot;&gt;&lt;/a&gt;第三章 基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript中的函数与其他语言中的函数有诸多不同之处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Undefined类型&lt;/strong&gt;&lt;br&gt;Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Null类型&lt;/strong&gt;&lt;br&gt;Null类型是第二个只有一个值的数据类型，这个特殊值时null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;br&gt;该类型只有两个字面值：true和false。&lt;br&gt;虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; messageAsBoolean&lt;/span&gt; = &lt;span class=&quot;typename&quot;&gt;Boolean&lt;/span&gt;(message);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给出各数据类型及其转换的规则：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alert(isNaN(NaN));              //true&lt;br&gt;alert(isNaN(10));               //false（10是一个数值）&lt;br&gt;alert(isNaN(“10”));             //false（可以被转换成数值10）&lt;br&gt;alert(isNaN(“blue”));           //false（不能被转换成数值）&lt;br&gt;alert(isNaN(true));             //false（可以被转换成数值1）&lt;/p&gt;
&lt;p&gt;有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&amp;quot;name&amp;quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;p&gt;一元操作符&lt;br&gt;递增操作符     ++&lt;br&gt;递减操作符     –&lt;br&gt;一元加操作符     +&lt;br&gt;一元减操作符     -&lt;br&gt;位操作符&lt;br&gt;按位非     NOT(~)&lt;br&gt;按位与     AND(&amp;amp;)&lt;br&gt;按位或     OR(|)     var result=25 | 3;alert(result);//27&lt;br&gt;按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26&lt;br&gt;左移     &amp;lt;&amp;lt;     var oldValue=2;var newValue=oldValue &amp;lt;&amp;lt; 5;//64&lt;br&gt;有符号的右移     &amp;gt;&amp;gt;     var oldValue=64;var newValue=oldValue &amp;gt;&amp;gt; 5;//2&lt;br&gt;无符号的右移     &amp;gt;&amp;gt;&amp;gt;     var oldValue=-64;var newValue=oldValue &amp;gt;&amp;gt;&amp;gt; 5;//134217726&lt;br&gt;布尔操作符&lt;br&gt;逻辑非     !     alert(!false);//true&lt;br&gt;逻辑与     &amp;amp;&amp;amp;     var result=true &amp;amp;&amp;amp; false;//false&lt;br&gt;逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true&lt;br&gt;乘性操作符（略）&lt;br&gt;加性操作符（略）&lt;br&gt;关系操作符（略）&lt;br&gt;条件操作符（略）&lt;br&gt;赋值操作符（略）&lt;br&gt;逗号操作符（略）         &lt;/p&gt;
&lt;p&gt;相等操作符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。&lt;/p&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h1 id=&quot;第四章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第四章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第四章 变量、作用域和内存问题&lt;/h1&gt;&lt;p&gt;JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。&lt;/p&gt;
&lt;h1 id=&quot;第五章-引用类型&quot;&gt;&lt;a href=&quot;#第五章-引用类型&quot; class=&quot;headerlink&quot; title=&quot;第五章 引用类型&quot;&gt;&lt;/a&gt;第五章 引用类型&lt;/h1&gt;&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;p&gt;大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。&lt;br&gt;第一种是使用new操作符后跟Object构造函数，如&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是使用对象字面量表示法，如&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;age :&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert(person[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);              &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);                 &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示方法&lt;/strong&gt;&lt;br&gt;创建数组的基本方式有两种。&lt;br&gt;第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;//空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含三个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含一个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是使用数组字面量表示法。如&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;//创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var names = []&lt;span class=&quot;comment&quot;&gt;;//创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含2或3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var options = [, , , , ,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含5或6项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;&lt;br&gt;数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测数组&lt;/strong&gt;&lt;br&gt;自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。&lt;br&gt;对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;isArray&lt;/span&gt;(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;转换方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toLocaleString() :&lt;br&gt;toString() :&lt;br&gt;valueOf() : &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈方法和队列方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。&lt;/p&gt;
&lt;p&gt;实现栈的方式（LIFO）后进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()： 栈中项插入
pop()：栈中项移除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现队列的方法（FIFO）先进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重排序方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组中已经存在两个可以直接用来重排序的方法：&lt;br&gt;reverse()和sort()方法。&lt;/p&gt;
&lt;p&gt;reverse()方法会反转数组项的顺序。&lt;/p&gt;
&lt;p&gt;默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。&lt;br&gt;另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需将其作为参数传递给sort()方法即可。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values.sort(compare);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(values);  &lt;span class=&quot;comment&quot;&gt;//0, 1, 5, 10, 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;ECMAScript为操作已经包含在数组中的项提供了很多内置方法。&lt;/p&gt;
&lt;p&gt;concat()：&lt;br&gt;该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.concat(&lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);  &lt;span class=&quot;comment&quot;&gt;//red, green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//red, green, blue, yellow, black, brown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;slice()：  &lt;/p&gt;
&lt;p&gt;该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors3&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow, purple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors3);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;splice()：&lt;br&gt;该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var removed = colors.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//删除第一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//red, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orange&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//从位置1开始插入两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, yellow, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//返回的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//插入两项，删除一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, red, purple, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//yellow, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。&lt;br&gt;这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。&lt;/p&gt;
&lt;p&gt;var person = {  name: “Nicholas” };&lt;br&gt;var people = [{ name: “Nicholas” }];&lt;/p&gt;
&lt;p&gt;var morePeople = [person];&lt;/p&gt;
&lt;p&gt;alert(people.indexOf(person));          //-1&lt;br&gt;alert(morePeople.indexOf(person));  //0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上方法都不会修改数组中的包含的值。&lt;/p&gt;
&lt;p&gt;其中，every()和filter()方法最相似。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var everyResult = numbers.every(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(everyResult);     &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var someResult = numbers.some(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(someResult);      &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var filterResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(filterResult);            &lt;span class=&quot;comment&quot;&gt;//[3, 4, 5, 4, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map()可以用来创建包含的项与另一个数组一一对应的项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var mapResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(mapResult);           &lt;span class=&quot;comment&quot;&gt;//[2, 4, 6, 8, 10, 8, 6, 4, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forEach()本质上和使用for循环迭代数组一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers.forEach(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;归并方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。&lt;br&gt;这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。&lt;br&gt;使用reduce()方法可以执行数组中所有值求和操作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var sum = values.reduce(function(prev, cur, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev + cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(sum);     &lt;span class=&quot;comment&quot;&gt;//15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Date类型&quot;&gt;&lt;a href=&quot;#Date类型&quot; class=&quot;headerlink&quot; title=&quot;Date类型&quot;&gt;&lt;/a&gt;Date类型&lt;/h2&gt;&lt;p&gt;创建日期对象，使用new操作符和Date构造函数即可。&lt;/p&gt;
&lt;p&gt;var now = new Date()&lt;/p&gt;
&lt;p&gt;根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。&lt;br&gt;Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式&lt;br&gt;var someDate = new Date(Date.parse(“May 25, 2004”));&lt;/p&gt;
&lt;p&gt;Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。&lt;/p&gt;
&lt;p&gt;//GMT时间2000年1月1日午夜零时&lt;br&gt;var y2k = new Date(Date.UTC(2000, 0));&lt;/p&gt;
&lt;p&gt;//GMT时间2005年5月5日下午5:55:55&lt;br&gt;var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));&lt;/p&gt;
&lt;p&gt;Date类型还有一些专门用于将日期格式化为字符串的方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.&lt;/p&gt;
&lt;h2 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h2&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。&lt;/p&gt;
&lt;p&gt;var expression = / pattern / flags ;&lt;/p&gt;
&lt;p&gt;其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。&lt;br&gt;关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。&lt;br&gt;另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。&lt;/p&gt;
&lt;h2 id=&quot;Function类型&quot;&gt;&lt;a href=&quot;#Function类型&quot; class=&quot;headerlink&quot; title=&quot;Function类型&quot;&gt;&lt;/a&gt;Function类型&lt;/h2&gt;&lt;p&gt;ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数声明与函数表达式&lt;/p&gt;
&lt;p&gt;解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;没有重载！&lt;/strong&gt;&lt;br&gt;由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为返回值的函数&lt;/strong&gt;&lt;br&gt;由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。&lt;br&gt;函数作为返回值是极有用的技术，是“闭包”技术的基础之一。&lt;br&gt;比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction (propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var data = [&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Zachary&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;&amp;#125;, &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据name来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Nicholas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据age来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Zachary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数内部属性（重点）&lt;/strong&gt;&lt;br&gt;在函数内部，有两个特殊的对象：arguments和this。&lt;/p&gt;
&lt;p&gt;arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//与函数名紧紧耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用arguments.callee替代函数名，消除耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * arguments.callee (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; trueFactorial = factorial;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;factorial = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(trueFactiorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));           &lt;span class=&quot;comment&quot;&gt;//120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));                    &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();             &lt;span class=&quot;comment&quot;&gt;//&quot;red&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor = sayColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor();           &lt;span class=&quot;comment&quot;&gt;//&quot;blue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。&lt;/p&gt;
&lt;p&gt;ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数属性和方法（重点）&lt;/strong&gt;&lt;br&gt;ECMAScript中函数是对象，因此也有属性和方法。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。&lt;br&gt;诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//传入arguments对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, [num1, num2]);       &lt;span class=&quot;comment&quot;&gt;//传入数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum1(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum2(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));     &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();                     &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(o);               &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; objectSayColor = sayColor.bind(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectSayColor();           &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2&lt;/span&gt; = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问s1时，访问过程处于读取模式，后台自动完成下列处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上三个步骤可以想象成下列代码&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。&lt;br&gt;引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed()：按指定小数位返回数值的字符串表示。&lt;/li&gt;
&lt;li&gt;toExponential()：返回以指数表示法表示的数值的字符串形式。&lt;/li&gt;
&lt;li&gt;toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符方法&lt;/strong&gt;&lt;br&gt;两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串操作方法&lt;/strong&gt;&lt;br&gt;concat()：&lt;br&gt;用于将一或多个字符串拼接起来，接受任意多个参数。&lt;/p&gt;
&lt;p&gt;slice()、substr()和substring()：&lt;br&gt;这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。&lt;/p&gt;
&lt;p&gt;当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串位置方法&lt;/strong&gt;&lt;br&gt;有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。&lt;br&gt;两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。&lt;br&gt;在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trim()方法&lt;/strong&gt;&lt;br&gt;该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串大小写转换方法&lt;/strong&gt;&lt;br&gt;ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串的模式匹配方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;match()：&lt;br&gt;在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。&lt;/p&gt;
&lt;p&gt;search()：&lt;br&gt;参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。&lt;/p&gt;
&lt;p&gt;replace()：&lt;br&gt;接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。&lt;/p&gt;
&lt;p&gt;split()：&lt;br&gt;该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。&lt;/p&gt;
&lt;p&gt;localeCompare()方法;&lt;br&gt;该方法比较两个字符串，并返回下列值中的一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fromCharCode()方法：&lt;/p&gt;
&lt;p&gt;String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。&lt;/p&gt;
&lt;h2 id=&quot;单体内置对象&quot;&gt;&lt;a href=&quot;#单体内置对象&quot; class=&quot;headerlink&quot; title=&quot;单体内置对象&quot;&gt;&lt;/a&gt;单体内置对象&lt;/h2&gt;&lt;p&gt;除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。&lt;/p&gt;
&lt;h3 id=&quot;Global对象&quot;&gt;&lt;a href=&quot;#Global对象&quot; class=&quot;headerlink&quot; title=&quot;Global对象&quot;&gt;&lt;/a&gt;Global对象&lt;/h3&gt;&lt;p&gt;所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()&lt;br&gt;isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI编码方法&lt;/strong&gt;&lt;br&gt;Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval()方法&lt;/strong&gt;&lt;br&gt;eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。&lt;br&gt;当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：&lt;/p&gt;
&lt;p&gt;var msg = “hello world”;&lt;br&gt;eval(“alert(msg)”);     //“hello world”&lt;/p&gt;
&lt;p&gt;变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Global对象的属性&lt;/strong&gt;&lt;br&gt;Global对象的所有属性：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window对象&lt;/strong&gt;&lt;br&gt;ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。&lt;/p&gt;
&lt;h3 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math()对象&quot;&gt;&lt;/a&gt;Math()对象&lt;/h3&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Math对象的属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Math对象的方法&lt;/strong&gt;&lt;br&gt;min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.&lt;br&gt;Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。&lt;br&gt;Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//选择一个介于2到10之间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var num = Math.&lt;span class=&quot;built_in&quot;&gt;floor&lt;/span&gt;(Math.random() * &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下函数可以直接指定随机范围（整数）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectFrom&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lowerValue, upperValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; choices = upperValue - lowerValue +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() * choices + lowerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = selectFrom(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(num);     &lt;span class=&quot;comment&quot;&gt;//介于2和10之间（包括2和10）的一个数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.abs(num)     返回num的绝对值&lt;br&gt;Math.asin(x)     返回x的反正弦值&lt;br&gt;Math.exp(num)     返回Math.E的num次幂&lt;br&gt;     Math.atan(x)     返回x的反正切值&lt;br&gt;Math.log(num)     返回num的自然对数&lt;br&gt;Math.atan2(y,x)     返回y/x的反正切值&lt;br&gt;Math.pow(num, power)     返回num的power次幂&lt;br&gt;Math.cos(x)     返回x的余弦值&lt;br&gt;Math.sqrt(num)     返回num的平方根&lt;br&gt;Math.sin(x)     返回x的正弦值&lt;br&gt;Math.acos(x)     返回x的反余弦值&lt;br&gt;Math.tan(x)     返回x的正切值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第六章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h3&gt;&lt;p&gt;ECMAScript中有两种属性：数据属性和访问器属性。&lt;br&gt;&lt;strong&gt;数据属性&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。&lt;br&gt;要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：&lt;br&gt;注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//抛出错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问器属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。&lt;br&gt;访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; book = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _year: &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edition: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(book, &lt;span class=&quot;string&quot;&gt;&quot;year&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.edition += newValue - &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;book.year = &lt;span class=&quot;number&quot;&gt;2005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(book.edition);        &lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一个属性的值会导致其他属性发生变化。&lt;br&gt;注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义多个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取属性的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。&lt;/p&gt;
&lt;p&gt;注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。&lt;/p&gt;
&lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;构造函数模式&quot;&gt;&lt;a href=&quot;#构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式&quot;&gt;&lt;/a&gt;构造函数模式&lt;/h3&gt;&lt;p&gt;像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age, job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;br&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。&lt;br&gt;创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将构造函数当做函数&lt;/strong&gt;&lt;br&gt;任何函数，只要通过new操作符来调用，那它就可以作为构造函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数的问题&lt;/strong&gt;&lt;br&gt;构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.&lt;/p&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;br&gt;创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。&lt;br&gt;如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。&lt;/p&gt;
&lt;p&gt;isPrototypeOf()：确定对象原型方法。&lt;br&gt;&lt;code&gt;alert(Person.prototype.isPrototypeOf(person1)); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; Object.getPrototypeOf()：ECMAScript 5新增方法。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt; == Person.prototype)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;  //true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt;.name)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; //&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;原型与in操作符&lt;/strong&gt;&lt;br&gt;有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;p&gt;而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function hasPrototypeProperty(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;/span&gt;name) &amp;amp;&amp;amp; (name in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。&lt;/p&gt;
&lt;p&gt;Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。&lt;/p&gt;
&lt;p&gt;如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型的动态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;h3 id=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;a href=&quot;#组合使用构造函数模式和原型模式&quot; class=&quot;headerlink&quot; title=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;/a&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。&lt;/p&gt;
&lt;h3 id=&quot;动态原型模式&quot;&gt;&lt;a href=&quot;#动态原型模式&quot; class=&quot;headerlink&quot; title=&quot;动态原型模式&quot;&gt;&lt;/a&gt;动态原型模式&lt;/h3&gt;&lt;p&gt;动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。&lt;/p&gt;
&lt;h3 id=&quot;寄生构造函数模式&quot;&gt;&lt;a href=&quot;#寄生构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;寄生构造函数模式&quot;&gt;&lt;/a&gt;寄生构造函数模式&lt;/h3&gt;&lt;p&gt;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。&lt;/p&gt;
&lt;h3 id=&quot;稳妥构造函数模式&quot;&gt;&lt;a href=&quot;#稳妥构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;稳妥构造函数模式&quot;&gt;&lt;/a&gt;稳妥构造函数模式&lt;/h3&gt;&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());    &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链的问题&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。&lt;br&gt;原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。&lt;/p&gt;
&lt;h3 id=&quot;借用构造函数&quot;&gt;&lt;a href=&quot;#借用构造函数&quot; class=&quot;headerlink&quot; title=&quot;借用构造函数&quot;&gt;&lt;/a&gt;借用构造函数&lt;/h3&gt;&lt;p&gt;在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递参数&lt;/strong&gt;&lt;br&gt;相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数的问题&lt;/strong&gt;&lt;br&gt;如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。&lt;/p&gt;
&lt;h3 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h3&gt;&lt;p&gt;组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SupType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Nicolas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayAge();         &lt;span class=&quot;comment&quot;&gt;//29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayAge();         &lt;span class=&quot;comment&quot;&gt;//27&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。&lt;br&gt;组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;/h3&gt;&lt;p&gt;借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    F.prototype = o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anttherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Rob&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yetAnotherPerosn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Linda&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Barbie&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.friends);  &lt;span class=&quot;comment&quot;&gt;//&quot;Shelby, Court, Van, Rob, Barbie&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。&lt;br&gt;ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。&lt;br&gt;object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。&lt;/p&gt;
&lt;h3 id=&quot;寄生式继承&quot;&gt;&lt;a href=&quot;#寄生式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生式继承&quot;&gt;&lt;/a&gt;寄生式继承&lt;/h3&gt;&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(original)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; = object(original);    &lt;span class=&quot;comment&quot;&gt;//通过调用函数创建一个新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;       &lt;span class=&quot;comment&quot;&gt;//以某种方式来增强这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;hi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;;                    &lt;span class=&quot;comment&quot;&gt;//返回这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson = createAnother(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.sayHi();  &lt;span class=&quot;comment&quot;&gt;//&quot;hi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。&lt;br&gt;注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。&lt;/p&gt;
&lt;h3 id=&quot;寄生组合式继承&quot;&gt;&lt;a href=&quot;#寄生组合式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生组合式继承&quot;&gt;&lt;/a&gt;寄生组合式继承&lt;/h3&gt;&lt;p&gt;组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);             &lt;span class=&quot;comment&quot;&gt;//第二次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();        &lt;span class=&quot;comment&quot;&gt;//第一次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。&lt;br&gt;而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(subType, superType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prototype = object(superType.prototype);    &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prototype.constructor = subType;                &lt;span class=&quot;comment&quot;&gt;//增强对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subType.prototype = prototype;                  &lt;span class=&quot;comment&quot;&gt;//指定对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inheritPrototype(SubType, SuperType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：&lt;br&gt;1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。&lt;br&gt;2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。&lt;br&gt;3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。&lt;br&gt;JavaScript主要使用原型链实现继承。&lt;strong&gt;原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的&lt;/strong&gt;。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。&lt;br&gt;使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。&lt;br&gt;此外，还存在下列可供选择的继承模式：&lt;br&gt;1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。&lt;br&gt;2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。&lt;br&gt;3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;h1 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h1&gt;&lt;p&gt;定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; functionName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num * arguments.callee(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var factorial = (&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;num * &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;不少开发人员总是搞不清匿名函数和闭包这两个概念。&lt;br&gt;&lt;strong&gt;闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;而匿名函数是指没有函数名称的函数。&lt;/strong&gt;&lt;br&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。&lt;br&gt;在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = compare(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 &lt;/p&gt;
&lt;p&gt;无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。&lt;br&gt;在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compare = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compare(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compareNames = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compareNames(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//解除对匿名函数的引用（以便释放内存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compareNames = null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包与变量&quot;&gt;&lt;a href=&quot;#闭包与变量&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数会返回一个函数数组，而其中的每个函数都返回10。&lt;br&gt;我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //匿名函数直接赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function(num) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于this对象&quot;&gt;&lt;a href=&quot;#关于this对象&quot; class=&quot;headerlink&quot; title=&quot;关于this对象&quot;&gt;&lt;/a&gt;关于this对象&lt;/h3&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;The Window&quot;（在非严格模式下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; that.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;My Object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(element.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//防止内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = element.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。&lt;/p&gt;
&lt;h2 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h2&gt;&lt;p&gt;JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。&lt;br&gt;用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//立即调用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里是块级作用域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数。&lt;br&gt;函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。&lt;/p&gt;
&lt;p&gt;无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outputNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(i);    &lt;span class=&quot;comment&quot;&gt;//导致一个错误！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。&lt;/p&gt;
&lt;h2 id=&quot;私有变量&quot;&gt;&lt;a href=&quot;#私有变量&quot; class=&quot;headerlink&quot; title=&quot;私有变量&quot;&gt;&lt;/a&gt;私有变量&lt;/h2&gt;&lt;p&gt;严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。&lt;br&gt;如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。&lt;br&gt;我们把有权访问私有变量和私有函数的公有方法成为&lt;strong&gt;特权方法&lt;/strong&gt;（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。&lt;br&gt;利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nihcholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。&lt;br&gt;构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。&lt;/p&gt;
&lt;h3 id=&quot;静态私有变量&quot;&gt;&lt;a href=&quot;#静态私有变量&quot; class=&quot;headerlink&quot; title=&quot;静态私有变量&quot;&gt;&lt;/a&gt;静态私有变量&lt;/h3&gt;&lt;p&gt;通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公有/特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject.prototype.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。&lt;br&gt;这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototye.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototype.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Michael&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person2.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。&lt;br&gt;以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。&lt;/p&gt;
&lt;h3 id=&quot;模块模式&quot;&gt;&lt;a href=&quot;#模块模式&quot; class=&quot;headerlink&quot; title=&quot;模块模式&quot;&gt;&lt;/a&gt;模块模式&lt;/h3&gt;&lt;p&gt;前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : value,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; : function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是方法的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权/公有方法和属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicProperty: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; application = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; components = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    components.push(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaseComponent());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公共&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getComponentCount : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; components.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerComponent : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; component == &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                components.push(component);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。&lt;br&gt;简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。&lt;/p&gt;
&lt;h3 id=&quot;增强的模块模式&quot;&gt;&lt;a href=&quot;#增强的模块模式&quot; class=&quot;headerlink&quot; title=&quot;增强的模块模式&quot;&gt;&lt;/a&gt;增强的模块模式&lt;/h3&gt;&lt;p&gt;有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。&lt;/p&gt;
&lt;h2 id=&quot;小结：&quot;&gt;&lt;a href=&quot;#小结：&quot; class=&quot;headerlink&quot; title=&quot;小结：&quot;&gt;&lt;/a&gt;小结：&lt;/h2&gt;&lt;p&gt;在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包还可以用于在对象中创建私有变量，相关概念和要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。&lt;/p&gt;
&lt;h1 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h1&gt;&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。&lt;/p&gt;
&lt;p&gt;定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。&lt;br&gt;尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，&lt;/p&gt;
&lt;h3 id=&quot;窗口关系及框架&quot;&gt;&lt;a href=&quot;#窗口关系及框架&quot; class=&quot;headerlink&quot; title=&quot;窗口关系及框架&quot;&gt;&lt;/a&gt;窗口关系及框架&lt;/h3&gt;&lt;p&gt;如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。&lt;br&gt;每个window对象都有一个name属性，其中包含框架的名称。&lt;br&gt;top对象始终指向最高（最外）层的框架，也就是浏览器窗口。&lt;br&gt;与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。&lt;/p&gt;
&lt;h3 id=&quot;窗口的位置&quot;&gt;&lt;a href=&quot;#窗口的位置&quot; class=&quot;headerlink&quot; title=&quot;窗口的位置&quot;&gt;&lt;/a&gt;窗口的位置&lt;/h3&gt;&lt;p&gt;使用如下代码可以取得窗口左边和上边的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; leftPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenY;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;moveTo():接收新位置的x,y坐标值&lt;/p&gt;
&lt;p&gt;moveBy():接收在水平和垂直方向上移动的像素数&lt;/p&gt;
&lt;h3 id=&quot;窗口大小&quot;&gt;&lt;a href=&quot;#窗口大小&quot; class=&quot;headerlink&quot; title=&quot;窗口大小&quot;&gt;&lt;/a&gt;窗口大小&lt;/h3&gt;&lt;p&gt;四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.&lt;/p&gt;
&lt;p&gt;resizeTo():接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy():接收新窗口与原窗口的宽度和高度之差&lt;/p&gt;
&lt;p&gt;innerWidth和innerHeight表示该容器中页面视图区的大小&lt;/p&gt;
&lt;h3 id=&quot;导航和打开新窗口&quot;&gt;&lt;a href=&quot;#导航和打开新窗口&quot; class=&quot;headerlink&quot; title=&quot;导航和打开新窗口&quot;&gt;&lt;/a&gt;导航和打开新窗口&lt;/h3&gt;&lt;p&gt;使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。&lt;/p&gt;
&lt;h3 id=&quot;间歇调用和超时调用&quot;&gt;&lt;a href=&quot;#间歇调用和超时调用&quot; class=&quot;headerlink&quot; title=&quot;间歇调用和超时调用&quot;&gt;&lt;/a&gt;间歇调用和超时调用&lt;/h3&gt;&lt;p&gt;javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。&lt;br&gt;超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。&lt;/p&gt;
&lt;p&gt;间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。&lt;/p&gt;
&lt;h3 id=&quot;系统对话框&quot;&gt;&lt;a href=&quot;#系统对话框&quot; class=&quot;headerlink&quot; title=&quot;系统对话框&quot;&gt;&lt;/a&gt;系统对话框&lt;/h3&gt;&lt;p&gt;浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;查询字符串参数&quot;&gt;&lt;a href=&quot;#查询字符串参数&quot; class=&quot;headerlink&quot; title=&quot;查询字符串参数&quot;&gt;&lt;/a&gt;查询字符串参数&lt;/h3&gt;&lt;p&gt;location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  &lt;/p&gt;
&lt;h3 id=&quot;位置操作&quot;&gt;&lt;a href=&quot;#位置操作&quot; class=&quot;headerlink&quot; title=&quot;位置操作&quot;&gt;&lt;/a&gt;位置操作&lt;/h3&gt;&lt;p&gt;用location对象改变浏览器位置的多种方式：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);  
window.location=&amp;quot;htttp://www.wrox.com&amp;quot;;  
location.href=&amp;quot;htttp://www.wrox.com&amp;quot;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。&lt;/p&gt;
&lt;p&gt;  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;&lt;a href=&quot;#navigator对象&quot; class=&quot;headerlink&quot; title=&quot;navigator对象&quot;&gt;&lt;/a&gt;navigator对象&lt;/h2&gt;&lt;p&gt;navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。&lt;/p&gt;
&lt;h3 id=&quot;检测插件&quot;&gt;&lt;a href=&quot;#检测插件&quot; class=&quot;headerlink&quot; title=&quot;检测插件&quot;&gt;&lt;/a&gt;检测插件&lt;/h3&gt;&lt;p&gt;navigator.plugins[]表示浏览器所用的插件的集合。&lt;br&gt;name: 插件的名字&lt;/p&gt;
&lt;p&gt;description:插件的描述&lt;/p&gt;
&lt;p&gt;filename:插件的文件名&lt;/p&gt;
&lt;p&gt;length:插件所处理的MIME类型数量&lt;/p&gt;
&lt;h3 id=&quot;注册处理程序&quot;&gt;&lt;a href=&quot;#注册处理程序&quot; class=&quot;headerlink&quot; title=&quot;注册处理程序&quot;&gt;&lt;/a&gt;注册处理程序&lt;/h3&gt;&lt;p&gt;FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。&lt;/p&gt;
&lt;p&gt;registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。&lt;/p&gt;
&lt;p&gt;navigator.registerContentHandler(‘application/rss+xml’, ‘&lt;a href=&quot;http://www.sohu.com?feed=%s’&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sohu.com?feed=%s’&lt;/a&gt;, ‘some Reader’);&lt;/p&gt;
&lt;p&gt;FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。&lt;/p&gt;
&lt;h2 id=&quot;screen对象&quot;&gt;&lt;a href=&quot;#screen对象&quot; class=&quot;headerlink&quot; title=&quot;screen对象&quot;&gt;&lt;/a&gt;screen对象&lt;/h2&gt;&lt;p&gt;screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;&lt;a href=&quot;#history对象&quot; class=&quot;headerlink&quot; title=&quot;history对象&quot;&gt;&lt;/a&gt;history对象&lt;/h2&gt;&lt;p&gt;history.go(-1) | history.back(); //后退一页&lt;/p&gt;
&lt;p&gt;history.go(1) | history.forward();//前进一页&lt;/p&gt;
&lt;p&gt;history.go(n);//前进n页&lt;/p&gt;
&lt;p&gt;history.go(‘sohu.com’);//跳转到最后的sohu页面&lt;/p&gt;
&lt;p&gt;history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。&lt;/p&gt;
&lt;h1 id=&quot;第9章，客户端检测&quot;&gt;&lt;a href=&quot;#第9章，客户端检测&quot; class=&quot;headerlink&quot; title=&quot;第9章，客户端检测&quot;&gt;&lt;/a&gt;第9章，客户端检测&lt;/h1&gt;&lt;p&gt;尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案&lt;/p&gt;
&lt;h2 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h2&gt;&lt;p&gt;检测浏览器是否具备某一能力。&lt;/p&gt;
&lt;p&gt;尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险&lt;/p&gt;
&lt;p&gt;并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。&lt;/p&gt;
&lt;h2 id=&quot;怪癖检测&quot;&gt;&lt;a href=&quot;#怪癖检测&quot; class=&quot;headerlink&quot; title=&quot;怪癖检测&quot;&gt;&lt;/a&gt;怪癖检测&lt;/h2&gt;&lt;p&gt;检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。&lt;/p&gt;
&lt;h2 id=&quot;用户代理检测&quot;&gt;&lt;a href=&quot;#用户代理检测&quot; class=&quot;headerlink&quot; title=&quot;用户代理检测&quot;&gt;&lt;/a&gt;用户代理检测&lt;/h2&gt;&lt;p&gt;通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。&lt;br&gt;识别呈现引擎&lt;/p&gt;
&lt;p&gt;注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera&lt;/p&gt;
&lt;p&gt;注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别&lt;br&gt;识别浏览器&lt;br&gt;识别平台&lt;br&gt;识别windows操作系统&lt;br&gt;识别移动设备&lt;br&gt;识别游戏系统&lt;br&gt;完整的用户代理检测代码&lt;/p&gt;
&lt;h1 id=&quot;第10章-DOM&quot;&gt;&lt;a href=&quot;#第10章-DOM&quot; class=&quot;headerlink&quot; title=&quot;第10章 DOM&quot;&gt;&lt;/a&gt;第10章 DOM&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>研究框架YYModel</title>
    <link href="http://peilinghui.com/2017/02/03/%E7%A0%94%E7%A9%B6%E6%A1%86%E6%9E%B6YYModel/"/>
    <id>http://peilinghui.com/2017/02/03/研究框架YYModel/</id>
    <published>2017-02-03T07:22:49.000Z</published>
    <updated>2017-04-14T14:59:41.000Z</updated>
    
    <content type="html">&lt;p&gt;在网络请求的传输和解析中，免不了用到字典转模型的内容。YYModel源码研究。&lt;br&gt;地址：&lt;a href=&quot;https://github.com/ibireme/YYModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ibireme/YYModel&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;分析源码&quot;&gt;&lt;a href=&quot;#分析源码&quot; class=&quot;headerlink&quot; title=&quot;分析源码&quot;&gt;&lt;/a&gt;分析源码&lt;/h1&gt;&lt;p&gt;就是runtime的应用。文件目录:&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.17.19.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;YYClassInfo&quot;&gt;&lt;a href=&quot;#YYClassInfo&quot; class=&quot;headerlink&quot; title=&quot;YYClassInfo&quot;&gt;&lt;/a&gt;YYClassInfo&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;YYClassIvarInfo 对 Class的Ivar进行了进行封装增加描述
YYClassMethodInfo 对 Class 的 Method进行封装增加描述
YYClassPropertyInfo 对 Class 的 Property进行了封装描述
YYClassInfo 是对于Class进行了封装，进行封装增加描述
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.30.52.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在runtime.h中obj_class定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class super_class                                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars                             OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYClassInfo中：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; class的描述信息.对一个class进行封装&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYClassInfo&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class cls; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class superCls; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; super class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Class metaCls;  &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; isMeta; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 是否为元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) YYClassInfo *superClassInfo; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; 父类的描述信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; ivars 用字典来装，与YYClassIvarInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassIvarInfo *&amp;gt; *ivarInfos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; methods用字典来装，与YYClassMethodInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassMethodInfo *&amp;gt; *methodInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;///&amp;lt; properties用字典来装，与YYClassPropertyInfo一一对应&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (nullable, &lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *, YYClassPropertyInfo *&amp;gt; *propertyInfos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 当class中有内容被修改了，如增加了一个新的方法，需要调用这个方法进行刷新class的信息，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 这个方法调用后会将needUpdate方法中的返回值设置为YES，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 从而需要调用classInfoWithClass或者classInfoWithClassName来获取刷新class的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setNeedUpdate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; classInfo是否需要刷新，当返回值为YES的时候，需要停止使用改Instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)needUpdate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 获得cls的详细信息，并刷新&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable instancetype)classInfoWithClass:(Class)cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  获得cls的详细信息，并刷新&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (nullable instancetype)classInfoWithClassName:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)className;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYClassInfo声明的方法里，我们可以看到YYClassInfo一旦class进行了修改，就要做对应的更新，这样的操作是为了能够高效缓存class的信息，如ivars，method，property，我们首先从这个类的入口方法开始看起.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过class获取对应class的信息，并且对这些信息进行处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)classInfoWithClass:(Class)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cls) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 类 缓存容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; classCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 元类 缓存容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; metaCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 为了线程安全 同步信号量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; dispatch_semaphore_t lock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        classCache = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;CFAllocatorGetDefault&lt;/span&gt;(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryKeyCallBacks&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryValueCallBacks&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        metaCache = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;CFAllocatorGetDefault&lt;/span&gt;(), &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryKeyCallBacks&lt;/span&gt;, &amp;amp;k&lt;span class=&quot;built_in&quot;&gt;CFTypeDictionaryValueCallBacks&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock = dispatch_semaphore_create(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是元类还是Class，从结果的容器中进行查找&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *info = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryGetValue&lt;/span&gt;(class_isMetaClass(cls) ? metaCache : classCache, (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(cls));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否找到info并且需要进行刷新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info &amp;amp;&amp;amp; info-&amp;gt;_needUpdate) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [info _update];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 释放信号量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_semaphore_signal(lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!info) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// info不在缓存容器中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ** &lt;span class=&quot;comment&quot;&gt;// 通过initWithClass重新创建一个info**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        **info = [[YYClassInfo alloc] initWithClass:cls];**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 缓存到对应的容器中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 再一次判断是meta还是class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(info&lt;span class=&quot;variable&quot;&gt;.isMeta&lt;/span&gt; ? metaCache : classCache, (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(cls), (__bridge &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)(info));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            dispatch_semaphore_signal(lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对一个类建立实例变量，属性，方法的索引之后，会对这个类进行缓存，以便下一次使用的时候不用重新建立索引，YYModel使用了 CFDictionaryCreateMutable 来进行缓存类的 info ，key 是类名，value 是 YYClassInfo 对象。使用 dispatch_semaphore_t 保证线程安全，之所以选择个是基于性能的考虑。&lt;/p&gt;
&lt;p&gt;这里有几点需要说明一下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mutable不是线程安全的，所以这里需要创建锁
创建缓存容器，如果在缓存容器中直接找到了class，则直接获取到对应的ivar，method，property，这样在下次访问到的时候就不用再去找
如果没有获取到，就开始创建一个YYClassInfo获得class中的描述信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个YYClassInfo&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithClass:(&lt;span class=&quot;type&quot;&gt;Class&lt;/span&gt;)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cls) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _cls = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _superCls = class_getSuperclass(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _isMeta = class_isMetaClass(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_isMeta) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _metaCls = objc_getMetaClass(class_getName(cls));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 获得类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _name = &lt;span class=&quot;type&quot;&gt;NSStringFromClass&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ** [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; _update];**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _superClassInfo = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; classInfoWithClass:_superCls];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;YYClassInfo维护了一个变量来判断是否需要刷新，通过调用setNeedUpdate来修改_needUpdate=YES，进而调用_update方法来进行刷新.&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)_update &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 刷新ivar，method，property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _ivarInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _methodInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _propertyInfos = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class cls = self.cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取得类中的methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; methodCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Method *methods = class_copyMethodList(cls, &amp;amp;methodCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (methods) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存method信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *methodInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _methodInfos = methodInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历methods&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; methodCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassMethodInfo *info = [[YYClassMethodInfo alloc] initWithMethod:methods[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用方法名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) methodInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(methods);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取类中的property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; propertyCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;objc_property_t&lt;/span&gt; *properties = class_copyPropertyList(cls, &amp;amp;propertyCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存property信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *propertyInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _propertyInfos = propertyInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; propertyCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassPropertyInfo *info = [[YYClassPropertyInfo alloc] initWithProperty:properties[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用属性名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) propertyInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(properties);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 取得类中的变量信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivarCount = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ivar *ivars = class_copyIvarList(cls, &amp;amp;ivarCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ivars) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建dictionary来进行缓存ivar信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *ivarInfos = [NSMutableDictionary &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _ivarInfos = ivarInfos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历ivar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; ivarCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            YYClassIvarInfo *info = [[YYClassIvarInfo alloc] initWithIvar:ivars[i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 用变量名做key info做value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (info.name) ivarInfos[info.name] = info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(ivars);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果当中有不存在的内容，把缓存dict置为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_ivarInfos) _ivarInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_methodInfos) _methodInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_propertyInfos) _propertyInfos = @&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 刷新结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _needUpdate = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;YYClassIvarInfo&quot;&gt;&lt;a href=&quot;#YYClassIvarInfo&quot; class=&quot;headerlink&quot; title=&quot;YYClassIvarInfo&quot;&gt;&lt;/a&gt;YYClassIvarInfo&lt;/h3&gt;&lt;p&gt;在runtime.h中ivar的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_name                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_type                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_offset                                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                                                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在YYclassInfo中：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYClassIvarInfo&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) Ivar ivar;              &lt;span class=&quot;comment&quot;&gt;///&amp;lt; ivar opaque struct&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;         &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) ptrdiff_t offset;       &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s offset变量偏移地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *typeEncoding; &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s type encoding变量的编码类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;) YYEncodingType type;    &lt;span class=&quot;comment&quot;&gt;///&amp;lt; Ivar&#39;s type转化成YYType类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Creates and returns an ivar info object.创建，返回一个成员变量对象。可以直接在外面暴露的地方获取到这些属性。&lt;br&gt;&lt;code&gt;- (instancetype)initWithIvar:(Ivar)ivar;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;对于Ivar，property和Method都进行了一层封装，最后都服务于YYClassInfo，这样做的一个好处就是把原来里层的内容暴露在外层，方便查找，也可以进行缓存，提高访问效率和命中率，这也是对后面进行json转换做的一些工作&lt;/p&gt;
&lt;h2 id=&quot;NSObject-YYModel&quot;&gt;&lt;a href=&quot;#NSObject-YYModel&quot; class=&quot;headerlink&quot; title=&quot;NSObject+YYModel&quot;&gt;&lt;/a&gt;NSObject+YYModel&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.31.45.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-11%20%E4%B8%8B%E5%8D%8810.31.37.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;提供数据-模型方法：&lt;br&gt;1.把json转换成对象，或者把对象转换成Json.&lt;br&gt;2.设置对象的属性用KVO字典&lt;br&gt;3.‘NSCoding’,”NSCopying”,”-hash”.”-isEqual:”的实现&lt;/p&gt;
&lt;h3 id=&quot;对映射处理的封装&quot;&gt;&lt;a href=&quot;#对映射处理的封装&quot; class=&quot;headerlink&quot; title=&quot;对映射处理的封装&quot;&gt;&lt;/a&gt;对映射处理的封装&lt;/h3&gt;&lt;h4 id=&quot;YYModelPropertyMeta&quot;&gt;&lt;a href=&quot;#YYModelPropertyMeta&quot; class=&quot;headerlink&quot; title=&quot;_YYModelPropertyMeta&quot;&gt;&lt;/a&gt;_YYModelPropertyMeta&lt;/h4&gt;&lt;p&gt;_YYModelPropertyMeta 是一个内部类，用来处理一个 Class 的 Property 的元数据类。和 YYClassPropertyInfo 不同的是，_YYModelPropertyMeta 还负责映射属性的维护。可以说是，对 YYClassPropertyInfo 更高层的封装，服务于映射的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建YYModelProperty的元类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelPropertyMeta&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @package&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// property 名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *_name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// property 编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncodingType _type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Foundation类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncoding&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt; _nsType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否为基础数据类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isCNumber;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class _cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否为集合类型即Array／Set／Dicitinoary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class _genericCls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性的get方法和set方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL _getter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL _setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性是否提供KVC方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isKVCCompatible;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性是否支持归档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _isStructAvailableForKeyedArchiver;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否有自定义的映射字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomClassFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key 如 @&amp;#123;@&quot;name&quot;:@&quot;user&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *_mappedToKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key是一个路径 @&amp;#123;@&quot;name&quot;:@&quot;person.name&quot;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_mappedToKeyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json 与属性映射的key是一个数组,即一个key对应多个json key @&amp;#123;@&quot;name&quot;:@[@&quot;name&quot;,@&quot;user&quot;,@&quot;account&quot;]&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_mappedToKeyArray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 描述的property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassPropertyInfo *_info;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    **&lt;span class=&quot;comment&quot;&gt;// 在多个属性映射一个json key 的时候使用**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    **_YYModelPropertyMeta *_next;**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;多个property对应一个json key的情况，很可能映射表是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;collection&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;     : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;fullName&quot;&lt;/span&gt; : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @&lt;span class=&quot;string&quot;&gt;&quot;username&quot;&lt;/span&gt; : @&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里name、fullName、username都对应json中name这个字段，我们拿刚刚这个json key 映射来做分析.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/677383-c43a21298b1a2f8c.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;这样做有什么用呢，我们可以看到这样用了一个链表把所有映射到同一个json key的属性串联起来，这样如果json key 字段里的值改了，我们可以看到最先得到映射的是name属性，有了这样一个表，其他几个属性只需要通过next指针就可以拿到对应jsonkey 修改了的值，这样是不是直接把需要修改的都串联起来了呢..&lt;br&gt;YYModelPropertyMeta实现文件里的方法:&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@implementation&lt;/span&gt; _YYModelPropertyMeta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)&lt;span class=&quot;string&quot;&gt;metaWithClassInfo:&lt;/span&gt;(YYClassInfo *)classInfo &lt;span class=&quot;string&quot;&gt;propertyInfo:&lt;/span&gt;(YYClassPropertyInfo *)propertyInfo &lt;span class=&quot;string&quot;&gt;generic:&lt;/span&gt;(Class)generic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建一个meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _YYModelPropertyMeta *meta = [self &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将属性名赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_name = propertyInfo.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 赋值编码类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_type = propertyInfo.type;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将描述属性赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_info = propertyInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 记录属性为容器类型的时候 元素的映射类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_genericCls = generic;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) == YYEncodingTypeObject) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 先匹配是否为NS类型 即Foundation 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_nsType = YYClassGetNSType(propertyInfo.cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 是否为C数据类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_isCNumber = YYEncodingTypeIsCNumber(meta-&amp;gt;_type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 属性为结构体类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) == YYEncodingTypeStruct) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         It seems that NSKeyedUnarchiver cannot decode NSValue except these structs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; NSSet *types = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 单例 创建一份c结构体类型映射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            NSMutableSet *set = [NSMutableSet &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 32 bit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGSize=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGPoint=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGRect=&amp;#123;CGPoint=ff&amp;#125;&amp;#123;CGSize=ff&amp;#125;&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGAffineTransform=ffffff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIEdgeInsets=ffff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIOffset=ff&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 64 bit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGSize=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGPoint=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGRect=&amp;#123;CGPoint=dd&amp;#125;&amp;#123;CGSize=dd&amp;#125;&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;CGAffineTransform=dddddd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIEdgeInsets=dddd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [set &lt;span class=&quot;string&quot;&gt;addObject:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;UIOffset=dd&amp;#125;&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            types = set;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 只有以上的结构体才能被归档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([types &lt;span class=&quot;string&quot;&gt;containsObject:&lt;/span&gt;propertyInfo.typeEncoding]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_isStructAvailableForKeyedArchiver = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置class类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    meta-&amp;gt;_cls = propertyInfo.cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果是容器类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (generic) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从容器class 中读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_hasCustomClassFromDictionary = [generic &lt;span class=&quot;string&quot;&gt;respondsToSelector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;modelCustomClassForDictionary:&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (meta-&amp;gt;_cls &amp;amp;&amp;amp; meta-&amp;gt;_nsType == YYEncodingTypeNSUnknown) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 从class类型中读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta-&amp;gt;_hasCustomClassFromDictionary = [meta-&amp;gt;_cls &lt;span class=&quot;string&quot;&gt;respondsToSelector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;modelCustomClassForDictionary:&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// getter 和 setter 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (propertyInfo.getter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([classInfo.cls &lt;span class=&quot;string&quot;&gt;instancesRespondToSelector:&lt;/span&gt;propertyInfo.getter]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_getter = propertyInfo.getter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (propertyInfo.setter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([classInfo.cls &lt;span class=&quot;string&quot;&gt;instancesRespondToSelector:&lt;/span&gt;propertyInfo.setter]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            meta-&amp;gt;_setter = propertyInfo.setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     *  只有实现了getter和setter方法 才能实现归档&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (meta-&amp;gt;_getter &amp;amp;&amp;amp; meta-&amp;gt;_setter) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         KVC中不支持的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         long double&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         指针对象 SEL等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (meta-&amp;gt;_type &amp;amp; YYEncodingTypeMask) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeBool:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt8:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt8:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt16:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt16:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt32:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt32:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeInt64:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUInt64:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeFloat:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeDouble:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeObject:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeClass:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeBlock:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeStruct:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;YYEncodingTypeUnion:&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                meta-&amp;gt;_isKVCCompatible = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;label&quot;&gt;            default:&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; meta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;流程大概如下&lt;br&gt;1.如果是属性是对象，通过 YYClassGetNSType 来从propertyInfo获取 NSType&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断属性是否可以归档。除了 CGSize ，CGPoint，CGRect，CGAffineTransform，UIEdgeInsets，UIOffset 其他都不支持归档
是否需要对字典设置单独的 class 通过类方法 modelCustomClassForDictionary 来返回特定的 model 类
判断是否支持 setter，和getter 方法。
判断时候支持 KVC。只有 long double,指针对象, SEL不支持KVC
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;YYModelMeta&quot;&gt;&lt;a href=&quot;#YYModelMeta&quot; class=&quot;headerlink&quot; title=&quot;_YYModelMeta&quot;&gt;&lt;/a&gt;_YYModelMeta&lt;/h4&gt;&lt;p&gt;_YYModelMeta 是对一个需要映射的 Model YYClassInfo进行了一些描述信息的封装。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// YYModelMeta 对ClassInfo增加描述&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelMeta&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @package&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *_classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// json key 和 property Meta 的映射关系字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *_mapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 所有属性的propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_allPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 映射jsonkeyPath 的PropertyMetas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_keyPathPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 映射多个jsonKey的propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *_multiKeysPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// 需要映射的属性的总个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; _keyMappedCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/// Model对应的Foundation class类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYEncoding&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt; _nsType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否实现了自定义的映射关系表 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomWillTransformFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomTransformFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomTransformToDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; _hasCustomClassFromDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_YYModelMeta&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)initWithClass:(Class)cls &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建classInfo对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *classInfo = [YYClassInfo classInfoWithClass:cls];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1. 判断是否合法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!classInfo) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2. 获得黑名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *blacklist = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelPropertyBlacklist)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *properties = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelPropertyBlacklist];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            blacklist = [&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithArray:properties];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3. 获得白名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *whitelist = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelPropertyWhitelist)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *properties = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelPropertyWhitelist];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (properties) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            whitelist = [&lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; setWithArray:properties];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4. 获取容器属性中的映射关系字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *genericMapper = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelContainerPropertyGenericClass)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断类中是否实现了对应的modelContainerPropertyGenericClass方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/* 例如&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&amp;#123;@&quot;shadows&quot; : [YYShadow class],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&quot;borders&quot; : YYBorder.class,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @&quot;attachments&quot; : @&quot;YYAttachment&quot; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        genericMapper = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;YYModel&amp;gt;)cls modelContainerPropertyGenericClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (genericMapper) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 将字段名和对应的class存放在字典里&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *tmp = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [genericMapper enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![key isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Class meta = object_getClass(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (class_isMetaClass(meta)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    tmp[key] = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([obj isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Class cls = &lt;span class=&quot;built_in&quot;&gt;NSClassFromString&lt;/span&gt;(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cls) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tmp[key] = cls;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            genericMapper = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 5. 创建Class中 所有属性的PropertyMeta对象 加入到字典中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用来保存class 和其父类的所有属性 除了NSOject外&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *allPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    YYClassInfo *curClassInfo = classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (curClassInfo &amp;amp;&amp;amp; curClassInfo&lt;span class=&quot;variable&quot;&gt;.superCls&lt;/span&gt; != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// recursive parse super class, but ignore root class (NSObject/NSProxy)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历当前ClassInfo 中的所有PropertyInfo， 将它们封装成PropertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (YYClassPropertyInfo *propertyInfo &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; curClassInfo&lt;span class=&quot;variable&quot;&gt;.propertyInfos&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.allValues&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 检查是否合法和黑名单白名单&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (blacklist &amp;amp;&amp;amp; [blacklist containsObject:propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (whitelist &amp;amp;&amp;amp; ![whitelist containsObject:propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 通过propetyInfo来创建一个meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _YYModelPropertyMeta *meta = [_YYModelPropertyMeta metaWithClassInfo:classInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                    propertyInfo:propertyInfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                         generic:genericMapper[propertyInfo&lt;span class=&quot;variable&quot;&gt;.name&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// meta nanme必须非空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta || !meta-&amp;gt;_name) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 必须实现get方法和set方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!meta-&amp;gt;_getter || !meta-&amp;gt;_setter) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 字典中没有这个字段 避免重复操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allPropertyMetas[meta-&amp;gt;_name]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            allPropertyMetas[meta-&amp;gt;_name] = meta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历父类的property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        curClassInfo = curClassInfo&lt;span class=&quot;variable&quot;&gt;.superClassInfo&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 判断是否为空，不为空赋值给model声明中的_allPropertyMetas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;) _allPropertyMetas = allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.allValues&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.copy&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建映射关系 jsonkey ：propertyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *mapper = [&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *keyPathPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *multiKeysPropertyMetas = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否实现自定义的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomPropertyMapper)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获得自定义的映射表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *customMapper = [(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; &amp;lt;YYModel&amp;gt;)cls modelCustomPropertyMapper];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 遍历自定义的字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [customMapper enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *propertyName, &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *mappedToKey, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 创建propetyMeta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            _YYModelPropertyMeta *propertyMeta = allPropertyMetas[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 由于用户自定义映射，把原来映射的规则删除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [allPropertyMetas removeObjectForKey:propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([mappedToKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 判断key字段是否为非空NSString&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mappedToKey&lt;span class=&quot;variable&quot;&gt;.length&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 直接保存property映射的key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_mappedToKey = mappedToKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 如果是keyPath的情况， 用数组来处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *keyPath = [mappedToKey componentsSeparatedByString:&lt;span class=&quot;string&quot;&gt;@&quot;.&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// &amp;#123;@&quot;name&quot;:@&quot;user.name&quot;&amp;#125; =&amp;gt; name : @[@&quot;user&quot;,@&quot;name&quot;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 保存keyPath映射关系&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    propertyMeta-&amp;gt;_mappedToKeyPath = keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// 添加到keyPathPropertyMetas数组中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [keyPathPropertyMetas addObject:propertyMeta];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 多个属性的时候，用next指针来指向前一个jsonKey映射的meta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_next = mapper[mappedToKey] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 保存jsonKey映射到最新的meta对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mapper[mappedToKey] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([mappedToKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; class]]) &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 如果是数组 属于一个属性映射多个jsonKey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; *mappedToKeyArray = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *oneKey &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; ((&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)mappedToKey)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![oneKey isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oneKey&lt;span class=&quot;variable&quot;&gt;.length&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *keyPath = [oneKey componentsSeparatedByString:&lt;span class=&quot;string&quot;&gt;@&quot;.&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        [mappedToKeyArray addObject:keyPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        [mappedToKeyArray addObject:oneKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta-&amp;gt;_mappedToKey) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        propertyMeta-&amp;gt;_mappedToKey = oneKey;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        propertyMeta-&amp;gt;_mappedToKeyPath = keyPath&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt; &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ? keyPath : &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!propertyMeta-&amp;gt;_mappedToKey) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_mappedToKeyArray = mappedToKeyArray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [multiKeysPropertyMetas addObject:propertyMeta];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                propertyMeta-&amp;gt;_next = mapper[mappedToKey] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                mapper[mappedToKey] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 处理没有自定义映射规则的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在上面的处理中 从allPropertyMetas中删除了有自定义映射规则的meta&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 剩下来的是没有自定义规则的属性，在这里就让这些属性的mappedKey等于属性名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [allPropertyMetas enumerateKeysAndObjectsUsingBlock:^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name, _YYModelPropertyMeta *propertyMeta, &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 直接让mappedKey等于属性名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        propertyMeta-&amp;gt;_mappedToKey = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        propertyMeta-&amp;gt;_next = mapper[name] ?: &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mapper[name] = propertyMeta;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对映射的数据做修正处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mapper&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;) _mapper = mapper;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (keyPathPropertyMetas) _keyPathPropertyMetas = keyPathPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (multiKeysPropertyMetas) _multiKeysPropertyMetas = multiKeysPropertyMetas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _classInfo = classInfo;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _keyMappedCount = _allPropertyMetas&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _nsType = YYClassGet&lt;span class=&quot;built_in&quot;&gt;NSType&lt;/span&gt;(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomWillTransformFromDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomWillTransformFromDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomTransformFromDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomTransformFromDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomTransformToDictionary = ([cls instancesRespondToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomTransformToDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _hasCustomClassFromDictionary = ([cls respondsToSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(modelCustomClassForDictionary:)]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;流程是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获取黑名单和白名单。
创建 allPropertyMetas ，将所有属性添加到其中，根据黑，白名单剔除其中的元素。
将 allPropertyMetas 中的处理 keyPath 的 key 添加到 _keyPathPropertyMetas，将需要处理多 key 映射的添加到 _multiKeysPropertyMetas 中。
缓存机制
对于处理好的映射关系，YYModel 会对它们进行缓存，用的也是 CFDictionaryGetValue 来完成，使用 dispatch_semaphore_t 来保证线程安全
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h2 id=&quot;简单的-Model-与-JSON-相互转换&quot;&gt;&lt;a href=&quot;#简单的-Model-与-JSON-相互转换&quot; class=&quot;headerlink&quot; title=&quot;简单的 Model 与 JSON 相互转换&quot;&gt;&lt;/a&gt;简单的 Model 与 JSON 相互转换&lt;/h2&gt;&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// JSON:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;uid&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;123456&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;created&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1965-07-31T00:00:00+0000&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Model:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface &lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;: NSObject&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;UInt64 uid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;NSString *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@&lt;span class=&quot;keyword&quot;&gt;property&lt;/span&gt;&lt;span class=&quot;title&quot;&gt; &lt;/span&gt;NSDate *created;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation &lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;*user&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yy_modelWithJSON&lt;/span&gt;:json];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 将 Model 转换为 JSON 对象:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *json = [&lt;span class=&quot;keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;yy_modelToJSONObject&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 JSON/Dictionary 中的对象类型与 Model 属性不一致时，YYModel 将会进行如下自动转换。自动转换不支持的值将会被忽略，以避免各种潜在的崩溃问题。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-12%20%E4%B8%8B%E5%8D%883.01.36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Model-属性名和-JSON-中的-Key-不相同&quot;&gt;&lt;a href=&quot;#Model-属性名和-JSON-中的-Key-不相同&quot; class=&quot;headerlink&quot; title=&quot;Model 属性名和 JSON 中的 Key 不相同&quot;&gt;&lt;/a&gt;Model 属性名和 JSON 中的 Key 不相同&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;n&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry Pottery&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;p&quot;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;ext&quot;&lt;/span&gt; : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&quot;A book written by J.K.Rowing.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;ID&quot;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; page;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *desc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *bookID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//返回一个 Dict，将 Model 属性名对映射到 JSON 的 Key。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)modelCustomPropertyMapper &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;name&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;page&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;p&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;desc&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;ext.desc&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;bookID&quot;&lt;/span&gt; : @[&lt;span class=&quot;string&quot;&gt;@&quot;id&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;ID&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;@&quot;book_id&quot;&lt;/span&gt;]&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以把一个或一组 json key (key path) 映射到一个或多个属性。如果一个属性没有映射关系，那默认会使用相同属性名作为映射。&lt;/p&gt;
&lt;p&gt;在 json-&amp;gt;model 的过程中：如果一个属性对应了多个 json key，那么转换过程会按顺序查找，并使用第一个不为空的值。&lt;/p&gt;
&lt;p&gt;在 model-&amp;gt;json 的过程中：如果一个属性对应了多个 json key (key path)，那么转换过程仅会处理第一个 json key (key path)；如果多个属性对应了同一个 json key，则转换过过程会使用其中任意一个不为空的值。&lt;/p&gt;
&lt;h2 id=&quot;Model-包含其他-Model&quot;&gt;&lt;a href=&quot;#Model-包含其他-Model&quot; class=&quot;headerlink&quot; title=&quot;Model 包含其他 Model&quot;&gt;&lt;/a&gt;Model 包含其他 Model&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;author&quot;&lt;/span&gt;:&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;J.K.Rowling&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;birthday&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;1965-07-31T00:00:00+0000&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry Potter&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;pages&quot;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model: 什么都不用做，转换会自动完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *birthday;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Author&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; pages;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; Author *author; &lt;span class=&quot;comment&quot;&gt;//Book 包含 Author 属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Book&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;容器类属性&quot;&gt;&lt;a href=&quot;#容器类属性&quot; class=&quot;headerlink&quot; title=&quot;容器类属性&quot;&gt;&lt;/a&gt;容器类属性&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Shadow&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Border&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Attachment&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *shadows; &lt;span class=&quot;comment&quot;&gt;//Array&amp;lt;Shadow&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSSet&lt;/span&gt; *borders; &lt;span class=&quot;comment&quot;&gt;//Set&amp;lt;Border&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *attachments; &lt;span class=&quot;comment&quot;&gt;//Dict&amp;lt;NSString,Attachment&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 返回容器类中的所需要存放的数据类型 (以 Class 或 Class Name 的形式)。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)modelContainerPropertyGenericClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;shadows&quot;&lt;/span&gt; : [Shadow class],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;borders&quot;&lt;/span&gt; : Border&lt;span class=&quot;variable&quot;&gt;.class&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;span class=&quot;string&quot;&gt;@&quot;attachments&quot;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;@&quot;Attachment&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;黑名单与白名单&quot;&gt;&lt;a href=&quot;#黑名单与白名单&quot; class=&quot;headerlink&quot; title=&quot;黑名单与白名单&quot;&gt;&lt;/a&gt;黑名单与白名单&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt; age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Attributes&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果实现了该方法，则处理过程中会忽略该列表内的所有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)modelPropertyBlacklist &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @[&lt;span class=&quot;string&quot;&gt;@&quot;test1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;@&quot;test2&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果实现了该方法，则处理过程中不会处理该列表外的属性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)modelPropertyWhitelist &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; @[&lt;span class=&quot;string&quot;&gt;@&quot;name&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;数据校验与自定义转换&quot;&gt;&lt;a href=&quot;#数据校验与自定义转换&quot; class=&quot;headerlink&quot; title=&quot;数据校验与自定义转换&quot;&gt;&lt;/a&gt;数据校验与自定义转换&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// JSON:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;Harry&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;timestamp&quot;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1445534567&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Model:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; *createdAt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当 JSON 转为 Model 完成后，该方法会被调用。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你也可以在这里做一些自动转换不能完成的工作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)modelCustomTransformFromDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *)dic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; *timestamp = dic[&lt;span class=&quot;string&quot;&gt;@&quot;timestamp&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (![timestamp isKindOfClass:[&lt;span class=&quot;built_in&quot;&gt;NSNumber&lt;/span&gt; class]]) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _createdAt = [&lt;span class=&quot;built_in&quot;&gt;NSDate&lt;/span&gt; dateWithTimeIntervalSince1970:timestamp&lt;span class=&quot;variable&quot;&gt;.floatValue&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 当 Model 转为 JSON 完成后，该方法会被调用。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你可以在这里对数据进行校验，如果校验不通过，可以返回 NO，则该 Model 会被忽略。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 你也可以在这里做一些自动转换不能完成的工作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)modelCustomTransformToDictionary:(&lt;span class=&quot;built_in&quot;&gt;NSMutableDictionary&lt;/span&gt; *)dic &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!_createdAt) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dic[&lt;span class=&quot;string&quot;&gt;@&quot;timestamp&quot;&lt;/span&gt;] = @(n&lt;span class=&quot;variable&quot;&gt;.timeIntervalSince1970&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Coding-Copying-hash-equal-description&quot;&gt;&lt;a href=&quot;#Coding-Copying-hash-equal-description&quot; class=&quot;headerlink&quot; title=&quot;Coding/Copying/hash/equal/description&quot;&gt;&lt;/a&gt;Coding/Copying/hash/equal/description&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYShadow&lt;/span&gt; :&lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;NSCoding&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;NSCopying&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;assign&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;CGSize&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;YYShadow&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 直接添加以下代码即可自动完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)encodeWithCoder:(&lt;span class=&quot;built_in&quot;&gt;NSCoder&lt;/span&gt; *)aCoder &amp;#123; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelEncodeWithCoder:aCoder]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)initWithCoder:(&lt;span class=&quot;built_in&quot;&gt;NSCoder&lt;/span&gt; *)aDecoder &amp;#123; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init]; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelInitWithCoder:aDecoder]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)copyWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelCopy]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)hash &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelHash]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)isEqual:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelIsEqual:object]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)description &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; yy_modelDescription]; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;CocoaPods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在 Podfile 中添加 pod &amp;apos;YYModel&amp;apos;。
执行 pod install。
导入 &amp;lt;YYModel/YYModel.h&amp;gt;。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/b6aaf5d56257&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/b6aaf5d56257&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较YYModel和MJExtension：&lt;/strong&gt;&lt;br&gt;YYModel、MJExtension 都是采用 Category 方式来实现功能，比较灵活，无侵入。&lt;br&gt;但注意 MJExtension 为 NSObject/NSString 添加了一些没有前缀的方法，且方法命名比较通用，可能会和一个工程内的其他类有冲突。&lt;/p&gt;
&lt;p&gt;YYModel 会进行对象类型检查，避免将错误的对象类型赋值到属性，以避免潜在的 Crash 问题。YYModel 会尝试自动转换，&lt;/p&gt;
&lt;p&gt;MJExtension 会对部分对象进行自动转换（比如 NSString 和 NSNumber 之间的转换），但当自动转换不能完成时，它会直接把 JSON 对象赋值给类型不匹配的 Model 属性。这样的结果会导致稍后 Model 在使用时，造成潜在的 Crash 风险。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;iOS JSON 模型转换库评测&lt;a href=&quot;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/10/23/ios_model_framework_benchmark/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在网络请求的传输和解析中，免不了用到字典转模型的内容。YYModel源码研究。&lt;br&gt;地址：&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;https://github.com/ibireme/YYModel&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二维码</title>
    <link href="http://peilinghui.com/2016/12/20/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://peilinghui.com/2016/12/20/二维码/</id>
    <published>2016-12-20T03:08:34.000Z</published>
    <updated>2017-02-20T03:43:15.000Z</updated>
    
    <content type="html">&lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的生成&quot;&gt;&lt;a href=&quot;#二维码的生成&quot; class=&quot;headerlink&quot; title=&quot;二维码的生成&quot;&gt;&lt;/a&gt;二维码的生成&lt;/h1&gt;&lt;h2 id=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;a href=&quot;#从服务器获取data地址再生成二维码&quot; class=&quot;headerlink&quot; title=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;/a&gt;从服务器获取data地址再生成二维码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;网络请求后处理data:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr_selector&quot;&gt;[self.progressHud hide:YES]&lt;/span&gt;;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; ([response.responseObject &lt;span class=&quot;attribute&quot;&gt;objectForKey&lt;/span&gt;:@&lt;span class=&quot;string&quot;&gt;&quot;data&quot;&lt;/span&gt;]) &amp;#123;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr_selector&quot;&gt;[self createImgWith:[response.responseObject objectForKey:@&quot;data&quot;]&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;生成二维码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)createImgWith:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)str &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.实例化二维码滤镜&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; *filter = [&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; filterWithName:&lt;span class=&quot;string&quot;&gt;@&quot;CIQRCodeGenerator&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.恢复滤镜的默认属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setDefaults];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3.将字符串转换成NSData&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *info = str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *infoData = [info dataUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//4.通过KVO设置滤镜inputMessage数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setValue:infoData forKey:&lt;span class=&quot;string&quot;&gt;@&quot;inputMessage&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 5.获得滤镜输出的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *outputImage = [filter outputImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//6. 将CIImage转换成UIImage，并放大显示,方法如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.qrCode&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.image&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:outputImage withSize:&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//return [UIImage imageWithCIImage:outputImage scale:20.0 orientation:UIImageOrientationUp];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  根据CIImage生成指定大小的UIImage 生成清晰的二维码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param image CIImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param size  图片宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *)image withSize:(&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; extent = &lt;span class=&quot;built_in&quot;&gt;CGRectIntegral&lt;/span&gt;(image&lt;span class=&quot;variable&quot;&gt;.extent&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; scale = MIN(size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent), size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.创建bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t width = &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t height = &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceRef&lt;/span&gt; cs = &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceCreateDeviceCMYK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; bitmapRef = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreate&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, width, height, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, cs, (&lt;span class=&quot;built_in&quot;&gt;CGBitmapInfo&lt;/span&gt;)k&lt;span class=&quot;built_in&quot;&gt;CGImageAlphaNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; *context = [&lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; contextWithOptions:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; bitmapImage = [context create&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:image fromRect:extent];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextSetInterpolationQuality&lt;/span&gt;(bitmapRef, k&lt;span class=&quot;built_in&quot;&gt;CGInterpolationNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextScaleCTM&lt;/span&gt;(bitmapRef, scale, scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextDrawImage&lt;/span&gt;(bitmapRef, extent, bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.保存bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; scaledImage = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreateImage&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRelease&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRelease&lt;/span&gt;(bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageWith&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:scaledImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;二维码的扫描&quot;&gt;&lt;a href=&quot;#二维码的扫描&quot; class=&quot;headerlink&quot; title=&quot;二维码的扫描&quot;&gt;&lt;/a&gt;二维码的扫描&lt;/h1&gt;&lt;p&gt;读取二维码需要导入AVFoundation框架&lt;br&gt;利用摄像头识别二维码中的内容（模拟器不行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入（摄像头）
由会话将摄像头采集到的二维码图像转换成字符串数据
输出（数据）
由预览图层显示扫描场景
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扫码主要用到的是AVFoundation用到的东西和相机基本相同，相机。遵守AVCaptureMetadataOutputObjectsDelegate.&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; ScanQRViewController ()&amp;lt;AVCaptureMetadataOutputObjectsDelegate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDevice *device;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDeviceInput *input;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置输出类型为Metadata，因为这种输出类型中可以设置扫描的类型，譬如二维码//当启动摄像头开始捕获输入时，如果输入中包含二维码，就会产生输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureMetadataOutput *output;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）关键用来操作扫描结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureSession *session;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图像预览层，实时显示捕获的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;开始扫描：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginScan&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//iOS 判断应用是否有使用相机的权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *mediaType = &lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//读取媒体类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatus&lt;/span&gt; authStatus = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; authorizationStatusForMediaType:mediaType];&lt;span class=&quot;comment&quot;&gt;//读取设备授权状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusRestricted&lt;/span&gt; || authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusDenied&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (TARGET_IPHONE_SIMULATOR) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//生成会话，用来结合输入输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	 _session =[[&lt;span class=&quot;built_in&quot;&gt;AVCaptureSession&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session setSessionPreset:&lt;span class=&quot;built_in&quot;&gt;AVCaptureSessionPresetHigh&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用AVMediaTypeVideo 默认使用后置摄像头进行初始化**实例化拍摄设备**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; *device           = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; defaultDeviceWithMediaType:&lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用设备初始化输入(设置输入设备)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; *input       = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; deviceInputWithDevice:device error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session addInput:input];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//生成输出对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; *output   = [[&lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置代理，一旦扫描到指定类型的数据，就会通过代理输出 //在扫描的过程中，会分析扫描的内容，分析成功后就会调用代理方法在队列中输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [output setMetadataObjectsDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; queue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [_session addOutput:output];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//指定当扫描到二维码的时候，产生输出 //AVMetadataObjectTypeQRCode 指定二维码 //指定识别类型一定要放到添加到session之后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [output setMetadataObjectTypes:@[&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeQRCode&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN13Code&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN8Code&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeCode128Code&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//设置扫描信息的识别区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; scanCrop = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; getRectOfInterest:_scanWindowView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; ViewoHoleBounds:_cameraView&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;x:%f y:%f width:%f height:%f&quot;&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.x&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.y&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output&lt;span class=&quot;variable&quot;&gt;.rectOfInterest&lt;/span&gt;             = scanCrop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//layer负责把图像渲染显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; *layer = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; layerWithSession:_session];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.videoGravity&lt;/span&gt;                = &lt;span class=&quot;built_in&quot;&gt;AVLayerVideoGravityResizeAspectFill&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;                       = _cameraView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_cameraView&lt;span class=&quot;variable&quot;&gt;.layer&lt;/span&gt; insertSublayer:layer atIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开始启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session startRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现代理方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark - 得到扫描二维码结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)captureOutput:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureOutput&lt;/span&gt; *)captureOutput didOutputMetadataObjects:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)metadataObjects fromConnection:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureConnection&lt;/span&gt; *)connection&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (metadataObjects&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_session stopRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//数组中包含的都是AVMetadataMachineReadableCodeObject 类型的对象，该对象中包含解码后的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;AVMetadataMachineReadableCodeObject&lt;/span&gt; * metadataObject = [metadataObjects objectAtIndex : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SystemSoundID completeSound;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *audioPath = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle] URLForResource:&lt;span class=&quot;string&quot;&gt;@&quot;beep&quot;&lt;/span&gt; withExtension:&lt;span class=&quot;string&quot;&gt;@&quot;ogg&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesCreateSystemSoundID((__bridge &lt;span class=&quot;built_in&quot;&gt;CFURLRef&lt;/span&gt; _Nonnull)(audioPath), &amp;amp;completeSound);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(completeSound);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sendRequestWithBarcode:metadataObject&lt;span class=&quot;variable&quot;&gt;.stringValue&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫码范围：&lt;/p&gt;
&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - 根据参数取得扫面范围reck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGRect)getRectOfInterest:(CGRect)rectFrame ViewoHoleBounds:(CGRect)holeBounds &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat x,y,&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;,heigth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = (rectFrame.origin.x)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = (rectFrame.origin.y)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt; = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    heigth = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; CGRectMake(y, x, heigth, &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫描动画：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;pragma&lt;/span&gt; mark - 扫描器开始进行动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginAnimated &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *lineImgView = [[UIImageView alloc]initWithFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lineImgView.image        = [UIImage imageNamed:@&lt;span class=&quot;string&quot;&gt;&quot;barcodeline&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_scanWindowView addSubview:lineImgView]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [UIView animateWithDuration:&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; delay:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; options:UIViewAnimationOptionRepeat animations:^&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineImgView.frame    = CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; completion:^(BOOL finished) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://my.oschina.net/u/2340880/blog/405847&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://my.oschina.net/u/2340880/blog/405847&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://c0ming.me/qr-code-scan/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://c0ming.me/qr-code-scan/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://yimouleng.com/2016/01/13/ios-QRCode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yimouleng.com/2016/01/13/ios-QRCode/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似支付宝二维码Demo：&lt;br&gt;&lt;a href=&quot;https://github.com/mokey1422/GBAliScan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mokey1422/GBAliScan&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的&quot;&gt;&lt;a href=&quot;#二维码的&quot; class=&quot;headerlink&quot; title=&quot;二维码的&quot;&gt;&lt;/a&gt;二维码的&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中的加密实现</title>
    <link href="http://peilinghui.com/2016/12/02/iOS%E4%B8%AD%E7%9A%84%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0/"/>
    <id>http://peilinghui.com/2016/12/02/iOS中的加密实现/</id>
    <published>2016-12-02T12:12:35.000Z</published>
    <updated>2017-04-14T15:00:42.000Z</updated>
    
    <content type="html">&lt;p&gt;在一个App登录的时候或者是一些个人信息输入的时候都需要有加密算法的实现来确保安全。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;p&gt;加密算法通常分为对称性加密算法和非对称性加密算法.&lt;/p&gt;
&lt;p&gt;对称性加密算法:信息接收双方都需事先知道密匙和加解密算法且其密匙是相同.  &lt;/p&gt;
&lt;p&gt;非对称算法:发送双方A,B事先均生成一堆密匙，然后A将自己的公有密匙发送给B，B将自己的公有密匙发送给A，如果A要给B发送消 息，则先需要用B的公有密匙进行消息加密，然后发送给B端，此时B端再用自己的私有密匙进行消息解密.&lt;br&gt;&lt;strong&gt;加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加密分为两种，对称加密和非对称加密。&lt;br&gt;所谓的对称，就是指加密秘钥和解密秘钥相同，而非对称自然就是指两者不同。&lt;/p&gt;
&lt;p&gt;对称加密的优点在于速度快，但是假设秘钥由服务器保存，如何安全的让客户端得到秘钥是需要解决的问题。&lt;/p&gt;
&lt;p&gt;常见的一个非对称加密算法是 RSA 算法，利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。&lt;br&gt;因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。&lt;br&gt;因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。&lt;/p&gt;
&lt;h1 id=&quot;几种对称性加密算法：AES-DES-3DES&quot;&gt;&lt;a href=&quot;#几种对称性加密算法：AES-DES-3DES&quot; class=&quot;headerlink&quot; title=&quot;几种对称性加密算法：AES,DES,3DES&quot;&gt;&lt;/a&gt;几种对称性加密算法：AES,DES,3DES&lt;/h1&gt;&lt;h1 id=&quot;几种非对称性加密算法：RSA-DSA-ECC&quot;&gt;&lt;a href=&quot;#几种非对称性加密算法：RSA-DSA-ECC&quot; class=&quot;headerlink&quot; title=&quot;几种非对称性加密算法：RSA,DSA,ECC&quot;&gt;&lt;/a&gt;几种非对称性加密算法：RSA,DSA,ECC&lt;/h1&gt;&lt;h1 id=&quot;几种线性散列算法（签名算法）：MD5-SHA1-HMAC&quot;&gt;&lt;a href=&quot;#几种线性散列算法（签名算法）：MD5-SHA1-HMAC&quot; class=&quot;headerlink&quot; title=&quot;几种线性散列算法（签名算法）：MD5,SHA1,HMAC&quot;&gt;&lt;/a&gt;几种线性散列算法（签名算法）：MD5,SHA1,HMAC&lt;/h1&gt;&lt;p&gt;MD5加密后的密文都是32位字符：无论原先没有加密前的字符串有多长  加密后都是32位字符  另外我们认为MD5是不可逆的，但事实上网站  md5.com 记录了全球的状态码&lt;br&gt; 可以直接将密文进行解析：所以要对MD5进行加盐来解决&lt;/p&gt;
&lt;p&gt; 方式1、直接进行MD5加密&lt;br&gt; 方式2、加盐后进行MD5加密&lt;br&gt; 方式3、HMAC+MD5&lt;/p&gt;
&lt;p&gt;在iOS开发中，如果某个字符串需要进行MD5加密.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;包含头文件“CommonDigest.h”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import&amp;lt;CommonCrypto/CommonDigest.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写下述方法。函数参数为需要加密的字符串，返回值为加密后得到的结果，也是一个字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;type&quot;&gt;NSString&lt;/span&gt; *)md5HexDigest:(&lt;span class=&quot;type&quot;&gt;NSString&lt;/span&gt; *)url  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; *original_str = [url &lt;span class=&quot;type&quot;&gt;UTF8String&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    unsigned &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;CC_MD5_DIGEST_LENGTH&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CC_MD5&lt;/span&gt;(original_str, strlen(original_str), &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;NSMutableString&lt;/span&gt; *hash = [&lt;span class=&quot;type&quot;&gt;NSMutableString&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;string&lt;/span&gt;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;; i++)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [hash appendFormat:@&lt;span class=&quot;string&quot;&gt;&quot;%02X&quot;&lt;/span&gt;, &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i]];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [hash lowercaseString];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;面试题目：&lt;br&gt;1）如果原文为字串s， 则在发送前先将s转换为UTF-8编码，然后按位取反，再将数据以字节为单位反转顺序，得到新的字节数组。&lt;br&gt;2）取出新字节数组的每一字节，为其生成一个0到100的随机数，用该字节减于随机数，得到的结果作为一个32位整数的最后8位，而随机数按位取反后则作为该整数的9至16位，从而生成一个新的整数，以此类推，得到一个整形数组d。&lt;br&gt;3） 将该整形数组发送给接收方，对方解密后得到原文内容s&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在一个App登录的时候或者是一些个人信息输入的时候都需要有加密算法的实现来确保安全。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习GCD</title>
    <link href="http://peilinghui.com/2016/10/05/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0GCD/"/>
    <id>http://peilinghui.com/2016/10/05/深入学习GCD/</id>
    <published>2016-10-05T08:22:32.000Z</published>
    <updated>2017-04-15T15:01:00.000Z</updated>
    
    <content type="html">&lt;p&gt;再次学习GCD的内容，并总结。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;h3 id=&quot;GCD概要&quot;&gt;&lt;a href=&quot;#GCD概要&quot; class=&quot;headerlink&quot; title=&quot;GCD概要&quot;&gt;&lt;/a&gt;GCD概要&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;异步执行的技术之一，开发者只需要定义向执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(queue,^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(),^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//主线程可以执行的处理：用户页面更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程, 并发&lt;/strong&gt;&lt;br&gt; 一个应用就相当于一个进程, 而一个进程可以同时分发几个线程同时处理任务.而并发正是一个进程开启多个线程同时执行任务的意思, 主线程专门用来刷新UI,处理触摸事件等 而子线程呢, 则用来执行耗时的操作, 例如访问数据库, 下载数据等..&lt;br&gt;1个CPU执行的CPU命令列为一条无分叉路径，即为“线程”。&lt;br&gt;由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU能够并列执行多个线程一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的优势&lt;/strong&gt;&lt;br&gt;说到优势, 当然有比较, 才能显得出优势所在. 事实上, iOS中我们能使用的多线程管理技术有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pthread(来自Clang, 纯C语言, 需要手动创建线程, 销毁线程, 手动进行线程管理. 而且代码极其恶心, )
NSThread(Foundation框架下的OC对象, 依旧需要自己进行线程管理，线程同步。 线程同步对数据的加锁会有一定的开销。)
GCD(两个字, 牛逼, 虽然是纯C语言, 但是它用难以置信的非常简洁的方式实现了极其复杂的多线程编程, 而且还支持block内联形式进行制定任务. 简洁! 高效! 而且我们再也不用手动进行线程管理了.)
NSOperationQueue(相当于Foundation框架的GCD, 以面向对象的语法对GCD进行了封装. 效率一样高)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下优点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。
GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。
GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;GCD的API&quot;&gt;&lt;a href=&quot;#GCD的API&quot; class=&quot;headerlink&quot; title=&quot;GCD的API&quot;&gt;&lt;/a&gt;GCD的API&lt;/h3&gt;&lt;p&gt;在介绍GCD的API之前, 我们先搞清楚四个名词: 串行, 并行, 同步, 异步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;串行 : 一个任务执行完, 再执行下一个任务
并行 : 多个任务同时执行
同步 : 在当前线程中执行任务, 不具备开启线程的能力
异步 : 在新的线程中执行任务, 具备开启线程的能力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Dispatch Queue&lt;/strong&gt;&lt;br&gt;Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.队列分两种.&lt;br&gt;一种是串行队列(Serial Dispatch Queue),&lt;br&gt;一种是并行队列(Concurrent Dispatch Queue).  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch Queue的种类            说明  
Serial Dispatch Queue            等待现在执行中处理结束  
Concurrent Dispatch Queue       不等待现在执行中处理结束
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并发队列 : 让多个任务同时执行(自动开启多个线程执行任务)&lt;br&gt;并发功能只有在异步函数(dispatch_async)下才有效(想想看为什么?)&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%885.08.16.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建队列&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)&lt;/code&gt;&lt;br&gt; 手动创建一个队列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label : 队列的标识符, 日后可用来调试程序
attr : 队列类型
DISPATCH_QUEUE_CONCURRENT : 并发队列
DISPATCH_QUEUE_SERIAL 或 NULL : 串行队列
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是, 通过dispatch_queue_create函数生成的queue在使用结束后需要通过dispatch_release函数来释放.(只有在MRC下才需要释放)&lt;/p&gt;
&lt;p&gt;并不是什么时候都需要手动创建队列, 事实上系统给我们提供2个很常用的队列. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主队列&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_get_main_queue();&lt;/code&gt;&lt;br&gt;该方法返回的是主线程中执行的同步队列. 用户界面的更新等一些必须在主线程中执行的操作追加到此队列中.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局并发队列&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_get_global_queue(long identifier, unsigned long flags);&lt;/code&gt;&lt;br&gt;该方法返回的是全局并发队列. 使用十分广泛.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;identifier : 优先级
DISPATCH_QUEUE_PRIORITY_HIGH : 高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT : 默认优先级
DISPATCH_QUEUE_PRIORITY_LOW : 低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND : 后台优先级
flags : 暂时用不上, 传 0 即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 : 对Main Dispatch Queue和Global Dispatch Queue执行dispatch_release和dispatch_retain没有任何问题. (MRC)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_sync(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下同步执行block&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_async(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下异步执行block(开启新线程)&lt;br&gt;dispatch_async 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_time(dispatch_time_t when, int64_t delta);&lt;/code&gt;&lt;br&gt;根据传入的时间(when)和延迟(delta)计算出一个未来的时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;when :
DISPATCH_TIME_NOW : 现在
DISPATCH_TIME_FOREVER : 永远(别传这个参数, 否则该时间很大)
delta : 该参数接收的是纳秒, 可以用一个宏NSEC_PER_SEC来进行转换, 例如你要延迟3秒, 则为 3 * NSEC_PER_SEC.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;延迟执行&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_after(dispatch_time_t when, dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有了上述获取时间的函数, 则可以直接把时间传入, 然后定义该延迟执行的block在哪一个queue队列中执行.&lt;br&gt;苹果还给我们提供了一个在主队列中延迟执行的代码块, 如下&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;, &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;delayInSeconds&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            code to be executed after a specified delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要传入需要延迟的秒数(delayInSeconds)和执行的任务block就可以直接调用了, 方便吧~&lt;/p&gt;
&lt;p&gt;注意 : 延迟执行不是在指定时间后执行任务处理, 而是在指定时间后将处理追加到队列中, 这个是要分清楚的.还是在主队列做这些操作吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列组&lt;/strong&gt;  （调度组）&lt;br&gt;Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 dispatch_group_t 的实例来记下这些不同的任务。&lt;/p&gt;
&lt;p&gt;当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。&lt;br&gt;第一种是 &lt;code&gt;dispatch_group_wait&lt;/code&gt;，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的&lt;br&gt;第二章是&lt;code&gt;dispatch_group_notify&lt;/code&gt;,以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 completionBlock 便会运行。你还指定了运行 completionBlock 的队列，此处，主队列就是你所需要的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 dispatch_source_create 如何工作。下面是创建一个源的函数原型：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;dispatch_source_t&lt;/span&gt; dispatch_source_create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;dispatch_source_type_t&lt;/span&gt; type,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt; handle,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; mask,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;dispatch_queue_t&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 Xcode 文档 得到哪些选项可用于每个 dispatch_source_type_t 参数。&lt;/p&gt;
&lt;p&gt;下面你将监控 DISPATCH_SOURCE_TYPE_SIGNAL 。如文档所显示的：&lt;/p&gt;
&lt;p&gt;一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_group_create();&lt;/code&gt;&lt;br&gt;有时候我们想要在队列中的多个任务都处理完毕之后做一些事情, 就能用到这个Group. 同队列一样, Group在使用完毕也是需要dispatch_release掉的(MRC).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栅栏&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dispatch_barrier_async(dispatch_queue_t queue, ^(void)block)&lt;/code&gt;&lt;br&gt;GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。&lt;br&gt;在访问数据库或文件时, 为了提高效率, 读取操作放在并行队列中执行. 但是写入操作必须在串行队列中执行(避免资源抢夺问题). 为了避免麻烦, 此时dispatch_barrier_async函数作用就出来了, 在这函数里进行写入操作, 写入操作会等到所有读取操作完毕后, 形成一道栅栏, 然后进行写入操作, 写入完毕后再把栅栏移除, 同时开放读取操作. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // code here
});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行10次代码, index顺序不确定. dispatch_apply会等待全部处理执行结束才会返回. 意味着dispatch_apply会阻塞当前线程. 所以&lt;strong&gt;dispatch_apply一般用于异步函数的block中.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那何时才适合用 dispatch_apply 呢？&lt;/p&gt;
&lt;p&gt;自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。&lt;br&gt;主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。&lt;br&gt;并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次性代码&lt;/strong&gt;&lt;br&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 只执行1次的代码(这里面默认是线程安全的)
});&lt;/code&gt;&lt;br&gt;该代码在整个程序的生命周期中只会执行一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂起和恢复&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_suspend(queue)&lt;/code&gt;&lt;br&gt;挂起指定的queue队列, 对已经执行的没有影响, 追加到队列中尚未执行的停止执行.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_resume(queue)&lt;/code&gt;&lt;br&gt;恢复指定的queue队列, 使尚未执行的处理继续执行. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的注意点&lt;/strong&gt;&lt;br&gt;因为在ARC下, 不需要我们释放自己创建的队列, 所以GCD的注意点就剩下死锁&lt;br&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;dispatch_sync&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;222&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;333&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三行代码将输出什么?&lt;br&gt;111&lt;br&gt;222&lt;br&gt;333 ?&lt;br&gt;还是&lt;br&gt;111&lt;br&gt;333 ?&lt;br&gt;其实都不对, 输出结果是&lt;br&gt;111&lt;br&gt;无疑问会先输出111, 然后在当前队列下调用dispatch_sync函数, dispatch_sync函数会把block追加到当前队列上, 然后等待block调用完毕该函数才会返回, 不巧的是, block在队列的尾端, 而队列正在执行的是dispatch_sync函数. 现在的情况是, block不执行完毕, dispatch_sync函数就不能返回, dispatch_sync不返回, 就没机会执行block函数. 这种你等我, 我也等你的情况就是死锁, 后果就是大家都执行不了, 当前线程卡死在这里.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免死锁?&lt;/strong&gt;&lt;br&gt;不要在当前队列使用同步函数, 在队列嵌套的情况下也不允许. 如下图,&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AD%BB%E9%94%81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;队列嵌套调用同步函数引发死锁&lt;/p&gt;
&lt;p&gt;大家可以想象, 队列1执行完NSLog后到队列2中执行NSLog, 队列2执行完后又跳回队列1中执行NSLog, 由于都是同步函数, 所以最内层的NSLog(“333”); 追加到队列1中, 实际上最外层的dispatch_sync是还没返回的, 所以它没有执行的机会. 也形成死锁. 运行程序, 果不其然, 打印如下 :&lt;br&gt;111&lt;br&gt;222&lt;/p&gt;
&lt;h3 id=&quot;GCD实现-GCD的使用场景&quot;&gt;&lt;a href=&quot;#GCD实现-GCD的使用场景&quot; class=&quot;headerlink&quot; title=&quot;GCD实现.(GCD的使用场景)&quot;&gt;&lt;/a&gt;GCD实现.(GCD的使用场景)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是GCD最常用的使用场景了, 如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 执行耗时操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;()&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 回到主线程作刷新UI等操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不阻塞主线程, 我们总是在后台线程中发送网络请求, 处理数据, 然后再回到主线程中刷新UI界面.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例&lt;/strong&gt;&lt;br&gt;     &lt;br&gt;单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了&lt;strong&gt;dispatch_once函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列和锁&lt;/strong&gt;&lt;br&gt;利用队列, 实现getter方法可以并发执行, 而setter方法串行执行并且setter和getter不能并发执行呢??? 没错, 我们这里用到了dispatch_barrier_async函数.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; )myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; localMyString = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        localMyString = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; localMyString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setMyString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_barrier_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _myString = myString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里利用了栅栏块必须单独执行, 不能与其他块并行的特性, 写入操作就必须等当前的读取操作都执行完毕, 然后单独执行写入操作, 等待写入操作执行完毕后再继续处理读取. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;它是BSD系内核惯有功能kqueue的包装. kqueue的CPU负荷非常小, 可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种. &lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;介绍一下GCD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有GCD，你怎样实现多线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSthread的缺点是什么？使用NSthread怎么实现数据同步？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何防止死锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD如何实现同步任务，即如何执行完一段代码后再去执行另一段代码；（线程组，barrier，信号量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;iOS中如何实现单例，用GCD来实现一下；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;GCD中如何创建异步线程，GCD中是否能stop一个线程执行； &lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD中有哪些方法？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD和NSOperation的区别；哪一个的复用性更好；NSOperation的队列可以cancel吗，里面的任务可以cancel吗； NSOperation并发有顺序吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多线程有哪几种实现方式，GCD的具体使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD中的数据不安全是怎么处理的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dispatch_main,同步和异步如何使用;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD指向了野指针了怎么办&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GCD有何缺点？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）&lt;br&gt;使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt; = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t &lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt; = dispatch_group_create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片1 */&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片2 */&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;, ^&amp;#123; &lt;span class=&quot;comment&quot;&gt;/*加载图片3 */&lt;/span&gt; &amp;#125;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notify(&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;, dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 合并图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]dispatch_barrier_async的作用是什么？&lt;/li&gt;
&lt;li&gt;[※※※※※]苹果为什么要废弃dispatch_get_current_queue？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;br&gt;Objective-C高级编程书。&lt;br&gt;&lt;a href=&quot;https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;再次学习GCD的内容，并总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入学习KVC和KVO</title>
    <link href="http://peilinghui.com/2016/08/20/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0KVC%E5%92%8CKVO/"/>
    <id>http://peilinghui.com/2016/08/20/深入学习KVC和KVO/</id>
    <published>2016-08-20T05:57:47.000Z</published>
    <updated>2017-03-25T14:50:47.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习KVC和KVO。研究源码NSKeyValueCoding.h和NSKeyValueObserving.h.在Foundation框架中。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;KVC&quot;&gt;&lt;a href=&quot;#KVC&quot; class=&quot;headerlink&quot; title=&quot;KVC&quot;&gt;&lt;/a&gt;KVC&lt;/h1&gt;&lt;h3 id=&quot;什么是-KVC？&quot;&gt;&lt;a href=&quot;#什么是-KVC？&quot; class=&quot;headerlink&quot; title=&quot;什么是 KVC？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是 KVC？&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;KVC 是 Key-Value-Coding 的简称。&lt;/li&gt;
&lt;li&gt;KVC 是一种可以直接通过字符串的名字 key 来访问类属性的机制，而不是通过调用 setter、getter 方法去访问。&lt;/li&gt;
&lt;li&gt;我们可以通过在运行时动态的访问和修改对象的属性。而不是在编译时确定，KVC 是 iOS 开发中的黑魔法之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;键值编码（key-value coding）是一种间接更改对象状态的方式。通过传入的字符串（key）查找要更改的对象的状态。查找的规则是，先查找以字符串（key）命名的getter和setter方法。如果没有找到对应的方法，再查找key和_key的实例变量。KVC 是字典转模型，模型转字典的神器  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;KVC的主要方法&quot;&gt;&lt;a href=&quot;#KVC的主要方法&quot; class=&quot;headerlink&quot; title=&quot;KVC的主要方法&quot;&gt;&lt;/a&gt;KVC的主要方法&lt;/h3&gt;&lt;p&gt;KVC 定义了一种按名称访问对象属性的机制，支持这种访问的主要方法是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置值&lt;br&gt;keyPath包含了key的功能&lt;br&gt;key：只能访问当前对象的属性&lt;br&gt;keyPath：能利用运算符一层一层往内部访问属性&lt;br&gt;对于标量值，会自动进行装箱和拆箱。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// value的值为OC对象，如果是基本数据类型要包装成NSNumber&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;(NSString *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// keyPath键路径，类型为xx.xx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forKeyPath:&lt;/span&gt;(NSString *)keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 它的默认实现是抛出异常，可以重写这个函数做错误处理。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;(id)value &lt;span class=&quot;string&quot;&gt;forUndefinedKey:&lt;/span&gt;(NSString *)key;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;获取值:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)valueForUndefinedKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;KVC-实现细节&quot;&gt;&lt;a href=&quot;#KVC-实现细节&quot; class=&quot;headerlink&quot; title=&quot;KVC 实现细节&quot;&gt;&lt;/a&gt;KVC 实现细节&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置值&lt;code&gt;- (void)setValue:(id)value forKey:(NSString *)key;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;首先搜索 setter 方法，有就直接赋值。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果上面的 setter 方法没有找到，再检查类方法&lt;code&gt;+ (BOOL)accessInstanceVariablesDirectly&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回 NO，则执行setValue：forUNdefinedKey：
返回 YES，则按_&amp;lt;key&amp;gt;，_&amp;lt;isKey&amp;gt;，&amp;lt;key&amp;gt;，&amp;lt;isKey&amp;gt;的顺序搜索成员名。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还没有找到的话，就调用setValue:forUndefinedKey:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当一个对象调用setValue方法时，方法内部会做以下操作：
①检查是否存在相应key的set方法，如果存在，就调用set方法
②如果set方法不存在，就会查找与key相同名称并且带下划线的成员属性，如果有，则直接给成员属性赋值
③如果没有找到_key,就会查找相同名称的属性key，如果有就直接赋值
④如果还没找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。
这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;获取值&lt;code&gt;- (id)valueForKey:(NSString *)key;&lt;/code&gt; &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先查找 getter 方法，找到直接调用。如果是 bool、int、float 等基本数据类型，会做 NSNumber 的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没查到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;返回 NO，则执行valueForUNdefinedKey:
返回 YES，则按_&amp;lt;key&amp;gt;,_is&amp;lt;Key&amp;gt;,&amp;lt;key&amp;gt;,is&amp;lt;Key&amp;gt;的顺序搜索成员名。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;还没有找到的话，调用valueForUndefinedKey:&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;KVC-与点语法比较&quot;&gt;&lt;a href=&quot;#KVC-与点语法比较&quot; class=&quot;headerlink&quot; title=&quot;KVC 与点语法比较&quot;&gt;&lt;/a&gt;&lt;strong&gt;KVC 与点语法比较&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;用 KVC 访问属性和用点语法访问属性的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用点语法编译器会做预编译检查，访问不存在的属性编译器会报错，但是用 KVC 方式编译器无法做检查，如果有错误只能运行的时候才能发现（crash）。&lt;/li&gt;
&lt;li&gt;相比点语法用 KVC 方式 KVC 的效率会稍低一点，但是灵活，可以在程序运行时决定访问哪些属性。&lt;/li&gt;
&lt;li&gt;用 KVC 可以访问对象的私有成员变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h2&gt;&lt;h3 id=&quot;字典转模型&quot;&gt;&lt;a href=&quot;#字典转模型&quot; class=&quot;headerlink&quot; title=&quot;字典转模型&quot;&gt;&lt;/a&gt;字典转模型&lt;/h3&gt;&lt;p&gt;&lt;code&gt;- (void)setValuesForKeysWithDictionary:(NSDictionary *)keyedValues;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;KVC-总结&quot;&gt;&lt;a href=&quot;#KVC-总结&quot; class=&quot;headerlink&quot; title=&quot;KVC 总结&quot;&gt;&lt;/a&gt;KVC 总结&lt;/h3&gt;&lt;p&gt;键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要通过 setter、getter 方法去访问对象的属性，&lt;/li&gt;
&lt;li&gt;可以访问私有成员变量的值，可以间接修改私有变量的值。&lt;/li&gt;
&lt;li&gt;可以轻松处理集合类(NSArray)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一旦使用KVC你的编译器无法检查出错误，即不会对设置的键、键值路径进行错误检查。&lt;/li&gt;
&lt;li&gt;执行效率要低于 setter 和 getter 方法。因为使用 KVC 键值编码，它必须先解析字符串，然后在设置或者访问对象的实例变量。&lt;/li&gt;
&lt;li&gt;使用 KVC 会破坏类的封装性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h1&gt;&lt;p&gt;KVO 是 Key-Value-Observing 的简称。在Foundation框架中的NSKeyValueObserver.h文件中。&lt;/p&gt;
&lt;p&gt;KVO 是一个观察者模式。观察一个对象的属性，注册一个指定的路径，若这个对象的的属性被修改，则 KVO 会自动通知观察者。&lt;/p&gt;
&lt;p&gt;更通俗的话来说就是任何对象都允许观察其他对象的属性，并且可以接收其他对象状态变化的通知。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 注册观察者，实施监听；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.person&lt;/span&gt; addObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              forKeyPath:&lt;span class=&quot;string&quot;&gt;@&quot;age&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 options:&lt;span class=&quot;built_in&quot;&gt;NSKeyValueObservingOptionNew&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 context:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 回调方法，在这里处理属性发生的变化；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)observeValueForKeyPath:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)keyPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      ofObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)object&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        change:(&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *,&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;gt; *)change&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       context:(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *)context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3.&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;// 移除观察者；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; removeObserver:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; forKeyPath:@“age&lt;span class=&quot;string&quot;&gt;&quot;];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;KVO是基于runtime机制实现的&lt;br&gt;Apple 使用了 isa 搅拌技术（isa-swizzling）来实现的 KVO 。当一个观察者注册对象的一个属性 isa 观察对象的指针被修改，指着一个中间类而不是在真正的类。&lt;/p&gt;
&lt;p&gt;当某个类的对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。&lt;br&gt;派生类在被重写的 setter 方法实现真正的通知机制（Person-&amp;gt;NSKVONotifying_Person）&lt;/p&gt;
&lt;p&gt; 当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。自然，重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。&lt;/p&gt;
&lt;p&gt;原来，这个中间类，继承自原本的那个类。不仅如此，Apple 还重写了 -class 方法，企图欺骗我们这个类没有变，就是原本那个类。更具体的信息，去跑一下 Mike Ash 的那篇文章里的代码就能明白，这里就不再重复。&lt;/p&gt;
&lt;h2 id=&quot;KVO底层实现&quot;&gt;&lt;a href=&quot;#KVO底层实现&quot; class=&quot;headerlink&quot; title=&quot;KVO底层实现&quot;&gt;&lt;/a&gt;KVO底层实现&lt;/h2&gt;&lt;p&gt;当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 (isa 指针告诉 Runtime 系统这个对象的类是什么) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例，如下所示：&lt;/p&gt;
&lt;p&gt;KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 怎么做到的呢?&lt;br&gt;答案是通过 isa 混写（isa-swizzling）。&lt;/p&gt;
&lt;p&gt;第一次对一个对象调用 &lt;code&gt;addObserver:forKeyPath:options:context:&lt;/code&gt; 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;setNow:&lt;/span&gt;(NSDate *)aDate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [self &lt;span class=&quot;string&quot;&gt;willChangeValueForKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;aDate &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   [self &lt;span class=&quot;string&quot;&gt;didChangeValueForKey:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;now&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。&lt;/p&gt;
&lt;h1 id=&quot;应用-1&quot;&gt;&lt;a href=&quot;#应用-1&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h3 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h3&gt;&lt;p&gt;在AFN中的AFURLSessionManager中使用了KVO&lt;/p&gt;
&lt;p&gt;UIProgressView (AFNetworking)&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 添加键值观察&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 观察者，负责处理监听事件的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 观察的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 观察的选项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 上下文&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.person &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;forKeyPath:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;options:&lt;/span&gt;NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld &lt;span class=&quot;string&quot;&gt;context:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;Person Name&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;observer中需要实现一下方法：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 所有的 kvo 监听到事件，都会调用此方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 1. 观察的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 2. 观察的对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 3. change 属性变化字典（新／旧）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 4. 上下文，与监听的时候传递的一致&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;observeValueForKeyPath:&lt;/span&gt;(NSString *)keyPath &lt;span class=&quot;string&quot;&gt;ofObject:&lt;/span&gt;(id)object &lt;span class=&quot;string&quot;&gt;change:&lt;/span&gt;(NSDictionary *)change &lt;span class=&quot;string&quot;&gt;context:&lt;/span&gt;(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; *)context;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]如何手动触发一个value的KVO?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自动触发 KVO 的原理：&lt;/p&gt;
&lt;p&gt;键值观察通知依赖于 NSObject 的两个方法: &lt;code&gt;willChangeValueForKey:&lt;/code&gt;和 &lt;code&gt;didChangevlueForKey:&lt;/code&gt;。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， &lt;code&gt;observeValueForKey:ofObject:change:context:&lt;/code&gt;会被调用，继而 didChangeValueForKey: 也会被调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果可以手动实现这些调用，就可以实现“手动触发”了。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？&lt;br&gt;都可以。 &lt;/li&gt;
&lt;li&gt;[※※※※]KVC的keyPath中的集合运算符如何使用？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;必须用在集合对象上或普通对象的集合属性上&lt;/li&gt;
&lt;li&gt;简单集合运算符有@avg， @count ， @max ， @min ，@sum，&lt;/li&gt;
&lt;li&gt;格式 @”@sum.age”或 @”集合属性.@max.age”&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]KVC和KVO的keyPath一定是属性么？&lt;br&gt;[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？&lt;br&gt;[※※※※※]apple用什么方式实现对一个对象的KVO？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/leejayID/KVC-KVO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/leejayID/KVC-KVO&lt;/a&gt;&lt;br&gt;Objective-C中的KVC和KVO&lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/#KVO&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/#KVO&lt;/a&gt;&lt;br&gt;如何自己动手实现 KVO&lt;a href=&quot;http://tech.glowing.com/cn/implement-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习KVC和KVO。研究源码NSKeyValueCoding.h和NSKeyValueObserving.h.在Foundation框架中。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习RunLoop</title>
    <link href="http://peilinghui.com/2016/07/19/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0RunLoop/"/>
    <id>http://peilinghui.com/2016/07/19/深入学习RunLoop/</id>
    <published>2016-07-19T14:45:17.000Z</published>
    <updated>2017-03-23T12:26:41.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。&lt;br&gt;源码：&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://opensource.apple.com/tarballs/CF/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;RunLoop-的概念&quot;&gt;&lt;a href=&quot;#RunLoop-的概念&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 的概念&quot;&gt;&lt;/a&gt;RunLoop 的概念&lt;/h1&gt;&lt;p&gt;其实，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&amp;gt;等待-&amp;gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。  &lt;/p&gt;
&lt;p&gt;OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。&lt;br&gt;&lt;strong&gt;CFRunLoopRef&lt;/strong&gt; 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是&lt;strong&gt;线程安全&lt;/strong&gt;的。&lt;br&gt;&lt;strong&gt;NSRunLoop&lt;/strong&gt; 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API &lt;strong&gt;不是线程安全&lt;/strong&gt;的。它的方法只应在当前线程的上下文中被调用。您不应该尝试调用NSRun​Loop在不同线程中运行的对象的方法，因为这样做可能会导致意外的结果。一个NSRun​Loop对象处理用于来源如从窗口系统鼠标和键盘事件，输入NSPort对象，和NSConnection对象。一个NSRun​Loop对象也处理NSTimer事件。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持程序的持续运行(比如主运行循环)&lt;/li&gt;
&lt;li&gt;处理App中的各种事件（比如触摸事件、定时器事件、Selector事件）&lt;/li&gt;
&lt;li&gt;节省CPU资源，提高程序性能：该做事时做事，该休息时休息&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;RunLoop的工作模式&quot;&gt;&lt;a href=&quot;#RunLoop的工作模式&quot; class=&quot;headerlink&quot; title=&quot;RunLoop的工作模式&quot;&gt;&lt;/a&gt;RunLoop的工作模式&lt;/h1&gt;&lt;p&gt;Run loop接收输入事件来自两种不同的来源：输入源（input source）和定时源（timer source）。两种源都使用程序的某一特定的处理例程来处理到达的事件。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.15.58.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;RunLoop-内部结构&quot;&gt;&lt;a href=&quot;#RunLoop-内部结构&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 内部结构&quot;&gt;&lt;/a&gt;RunLoop 内部结构&lt;/h2&gt;&lt;p&gt;CFRunloop.h文件中&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//CFRunloop.h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFStringRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_EXTENSIBLE_STRING_ENUM&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopSource&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopSourceRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//是事件产生的地方&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserver&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopObserverRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CF_BRIDGED_MUTABLE_TYPE&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt;) __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimer&lt;/span&gt; * &lt;span class=&quot;built_in&quot;&gt;CFRunLoopTimerRef&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//基于时间的触发器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//  CFRunLoop.c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoop&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pthread_t _pthread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _commonModes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeRef&lt;/span&gt; _currentMode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableSetRef&lt;/span&gt; _sources1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _observers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFMutableArrayRef&lt;/span&gt; _timers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RunLoop 与线程的关系&lt;/strong&gt;  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每条线程都有唯一的一个与之对应的RunLoop对象&lt;/li&gt;
&lt;li&gt;主线程的RunLoop已经自动启动的，子线程的RunLoop需要主动创建。&lt;/li&gt;
&lt;li&gt;RunLoop在第一次获取时创建，在线程结束时销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;iOS的应用程序里面，程序启动后会有一个如下的main（）函数&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;  main（&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc，&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * argv []）&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;  &lt;span class=&quot;built_in&quot;&gt;UIApplicationMain&lt;/span&gt;（argc，argv，&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;，&lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;（[AppDelegate class ]））;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重点是UIApplicationMain（）函数，这个方法会为主线程设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候还能立马响应。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在任何一个Cocoa程序的线程中，都可以通过以下代码来获取到当前线程的运行循环。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;NSRunLoop * runloop = [NSRunLoop  currentRunLoop];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关系；&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.37.07.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。&lt;/li&gt;
&lt;li&gt;每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。&lt;/li&gt;
&lt;li&gt;如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。&lt;/li&gt;
&lt;li&gt;这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CFRunLoopMode&quot;&gt;&lt;a href=&quot;#CFRunLoopMode&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopMode&quot;&gt;&lt;/a&gt;CFRunLoopMode&lt;/h3&gt;&lt;p&gt;系统默认注册了5个Mode:(前两个跟最后一个常用)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行&lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用&lt;/li&gt;
&lt;li&gt;GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到&lt;/li&gt;
&lt;li&gt;kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode。&lt;br&gt;在CFRunLoop.h中暴露的是：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDefaultMode&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopMode&lt;/span&gt; k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCommonModes&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;CFRunLoopRef&quot;&gt;&lt;a href=&quot;#CFRunLoopRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopRef&quot;&gt;&lt;/a&gt;CFRunLoopRef&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//获取当前线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetMain&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//获取主线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;CFRunLoopSourceRef&quot;&gt;&lt;a href=&quot;#CFRunLoopSourceRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopSourceRef&quot;&gt;&lt;/a&gt;CFRunLoopSourceRef&lt;/h3&gt;&lt;p&gt;CFRunLoopSourceRef是事件源（输入源）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照官方文档的分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Port-Based Sources，系统底层的 Port 事件，例如 CFSocketRef ，在应用层基本用不到&lt;/li&gt;
&lt;li&gt;Custom Input Sources，用户手动创建的 Source&lt;/li&gt;
&lt;li&gt;Cocoa Perform Selector Sources， Cocoa 提供的 performSelector 系列方法，也是一种事件源  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;按照函数调用栈的分类&lt;/strong&gt;&lt;br&gt;源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Source0：非基于Port的。 app 内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。&lt;/li&gt;
&lt;li&gt;Source1：基于Port的。包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;CFRunLoopTimerRef&quot;&gt;&lt;a href=&quot;#CFRunLoopTimerRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopTimerRef&quot;&gt;&lt;/a&gt;CFRunLoopTimerRef&lt;/h3&gt;&lt;p&gt;CFRunLoopTimerRef是基于时间的触发器,在 iOS 用到的 NSTimer 或者 performSelector:afterDelay: 都是通过它来实现的。使用时先设置一个时间长度和一个回调，然后将其加入 RunLoop，这样 RunLoop 就会注册对应的时间点，当到了该时间点时就会唤醒 RunLoop 来执行那个回调。iOS7 之后，timer 还可有一个 tolerance，因为 timer 不太准确，如上面提到的，某个 mode 下的 timer 在 RunLoop 切换 mode 时可能就失效了，而 tolerance 则用来计算最后能执行那个回调的时间点。&lt;/p&gt;
&lt;p&gt;基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响&lt;/p&gt;
&lt;p&gt;GCD的定时器不受RunLoop的Mode影响&lt;/p&gt;
&lt;h3 id=&quot;CFRunLoopObserverRef&quot;&gt;&lt;a href=&quot;#CFRunLoopObserverRef&quot; class=&quot;headerlink&quot; title=&quot;CFRunLoopObserverRef&quot;&gt;&lt;/a&gt;CFRunLoopObserverRef&lt;/h3&gt;&lt;p&gt;CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变&lt;/p&gt;
&lt;p&gt;可以监听的时间点有以下几个：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Run Loop Observer Activities */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CF_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CFOptionFlags, CFRunLoopActivity)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopEntry = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;),		&lt;span class=&quot;comment&quot;&gt;//即将进入Loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeTimers = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将处理Timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeSources = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将处理Source&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopBeforeWaiting = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//即将进入休眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopAfterWaiting = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;), &lt;span class=&quot;comment&quot;&gt;//刚从休眠中唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopExit = (&lt;span class=&quot;number&quot;&gt;1U&lt;/span&gt;L &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;),       &lt;span class=&quot;comment&quot;&gt;//即将推出Loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kCFRunLoopAllActivities = &lt;span class=&quot;number&quot;&gt;0x0FFFFFFF&lt;/span&gt;U&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以使用 CFRunLoopObserverCreateWithHandler() 来创建 observer，创建时设置要监听的状态变化和回调，再用 CFRunLoopAddObserver() 来给 RunLoop 添加 observer，当该 RunLoop 状态发生在监听类型内的变化时，observer 就会执行回调 ：&lt;/p&gt;
&lt;!--## 定时源
![](http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%883.35.47.png)

RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。


--&gt;
&lt;h1 id=&quot;运行逻辑&quot;&gt;&lt;a href=&quot;#运行逻辑&quot; class=&quot;headerlink&quot; title=&quot;运行逻辑&quot;&gt;&lt;/a&gt;运行逻辑&lt;/h1&gt;&lt;h2 id=&quot;获取RunLoop&quot;&gt;&lt;a href=&quot;#获取RunLoop&quot; class=&quot;headerlink&quot; title=&quot;获取RunLoop&quot;&gt;&lt;/a&gt;获取RunLoop&lt;/h2&gt;&lt;p&gt;苹果不允许我们创建 RunLoop，要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数，获取过程大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; __&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CF_EXPORT&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_t t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第一次进入时，创建全局 dictionary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建可变字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFMutableDictionaryRef&lt;/span&gt; dict = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryCreateMutable&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 先创建主线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; mainLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCreate&lt;/span&gt;(pthread_main_thread_np());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 主线程的 RunLoop 存进字典中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(dict, pthread_main_thread_np(), mainLoop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 用 传进来的线程 作 key，获取对应的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; loop = &lt;span class=&quot;built_in&quot;&gt;CFDictionaryGetValue&lt;/span&gt;(__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;, t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果获取不到，则新建一个，并存入字典&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!loop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; newLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopCreate&lt;/span&gt;(t);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;CFDictionarySetValue&lt;/span&gt;(__&lt;span class=&quot;built_in&quot;&gt;CFRunLoops&lt;/span&gt;, pthreadPointer(t), newLoop);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; loop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取主线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetMain&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!__main) __main = _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_main_thread_np());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; __main;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 获取当前线程的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _&lt;span class=&quot;built_in&quot;&gt;CFRunLoopGet0&lt;/span&gt;(pthread_self());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见，线程和 RunLoop 是一一对应的，对应关系保存在一个全局的 dictionary 中。RunLoop 类似懒加载，只有在第一次获取的时候才会创建。当线程销毁时，也销毁对应的 RunLoop。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop的运行&quot;&gt;&lt;a href=&quot;#RunLoop的运行&quot; class=&quot;headerlink&quot; title=&quot;RunLoop的运行&quot;&gt;&lt;/a&gt;RunLoop的运行&lt;/h2&gt;&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 用 &lt;span class=&quot;type&quot;&gt;DefaultMode&lt;/span&gt; 启动(&lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;循环)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRun&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt;) &amp;#123;	/* &lt;span class=&quot;type&quot;&gt;DOES&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CALLOUT&lt;/span&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int32_t &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(), kCFRunLoopDefaultMode, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;e10, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;CHECK_FOR_FORK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (kCFRunLoopRunStopped != &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; &amp;amp;&amp;amp; kCFRunLoopRunFinished != &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 用指定的 mode 启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;SInt32&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunInMode&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFStringRef&lt;/span&gt; modeName, &lt;span class=&quot;type&quot;&gt;CFTimeInterval&lt;/span&gt; seconds, &lt;span class=&quot;type&quot;&gt;Boolean&lt;/span&gt; returnAfterSourceHandled) &amp;#123;     /* &lt;span class=&quot;type&quot;&gt;DOES&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CALLOUT&lt;/span&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CHECK_FOR_FORK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopGetCurrent&lt;/span&gt;(), modeName, seconds, returnAfterSourceHandled);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &lt;span class=&quot;type&quot;&gt;RunLoop&lt;/span&gt; 的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;SInt32&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;CFRunLoopRunSpecific&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;CFRunLoopRef&lt;/span&gt; rl, &lt;span class=&quot;type&quot;&gt;CFStringRef&lt;/span&gt; modeName, &lt;span class=&quot;type&quot;&gt;CFTimeInterval&lt;/span&gt; seconds, &lt;span class=&quot;type&quot;&gt;Boolean&lt;/span&gt; returnAfterSourceHandled) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 根据 modeName 找到对应的 mode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;CFRunLoopModeRef&lt;/span&gt; currentMode = __CFRunLoopFindMode(rl, modeName, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 判断 mode 是否为空 (即 source/timer 皆空)，是的话则返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;NULL&lt;/span&gt; == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&amp;gt;_currentMode)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 通知 observers: 即将进入 loop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 进入 loop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 通知 observers： 即将退出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 进入 RunLoop 后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; int32_t __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRun&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置 timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_source_t timeout_timer = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置过期时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    seconds = &lt;span class=&quot;number&quot;&gt;9999999999.0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int32_t retVal = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 开始 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 告诉 observer：要处理 timer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeTimers&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	   &lt;span class=&quot;comment&quot;&gt;// 告诉 observer：要处理 sources&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeSources&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行被加入的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 处理 Sources0（非 port）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Boolean sourceHandledThisLoop = __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoSources0&lt;/span&gt;(rl, rlm, stopAfterHandle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceHandledThisLoop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!didDispatchPortLastTime) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 如果有 GCD 分发到 main queue 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopServiceMachPort&lt;/span&gt;(dispatchPort, &amp;amp;msg)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// 跳过睡眠阶段，直接去处理消息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;goto&lt;/span&gt; handle_msg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知 observers：即将进入睡眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; () __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopBeforeWaiting&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 调用 mach_msg 等待接受 mach_port 的消息，线程将进入睡眠&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopServiceMachPort&lt;/span&gt;(waitSet, &amp;amp;msg, ...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通知 observers：刚被唤醒&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoObservers&lt;/span&gt;(rl, rlm, k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopAfterWaiting&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 处理消息的标记&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    handle_msg:;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过判断端口，找出要处理的事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (MACH_PORT_NULL == livePort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 纯粹是被手动唤醒的，无消息，则不做任何处理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (livePort == rlm-&amp;gt;_timerPort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;comment&quot;&gt;// 被 timer 唤醒,则触发这个 timer 的回调&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoTimers&lt;/span&gt;(rl, rlm, mach_absolute_time())；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (livePort == dispatchPort) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  &lt;span class=&quot;comment&quot;&gt;// 被 GCD 唤醒,则执行所有调用 dispatch_async 等方法放入main queue 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            __&lt;span class=&quot;built_in&quot;&gt;CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__&lt;/span&gt;(msg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;comment&quot;&gt;// 如果被 source1（基于 port） 唤醒的，则处理这个事件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoSource1&lt;/span&gt;(rl, rlm, &amp;amp;reply) || sourceHandledThisLoop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; != reply) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               mach_msg(reply, MACH_SEND_MSG);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 执行加入到 loop 的 block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __&lt;span class=&quot;built_in&quot;&gt;CFRunLoopDoBlocks&lt;/span&gt;(rl, rlm);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 判断是否应该退出 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sourceHandledThisLoop &amp;amp;&amp;amp; stopAfterHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 传入的参数是否说明应该在处理完事件就返回&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunHandledSource&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (timeout_context-&amp;gt;termTSR &amp;lt; mach_absolute_time()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 是否过期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunTimedOut&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopIsStopped&lt;/span&gt;(rl)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 是否被强制停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rlm-&amp;gt;_stopped) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunStopped&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (__&lt;span class=&quot;built_in&quot;&gt;CFRunLoopModeIsEmpty&lt;/span&gt;(rl, rlm)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// mode 是否为空，即 source、timer 为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            retVal = k&lt;span class=&quot;built_in&quot;&gt;CFRunLoopRunFinished&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 都不是，则继续 loop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; == retVal);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; retVal;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而判断 mode 的逻辑大致如下：&lt;/p&gt;
&lt;figure class=&quot;highlight lasso&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__CFRunLoopModeIsEmpty() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources0 &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFSetGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources0)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources1 &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFSetGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_sources1)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;NULL&lt;/span&gt; != rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_timers &lt;span class=&quot;subst&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt; CFArrayGetCount(rlm&lt;span class=&quot;subst&quot;&gt;-&amp;gt;&lt;/span&gt;_timers)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h1&gt;&lt;h2 id=&quot;AutoreleasePool（自动释放池）&quot;&gt;&lt;a href=&quot;#AutoreleasePool（自动释放池）&quot; class=&quot;headerlink&quot; title=&quot;AutoreleasePool（自动释放池）&quot;&gt;&lt;/a&gt;AutoreleasePool（自动释放池）&lt;/h2&gt;&lt;p&gt;一般我们比较关心的是自动释放池什么时候会释放？&lt;br&gt;在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;CFRunLoopObserver&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;activities = 0x1, callout = _wrapRunLoopWithAutoreleasePoolHandler&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;CFRunLoopObserver&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;即 app 启动后，苹果会给 RunLoop 注册很多个 observers，其中有两个是跟自动释放池相关的，其回调都是 &lt;code&gt;_wrapRunLoopWithAutoreleasePoolHandler()&lt;/code&gt;&lt;br&gt;第一个 observer 监听的是 activities = 0x1（kCFRunLoopEntry），也就是在即将进入 loop 时，其回调会调用 &lt;code&gt;_objc_autoreleasePoolPush()&lt;/code&gt; 创建自动释放池；&lt;br&gt;第二个 observer 监听的是 &lt;code&gt;activities = 0xa0（kCFRunLoopBeforeWaiting | kCFRunLoopExit）&lt;/code&gt;，即监听的是准备进入睡眠和即将退出 loop 两个事件。在准备进入睡眠之前，因为睡眠可能时间很长，所以为了不占用资源先调用 &lt;code&gt;_objc_autoreleasePoolPop()&lt;/code&gt;释放旧的释放池，并调用 &lt;code&gt;_objc_autoreleasePoolPush()&lt;/code&gt; 创建新建一个新的，用来装载被唤醒后要处理的事件对象；在最后即将退出 loop 时则会 &lt;code&gt;_objc_autoreleasePoolPop()&lt;/code&gt; 释放池子。&lt;/p&gt;
&lt;h2 id=&quot;事件响应&quot;&gt;&lt;a href=&quot;#事件响应&quot; class=&quot;headerlink&quot; title=&quot;事件响应&quot;&gt;&lt;/a&gt;事件响应&lt;/h2&gt;&lt;p&gt;苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件。&lt;br&gt;_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括&lt;strong&gt;识别 UIGesture/处理屏幕旋转/发送给 UIWindow&lt;/strong&gt; 等。通常事件比如 &lt;strong&gt;UIButton 点击&lt;/strong&gt;、&lt;strong&gt;touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;手势识别&quot;&gt;&lt;a href=&quot;#手势识别&quot; class=&quot;headerlink&quot; title=&quot;手势识别&quot;&gt;&lt;/a&gt;手势识别&lt;/h2&gt;&lt;p&gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。&lt;/p&gt;
&lt;p&gt;当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。&lt;/p&gt;
&lt;h2 id=&quot;界面更新&quot;&gt;&lt;a href=&quot;#界面更新&quot; class=&quot;headerlink&quot; title=&quot;界面更新&quot;&gt;&lt;/a&gt;界面更新&lt;/h2&gt;&lt;p&gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;h2 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h2&gt;&lt;p&gt;NSTimer 其实就是 CFRunLoopTimerRef。&lt;br&gt;解决界面卡顿&lt;/p&gt;
&lt;h2 id=&quot;PerformSelecter&quot;&gt;&lt;a href=&quot;#PerformSelecter&quot; class=&quot;headerlink&quot; title=&quot;PerformSelecter&quot;&gt;&lt;/a&gt;PerformSelecter&lt;/h2&gt;&lt;p&gt;当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。&lt;/p&gt;
&lt;p&gt;当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop-与-GCD&quot;&gt;&lt;a href=&quot;#RunLoop-与-GCD&quot; class=&quot;headerlink&quot; title=&quot;RunLoop 与 GCD&quot;&gt;&lt;/a&gt;RunLoop 与 GCD&lt;/h2&gt;&lt;p&gt;RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。 例如 dispatch_async()。&lt;br&gt;当调用 &lt;code&gt;dispatch_async(dispatch_get_main_queue(), block)&lt;/code&gt;时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 &lt;code&gt;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()&lt;/code&gt; 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。&lt;/p&gt;
&lt;h2 id=&quot;UIImageView-延迟加载图片&quot;&gt;&lt;a href=&quot;#UIImageView-延迟加载图片&quot; class=&quot;headerlink&quot; title=&quot;UIImageView 延迟加载图片&quot;&gt;&lt;/a&gt;UIImageView 延迟加载图片&lt;/h2&gt;&lt;p&gt;给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。&lt;/p&gt;
&lt;h2 id=&quot;AFNetworking&quot;&gt;&lt;a href=&quot;#AFNetworking&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking&quot;&gt;&lt;/a&gt;AFNetworking&lt;/h2&gt;&lt;p&gt;子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。具体做法是：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 返回一个线程 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *)networkRequestThread &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; *_networkRequestThread = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; oncePredicate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;oncePredicate, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 创建一个线程，并在该线程上执行下一个方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _networkRequestThread = [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; alloc] initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                        selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(networkRequestThreadEntryPoint:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                          object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 开启线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_networkRequestThread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; _networkRequestThread;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 在新开的线程中执行的第一个方法 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)networkRequestThreadEntryPoint:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)__unused object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[&lt;span class=&quot;built_in&quot;&gt;NSThread&lt;/span&gt; currentThread] setName:&lt;span class=&quot;string&quot;&gt;@&quot;AFNetworking&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 获取当前线程对应的 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; *runLoop = [&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 为 RunLoop 添加 source，模式为 DefaultMode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop addPort:[&lt;span class=&quot;built_in&quot;&gt;NSMachPort&lt;/span&gt; port] forMode:&lt;span class=&quot;built_in&quot;&gt;NSDefaultRunLoopMode&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 开始运行 RunLoop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [runLoop run];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。&lt;/p&gt;
&lt;h2 id=&quot;AsyncDisplayKit&quot;&gt;&lt;a href=&quot;#AsyncDisplayKit&quot; class=&quot;headerlink&quot; title=&quot;AsyncDisplayKit&quot;&gt;&lt;/a&gt;AsyncDisplayKit&lt;/h2&gt;&lt;p&gt;AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，&lt;/p&gt;
&lt;h1 id=&quot;与-Runloop-相关的坑&quot;&gt;&lt;a href=&quot;#与-Runloop-相关的坑&quot; class=&quot;headerlink&quot; title=&quot;与 Runloop 相关的坑&quot;&gt;&lt;/a&gt;与 Runloop 相关的坑&lt;/h1&gt;&lt;p&gt;日常开发中，与 runLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行。&lt;/p&gt;
&lt;p&gt;有如下两种解决方案：&lt;/p&gt;
&lt;p&gt;第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。&lt;br&gt;第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。&lt;br&gt;在 AFNetworking 3.0 中，就有相关的代码，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)startActivationDelayTimer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelayTimer&lt;/span&gt; = [&lt;span class=&quot;built_in&quot;&gt;NSTimer&lt;/span&gt; timerWithTimeInterval:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelay&lt;/span&gt; target:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(activationDelayTimerFired) userInfo:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; repeats:&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;built_in&quot;&gt;NSRunLoop&lt;/span&gt; mainRunLoop] addTimer:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.activationDelayTimer&lt;/span&gt; forMode:&lt;span class=&quot;built_in&quot;&gt;NSRunLoopCommonModes&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里就是添加了一个计时器，由于指定了 NSRunLoopCommonModes，所以不管 RunLoop 出于什么状态，都执行这个计时器任务。&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;[※※※]runloop和线程有什么关系？&lt;/li&gt;
&lt;li&gt;[※※※]runloop的mode作用是什么？&lt;br&gt;model主要是用来指定事件在运行循环中的优先级的，分为：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态  &lt;/li&gt;
&lt;li&gt;UITrackingRunLoopMode：ScrollView滑动时&lt;/li&gt;
&lt;li&gt;UIInitializationRunLoopMode：启动时&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）：模式集合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;苹果公开提供的模式有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode（kCFRunLoopDefaultMode）&lt;/li&gt;
&lt;li&gt;NSRunLoopCommonModes（kCFRunLoopCommonModes）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]猜想runloop内部是如何实现的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何刷新View界面？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程和RunLoop的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer有什么需注意的以及和RunLoop的关系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;主线程runloop(mainRunloop)主要执行事件：&lt;br&gt;负责创建Autoreleasepool和释放autoreleasepool,  周期大概是event loop(事件循环)；&lt;br&gt;事件响应—&amp;gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;手势识别—&amp;gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。&lt;/p&gt;
&lt;p&gt;界面更新—&amp;gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NSTimer事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PerformSelecter—&amp;gt;performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;br&gt;iOS RunLoop进阶:&lt;a href=&quot;http://www.jianshu.com/p/2c067bdc7e47#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/2c067bdc7e47#&lt;/a&gt;&lt;br&gt;解密-神秘的RunLoop：&lt;a href=&quot;http://www.jianshu.com/p/cf4915508929&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/cf4915508929&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/&lt;/a&gt;&lt;br&gt;RunLoop源码观察:&lt;a href=&quot;http://tutudev.com/2016/06/28/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tutudev.com/2016/06/28/runloop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入理解RunLoop&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/05/18/runloop/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。&lt;br&gt;源码：&lt;a href=&quot;https://opensource.apple.com/tarballs/CF/&quot;&gt;https://opensource.apple.com/tarballs/CF/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot;&gt;API&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>消息处理之performSelector</title>
    <link href="http://peilinghui.com/2016/07/10/%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E4%B9%8BperformSelector/"/>
    <id>http://peilinghui.com/2016/07/10/消息处理之performSelector/</id>
    <published>2016-07-10T08:22:32.000Z</published>
    <updated>2017-04-15T15:05:32.000Z</updated>
    
    <content type="html">&lt;p&gt;前面一篇文章介绍了runtime的知识，就是调用[Person run]的直接方法调用和performSelector有什么区别呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;performSelector和直接调用方法的区别&quot;&gt;&lt;a href=&quot;#performSelector和直接调用方法的区别&quot; class=&quot;headerlink&quot; title=&quot;performSelector和直接调用方法的区别&quot;&gt;&lt;/a&gt;performSelector和直接调用方法的区别&lt;/h1&gt;&lt;p&gt;performSelector和直接调用方法的区别就在于runtime。&lt;br&gt;&lt;strong&gt;直接调用&lt;/strong&gt;是&lt;strong&gt;编译时&lt;/strong&gt;会自动校验。如果方法不存在，那么直接调用在编译时候就能够发现，编译器会直接报错。&lt;br&gt;&lt;strong&gt;使用performSelector&lt;/strong&gt;的话一定是在&lt;strong&gt;运行时&lt;/strong&gt;才能发现，如果此方法不存在就会崩溃。所以如果使用performSelector的话他就会有个最佳伴侣&lt;code&gt;- (BOOL)respondsToSelector:(SEL)aSelector;&lt;/code&gt;来在运行时判断对象是否响应此方法。&lt;/p&gt;
&lt;h1 id=&quot;performSelector的使用&quot;&gt;&lt;a href=&quot;#performSelector的使用&quot; class=&quot;headerlink&quot; title=&quot;performSelector的使用&quot;&gt;&lt;/a&gt;performSelector的使用&lt;/h1&gt;&lt;h2 id=&quot;线程无关的方法&quot;&gt;&lt;a href=&quot;#线程无关的方法&quot; class=&quot;headerlink&quot; title=&quot;线程无关的方法&quot;&gt;&lt;/a&gt;线程无关的方法&lt;/h2&gt;&lt;p&gt;可以看到在NSObject.h文件中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无参数传递&lt;/li&gt;
&lt;li&gt;传递一个参数&lt;/li&gt;
&lt;li&gt;传递两个参数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight gcode&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;performSelector:&lt;span class=&quot;comment&quot;&gt;(SEL)&lt;/span&gt;aSelector;&lt;span class=&quot;comment&quot;&gt;//无参数传递&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;performSelector:&lt;span class=&quot;comment&quot;&gt;(SEL)&lt;/span&gt;aSelector withObject:&lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;object;&lt;span class=&quot;comment&quot;&gt;//传递一个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;performSelector:&lt;span class=&quot;comment&quot;&gt;(SEL)&lt;/span&gt;aSelector withObject:&lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;object&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; withObject:&lt;span class=&quot;comment&quot;&gt;(id)&lt;/span&gt;object&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//传递两个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Delayed-perform&quot;&gt;&lt;a href=&quot;#Delayed-perform&quot; class=&quot;headerlink&quot; title=&quot;Delayed perform&quot;&gt;&lt;/a&gt;Delayed perform&lt;/h2&gt;&lt;p&gt;在NSRunLoop.h中：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@interface&lt;/span&gt; NSObject (NSDelayedPerforming)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;performSelector:&lt;/span&gt;(SEL)aSelector &lt;span class=&quot;string&quot;&gt;withObject:&lt;/span&gt;(nullable id)anArgument &lt;span class=&quot;string&quot;&gt;afterDelay:&lt;/span&gt;(NSTimeInterval)delay &lt;span class=&quot;string&quot;&gt;inModes:&lt;/span&gt;(NSArray&amp;lt;NSRunLoopMode&amp;gt; *)modes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;performSelector:&lt;/span&gt;(SEL)aSelector &lt;span class=&quot;string&quot;&gt;withObject:&lt;/span&gt;(nullable id)anArgument &lt;span class=&quot;string&quot;&gt;afterDelay:&lt;/span&gt;(NSTimeInterval)delay;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;cancelPreviousPerformRequestsWithTarget:&lt;/span&gt;(id)aTarget &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;(SEL)aSelector &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;(nullable id)anArgument;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;cancelPreviousPerformRequestsWithTarget:&lt;/span&gt;(id)aTarget;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1、前两个方法为异步执行&lt;br&gt;2、前两个方法只能在主线程中执行，其它线程不执行&lt;br&gt;3、即使delay传参为0，也不会立即执行，而是在next runloop执行&lt;br&gt;4、可用于当点击UI中一个按钮会触发一个消耗系统性能的事件，在事件执行期间按钮会一直处于高亮状态，此时可以调用该方法去异步的处理该事件，就能避免上面的问题。&lt;/p&gt;
&lt;p&gt;在方法未到执行时间之前，取消方法为后两个方法&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@interface&lt;/span&gt; NSRunLoop (NSOrderedPerform)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;performSelector:&lt;/span&gt;(SEL)aSelector &lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;(id)target &lt;span class=&quot;string&quot;&gt;argument:&lt;/span&gt;(nullable id)arg &lt;span class=&quot;string&quot;&gt;order:&lt;/span&gt;(NSUInteger)order &lt;span class=&quot;string&quot;&gt;modes:&lt;/span&gt;(NSArray&amp;lt;NSRunLoopMode&amp;gt; *)modes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;cancelPerformSelector:&lt;/span&gt;(SEL)aSelector &lt;span class=&quot;string&quot;&gt;target:&lt;/span&gt;(id)target &lt;span class=&quot;string&quot;&gt;argument:&lt;/span&gt;(nullable id)arg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;cancelPerformSelectorsWithTarget:&lt;/span&gt;(id)target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;on-mainthread&quot;&gt;&lt;a href=&quot;#on-mainthread&quot; class=&quot;headerlink&quot; title=&quot;on mainthread&quot;&gt;&lt;/a&gt;on mainthread&lt;/h2&gt;&lt;p&gt;在NSThread.h中&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;pp&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;performSelectorOnMainThread:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;SEL&lt;/span&gt;)&lt;/span&gt;aSelector withObject:&lt;span class=&quot;params&quot;&gt;(nullable id)&lt;/span&gt;arg waitUntilDone:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;BOOL&lt;/span&gt;)&lt;/span&gt;wait modes:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;NSArray&lt;/span&gt; *)&lt;/span&gt;array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;params&quot;&gt;(void)&lt;/span&gt;performSelectorOnMainThread:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;SEL&lt;/span&gt;)&lt;/span&gt;aSelector withObject:&lt;span class=&quot;params&quot;&gt;(nullable id)&lt;/span&gt;arg waitUntilDone:&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;variable&quot;&gt;BOOL&lt;/span&gt;)&lt;/span&gt;wait;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;这两个方法，在主线程和子线程中均可执行，均会在主线程中调aSelector方法&lt;/li&gt;
&lt;li&gt;如果设置wait为NO:等待当前线程执行完以后，主线程才会执行aSelector方法；&lt;/li&gt;
&lt;li&gt;设置为YES：不等待当前线程执行完，就在主线程上执行aSelector方法。&lt;/li&gt;
&lt;li&gt;第二个方法使用默认的模式（NSDefaultRunLoopMode）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;传递三个及以上的参数&quot;&gt;&lt;a href=&quot;#传递三个及以上的参数&quot; class=&quot;headerlink&quot; title=&quot;传递三个及以上的参数&quot;&gt;&lt;/a&gt;传递三个及以上的参数&lt;/h2&gt;&lt;p&gt;perform方法要求传入参数必须是对象，如果方法本身的参数是int，直接传NSNumber会导致得到的int参数不正确。&lt;/p&gt;
&lt;h3 id=&quot;第一种：NSInvocation&quot;&gt;&lt;a href=&quot;#第一种：NSInvocation&quot; class=&quot;headerlink&quot; title=&quot;第一种：NSInvocation&quot;&gt;&lt;/a&gt;第一种：NSInvocation&lt;/h3&gt;&lt;p&gt;使用了runtime的反射机制，效率较低，可读性不高&lt;/p&gt;
&lt;p&gt;列举ASIHTTPRequest.m的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SEL callback = &lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;performInvocation:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;onTarget:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;releasingObject:&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMethodSignature *cbSignature = [ASIHTTPRequest &lt;span class=&quot;string&quot;&gt;methodSignatureForSelector:&lt;/span&gt;callback];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// NSInvocation : 利用一个NSInvocation对象包装一次方法调用（方法调用者、方法名、方法参数、方法返回值）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSInvocation *cbInvocation = [NSInvocation &lt;span class=&quot;string&quot;&gt;invocationWithMethodSignature:&lt;/span&gt;cbSignature];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cbInvocation &lt;span class=&quot;string&quot;&gt;setSelector:&lt;/span&gt;callback];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cbInvocation &lt;span class=&quot;string&quot;&gt;setTarget:&lt;/span&gt;self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//前两个参数为self与selector，其它参数要从2开始&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cbInvocation &lt;span class=&quot;string&quot;&gt;setArgument:&lt;/span&gt;&amp;amp;invocation &lt;span class=&quot;string&quot;&gt;atIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cbInvocation &lt;span class=&quot;string&quot;&gt;setArgument:&lt;/span&gt;&amp;amp;target &lt;span class=&quot;string&quot;&gt;atIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cbInvocation &lt;span class=&quot;string&quot;&gt;performSelectorOnMainThread:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(invoke) &lt;span class=&quot;string&quot;&gt;withObject:&lt;/span&gt;nil &lt;span class=&quot;string&quot;&gt;waitUntilDone:&lt;/span&gt;[NSThread isMainThread]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;第二种：把多个参数封装成一个参数&quot;&gt;&lt;a href=&quot;#第二种：把多个参数封装成一个参数&quot; class=&quot;headerlink&quot; title=&quot;第二种：把多个参数封装成一个参数&quot;&gt;&lt;/a&gt;第二种：把多个参数封装成一个参数&lt;/h3&gt;&lt;p&gt;我们还可以将参数进行封装成一个结构体,Class,或者是字典和其他集合。可以把结构体转换为对象.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;) anotherMethod &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; target = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     SEL selector = &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(methodWithFirst:second:third:); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 首先第一个参数和第二个参数是self和selector&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 剩下的参数可以是对象或者基本数据类型，根据方法需要填写参数类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*MethodType)(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, SEL, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 这个方法实际上返回的是IMP类型，为了方便调用，强转为MethodType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     MethodType methodToCall = (MethodType)[target methodForSelector:selector]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     methodToCall(target, selector, @(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), @(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), @(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)methodWithFirst:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) object second:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) secondObject third:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;) thirdObject &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;// Code here &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;其他例子&quot;&gt;&lt;a href=&quot;#其他例子&quot; class=&quot;headerlink&quot; title=&quot;其他例子&quot;&gt;&lt;/a&gt;其他例子&lt;/h1&gt;&lt;h3 id=&quot;例子1&quot;&gt;&lt;a href=&quot;#例子1&quot; class=&quot;headerlink&quot; title=&quot;例子1&quot;&gt;&lt;/a&gt;例子1&lt;/h3&gt;&lt;p&gt;例如在封装一个控件的时候，一个自定义的label的响应事件：&lt;br&gt;&lt;code&gt;[obj.lblVal performSelector:NSSelectorFromString(@&amp;quot;removeGesture&amp;quot;) withObject:nil];&lt;/code&gt;&lt;br&gt;对于自定义的封装控件lblVal来说，在它的实现中就有removeGesture的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)removeGesture &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.gesture&lt;/span&gt;) &amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; removeGestureRecognizer: &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.gesture&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.gesture&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;例子2&quot;&gt;&lt;a href=&quot;#例子2&quot; class=&quot;headerlink&quot; title=&quot;例子2&quot;&gt;&lt;/a&gt;例子2&lt;/h3&gt;&lt;p&gt;在AppDelegate.m中&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)initAllFunctionSwitchDictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *path = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle] pathForResource:&lt;span class=&quot;string&quot;&gt;@&quot;TDFFunctionSwitch&quot;&lt;/span&gt; ofType:&lt;span class=&quot;string&quot;&gt;@&quot;plist&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *dic = [&lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; dictionaryWithContentsOfFile:path];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [Platform Instance]&lt;span class=&quot;variable&quot;&gt;.allFunctionSwitchDictionary&lt;/span&gt; = dic;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从而加载TDFFunctionSwitch.plist文件，在这个文件中mediatorMethod对应着TDFMediator_TDFXXXViewController。&lt;br&gt;mediatorClass对应着TDFMediator+XXXModule。&lt;br&gt;在每一个模块中:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)pushViewControllerWithCode:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)actionCode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *switchU = [Platform Instance]&lt;span class=&quot;variable&quot;&gt;.allFunctionSwitchDictionary&lt;/span&gt;[actionCode];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (switchU[&lt;span class=&quot;string&quot;&gt;@&quot;mediatorMethod&quot;&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL action = &lt;span class=&quot;built_in&quot;&gt;NSSelectorFromString&lt;/span&gt;(switchU[&lt;span class=&quot;string&quot;&gt;@&quot;mediatorMethod&quot;&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ([[TDFMediator sharedInstance] respondsToSelector:action]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;built_in&quot;&gt;UIViewController&lt;/span&gt; *viewController = [[TDFMediator sharedInstance] performSelector:action withObject:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       	[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; pushViewController:viewController animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;先获得SEL，获得每个对应的code中的mediatorMethod，利用performSelector，来跳转页面。从而实现的中间者模式。&lt;/p&gt;
&lt;h3 id=&quot;例子3&quot;&gt;&lt;a href=&quot;#例子3&quot; class=&quot;headerlink&quot; title=&quot;例子3&quot;&gt;&lt;/a&gt;例子3&lt;/h3&gt;&lt;p&gt;线程间的通信：&lt;/p&gt;
&lt;p&gt;在主线程更新view的高度：&lt;br&gt;&lt;code&gt;[self performSelectorOnMainThread:@selector(updateInfoViewHeight) withObject:nil waitUntilDone:YES];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在主线程更新tableView的数据源：&lt;br&gt;&lt;code&gt;[self.tabView performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:YES];&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在指定线程中做事情：&lt;br&gt;performSelector:onThread:withObject:waitUntilDone:&lt;br&gt;performSelector:onThread:withObject:waitUntilDone:modes:&lt;br&gt;在ASIHTTPRequest.m中：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr_selector&quot;&gt;[self setInProgress:YES]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr_selector&quot;&gt;[self performSelector:@selector(main) onThread:[[self class]&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;threadForRequest&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:self&lt;/span&gt;] &lt;span class=&quot;tag&quot;&gt;withObject&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:nil&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;waitUntilDone&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:NO&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;waitUntilDone参数是个bool值，如果设置为NO,相当于异步执行，当前函数执行完，立即执行后面的语句。如果设置为YES,相当于同步执行，当前线程要等待Selector中的函数执行完后再执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在当前线程中做事情：&lt;br&gt;performSelector:withObject:afterDelay:&lt;br&gt;performSelector:withObject:afterDelay:inModes: &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;取消发送给当前线程的某个消息&lt;br&gt;cancelPreviousPerformRequestsWithTarget:&lt;br&gt;cancelPreviousPerformRequestsWithTarget:selector:object: &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;防止按钮多次点击&quot;&gt;&lt;a href=&quot;#防止按钮多次点击&quot; class=&quot;headerlink&quot; title=&quot;防止按钮多次点击&quot;&gt;&lt;/a&gt;防止按钮多次点击&lt;/h3&gt;&lt;p&gt;这种方式是在0.2秒内取消之前的点击事件，以做到防止多次点击。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)completeClicked:(&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class] cancelPreviousPerformRequestsWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; selector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(buttonClick:) object:sender];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; performSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(buttonClick:) withObject:sender afterDelay:&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;f];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这种方式是在点击后设为不可被点击的状态，&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒后恢复&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)buttonClicked:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.button&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.enabled&lt;/span&gt; =&lt;span class=&quot;literal&quot;&gt;NO&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [selfperformSelector:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(changeButtonStatus)withObject:nilafterDelay:&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;f];&lt;span class=&quot;comment&quot;&gt;//防止重复点击&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)changeButtonStatus&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.button&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.enabled&lt;/span&gt; =&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Demo：&lt;a href=&quot;https://github.com/peilinghui/BokeDemo/tree/master/PLHPerformDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/BokeDemo/tree/master/PLHPerformDemo&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面一篇文章介绍了runtime的知识，就是调用[Person run]的直接方法调用和performSelector有什么区别呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>深入学习Runtime</title>
    <link href="http://peilinghui.com/2016/07/05/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0Runtime/"/>
    <id>http://peilinghui.com/2016/07/05/深入学习Runtime/</id>
    <published>2016-07-05T08:22:32.000Z</published>
    <updated>2017-04-15T03:01:27.000Z</updated>
    
    <content type="html">&lt;p&gt;研究Runtime的源码。看runtime.h文件。runtime是一套比较底层的纯C语言API。平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;有什么用？&lt;br&gt; runtime是属于OC的底层, 可以进行一些非常底层的操作。 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt; 发送消息(objc_send)
2&amp;gt; 交换方法(method_exchangeImplementations)
3&amp;gt; 动态创建一个类（比如KVO的底层实现）  
4&amp;gt; 动态添加方法，（performSelector）
5&amp;gt; 给分类添加属性。(其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间) objc_setAssociatedObject与objc_getAssociatedObject
6&amp;gt; 字典转模型（利用runtime,遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。）
6&amp;gt; 可以把消息转发给想要的对象，或者随意交换一个方法的实现。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;objc的文件夹中的源码文件，看完就能明白runtime和对象消息转发机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-07%20%E4%B8%8B%E5%8D%883.09.36.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Objective-C的元素&quot;&gt;&lt;a href=&quot;#Objective-C的元素&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的元素&quot;&gt;&lt;/a&gt;Objective-C的元素&lt;/h2&gt;&lt;p&gt;你创建的每个类（派生形式NSObject / NSObject子类）将在堆上分配并将返回一个指针。&lt;br&gt;先看objc.h文件中：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !OBJC_TYPES_DEFINED&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// An opaque type that represents an Objective-C class.**Class是一个指向objc_class结构体的指针**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//我们所说的类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// Represents an instance of a class.isa是一个指向objc_class结构体的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/// A pointer to an instance of a class.id是一个指向objc_object结构体的指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//我们所说的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_object *id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再看runtime.h文件中关于objc_class的定义：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class *Class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_class &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Class isa                                 OBJC_ISA_&lt;span class=&quot;built_in&quot;&gt;AVAILABILITY&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// metaclass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Class super_class                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 父类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                          OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                              OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; info                                 OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; instance_size                        OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 该类的实例变量大小（包括从父类继承下来的实例变量）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar_list *ivars              OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 该类的成员变量地址列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list **methodLists     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_cache *cache                  OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 缓存最近使用的方法地址，用于提升效率；&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols      OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 存储该类声明遵守的协议的列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* Use `Class` instead of `struct objc_class *` */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由此可以看到，对象(id)就是一个isa指针，而类(class)中不仅有isa指针，还有其他成员变量。类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object也就是中的isa)，这样我们就可以区别对象和类了。&lt;/p&gt;
&lt;p&gt;再仔细看其中成员变量的含义：&lt;/p&gt;
&lt;h3 id=&quot;1-isa：&quot;&gt;&lt;a href=&quot;#1-isa：&quot; class=&quot;headerlink&quot; title=&quot;1. isa：&quot;&gt;&lt;/a&gt;1. &lt;strong&gt;isa&lt;/strong&gt;：&lt;/h3&gt;&lt;p&gt;id中的isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）。&lt;br&gt;而class中的isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。&lt;/p&gt;
&lt;h4 id=&quot;2-super-class&quot;&gt;&lt;a href=&quot;#2-super-class&quot; class=&quot;headerlink&quot; title=&quot;2. super_class:&quot;&gt;&lt;/a&gt;2. super_class:&lt;/h4&gt;&lt;p&gt;指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。&lt;/p&gt;
&lt;p&gt;类与对象的继承层次关系如图（图片源自网络）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/objective-runtime-1.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;所有的class中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。&lt;/p&gt;
&lt;h4 id=&quot;3-SEL&quot;&gt;&lt;a href=&quot;#3-SEL&quot; class=&quot;headerlink&quot; title=&quot;3. SEL:&quot;&gt;&lt;/a&gt;3. SEL:&lt;/h4&gt;&lt;p&gt;&lt;code&gt;typedef struct objc_selector *SEL;&lt;/code&gt;SEL是selector在Objective-C中的表示类型。selector可以理解为区别方法的ID。&lt;/p&gt;
&lt;h4 id=&quot;4-IMP&quot;&gt;&lt;a href=&quot;#4-IMP&quot; class=&quot;headerlink&quot; title=&quot;4. IMP:&quot;&gt;&lt;/a&gt;4. IMP:&lt;/h4&gt;&lt;p&gt;是“implementation”的缩写，它是由编译器生成的&lt;strong&gt;方法实现的一个函数指针&lt;/strong&gt;。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。(obj.h)&lt;br&gt;一个函数是由一个selector(SEL)，和一个implement(IML)组成的；Selector相当于门牌号，而Implement才是真正的住户（函数实现）。理解Selector和Implementation的关系蛮重要的！&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/// A &lt;span class=&quot;type&quot;&gt;pointer&lt;/span&gt; to the function &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; implementation. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#if !OBJC_OLD_DISPATCH_PROTOTYPES&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;type&quot;&gt;IMP&lt;/span&gt;)(&lt;span class=&quot;type&quot;&gt;void&lt;/span&gt; /* id, &lt;span class=&quot;type&quot;&gt;SEL&lt;/span&gt;, ... */ ); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef id (*&lt;span class=&quot;type&quot;&gt;IMP&lt;/span&gt;)(id, &lt;span class=&quot;type&quot;&gt;SEL&lt;/span&gt;, ...); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;5-Method：&quot;&gt;&lt;a href=&quot;#5-Method：&quot; class=&quot;headerlink&quot; title=&quot;5. Method：&quot;&gt;&lt;/a&gt;5. Method：&lt;/h4&gt;&lt;p&gt;Method代表类中的某个方法的类型。(runtime.h中)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_method *Method;&lt;/code&gt;&lt;br&gt;objc_method的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL method_name                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *method_types                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    IMP method_imp                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 方法实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;6-Ivar&quot;&gt;&lt;a href=&quot;#6-Ivar&quot; class=&quot;headerlink&quot; title=&quot;6. Ivar:&quot;&gt;&lt;/a&gt;6. Ivar:&lt;/h4&gt;&lt;p&gt;代表类中实例变量的类型&lt;code&gt;typedef struct objc_ivar *Ivar;&lt;/code&gt;&lt;br&gt;objc_ivar的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_name                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 变量名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *ivar_type                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 变量类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ivar_offset                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 基地址偏移字节&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; space                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 占用空间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;7-Category&quot;&gt;&lt;a href=&quot;#7-Category&quot; class=&quot;headerlink&quot; title=&quot;7. Category :&quot;&gt;&lt;/a&gt;7. Category :&lt;/h4&gt;&lt;p&gt;代表一个分类&lt;code&gt;typedef struct objc_category *Category;&lt;/code&gt;&lt;br&gt;objc_category的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_category &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *category_name                                      OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *class_name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list *instance_methods                OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_method_list *class_methods                   OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_protocol_list *protocols                     OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在运行时，类（包括class和metaclass）的objc_class结构体是固定的，不可能往这个结构体中添加数据，只能修改！譬如可以修改isa指针，让它指向一个中间类；在我的理解里，应该也可以修改ivars和methodLists，让它们指向一个新的区域；若可以这样，那么就可以在运行时随意添加/修改/删除成员变量和方法了。&lt;br&gt;但是，貌似Objective-C Runtime没有提供修改ivars和methodLists指针值的接口。&lt;br&gt;也因此，ivars在运行时指向的是一个固定区域，当然可以修改这个区域的值了，但这其实只是修改成员变量值而已；「在这个内存区域后面续上一段空余区域用于存放新的成员变量」？呵呵，想多了吧！因此，我们没办法在运行时为对象添加成员变量，这解释了为什么category中不能定义property（dynamic property不算）；&lt;br&gt;P.S: 那为什么protocol中可以添加变量，在我的理解里，protocol是在编译器处理的。所以objc_class中有一个变量叫protocols；&lt;br&gt;和ivars不同，methodLists是一个二维数组。虽然我们没办法扩展methodLists指向的内存区域，但是我们可以改变这个内存区域（这个内存区域存储的都是指针）的值。因此，我们可以在运行时动态添加（以及做其他的处理，譬如交换等）方法！&lt;/p&gt;
&lt;h4 id=&quot;8-objc-property-t&quot;&gt;&lt;a href=&quot;#8-objc-property-t&quot; class=&quot;headerlink&quot; title=&quot;8. objc_property_t:&quot;&gt;&lt;/a&gt;8. objc_property_t:&lt;/h4&gt;&lt;p&gt;objc_property_t是属性，它可以动态的为已存在的类添加新的方法。它的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;&lt;br&gt;objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name; &lt;span class=&quot;comment&quot;&gt;// 名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *value;  &lt;span class=&quot;comment&quot;&gt;// 值（通常是空的）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;objc_property_attribute_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;9-Cache&quot;&gt;&lt;a href=&quot;#9-Cache&quot; class=&quot;headerlink&quot; title=&quot;9. Cache&quot;&gt;&lt;/a&gt;9. Cache&lt;/h4&gt;&lt;p&gt;Catch的定义如下：&lt;/p&gt;
&lt;p&gt;typedef struct objc_cache *Cache&lt;br&gt;objc_cache的定义如下：&lt;/p&gt;
&lt;p&gt;struct objc_cache {&lt;br&gt;    unsigned int mask                   OBJC2_UNAVAILABLE;&lt;br&gt;    unsigned int occupied               OBJC2_UNAVAILABLE;&lt;br&gt;    Method buckets[1]                   OBJC2_UNAVAILABLE;&lt;br&gt;};&lt;br&gt;mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。&lt;br&gt;occupied: 实际占用cache buckets的总数。&lt;br&gt;buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。&lt;br&gt;&lt;strong&gt;objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;10-Module&quot;&gt;&lt;a href=&quot;#10-Module&quot; class=&quot;headerlink&quot; title=&quot;10.Module&quot;&gt;&lt;/a&gt;10.Module&lt;/h4&gt;&lt;p&gt;Module定义如下：&lt;br&gt;&lt;code&gt;typedef struct objc_module *Module                           OBJC2_UNAVAILABLE;&lt;/code&gt;&lt;br&gt;objc_module定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; objc_module &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; version                                    OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; size                                       OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name                                         OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Symtab symtab                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;                                                            OBJC2_UN&lt;span class=&quot;built_in&quot;&gt;AVAILABLE&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Objective-C的消息传递&quot;&gt;&lt;a href=&quot;#Objective-C的消息传递&quot; class=&quot;headerlink&quot; title=&quot;Objective-C的消息传递&quot;&gt;&lt;/a&gt;Objective-C的消息传递&lt;/h2&gt;&lt;p&gt;消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；&lt;/p&gt;
&lt;p&gt;消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现&lt;/p&gt;
&lt;p&gt;消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。&lt;/p&gt;
&lt;h3 id=&quot;objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend的作用&quot;&gt;&lt;/a&gt;objc_msgSend的作用&lt;/h3&gt;&lt;p&gt;在面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会从对象发送消息转换成Runtime的objc_msgSend函数调用。&lt;br&gt;例如某实例变量receiver实现某一个方法oneMethod&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[receiver oneMethod];&lt;/code&gt;&lt;br&gt;Runtime会将其转成类似这样的代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector);&lt;/code&gt;&lt;br&gt;具体会转换成什么代码呢？&lt;/p&gt;
&lt;p&gt;objc_msgSend:普通的消息都会通过该函数发送&lt;br&gt;objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值&lt;br&gt;objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例&lt;br&gt;objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值。&lt;/p&gt;
&lt;p&gt;objc_msgSend函数的调用过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。&lt;/li&gt;
&lt;li&gt;检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。&lt;/li&gt;
&lt;li&gt;如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。&lt;/li&gt;
&lt;li&gt;如果 cache 找不到就找一下方法分发表。&lt;/li&gt;
&lt;li&gt;如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。&lt;/li&gt;
&lt;li&gt;如果还找不到就要开始进入动态方法解析了，后面会提到。&lt;br&gt;PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举 objc_msgSend(obj, foo) 这个例子来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，通过 obj 的 isa 指针找到它的 class ;
在 class 的 method list 找 foo ;
如果 class 中没到 foo，继续往它的 superclass 中找 ;
一旦找到 foo 这个函数，就去执行它的实现IMP .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.&lt;/p&gt;
&lt;h4 id=&quot;第11条：理解objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#第11条：理解objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;第11条：理解objc_msgSend的作用&quot;&gt;&lt;/a&gt;第11条：理解objc_msgSend的作用&lt;/h4&gt;&lt;p&gt;消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。&lt;br&gt;OC的消息机制&lt;br&gt;&lt;code&gt;[someObject messageName: parameter]&lt;/code&gt;&lt;br&gt;&lt;code&gt;id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&amp;quot;方法列表&amp;quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&amp;quot;消息转发&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一些函数：&lt;br&gt;objc_msgSend_stret:待发送的消息要返回结构体&lt;br&gt;objc_msgSend_fpret:消息返回的是浮点数&lt;br&gt;objc_msgSendSuper:要给超类发送消息&lt;/p&gt;
&lt;h3 id=&quot;动态方法解析和转发&quot;&gt;&lt;a href=&quot;#动态方法解析和转发&quot; class=&quot;headerlink&quot; title=&quot;动态方法解析和转发&quot;&gt;&lt;/a&gt;动态方法解析和转发&lt;/h3&gt;&lt;p&gt;动态解析流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8A%E5%8D%889.16.01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象在收到无法解读的消息后，首先将调用其所属类的下列方法：(NSObject.h中)&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//尚未实现的方法是类方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)&lt;span class=&quot;string&quot;&gt;resolveClassMethod:&lt;/span&gt;(SEL)sel &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//尚未实现的方法是实例方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)&lt;span class=&quot;string&quot;&gt;resolveInstanceMethod:&lt;/span&gt;(SEL)sel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这步会进入forwardingTargetForSelector:方法，&lt;br&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt;用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；&lt;br&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。&lt;br&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;第12条：消息转发机制&quot;&gt;&lt;a href=&quot;#第12条：消息转发机制&quot; class=&quot;headerlink&quot; title=&quot;第12条：消息转发机制&quot;&gt;&lt;/a&gt;第12条：消息转发机制&lt;/h4&gt;&lt;p&gt;消息转发分为两大阶段：第一阶段：征询接受者，动态方法解析。&lt;br&gt;第二阶段：完整的消息转发机制，请接收者看看有没有其他对象能处理这条消息，若有，则把消息转给那个对象。若没有，则启动完整的消息转发机制，会把消息有关的细节全都封装到NSInvocation中去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析：对象收到无法解读的消息后，调用类方法：&lt;br&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)selector&lt;/code&gt;&lt;br&gt;要访问CoreData框架中的NSManagedObjects对象时，用resolveInstanceMethod来实现@dynamic属性。  &lt;/li&gt;
&lt;li&gt;备援接收者：能不能把这条消息传给其他接收者来处理&lt;br&gt;&lt;code&gt;-(id)forwardingTargetForSelector:(SEL)selctor;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完整的消息转发：首先，创建NSInvocation对象，把选择子，目标(target)及参数都封装于其中，在触发NSInvocation对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。&lt;br&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以完整的例子演示动态方法解析&lt;br&gt;由开发者来添加属性定义，并将其声明为@dynamic，而类则会自动处理相关属性值的存放于获取操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;a href=&quot;#第14条：理解“类对象”的用意&quot; class=&quot;headerlink&quot; title=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;/a&gt;第14条：理解“类对象”的用意&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Objective-c对象的本质：都是指向某块内存数据的指针，所以声明变量时，类型后面要加“&lt;em&gt;”字符。`NSString &lt;/em&gt;point= @“string”；&lt;code&gt;id类型本身就是指针。可以改写为&lt;/code&gt;id point= @“string”;`&lt;br&gt;描述objective-c对象所用的数据结构定义在runtime.h文件中，对于id，Class，还有is a 指针，涉及到runtime的机制.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在类继承体系中查询类型信息&lt;br&gt;“isMemberOfClass”:能够判断出对象是否为某个特定类的实例。&lt;br&gt;“isKindOfClass”:能够判断出对象是否为某类或某派生类的实例。&lt;br&gt;通过使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。
如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。
尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h2&gt;&lt;h3 id=&quot;isa-swizzling-的应用&quot;&gt;&lt;a href=&quot;#isa-swizzling-的应用&quot; class=&quot;headerlink&quot; title=&quot;isa swizzling 的应用&quot;&gt;&lt;/a&gt;isa swizzling 的应用&lt;/h3&gt;&lt;h4 id=&quot;KVO的实现&quot;&gt;&lt;a href=&quot;#KVO的实现&quot; class=&quot;headerlink&quot; title=&quot;KVO的实现&quot;&gt;&lt;/a&gt;KVO的实现&lt;/h4&gt;&lt;p&gt;利用runtime动态产生一个类。&lt;br&gt;PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;据此，我们可以手动实现一个KVO。&lt;a href=&quot;http://tech.glowing.com/cn/implement-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/implement-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C中的KVC和KVO&lt;a href=&quot;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Method-Swizzling-应用&quot;&gt;&lt;a href=&quot;#Method-Swizzling-应用&quot; class=&quot;headerlink&quot; title=&quot;Method Swizzling 应用&quot;&gt;&lt;/a&gt;Method Swizzling 应用&lt;/h3&gt;&lt;p&gt;Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现：&lt;br&gt;class_replaceMethod 替换类方法的定义&lt;br&gt;&lt;strong&gt;method_exchangeImplementations 交换 2 个方法的实现&lt;/strong&gt;&lt;br&gt;method_setImplementation 设置 1 个方法的实现&lt;/p&gt;
&lt;p&gt;使用 method swizlling 来修改原有的方法时, 就是在分类 load 中实现的.不在 initialize 方法中改变方法实现的原因是 initialize 可能会被子类所继承并重新执行最终导致无限递归, 而 load 并不会被继承.&lt;/p&gt;
&lt;h4 id=&quot;第13条：用method-swizzling调试黑盒方法&quot;&gt;&lt;a href=&quot;#第13条：用method-swizzling调试黑盒方法&quot; class=&quot;headerlink&quot; title=&quot;第13条：用method swizzling调试黑盒方法&quot;&gt;&lt;/a&gt;第13条：用method swizzling调试黑盒方法&lt;/h4&gt;&lt;p&gt;method swizzling：与给定的选择子名称相对应得方法也可以在运行期改变。（不需要源码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能）可用在本类的所有实例中。&lt;strong&gt;使用另一份实现来替换原有的方法实现&lt;/strong&gt;&lt;br&gt;IMP指针：id(*IMP)(id,SEL,….)类的方法列表会吧选择子的名称映射到相关方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示。&lt;br&gt;互换两个方法的实现：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互换两个已经写好方法实现：(两个参数为待交换的两个方法实现)&lt;br&gt;&lt;code&gt;void method_exchangeImplementations(Method m1,Method m2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获得方法实现：&lt;br&gt;&lt;code&gt;Method class_getInstanceMethod(Class aClass,SEL aselector)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 来为既有的方法添加新功能，新方法添加在NSString的一个“分类”中，在方法中实现所需的附加功能，并调用原有的实现。
- 为完全不知道其具体实现的黑盒方法增加日志记录，有助于程序调试。不宜乱用
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;给分类添加属性&quot;&gt;&lt;a href=&quot;#给分类添加属性&quot; class=&quot;headerlink&quot; title=&quot;给分类添加属性&quot;&gt;&lt;/a&gt;给分类添加属性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Category实现的原理，同样解释了Category不能添加属性的原因&lt;/strong&gt;&lt;br&gt;在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，&lt;/p&gt;
&lt;p&gt;最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的深入理解Objective-C：Category&lt;a href=&quot;http://tech.meituan.com/DiveIntoCategory.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.meituan.com/DiveIntoCategory.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;任性的话可以在Category中添加@dynamic的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。&lt;strong&gt;所以无法在运行时动态给对象增加成员变量&lt;/strong&gt;。&lt;br&gt;相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 methodLists的指针的指针。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是Category实现的原理。&lt;strong&gt;同时也说明了为什么Category只可为对象增加成员方法，却不能增加成员变量。&lt;/strong&gt;&lt;br&gt;iOS 关联引用为分类添加属性:&lt;br&gt; 主要代码：（runtime.h）&lt;/p&gt;
 &lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; objc_setAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; value, objc_AssociationPolicy policy)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; objc_getAssociatedObject(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *key)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;字典转模型&quot;&gt;&lt;a href=&quot;#字典转模型&quot; class=&quot;headerlink&quot; title=&quot;字典转模型&quot;&gt;&lt;/a&gt;字典转模型&lt;/h3&gt;&lt;p&gt;要将JSON转换为Model啦！&lt;br&gt;利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上。&lt;/p&gt;
&lt;h3 id=&quot;利用runtime遍历模型对象的所有属性来归档和解档&quot;&gt;&lt;a href=&quot;#利用runtime遍历模型对象的所有属性来归档和解档&quot; class=&quot;headerlink&quot; title=&quot;利用runtime遍历模型对象的所有属性来归档和解档&quot;&gt;&lt;/a&gt;利用runtime遍历模型对象的所有属性来归档和解档&lt;/h3&gt;&lt;p&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt; &lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;/p&gt;
&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;讲讲Runtime，以及消息转发过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;讲讲runtime，以及hook，以及如何进行方法交换；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;详解runtime，OC为什么是动态的语言，内部机制；&lt;br&gt;在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得Objective-C成为一门真正的动态语言。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;runtime 的运行机制？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KVO如何实现，内部机制；&lt;br&gt;&lt;a href=&quot;http://zhangbuhuai.com/understanding-kvo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://zhangbuhuai.com/understanding-kvo/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kvo的底层实现？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何去手动触发KVO，如何让KVO去监听一个方法；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※]objc中向一个nil对象发送消息将会发生什么？&lt;br&gt;在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]什么时候会报unrecognized selector的异常？&lt;br&gt;objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：&lt;br&gt;见上图。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）  &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.&lt;/li&gt;
&lt;li&gt;每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的对象方法列表成员变量的列表,属性列表。它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。&lt;/li&gt;
&lt;li&gt;根对象就是NSObject，它的superclass指针指向nil。&lt;/li&gt;
&lt;li&gt;类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※]一个objc对象的isa的指针指向什么？有什么作用？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isa是对象中的隐藏指针,指向创建这个对象的类。
对象会顺着内部的isa指针找到存储于类中的方法并执行。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）&lt;br&gt;selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;无论在MRC下还是ARC下均不需要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。&lt;br&gt;_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：&lt;/p&gt;
&lt;p&gt;resolveInstanceMethod:方法 (或 resolveClassMethod:)。&lt;br&gt;forwardingTargetForSelector:方法&lt;br&gt;methodSignatureForSelector:方法&lt;br&gt;forwardInvocation:方法&lt;br&gt;doesNotRecognizeSelector: 方法&lt;/p&gt;
&lt;p&gt;直接调用调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，&lt;/p&gt;
&lt;p&gt;如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”&lt;/p&gt;
&lt;p&gt;哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的：JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。&lt;br&gt;作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。&lt;/li&gt;
&lt;li&gt;RAC(ReactiveCocoa) 源码中也用到了该方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]runtime如何实现weak变量的自动置nil？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;不能向编译后得到的类中增加实例变量;&lt;/li&gt;
&lt;li&gt;能向运行时创建的类中添加实例变量;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;下面的代码分别输出什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Son&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;Father&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;答案：都输出”Son”&lt;br&gt;解释：objc中super是编译器标示符，并不像self一样是一个对象，遇到向super发的方法时会转译成&lt;strong&gt;objc_msgSendSuper(…)&lt;/strong&gt;，而参数中的对象还是self，于是从父类开始沿继承链寻找 - class这个方法，最后在NSObject中找到（若无override），此时，[self class]和[super class]已经等价了。&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;Objective-C 消息发送与转发机制原理&lt;br&gt;&lt;a href=&quot;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C Runtime 1小时入门教程：&lt;br&gt;&lt;a href=&quot;https://www.ianisme.com/ios/2019.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Objective-C对象模型及应用&lt;a href=&quot;http://blog.devtang.com/2013/10/15/objective-c-object-model/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2013/10/15/objective-c-object-model/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Method Swizzling 和 AOP 实践&lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://tech.glowing.com/cn/method-swizzling-aop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Method Swizzling&lt;br&gt;&lt;a href=&quot;http://nshipster.com/method-swizzling/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://nshipster.com/method-swizzling/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;手Runtime（附MJExtension的底层实现）&lt;br&gt;&lt;a href=&quot;http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;iOS面试题sunny&lt;a href=&quot;http://blog.sunnyxx.com/2015/07/04/ios-interview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/07/04/ios-interview/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;答案&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;研究Runtime的源码。看runtime.h文件。runtime是一套比较底层的纯C语言API。平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TableView的一些事</title>
    <link href="http://peilinghui.com/2016/07/02/TableView%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://peilinghui.com/2016/07/02/TableView的一些事/</id>
    <published>2016-07-02T02:32:49.000Z</published>
    <updated>2016-10-12T12:07:46.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView的基本信息&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UITableView的基本信息&quot;&gt;&lt;a href=&quot;#UITableView的基本信息&quot; class=&quot;headerlink&quot; title=&quot;UITableView的基本信息&quot;&gt;&lt;/a&gt;UITableView的基本信息&lt;/h2&gt;&lt;h3 id=&quot;初始化方法&quot;&gt;&lt;a href=&quot;#初始化方法&quot; class=&quot;headerlink&quot; title=&quot;初始化方法&quot;&gt;&lt;/a&gt;初始化方法&lt;/h3&gt;&lt;p&gt; &lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;&lt;/code&gt;&lt;br&gt;这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;// 标准的表视图风格    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStyleGrouped&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;// 分组的表视图风格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用属性&quot;&gt;&lt;a href=&quot;#常用属性&quot; class=&quot;headerlink&quot; title=&quot;常用属性&quot;&gt;&lt;/a&gt;常用属性&lt;/h3&gt;&lt;p&gt;获取表视图的风格(只读属性)&lt;br&gt;&lt;code&gt;@property(nonatomic, readonly) UITableViewStyle    style;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图代理和数据源代理(代理方法后面讨论)&lt;br&gt;&lt;code&gt;@property (nonatomic, assign)id &amp;lt;UITableViewDataSource&amp;gt; dataSource;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property(nonatomic, assign)id &amp;lt;UITableViewDelegate&amp;gt;   delegate;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图的行高(默认为44)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat rowHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat  sectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  sectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedRowHeight;&lt;/code&gt;&lt;br&gt;注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。&lt;/p&gt;
&lt;p&gt;下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的位置&lt;br&gt;&lt;code&gt;@property (nonatomic)UIEdgeInsets  separatorInset;&lt;/code&gt;&lt;br&gt;如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tab=[[&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; style:&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tab&lt;span class=&quot;variable&quot;&gt;.separatorInset&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, tab&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置tableView背景view视图&lt;br&gt;&lt;code&gt;@property(nonatomic, readwrite, retain) UIView *backgroundView;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用方法详解&quot;&gt;&lt;a href=&quot;#常用方法详解&quot; class=&quot;headerlink&quot; title=&quot;常用方法详解&quot;&gt;&lt;/a&gt;常用方法详解&lt;/h3&gt;&lt;p&gt;重载tableView&lt;br&gt;&lt;code&gt;- (void)reloadData;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重载索引栏&lt;br&gt;&lt;code&gt;- (void)reloadSectionIndexTitles;&lt;/code&gt;&lt;br&gt;这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。&lt;/p&gt;
&lt;p&gt;获取分区数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSections;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取行数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取分区的大小(包括头视图，所有行和尾视图)&lt;br&gt;&lt;code&gt;- (CGRect)rectForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区分别获取头视图，尾视图和行的高度&lt;br&gt;&lt;code&gt;- (CGRect)rectForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个点在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个cell在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过位置路径获取cell&lt;br&gt;&lt;code&gt;- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见的cell&lt;br&gt;&lt;code&gt;- (NSArray *)visibleCells;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见行的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForVisibleRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取头视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取尾视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到某一位置(行)&lt;br&gt;&lt;code&gt;- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPosition&lt;/span&gt;) &amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//同UITableViewScrollPositionTop   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的顶部        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionMiddle&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的中间      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionBottom&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView最下面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到选中行&lt;br&gt;&lt;code&gt;- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;这个函数与上面的非常相似，只是它是将表示图定位到选中的行。&lt;/p&gt;
&lt;h2 id=&quot;tableView操作刷新块的应用&quot;&gt;&lt;a href=&quot;#tableView操作刷新块的应用&quot; class=&quot;headerlink&quot; title=&quot;tableView操作刷新块的应用&quot;&gt;&lt;/a&gt;tableView操作刷新块的应用&lt;/h2&gt;&lt;p&gt;在介绍动画块之前，我们先看几个函数：&lt;br&gt;插入分区&lt;br&gt;&lt;code&gt;- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;animation参数是一个枚举，枚举的动画类型如下&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimation&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationFade&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//淡入淡出  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationRight&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从右滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationLeft&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从左滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从上滑入    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationBottom&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从下滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationNone&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//没有动画   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationMiddle&lt;/span&gt;,           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationAutomatic&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 自动选择合适的动画&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除分区&lt;br&gt;&lt;code&gt;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一个分区&lt;br&gt;&lt;code&gt;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ;&lt;/code&gt;&lt;br&gt;移动一个分区&lt;br&gt;&lt;code&gt;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;&lt;/code&gt;&lt;br&gt;插入一些行&lt;br&gt;&lt;code&gt;- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;删除一些行&lt;br&gt;&lt;code&gt;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一些行&lt;br&gt;&lt;code&gt;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;移动某行&lt;br&gt;&lt;code&gt;- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;&lt;/code&gt;&lt;br&gt;了解了上面几个函数，我们来看什么是操作刷新块：&lt;br&gt;当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。&lt;br&gt;IOS为我们提供了下面两个函数解决这个问题：&lt;br&gt;开始块标志&lt;br&gt;&lt;code&gt;- (void)beginUpdates;&lt;/code&gt;&lt;br&gt;结束快标志&lt;br&gt;&lt;code&gt;- (void)endUpdates;&lt;/code&gt;&lt;br&gt;我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下：&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab beginUpdates]&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]&lt;/span&gt;] &lt;span class=&quot;tag&quot;&gt;withRowAnimation&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:UITableViewRowAnimationLeft&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[dataArray removeObjectAtIndex:1]&lt;/span&gt;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[tab endUpdates]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：不要在这个块中调用reloadData这个方法，它会使动画失效。&lt;/p&gt;
&lt;h2 id=&quot;tableView的编辑操作&quot;&gt;&lt;a href=&quot;#tableView的编辑操作&quot; class=&quot;headerlink&quot; title=&quot;tableView的编辑操作&quot;&gt;&lt;/a&gt;tableView的编辑操作&lt;/h2&gt;&lt;p&gt;设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮)&lt;br&gt;&lt;code&gt;@property (nonatomic, getter=isEditing) BOOL editing;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)setEditing:(BOOL)editing animated:(BOOL)animated;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以被选中(默认为YES)&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell编辑模式下是否可以被选中&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑模式下是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;选中cell的相关操作&quot;&gt;&lt;a href=&quot;#选中cell的相关操作&quot; class=&quot;headerlink&quot; title=&quot;选中cell的相关操作&quot;&gt;&lt;/a&gt;选中cell的相关操作&lt;/h2&gt;&lt;p&gt;获取选中cell的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForSelectedRow;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取多选cell的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForSelectedRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码手动选中与取消选中某行&lt;br&gt;&lt;code&gt;- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;注意：这两个方法将不会回调代理中的方法。 &lt;/p&gt;
&lt;h2 id=&quot;tableView附件的相关方法&quot;&gt;&lt;a href=&quot;#tableView附件的相关方法&quot; class=&quot;headerlink&quot; title=&quot;tableView附件的相关方法&quot;&gt;&lt;/a&gt;tableView附件的相关方法&lt;/h2&gt;&lt;p&gt;设置索引栏最小显示行数&lt;br&gt;&lt;code&gt;@property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;设置索引栏字体颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏背景颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏被选中时的颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的风格&lt;br&gt;&lt;code&gt;@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle;&lt;/code&gt;&lt;br&gt;这个风格是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//无线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLine&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//有线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLineEtched&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置分割线颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor           *separatorColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线毛玻璃效果(IOS8之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic, copy) UIVisualEffect      *separatorEffect;&lt;/code&gt;&lt;br&gt;注意：这个属性是IOS8之后新的。&lt;/p&gt;
&lt;p&gt;设置tableView头视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableHeaderView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView尾视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableFooterView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池中取cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个已注册的cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池获取头视图或尾视图&lt;br&gt;&lt;code&gt;- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过xib文件注册cell&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过OC类注册cell&lt;br&gt; &lt;code&gt;- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier&lt;/code&gt;&lt;br&gt;上面两个方法是IOS6之后的方法。&lt;/p&gt;
&lt;p&gt;通过xib文件和OC类获取注册头视图和尾视图&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-UITableView的代理方法&quot;&gt;&lt;a href=&quot;#iOS-UITableView的代理方法&quot; class=&quot;headerlink&quot; title=&quot;iOS UITableView的代理方法&quot;&gt;&lt;/a&gt;iOS UITableView的代理方法&lt;/h2&gt;&lt;h3 id=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;a href=&quot;#UITableViewDataSource（数据源代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;/a&gt;UITableViewDataSource（数据源代理）&lt;/h3&gt;&lt;p&gt;1、必须实现的回调方法&lt;br&gt;返回每个分区的行数&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每一行的cell&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、可选实现的方法&lt;br&gt;返回分区数(默认为1)&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区头部的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区的尾部标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可编辑&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可以被移动&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引）&lt;br&gt;&lt;code&gt;- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题对应的分区&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;tableView接受编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyle&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//没有编辑操作  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleDelete&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//删除操作    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleInsert&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//插入操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tableView的cell被移动时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;a href=&quot;#UITableViewDelegate（tableView代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;/a&gt;UITableViewDelegate（tableView代理）&lt;/h3&gt;&lt;p&gt;cell将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;头视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尾视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的方法&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率)&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置自定义头视图和尾视图&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以高亮&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;cell高亮和取消高亮时分别调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经选中和已经取消选中后调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格&lt;br&gt;&lt;code&gt;- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义删除按钮的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。&lt;br&gt;&lt;code&gt;- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath*)indexPath ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑时背景是否缩进&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将要编辑和结束编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移动特定的某行&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;TableView性能优化&quot;&gt;&lt;a href=&quot;#TableView性能优化&quot; class=&quot;headerlink&quot; title=&quot;TableView性能优化&quot;&gt;&lt;/a&gt;TableView性能优化&lt;/h2&gt;&lt;p&gt;tableview优化两个思路：缓存操作和异步操作。&lt;br&gt;最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。&lt;/p&gt;
&lt;h3 id=&quot;cell复用机制。&quot;&gt;&lt;a href=&quot;#cell复用机制。&quot; class=&quot;headerlink&quot; title=&quot;cell复用机制。&quot;&gt;&lt;/a&gt;cell复用机制。&lt;/h3&gt;&lt;p&gt;如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先注册cell&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt; ()&amp;lt;&lt;span class=&quot;title&quot;&gt;UITableViewDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UITableViewDelegate&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tableView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *cellId = &lt;span class=&quot;string&quot;&gt;@&quot;Cell&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.delegate&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.dataSource&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第一种注册cell&amp;lt;nib文件类HomeTableViewCell&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.tableView&lt;/span&gt; registerNib:[&lt;span class=&quot;built_in&quot;&gt;UINib&lt;/span&gt; nibWithNibName:&lt;span class=&quot;string&quot;&gt;@&quot;HomeTableViewCell&quot;&lt;/span&gt; bundle:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;] forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第二种注册Cell&amp;lt;纯手工打造的HomeVC&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [self.tableView registerClass:[HomeVC class]forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重用相关API&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Cell：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forIndexPath:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Section 的 Header/Footer：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableHeaderFooterViewWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UITableViewCell *)&lt;span class=&quot;string&quot;&gt;tableView:&lt;/span&gt;(UITableView *)tableView &lt;span class=&quot;string&quot;&gt;cellForRowAtIndexPath:&lt;/span&gt;(NSIndexPath *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//获取重用池中的cell&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HomeTableViewCell *cell = [tableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果没有取到,就初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cell) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell = [[HomeTableViewCell alloc] &lt;span class=&quot;string&quot;&gt;initWithStyle:&lt;/span&gt;UITableViewCellStyleDefault &lt;span class=&quot;string&quot;&gt;reuseIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cell.cellNameLab.text = @&lt;span class=&quot;string&quot;&gt;&quot;Name&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;a href=&quot;#cell使用drawRect方法添加子控件&quot; class=&quot;headerlink&quot; title=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;/a&gt;cell使用drawRect方法添加子控件&lt;/h3&gt;&lt;p&gt;如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。&lt;/p&gt;
&lt;h3 id=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;a href=&quot;#高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot; class=&quot;headerlink&quot; title=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;/a&gt;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;- (CGSize)systemLayoutSizeFittingSize: (CGSize)targetSize&lt;/code&gt;&lt;br&gt;方法计算。&lt;/p&gt;
&lt;h3 id=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;a href=&quot;#避免快速滑动情况下开过多线程。&quot; class=&quot;headerlink&quot; title=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;/a&gt;避免快速滑动情况下开过多线程。&lt;/h3&gt;&lt;p&gt;cell中的图片开线程异步加载&lt;sdwebimage(异步操作)&gt;。但是线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; canLoad:Bool = !tableView&lt;span class=&quot;variable&quot;&gt;.dragging&lt;/span&gt; &amp;amp;&amp;amp; !tableView&lt;span class=&quot;variable&quot;&gt;.declearating&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;  canLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//开始loaddata，异步加载图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidScroll:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)sender&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//刷新tableview&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//在此刷新的是屏幕上显示的cell的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.table&lt;/span&gt; reloadData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/sdwebimage(异步操作)&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片处理&quot;&gt;&lt;a href=&quot;#图片处理&quot; class=&quot;headerlink&quot; title=&quot;图片处理&quot;&gt;&lt;/a&gt;图片处理&lt;/h3&gt;&lt;p&gt;1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。&lt;br&gt;2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示&lt;br&gt;3）避免对layer做过多的操作，尽量设置图片为不透明&lt;/p&gt;
&lt;h2 id=&quot;tableView的数据刷新&quot;&gt;&lt;a href=&quot;#tableView的数据刷新&quot; class=&quot;headerlink&quot; title=&quot;tableView的数据刷新&quot;&gt;&lt;/a&gt;tableView的数据刷新&lt;/h2&gt;&lt;p&gt;对tableView的刷新直接就是reloadData.调用这个方法之后,控制器会把数据源方法重新执行一遍,如果前面我们的数据需要保存,reloadData重新执行一遍,我们的数据都会被刷新掉,那么我改如何解决这个问题呢 ? 这就我们对其中某一个分组,或者某一个指定的Cell进行刷新.具体的代码实现如下,&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个section刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexSet *indexSet=[[NSIndexSet alloc]&lt;span class=&quot;string&quot;&gt;initWithIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableview &lt;span class=&quot;string&quot;&gt;reloadSections:&lt;/span&gt;indexSet &lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationAutomatic];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个指定cell刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexPath *indexPath=[NSIndexPath &lt;span class=&quot;string&quot;&gt;indexPathForRow:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;inSection:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableView &lt;span class=&quot;string&quot;&gt;reloadRowsAtIndexPaths:&lt;/span&gt;[NSArray &lt;span class=&quot;string&quot;&gt;arrayWithObjects:&lt;/span&gt;indexPath,nil] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationNone];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多参考资料：&quot;&gt;&lt;a href=&quot;#更多参考资料：&quot; class=&quot;headerlink&quot; title=&quot;更多参考资料：&quot;&gt;&lt;/a&gt;更多参考资料：&lt;/h3&gt;&lt;p&gt;优化UITableViewCell高度计算的那些事：&lt;a href=&quot;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&lt;/a&gt;&lt;br&gt;objc的期刊：更轻量的View Controller：&lt;a href=&quot;https://objccn.io/issue-1-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-1-1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView的基本信息&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中页面传值和页面跳转 </title>
    <link href="http://peilinghui.com/2016/07/02/iOS%E4%B8%AD%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <id>http://peilinghui.com/2016/07/02/iOS中页面传值和页面跳转/</id>
    <published>2016-07-02T02:32:09.000Z</published>
    <updated>2016-10-12T14:03:54.000Z</updated>
    
    <content type="html">&lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios的页面通信&quot;&gt;&lt;a href=&quot;#ios的页面通信&quot; class=&quot;headerlink&quot; title=&quot;ios的页面通信&quot;&gt;&lt;/a&gt;ios的页面通信&lt;/h2&gt;&lt;p&gt;开发过程中我们在页面传值时我们通常使用的方法有:属性传值法,block传值法,代理传值法,以及单例传值法,通知传值法。&lt;/p&gt;
&lt;h3 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;属性传值多用于在将前一个页面的值传到后一个页面去,也就是我们通常说的从前往后传值，  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当第一个页面push到第二个页面的时候.我们在第二个页面声明一个属性用于接受从第一个页面传递过去的值,然后在push这个事件被触发的时候进行赋值.&lt;br&gt;也就是说,先初始化创建第二个控制器(页面),然后通过创建的控制器来访问它所对应的属性,将即将传递的值赋给它,这样就完成了属性传值.于是当页面(控制器)被push到第二个页面之后我们访问它的属性的时候,也就顺便获取到了传递过来的值.&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;next:&lt;/span&gt;(UINavigationController *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ScondViewController *secondNC = [[ScondViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将第一个界面的输入框信息赋值给第二个页面的Label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondNC.tfString = _firstTF.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.navigationController &lt;span class=&quot;string&quot;&gt;pushViewController:&lt;/span&gt;secondNC &lt;span class=&quot;string&quot;&gt;animated:&lt;/span&gt;YES];   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代理传值多用于从后往前传值.只要在协议中声明一个协议方法，然后两个类一个作为委托方一个作为遵守方来调用和实现方法就可以实现传值。十分高效而且针对性很强。委托者：声明delegate属性，调用协议方法。被委托者：遵守协议，设定被委托者，覆写协议方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的.h中创建一个协议,并且设置代理属性,让其遵循该协议.&lt;br&gt;// 设置一个协议方法&lt;br&gt;@protocol SecondVCDelegate&lt;br&gt; // 代理传值    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)passValue:(NSString *)value;&lt;br&gt;@end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明代理属性进行代理传值&lt;br&gt;@property(nonatomic,weak)id delegate;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SecondViewController的导航控制器设置了右按钮(返回按钮),那么,我们只需要在其触发事件(back:)中调用代理方法去执行传值即可.&lt;br&gt;代码如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;back&lt;/span&gt;:(UINavigationController *)&lt;span class=&quot;tag&quot;&gt;sender&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[_delegate passValue:_secondTF.text]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[self.navigationController popViewControllerAnimated:YES]&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;然后在FirstViewController的next方法中为SecondNC制定其代理为其自身即可.&lt;/li&gt;
&lt;li&gt;实现其代理方法&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)passValue:(NSString *)&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;_f&lt;/span&gt;irstLab.text = &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样我们就可以在第一个页面得到第二个页面的值了.&lt;/p&gt;
&lt;h3 id=&quot;block传值&quot;&gt;&lt;a href=&quot;#block传值&quot; class=&quot;headerlink&quot; title=&quot;block传值&quot;&gt;&lt;/a&gt;block传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;block的本质就和其他OC中变量类似,只不过,block中存储的数据是函数体,但是在使用block时完全可以像调用其他函数似的,传入参数,然后得到返回值.从后往前传值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在SecondViewController中定义并声明block属性.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义有参无返回值的匿名函数(传递字符串)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^MyBlock)(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SecondViewController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)MyBlock block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的back方法中调用block,并且将在这个控制器的textField中的文字作为block的参数传递给block.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt;(_secondTF&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;FirstViewController的next方法中,也就是alloc出SecondViewController的时候调用SecondViewController的block,实现传值&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)temp = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secVC&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt; = ^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过回调将传进来的字符串赋值给label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp&lt;span class=&quot;variable&quot;&gt;.firstLab&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt; = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述代码中,因为block里面不能直接使用属性,实例变量和方法(因为会造成循环引用),所以我们重新用__weak修饰self并重新命名为temp.这样我们就实现了传值.&lt;/p&gt;
&lt;h3 id=&quot;通知传值&quot;&gt;&lt;a href=&quot;#通知传值&quot; class=&quot;headerlink&quot; title=&quot;通知传值&quot;&gt;&lt;/a&gt;通知传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类似于广播的一种传值模式，十分简单易用。一般负责在两个不同的类之间传值，且耦合度很低。这种方式中NSNotificationCenter担任一个中介者的身份，已提供观察者与被观察者相互传递信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C中使用NSNotifation表示通知，每个NSNotifation对象都具有名称name（NSNotificationCenter根据该名称检索此通知的所有观察者）、来源对象Poster-object（发布该通知的对象）和可选的userInfo字典（来源对象需要告诉观察者的额外信息NSDictionary）。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter就相当于一个俱乐部，只要一行代码一个类就能加入其中成为会员(Observer向NSNotificationCenter注册感兴趣信息)，当然这个类要告诉俱乐部它对哪些信息感兴趣，当有新的信息出现时，俱乐部会询问每一位会员这个信息是否是它们所需要的(Poster向NSNotificationCenter发送通知)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在ViewController中添加观察者&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;prepareForSegue:&lt;/span&gt;(UIStoryboardSegue *)segue &lt;span class=&quot;string&quot;&gt;sender:&lt;/span&gt;(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[NSNotificationCenter defaultCenter] &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;changeLabelText:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;改变名称&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中实现观察者接到消息之后执行的方法&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)changeLabelText:(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt;*)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.NameLabel&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;=sender&lt;span class=&quot;variable&quot;&gt;.userInfo&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在NextViewController.m中发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心发送通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSNotificationAction&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;* dic=@&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.nameTextField&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter] postNotificationName:&lt;span class=&quot;string&quot;&gt;@&quot;改变名称&quot;&lt;/span&gt; object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; userInfo:dic];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; dismissViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中要移除观察者&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除通知中心&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr_selector&quot;&gt;[[NSNotificationCenter defaultCenter]&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSNotificationCenter *)defaultCenter;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)postNotification:(NSNotification *)notification;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)removeObserver:(id)observer;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)removeObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地通知和远程推送通知&quot;&gt;&lt;a href=&quot;#本地通知和远程推送通知&quot; class=&quot;headerlink&quot; title=&quot;本地通知和远程推送通知&quot;&gt;&lt;/a&gt;本地通知和远程推送通知&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本地通知：由本应用负责调用，只能从当前设备上的iOS发出。&lt;br&gt;远程通知：由远程服务器上的程序发送至Apple Push Notification service(APNs)，再由APNs把消息推送住设备上对应的程序。&lt;/li&gt;
&lt;li&gt;本地通知是一个UILocalNotification对象，创建这个对象以后，就可以通过UIApplication的两个方法来发送通知了。&lt;br&gt;&lt;code&gt;- (void)presentLocalNotificationNow:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)scheduleLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;  // copies notification&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)cancelLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)cancelAllLocalNotifications NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程通知&lt;br&gt;UIApplication中注册远程push通知：&lt;br&gt;&lt;code&gt;- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;br&gt;调用下面方法：(重写应用程序委托类的3个方法)&lt;br&gt; &lt;code&gt;- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);&lt;/code&gt;- &lt;/p&gt;
&lt;h3 id=&quot;单例传值&quot;&gt;&lt;a href=&quot;#单例传值&quot; class=&quot;headerlink&quot; title=&quot;单例传值&quot;&gt;&lt;/a&gt;单例传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;由于单例在内存中只创建一次的并且可以全局访问的属性,我们可以在必要的时候将数据存放在单例的属性中,并且在必要的时候从单例中通过访问其属性进行调用,这样就实现值的传递&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *Str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明静态区对象的原因,希望程序运行期间,在内存中一直存在,这样对外界来说,可以随时读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DataHandle *dataHandle = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例(全局区)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; == dataHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 我们创建单例使用加号方法的原因是因为,在创建之前,无法存在一个实例对象去调用动态方法来创建它本身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataHandle = [[DataHandle alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataHandle; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只需要在需要的时候通过其类方法(+ (instancetype)sharedDataHandle)来创建出单例对象来,然后将textField的text属性以赋值的方式赋给单例的Srt属性即可.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入学习内存管理</title>
    <link href="http://peilinghui.com/2016/07/01/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://peilinghui.com/2016/07/01/深入学习内存管理/</id>
    <published>2016-07-01T08:57:25.000Z</published>
    <updated>2017-03-24T05:17:42.000Z</updated>
    
    <content type="html">&lt;p&gt;深入学习内存管理。理解相关基础知识。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;引用计数&quot;&gt;&lt;a href=&quot;#引用计数&quot; class=&quot;headerlink&quot; title=&quot;引用计数&quot;&gt;&lt;/a&gt;引用计数&lt;/h1&gt;&lt;h3 id=&quot;内存管理的思考方式&quot;&gt;&lt;a href=&quot;#内存管理的思考方式&quot; class=&quot;headerlink&quot; title=&quot;内存管理的思考方式&quot;&gt;&lt;/a&gt;内存管理的思考方式&lt;/h3&gt;&lt;p&gt; 1&amp;gt; 自己生成的对象，自己持有&lt;br&gt; alloc,new,copy,mutablecopy(copy方法利用NSCopying方法约定，由各类实现copyWithZone：方法生成并持有不可变对象的副本)&lt;br&gt; 2&amp;gt; 非自己生成的对象，自己持有&lt;br&gt; NSMutableArray类的array方法。使用retain方法可以持有&lt;br&gt; &lt;code&gt;id obj = [NSMutableArray array];
    [obj retain];&lt;/code&gt;&lt;br&gt; 3&amp;gt;不再需要自己持有的对象时释放&lt;br&gt; 用alloc\new\copy\mutableCopy方法生成并持有的对象，或用retain方法持有的对象，一旦不再需要，务必要用release进行释放。&lt;br&gt;4&amp;gt;无法释放非自己持有的对象&lt;br&gt;&lt;strong&gt;程序崩溃情况&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 再度释放已经释放了的对象
- 访问已经释放的对象时。
- 释放了非自己持有的对象
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;alloc-retain-release-dealloc在GUNstep中的实现：&quot;&gt;&lt;a href=&quot;#alloc-retain-release-dealloc在GUNstep中的实现：&quot; class=&quot;headerlink&quot; title=&quot;alloc/retain/release/dealloc在GUNstep中的实现：&quot;&gt;&lt;/a&gt;alloc/retain/release/dealloc在GUNstep中的实现：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 在objective-c的对象中存有引用计数这一整数值
- 调用alloc或是retain方法后，引用计数值加1.
- 调用release后，引用计数值减1.
- 引用计数值为0时，调用dealloc方法废弃对象。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;苹果的实现&quot;&gt;&lt;a href=&quot;#苹果的实现&quot; class=&quot;headerlink&quot; title=&quot;苹果的实现&quot;&gt;&lt;/a&gt;苹果的实现&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;GNUstep&lt;/strong&gt;将用内存块头部管理引用计数的好处：（GNUstep是与苹果Cocoa框架互换的框架）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 少量代码即可完成
- 能够统一管理引用计数用内存块与对象用内存块。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;苹果实现&lt;/strong&gt;通过&lt;strong&gt;引用技术表&lt;/strong&gt;来管理引用计数的好处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 对象用内存块的分配无需考虑内存块头部
- 引用计数表各记录中存有内存块地址，可以从各个记录追溯到各对象的内存块。（在调试的时候，只要内存技术表没有被破坏，就可以确认各内存块的位置；使用工具检测内存泄露时，引用计数表的各记录也有助于检测各对象的持有者是否存在）
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;autorelease简介&quot;&gt;&lt;a href=&quot;#autorelease简介&quot; class=&quot;headerlink&quot; title=&quot;autorelease简介&quot;&gt;&lt;/a&gt;autorelease简介&lt;/h3&gt;&lt;p&gt;autorelease类似于C语言的局部变量。只是编程人员可以设定变量的作用域&lt;br&gt;具体使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类方法用于返回autorelease对象：&lt;br&gt;&lt;code&gt;id array = [NAMutableArray arrayWithCapacity];&lt;/code&gt;&lt;br&gt;相当于：&lt;br&gt;&lt;code&gt;id array = [[NAMutableArray arrayWithCapacity]autorelease];&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;autorelease实现&quot;&gt;&lt;a href=&quot;#autorelease实现&quot; class=&quot;headerlink&quot; title=&quot;autorelease实现&quot;&gt;&lt;/a&gt;autorelease实现&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[obj autorelease];&lt;/code&gt;相当于&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(id) &lt;span class=&quot;tag&quot;&gt;autorelease&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;attr_selector&quot;&gt;[NSAutoreleasePool addObject:self]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot;&gt;&lt;a href=&quot;#autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot; class=&quot;headerlink&quot; title=&quot;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&quot;&gt;&lt;/a&gt;autoreleasepool底层是如何实现的？（苹果是如何实现autoreleasepool的）&lt;/h3&gt;&lt;p&gt;autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;objc_autoreleasepoolPush
objc_autoreleasepoolPop
objc_autorelease
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。&lt;/p&gt;
&lt;h1 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h1&gt;&lt;p&gt;ARC自动引用计数&lt;br&gt;  Automatic Reference Counting，降低了程序崩溃、内存泄露的风险，很大程度上减少了开发程序的工作量。&lt;br&gt; 使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Xcode4.2或以上版本&lt;/li&gt;
&lt;li&gt;使用LLVM编译器3.0或以上版本&lt;/li&gt;
&lt;li&gt;编译器选项中设置ARC为有效1. “-fobjc-arc”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或release代码&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;所有权的修饰符&quot;&gt;&lt;a href=&quot;#所有权的修饰符&quot; class=&quot;headerlink&quot; title=&quot;所有权的修饰符&quot;&gt;&lt;/a&gt;所有权的修饰符&lt;/h3&gt;&lt;p&gt;在ARC环境下，id类型和对象类型和C语言其他类型不同，类型前必须加上所有权的修饰符。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__strong
__weak
__unsafe_unretained
__autoreleasing
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;__strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARC中, id及其他对象默认就是__strong修饰符修饰，持有强引用的变量超出其作用域时被废弃, 随着强引用的失效, 引用的对象会随之释放.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__weak&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;__strong修饰符修饰在两个对象持有和自己持有自己时很容易有循环引用，从而造成内存泄露。&lt;br&gt;避免循环引用问题。弱引用不能持有对象实例。 并且弱引用的对象被废弃时, 则此弱引用将自动失效并等于nil。&lt;/p&gt;
&lt;p&gt;通过__weak变量访问对象实际上必定是访问注册到autoreleasepool的对象, 因为该修饰符只持有对象的弱引用, 在访问对象的过程中, 该对象可能被废弃, 如果把要访问的对象注册到autoreleasepool中, 那么在block结束之前都能确保该对象存在.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj0 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     obj1 = obj0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;A:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;B:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;A:&lt;/span&gt; &amp;lt;&lt;span class=&quot;string&quot;&gt;NSObject:&lt;/span&gt;ox753e180&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;B:&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;__weak 的几个使用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Delegate 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 Delegate 属性为 weak 的。但是这里有一个疑问，我们常用到的 UITableView 的 delegate 属性是这样定义的： @property (nonatomic, assign) id&lt;uitableviewdelegate&gt; delegate;，为什么用的修饰符是 assign 而不是 weak？其实这个 assign 在 ARC 中意义等同于 __unsafe_unretaied（后面会讲到），它是为了在 ARC 特性下兼容 iOS4 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 weak。&lt;/uitableviewdelegate&gt;&lt;/li&gt;
&lt;li&gt;在 Block 中防止强引用循环。关于 Block 可以看这篇文章的详细探讨：Block&lt;/li&gt;
&lt;li&gt;用来修饰指向由 Interface Builder 创建的控件。比如：@property (weak, nonatomic) IBOutlet UIButton *testButton;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unsafe_unretained 修饰的指针纯粹只是指向对象，没有任何额外的操作，&lt;strong&gt;不会去持有对象使得对象的 retainCount +1。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 nil，所以成为了野指针，非常不安全。&lt;/strong&gt;&lt;br&gt;不安全的修饰符, 附有该修饰符的变量不属于编译器的内存管理对象. 该修饰符与&lt;/strong&gt;weak一样, 是弱引用, &lt;strong&gt;并不能持有对象.并且访问该修饰符的变量时如果不能确保其确实存在, 则应用程序会崩溃!&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __unsafe_unretained obj1 = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj0 = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     obj1 = obj0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;A:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;B:%@&quot;&lt;/span&gt;,obj1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &amp;lt;&lt;span class=&quot;constant&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:ox753e180&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt; &amp;lt;&lt;span class=&quot;constant&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:ox753e180&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;__unsafe_unretained 的应用场景：&lt;/p&gt;
&lt;p&gt;在 ARC 环境下但是要兼容 iOS4.x 的版本，用 &lt;strong&gt;unsafe_unretained 替代 &lt;/strong&gt;weak 解决强引用循环的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__autoreleasing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 ARC 模式下，我们不能显示的使用 autorelease 方法了，但是 autorelease 的机制还是有效的。  &lt;/p&gt;
&lt;p&gt;通过将对象赋给&lt;strong&gt;__autoreleasing&lt;/strong&gt;修饰的变量就能达到在 MRC 模式下调用对象的 autorelease 方法同样的效果。&lt;br&gt;&lt;strong&gt;可理解为, ARC下用@autoreleasepool block代替NSAutoreleasePool类, 用__autoreleasing修饰符的变量代替autorelease方法.&lt;/strong&gt;&lt;br&gt;但是, 显式使用&lt;strong&gt;autoreleasing修饰符跟&lt;/strong&gt;strong一样罕见,&lt;/p&gt;
&lt;p&gt;ps : id的指针或者对象的指针会被隐式附上__autoreleasing修饰符, 如 :&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == id __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 ARC 模式下，显式的使用 __autoreleasing 的场景很少见，但是 autorelease 的机制却依然在很多地方默默起着作用。我们来看看这些场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法返回值。(保证返回时对象没被释放以便方法外的接收方能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 autorelease 机制。)&lt;/li&gt;
&lt;li&gt;访问 &lt;strong&gt;weak 修饰的变量。 ( &lt;/strong&gt;weak 修饰的变量时，实际上必定会访问注册到 Autorelease Pool 的对象,因为 __weak 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 Autorelease Pool 中，就能保证 Autorelease Pool 被销毁前对象是存在的。)&lt;/li&gt;
&lt;li&gt;id 的指针或对象的指针(id &lt;em&gt;)。（所有这种指针的指针类型（id &lt;/em&gt;）的函数参数如果不加修饰符，编译器会默认将他们认定为 &lt;strong&gt;autoreleasing 类型。）【提醒】某些类的方法会隐式地使用自己的 Autorelease Pool，在这种时候使用 &lt;/strong&gt;autoreleasing 类型要特别小心。NSDictionary 的 enumerateKeysAndObjectsUsingBlock 方法：所以要在Block外加　// 加 __block 保证可以在Block内被修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ARC规则&quot;&gt;&lt;a href=&quot;#ARC规则&quot; class=&quot;headerlink&quot; title=&quot;ARC规则&quot;&gt;&lt;/a&gt;ARC规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- 不能使用retain/release/retainCount/autorelease
- 不能使用NSAllocateObject/NSDeallocateObject(alloc实现实际上是通过直接调用NSAllocateObject函数来生成并持有对象, ARC下禁止使用NSAllocateObject函数与NSDeallocateObject函数)
- 需遵循内存管理的方法命名规则
- 不要显示调用dealloc(可以重写dealloc，但是不能调用[super dealloc])
- 使用@autoreleasepool块代替NSAutoreleasePool
- 不能使用区域（NSZone）
- 对象型变量不能作为C语言结构体(struct/union)的成员(可强制转换为void *或者是添加__unsafe__retained修饰符)
- 显示转换id和“void *”（通过__bridge可以id和void *相互转换，__bridge__retain可使要转换赋值的变量也持有所赋值的对象相当于retain，__bridge__transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放相当于release）这些转换也多数适用在OC对象和Core Foundation对象之间的相互转换。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt; &lt;code&gt;@property (nonatomic, strong) NSString *name;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在ARC下, 以下可作为这种属性声明中使用的属性来用.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-24%20%E4%B8%8A%E5%8D%8810.25.04.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;从修饰符也可看出assign和weak的区别，和assign为什么不能修饰对象。&lt;/p&gt;
&lt;h1 id=&quot;ARC的实现&quot;&gt;&lt;a href=&quot;#ARC的实现&quot; class=&quot;headerlink&quot; title=&quot;ARC的实现&quot;&gt;&lt;/a&gt;ARC的实现&lt;/h1&gt;&lt;p&gt;ARC是由编译器+运行时库共同完成的.&lt;/p&gt;
&lt;h3 id=&quot;strong修饰符&quot;&gt;&lt;a href=&quot;#strong修饰符&quot; class=&quot;headerlink&quot; title=&quot;__strong修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__strong修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行. 它是用来持有返回注册在autoreleasepool中对象的方法.这个函数是成对的, 另外一个objc_autoreleaseReturnValue函数则用于alloc/new/copy/mutableCopy方法以外的类方法返回对象的实现上, 如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autoreleaseReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数有什么用?&lt;/p&gt;
&lt;p&gt;可以这样来总结 :&lt;/p&gt;
&lt;p&gt;如果编译器检测到调用autorelease之后又紧接着调用retain的话, 就省略掉autorelease方法的调用. 通过objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数将对象直接传递, 忽略掉多余的操作, 优化程序.&lt;/p&gt;
&lt;h3 id=&quot;weak修饰符&quot;&gt;&lt;a href=&quot;#weak修饰符&quot; class=&quot;headerlink&quot; title=&quot;__weak修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__weak修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;若附有__weak修饰符的变量所引用的对象被废弃, 则将nil赋值给该变量.&lt;/li&gt;
&lt;li&gt;使用附有__weak修饰符的变量, 即是使用注册到autoreleasepool中的对象.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id __weak obj1 = obj&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1 = 0&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, 0)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;访问__weak变量时, 相当于访问注册到autoreleasepool的对象&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = objc_loadWeakRetained(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objc_loadWeakRetained函数取出附有__weak修饰符变量所引用对象并retain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是, 通过&lt;strong&gt;weak变量访问所引用的对象几次, 对象就被注册到autoreleasepool里几次. (将附有&lt;/strong&gt;weak修饰符的变量赋值给附有__strong修饰符的变量后再使用可避免此问题)&lt;/p&gt;
&lt;h3 id=&quot;autoreleasing修饰符&quot;&gt;&lt;a href=&quot;#autoreleasing修饰符&quot; class=&quot;headerlink&quot; title=&quot;__autoreleasing修饰符&quot;&gt;&lt;/a&gt;&lt;strong&gt;__autoreleasing修饰符&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;将对象赋值给附有__autoreleasing修饰符的变量等同于MRC下调用对象的autorelease方法.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么调用alloc/new/&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;/mutableCopy以外的方法会怎样呢?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见注册autorelease的方法没有改变, 仍是objc_autorelease函数&lt;/p&gt;
&lt;h3 id=&quot;如何获取引用计数值&quot;&gt;&lt;a href=&quot;#如何获取引用计数值&quot; class=&quot;headerlink&quot; title=&quot;如何获取引用计数值&quot;&gt;&lt;/a&gt;&lt;strong&gt;如何获取引用计数值&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;获取引用数值的函数&lt;br&gt;uinptr_t _objc_rootRetainCount(id obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSUInteger)retainCount;
该方法返回的引用计数不一定准确, 因为有时系统会优化对象的释放行为, 在保留计数为1的时候就把它回收. 所以你用这个方法打印出来的引用计数可能永远不会出现0. 我们不应该根据retainCount来调试程序!!
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们现在的工程几乎都运行在ARC下, 所以大部分内存管理代码都不需要我们自己写, 而由编译器帮我们搞定. 所以在ARC下我们只需要怎样不要去破坏这个生态即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;避免循环引用(使用__weak修饰符)
遵循ARC方法命名规则
适时清空指针(赋值nil即可, 避免野指针错误)
如用到Core Foundation对象, 则在dealloc方法中释放
在dealloc方法中只释放引用并移除监听(不能在dealloc中开启异步任务)
对于内存开销较大的资源, 如file descriptor, socket, 大块内存等应在不需要使用的时候调用close方法释放掉而不是在dealloc中处理.
适当使用@autoreleasepool block来降低内存峰值(之前我写的一篇文章中有demo)
必要时开启&amp;quot;僵尸对象&amp;quot;调试内存管理问题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;属性与内存管理&quot;&gt;&lt;a href=&quot;#属性与内存管理&quot; class=&quot;headerlink&quot; title=&quot;属性与内存管理&quot;&gt;&lt;/a&gt;属性与内存管理&lt;/h2&gt;&lt;p&gt;@property实际上是getter和setter和ivar，@synthesize是合成这2个方法.&lt;br&gt;@property()，如果你里面什么都不写，那么系统会默认的把你的属性设置为：&lt;br&gt;@property(atomic, assign)….  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于nonatomic&lt;/strong&gt;&lt;br&gt;指定 nonatomic特性，编译器合成访问器的时候不会去考虑线程安全问题。&lt;br&gt;如果你的多个线程在同一时间会访问到这个变量的话，可以将特性声明为 atomic(通过省略关键字nonatomic)。在这种特性的状态下，编辑器在合成访问器的时候就会在访问器里面加一个锁 （@synchronized），在同一时间只能有一个线程访问该变量。&lt;br&gt;但是使用锁是需要付出代价的，一个声明为atomic的属性，在设置和获取这个变量的时候都要比声明为nonatomic的慢。所以如果你不打算编写多线程代码，最好把变量的属性特性声明为nonatomic。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于assign、retain和copy&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign：适用基本数据类型，（不适用于对象）简单赋值，不更改索引计数。&lt;strong&gt;因为assign对于在引用计数下的对象特性，只创建了一个弱引用（也就是平时说的浅复制）。这样使用变量会很危险。&lt;/strong&gt;当你release了前一个对象的时候，被赋值的对象指针就成了无头指针了。因此在为对象类型的变量声明属性的时候，尽量不要使用assign。）&lt;br&gt;retain：适用于普通对象。释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1。&lt;br&gt;copy：适用于NSString与block。建立一个索引计数为1的对象，然后释放旧对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;weak和strong的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;copy与retain的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;copy其实是建立了一个相同的对象，而retain不是；&lt;br&gt;copy是内容拷贝，retain是指针拷贝；&lt;br&gt;copy是内容的拷贝 ,对于像NSString,的确是这样。如果拷贝的是NSArray这时只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;assign和weak的区别；&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;assign是指针赋值，不对引用计数操作，使用之后如果没有置为nil，可能就会产生野指针；&lt;br&gt;weak一旦不进行使用后，永远不会使用了，就不会产生野指针！ 用weak避免循环引用.&lt;br&gt;assign 可以用非 OC 对象,而 weak 必须用于 OC 对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Autorelease-Pool&quot;&gt;&lt;a href=&quot;#Autorelease-Pool&quot; class=&quot;headerlink&quot; title=&quot;Autorelease Pool&quot;&gt;&lt;/a&gt;Autorelease Pool&lt;/h2&gt;&lt;p&gt;一般地，在新建一个iphone 项目的时候，xcode会自动地为你创建一个autorelease pool，这个pool就写在Main函数里面。&lt;br&gt;在NSAutoreleasePool中包含了一个可变数组，用来存储被声明为autorelease的对象。当NSAutoreleasePool自身被销毁的时候，它会遍历这个数组，release数组中的每一个成员（注意，这里只是release，并没有直接销毁对象）。若成员的retain count 大于1，那么对象没有被销毁，造成内存泄露。&lt;br&gt;默认的NSAutoreleasePool只有一个，你可以在你的程序中创建NSAutoreleasePool，被标记为autorelease的对象会跟最近的 NSAutoreleasePool匹配。&lt;br&gt; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];&lt;br&gt;//Create some objects&lt;br&gt;//do something…&lt;br&gt;[pool  release];&lt;br&gt;你也可以嵌套使用NSAutoreleasePool ，就像你嵌套使用for一样。&lt;br&gt;即使NSAutoreleasePool 看起来没有手动release那么繁琐，但是使用NSAutoreleasePool 来管理内存的方法还是不推荐的。因为在一个NSAutoreleasePool 里面，如果有大量对象被标记为autorelease，在程序运行的时候，内存会剧增，直到NSAutoreleasePool 被销毁的时候才会释放。如果其中的对象足够的多，在运行过程中你可能会收到系统的低内存警告，或者直接crash。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;autorelease的具体使用方法：&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象。&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法。&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;RunLoop开始 -&amp;gt; 创建autoreleasepool -&amp;gt; 线程处理事件循环 -&amp;gt; 废弃autoreleasepool -&amp;gt; RunLoop结束 -&amp;gt; 等待下一个Loop开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Autorelease Pool 扩展&lt;/strong&gt;：&lt;br&gt; 如果你极具好奇心，把Main函数中的NSAutoreleasePool代码删除掉，然后再自己的代码中把对象声明为autorelease，你会 发现系统并不会给你发出错误信息或者警告。用内存检测工具去检测内存的话，你可能会惊奇的发现你的对象仍然被销毁了。&lt;br&gt;其实在新生成一个Run Loop的时候，系统会自动的创建一个NSAutoreleasePool ，这个NSAutoreleasePool 无法被删除。&lt;br&gt;在做内存测试的时候，请不要用NSString。OC对字符串作了特殊处理&lt;br&gt;NSString *str =[[NSString alloc] stringWithString:@”123”];&lt;br&gt;在输出str的retain count 的时候，你会发现retain count 大于1。&lt;/p&gt;
&lt;h1 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;内存管理，MRC，ARC的区别；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property 后面可以有哪些修饰符？&lt;br&gt;属性可以拥有的特质分为四类:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;原子性--- nonatomic 特质  
读/写权限---readwrite(读写)、readonly (只读) 
内存管理语义---assign、strong、 weak、unsafe_unretained、copy  
方法名---getter=&amp;lt;name&amp;gt; 、setter=&amp;lt;name&amp;gt;
不常用的：nonnull,null_resettable,nullable
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况使用 weak 关键字，相比 assign 有什么不同？assign为什么不能修饰对象？修饰了对象后会发生什么？  weak为什么比assign安全，其实现原理是怎样的？ weak在它指向的对象被释放后，会被置为nil，该机制是如何实现的；&lt;br&gt;因为assign对于在引用计数下的对象特性，只创建了一个弱引用（也就是平时说的浅复制）。这样使用变量会很危险。当你release了前一个对象的时候，被赋值的对象指针就成了无头指针了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;怎么用 copy 关键字？NSString为什么用的copy，copy和strong有什么区别；&lt;br&gt;NSString，NSArray，NSDictionary，Block使用copy。&lt;br&gt;用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。&lt;br&gt;另一篇：深拷贝和浅拷贝的详解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个写法会出什么问题： @property (copy) NSMutableArray *array;&lt;br&gt;两个问题：1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；&lt;br&gt;2、使用了 atomic 属性会严重影响性能 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？&lt;br&gt;若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property 的本质是什么？&lt;br&gt;@property = ivar + getter + setter;&lt;br&gt;property在runtime中是objc_property_t定义如下:&lt;br&gt;&lt;code&gt;typedef struct objc_property *objc_property_t;&lt;/code&gt;&lt;br&gt;而objc_property是一个结构体，包括name和attributes，定义如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;property_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *attributes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;ivar、getter、setter 是如何生成并添加到这个类中的？&lt;/strong&gt;&lt;br&gt;“自动合成”( autosynthesis).编译器会自动编写访问这些属性所需的方法,在编译期执行.生成了五个东西&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
setter 与 getter 方法对应的实现函数
ivar_list ：成员变量列表
method_list ：方法列表
prop_list ：属性列表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;@protocol 和 category 中如何使用 @property&lt;br&gt;在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性.&lt;br&gt;category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：&lt;br&gt;objc_setAssociatedObject&lt;br&gt;objc_getAssociatedObject&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Category和Extension区别；Category的缺点和优点；如何克服或者弥补这个缺点（不能添加实例变量，用Runtime实现）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Category；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 用于给class及其subclass添加新的方法
- 有自己单独的 .h 和 .m 文件
- 用于添加新方法，而不能添加新属性（property）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Extension&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Extension常被称为是匿名的Category
- 用于给类添加新方法，但只作用于原始类，不作用于subclass
- 只能对有implementation源代码的类写Extension，对于没有implementation源代码的类，比如framework class，是不可以的
- **Extension可以给原始类添加新方法，以及新属性**
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;category 与extension不同在于后者可以添加属性，后者添加的方法也必须是要实现的。extension是私有的category。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Category的缺点和优点：&lt;/strong&gt;&lt;br&gt;    缺陷：一是无法向类中添加新的实例变量。&lt;br&gt;          二是名称冲突，在自己的类别方法名中添加一个前缀，以确保不会发生冲突。&lt;br&gt;    优势：将类的实现代码分散到多个不同文件或框架中，创建对私有方法的前向引用，以及向对象添加非正式协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;runtime 如何实现 weak 属性?（runtime 如何实现 weak 变量的自动置nil？）&lt;br&gt;对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; - (void)setObject:(&lt;span class=&quot;type&quot;&gt;NSObject&lt;/span&gt; *)&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(self, &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;, &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;OBJC_ASSOCIATION_ASSIGN&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cyl_runAtDealloc&lt;/span&gt;:&lt;/span&gt;^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _object = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;weak属性需要在dealloc中置nil么？  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不需要。&lt;br&gt;在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@synthesize和@dynamic分别有什么作用?&lt;br&gt;@synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。&lt;br&gt;@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&lt;br&gt;对应基本数据类型默认关键字是：atomic,readwrite,assign&lt;br&gt;对于普通的 Objective-C 对象：atomic,readwrite,strong&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？&lt;br&gt;使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.&lt;br&gt;如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？不会&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结下 @synthesize 合成实例变量的规则，有以下几点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
如果这个成员已经存在了就不再生成了.
如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：
如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,
如果是 @synthesize foo = _foo; 就不会生成成员变量了.
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？&lt;br&gt;什么情况下不会autosynthesis（自动合成）？就需要使用@synthesize 来手动合成ivar。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;同时重写了 setter 和 getter 时
重写了只读属性的 getter 时
使用了 @dynamic 时
在 @protocol 中定义的所有属性
在 category 中定义的所有属性
重载的属性
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;releasepool被释放了，里面的对象都会被释放吗？过程是怎样的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自动释放池底层怎么实现？&lt;br&gt;自动释放池以队列数组的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;什么情况下会发生内存泄漏和内存溢出？ 如何查看或者检测内存泄露；&lt;br&gt;内存泄露：如果失去了对一个对象的访问权，而又没有将retain count减至0，就会造成内存泄露。不再需要的对象没有释放，导致内存泄露，内存泄露会导致应用闪退。循环引用造成内存不可回收。&lt;br&gt;1&amp;gt;block中使用strong self，如果不注意很容易造成内存泄露&lt;br&gt;2&amp;gt;delegate如果设置为strong也很大可能造成内存泄露，不过具体还要看有没有循环引用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARC是依靠什么实现的？ARC是一种编译时特性还是运行时特性；&lt;br&gt;编译期和运行期两部分共同帮助开发者管理内存。&lt;br&gt;简单来说，编译器在编译代码时，会自动生成实例的引用计数代码，帮助我们完成之前MRC需要完成的工作，不过据说除此之外，编译器也会执行某些优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果自己实现一个setter方法，该如何写代码？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;讲讲Foundation和CoreFoundation之间的区别；CoreFoundation是不支持ARC的，如何与Foundation之间进行转化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Core Foundation框架 (CoreFoundation.framework) 是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能。&lt;br&gt;Foundation框架提供Objective-C接口。  &lt;/p&gt;
&lt;p&gt;CocoaFoundation指针与CoreFoundation指针转换，需要考虑的是所指向对象所有权的归属。ARC提供了3个修饰符来管理。&lt;br&gt;　　1. &lt;strong&gt;bridge，什么也不做，仅仅是转换。此种情况下：&lt;br&gt;　　　　i). 从Cocoa转换到Core，需要人工CFRetain，否则，Cocoa指针释放后， 传出去的指针则无效。&lt;br&gt;　　　　ii). 从Core转换到Cocoa，需要人工CFRelease，否则，Cocoa指针释放后，对象引用计数仍为1，不会被销毁。&lt;br&gt;　　2. &lt;/strong&gt;bridge_retained，转换后自动调用CFRetain，即帮助自动解决上述i的情形。&lt;br&gt;　　3. __bridge_transfer，转换后自动调用CFRelease，即帮助自动解决上述ii的情形。&lt;br&gt;  参考：&lt;a href=&quot;http://www.jianshu.com/p/5c98ac2dab58&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/5c98ac2dab58&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;release如何实现对象释放？autorelease如何实现？两者的区别与联系？release能做的事情autorelease都能做，那么release可不可以舍弃？为什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;release和autorelease区别&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;release立即释放，autorelease不立即释放，先放到autoreleasepool中，当pool结束后自动调用release。&lt;br&gt;一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;dealloc里做哪些操作？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dealloc不remove通知会怎么样?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;atomic一定是线程安全的吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BAD_ACCESS这个bug是如何出现的？&lt;br&gt;野指针。正在使用的对象被释放了，导致野指针，访问野指针导致程序崩溃。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※]objc使用什么机制管理对象内存？—-&lt;strong&gt;引用计数&lt;/strong&gt;&lt;br&gt;通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的 retainCount，如果retainCount 为 0，说明该对象没有地方需要继续使用了，可以释放掉了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]ARC通过什么方式帮助开发者管理内存？&lt;br&gt;ARC的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）&lt;br&gt;UIKit通过CFRunLoopObserve在RunLoop两次sleep间，对Autorelease Pool进行pop和push，将这次loop中产生的autorelease对象释放。&lt;br&gt;如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存不足的产生的例子？如何解决？&lt;br&gt;在for循环中读入大量图片的同时，改变其尺寸。图像文件读入到NSData对象，并从中产生UIImage对象，改变该尺寸后生成新的UIImage对象，这种情况就会产生大量的autorelease的对象。不废弃NSAutoreleasePool对象，那么生成的对象就不能释放，就会产生内存不足。&lt;br&gt;解决：在适当的地方生成、持有或废弃NSAutoreleasePool对象；&lt;br&gt;返回NSMutableArray类的arrayWithCapcity方法。来返回autorelease对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.weak是怎么实现自动设置为nil的？&lt;br&gt;答：当把一个强引用的变量赋值给一个弱引用的变量时， 实际上编译器做了以下几步:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、把__weak变量初始化为0
2、使用__strong变量的地址作为键值，把__weak变量的地址注册到weak表中，weak表是一个散列表
3、如果__strong变量的地址为0，就把对应__weak变量的地址从weak表中删除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用weak表，使用废弃变量的地址作为键值进行检索，就能高速获取对应的附有__weak修饰符的变量的地址。&lt;br&gt;废弃谁都不持有的对象时，编译器进行了如下几步操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1、从weak表中获取废弃对象的地址作为键值的记录
2、将记录中所有weak变量的地址赋值为nil
3、将记录从weak表中删除
4、将废弃对象的地址作为键值的记录从引用计数表中删除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，如果大量的使用附有&lt;strong&gt;weak修饰符的变量，会消耗相应的CPU资源，所以应该只在为了避免循环引用时再使用&lt;/strong&gt;weak修饰符。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/22&quot; alt=&quot;&quot;&gt;&lt;br&gt;参考：&lt;/p&gt;
&lt;p&gt;iOS ARC 内存管理要点&lt;a href=&quot;http://www.samirchen.com/ios-arc/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.samirchen.com/ios-arc/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;深入学习内存管理。理解相关基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://peilinghui.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="iOS面试" scheme="http://peilinghui.com/tags/iOS%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习笔记</title>
    <link href="http://peilinghui.com/2016/06/29/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2016/06/29/ReactiveCocoa学习笔记/</id>
    <published>2016-06-29T08:24:44.000Z</published>
    <updated>2016-07-04T01:40:17.000Z</updated>
    
    <content type="html">&lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;官网文档地址：&lt;a href=&quot;https://github.com/peilinghui/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/ReactiveCocoa&lt;/a&gt;&lt;br&gt;学习一些优秀的博客地址：&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程二&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa简介&quot;&gt;&lt;a href=&quot;#ReactiveCocoa简介&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa简介&quot;&gt;&lt;/a&gt;ReactiveCocoa简介&lt;/h1&gt;&lt;p&gt;ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架.&lt;/p&gt;
&lt;p&gt;ReactiveCocoa结合了几种编程风格：&lt;/p&gt;
&lt;p&gt;函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。&lt;br&gt;响应式编程（Reactive Programming）：关注于数据流和变化传播。&lt;br&gt;ReactiveCocoa就被开发者们描述为响应式函数编程框架(FRP);使用RAC就不需要考虑调用的顺序,直接考虑结果,使得代码高聚合,方便管理.&lt;br&gt;一个优点提供了一个单一的、统一的方法去处理异步的行为，包括delegate方法,blocks回调,target-action机制,notifications和KVO.&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa使用&quot;&gt;&lt;a href=&quot;#ReactiveCocoa使用&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa使用&quot;&gt;&lt;/a&gt;ReactiveCocoa使用&lt;/h1&gt;&lt;h2 id=&quot;RACSiganl-RAC的核心类-信号类-用来数据传递&quot;&gt;&lt;a href=&quot;#RACSiganl-RAC的核心类-信号类-用来数据传递&quot; class=&quot;headerlink&quot; title=&quot;RACSiganl(RAC的核心类):信号类 用来数据传递&quot;&gt;&lt;/a&gt;RACSiganl(RAC的核心类):信号类 用来数据传递&lt;/h2&gt;&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 该信号默认是一个冷信号,当值改变了,也并不会触发改信号,只有订阅了该信号,才会触发改信号.
- 订阅信号的方法: subscribeNext:
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//1.创建一个信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RACSignal *singal = [RACSignal createSignal:^RACDisposable *(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;RACSubscriber&amp;gt; subscriber) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//2. 发送一个信号.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;Signal&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendCompleted];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [RACDisposable disposableWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//信号取消&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;信号被销毁&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//3. 订阅信号 ,激活信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [singal subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//x : 就是信号发送到数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;error:^(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;error = %@&quot;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; completed:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;completed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;a href=&quot;#RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot; class=&quot;headerlink&quot; title=&quot;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;/a&gt;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&lt;/h2&gt;&lt;p&gt;使用场景:通常用来代替代理，有了它，就不必要定义代理了。&lt;br&gt;RACReplaySubject:重复提供信号类，RACSubject的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject与RACSubject区别:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。
- 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。
- 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;RACSubject和RACReplaySubject简单使用&quot;&gt;&lt;a href=&quot;#RACSubject和RACReplaySubject简单使用&quot; class=&quot;headerlink&quot; title=&quot;RACSubject和RACReplaySubject简单使用:&quot;&gt;&lt;/a&gt;RACSubject和RACReplaySubject简单使用:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RACSubject使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
3.发送信号 sendNext:(id)value

**RACSubject:底层实现和RACSignal不一样**
1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。
2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.创建信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSubject *subject = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2.订阅信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第一个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第二个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3.发送信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;1&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSignal不一样，创建信号时没有block。
2.可以先订阅信号，也可以先发送信号。
   2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
   2.2 发送信号 sendNext:(id)value

// RACReplaySubject:底层实现和RACSubject不一样。
// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock

// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。
// 也就是先保存值，在订阅值。

// 1.创建信号
RACReplaySubject *replaySubject = [RACReplaySubject subject];

// 2.发送信号
[replaySubject sendNext:@1];
[replaySubject sendNext:@2];

// 3.订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第一个订阅者接收到的数据%@&amp;quot;,x);
}];

// 订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第二个订阅者接收到的数据%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RACSubject替换代理&lt;br&gt;    // 需求:&lt;br&gt;    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面&lt;br&gt;    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器&lt;/p&gt;
&lt;p&gt;步骤一：在第二个控制器.h，添加一个RACSubject代替代理。&lt;br&gt;@interface TwoViewController : UIViewController&lt;/p&gt;
&lt;p&gt;@property (nonatomic, strong) RACSubject *delegateSignal;&lt;/p&gt;
&lt;p&gt;@end&lt;/p&gt;
&lt;p&gt;步骤二：监听第二个控制器按钮点击&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; TwoViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)&lt;span class=&quot;attribute&quot;&gt;notice&lt;/span&gt;:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通知第一个控制器，告诉它，按钮被点了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 通知代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 判断代理信号是否有值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; (self.delegateSignal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 有值，才需要通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr_selector&quot;&gt;[self.delegateSignal sendNext:nil]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OneViewController&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)btnClick:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TwoViewController *twoVc = [[TwoViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 订阅代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;点击了通知按钮&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 跳转到第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; presentViewController:twoVc animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;替换Target和Action&quot;&gt;&lt;a href=&quot;#替换Target和Action&quot; class=&quot;headerlink&quot; title=&quot;替换Target和Action&quot;&gt;&lt;/a&gt;替换Target和Action&lt;/h2&gt;&lt;h3 id=&quot;TextField的字符变化&quot;&gt;&lt;a href=&quot;#TextField的字符变化&quot; class=&quot;headerlink&quot; title=&quot;TextField的字符变化&quot;&gt;&lt;/a&gt;TextField的字符变化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[self.textFild.rac_textSignal map:^id(id value) {
    NSLog(@&amp;quot;%@&amp;quot;, value);
    return @1;
}] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;, x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;构造的映射块value的值就是控件中的字符变化，根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回text.length，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。&lt;br&gt;&lt;strong&gt;filter&lt;/strong&gt;就是过滤，它可以帮助你筛选出你需要的信号变化。&lt;br&gt;take是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以take 2就是获取前两个信号，skip 2就是跳过前两个。repeat是重复发送信号。&lt;br&gt;&lt;strong&gt;delay&lt;/strong&gt;延时信号，顾名思义，即延迟发送信号.&lt;br&gt;&lt;strong&gt;throttle&lt;/strong&gt;搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。&lt;br&gt;&lt;strong&gt;distinctUntilChanged&lt;/strong&gt;网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。distinctUntilChanged的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。&lt;br&gt;&lt;strong&gt;timeout&lt;/strong&gt;超时信号，当超出限定时间后会给订阅者发送error信号。&lt;br&gt;&lt;strong&gt;ignore&lt;/strong&gt;忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。&lt;/p&gt;
&lt;h3 id=&quot;UIButton的事件的监听&quot;&gt;&lt;a href=&quot;#UIButton的事件的监听&quot; class=&quot;headerlink&quot; title=&quot;UIButton的事件的监听&quot;&gt;&lt;/a&gt;UIButton的事件的监听&lt;/h3&gt;&lt;p&gt;  [[button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {&lt;br&gt;        //这个x就是button,已经知道了类型就可以把id x 修改成UIButton *button&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }]; &lt;/p&gt;
&lt;h3 id=&quot;手势事件&quot;&gt;&lt;a href=&quot;#手势事件&quot; class=&quot;headerlink&quot; title=&quot;手势事件&quot;&gt;&lt;/a&gt;手势事件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UITapGestureRecognizer *tap =[[UITapGestureRecognizer alloc]init];
[[tap rac_gestureSignal] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
[self.view addGestureRecognizer:tap];   
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RAC的通知不需要移除remove observer，因为在rac_add方法中他已经写了remove&lt;/strong&gt;&lt;br&gt;[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];  &lt;/p&gt;
&lt;h3 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h3&gt;&lt;p&gt;//延迟一定时间做某事&lt;br&gt;    [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{&lt;br&gt;        NSLog(@”Ricky”);&lt;br&gt;    }];&lt;br&gt;//每个多长时间调用一次事件&lt;br&gt;    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];&lt;/p&gt;
&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;RACObserve(TARGET, KEYPATH)这种形式，TARGET是监听目标，KEYPATH是要观察的属性值&lt;br&gt;&lt;strong&gt;监听UIScrollView的contentOffset&lt;/strong&gt;&lt;br&gt;UIScrollView *scroller =[[UIScrollView alloc]initWithFrame:CGRectMake(100, 100, 100, 200)];&lt;br&gt;    [self.view addSubview:scroller];&lt;br&gt;    [RACObserve(scroller, contentOffset) subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];   &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt;
    
    </summary>
    
      <category term="RAC" scheme="http://peilinghui.com/categories/RAC/"/>
    
    
      <category term="RAC,学习笔记" scheme="http://peilinghui.com/tags/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS调试技巧</title>
    <link href="http://peilinghui.com/2016/05/14/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://peilinghui.com/2016/05/14/iOS调试技巧/</id>
    <published>2016-05-14T09:50:17.000Z</published>
    <updated>2016-05-23T01:31:21.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;对于bug,我们要合理的假设，找原因；对原因与bug之间的因果关系进行分析。&lt;/p&gt;
&lt;h2 id=&quot;lldb的使用&quot;&gt;&lt;a href=&quot;#lldb的使用&quot; class=&quot;headerlink&quot; title=&quot;lldb的使用&quot;&gt;&lt;/a&gt;lldb的使用&lt;/h2&gt;&lt;p&gt;主要是打断点的时候使用lldb.&lt;/p&gt;
&lt;h3 id=&quot;查看值&quot;&gt;&lt;a href=&quot;#查看值&quot; class=&quot;headerlink&quot; title=&quot;查看值&quot;&gt;&lt;/a&gt;查看值&lt;/h3&gt;&lt;p&gt;1&amp;gt;非对象的值&lt;br&gt;&lt;code&gt;int a = 10;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) p a&lt;br&gt;(原始命令：p = print = expression –)&lt;br&gt;输出：(int)$0 = 10&lt;br&gt;(lldb)p 10 + 10&lt;br&gt;输出：$1 = 20  &lt;/p&gt;
&lt;p&gt;2&amp;gt;对象的值&lt;br&gt;&lt;code&gt;NSString *string = @“Hello，world”;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) po string&lt;br&gt;(原始命令：po = expression -o – = e -o –string)&lt;br&gt;输出：Hello，world  &lt;/p&gt;
&lt;p&gt;注意：清空控制台：command+K  &lt;/p&gt;
&lt;h3 id=&quot;修改变量的值&quot;&gt;&lt;a href=&quot;#修改变量的值&quot; class=&quot;headerlink&quot; title=&quot;修改变量的值&quot;&gt;&lt;/a&gt;修改变量的值&lt;/h3&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第一个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第二个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) e(代表expression表达式) a=11&lt;br&gt;输出：(int) $0 = 11  &lt;/p&gt;
&lt;h3 id=&quot;定义一个变量&quot;&gt;&lt;a href=&quot;#定义一个变量&quot; class=&quot;headerlink&quot; title=&quot;定义一个变量&quot;&gt;&lt;/a&gt;定义一个变量&lt;/h3&gt;&lt;p&gt;(lldb) e int $b = 20&lt;br&gt;(lldb) e int $b + $0&lt;br&gt;输出：(int) $1 = 31&lt;/p&gt;
&lt;h3 id=&quot;调用一个函数&quot;&gt;&lt;a href=&quot;#调用一个函数&quot; class=&quot;headerlink&quot; title=&quot;调用一个函数&quot;&gt;&lt;/a&gt;调用一个函数&lt;/h3&gt;&lt;p&gt;代码中：&lt;br&gt;&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; test]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;test&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;test被调用了&quot;&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(lldb) call [self init]&lt;br&gt;输出：test被调用了&lt;/p&gt;
&lt;h3 id=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;a href=&quot;#函数提前返回，返回一个特定值&quot; class=&quot;headerlink&quot; title=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;/a&gt;函数提前返回，返回一个特定值&lt;/h3&gt;&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; returnValue = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; testReturn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)testReturn&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) thread return 100&lt;br&gt;(lldb) p returnValue&lt;br&gt;输出：(NSInteger) $1 = 0&lt;br&gt;(NSInteger) $2 = 100&lt;/p&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;p&gt;1&amp;gt;继续运行 (相当于控制台第一个按钮)&lt;br&gt;c = continue = process continue&lt;br&gt;2&amp;gt;step over&lt;br&gt;n = next = thread step-over&lt;br&gt;3&amp;gt;step in(跳入函数)&lt;br&gt;s = thread step-in&lt;br&gt;4&amp;gt;step out(跳出函数)&lt;br&gt;finish = thread step-over&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
