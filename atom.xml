<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>向着阳光奔跑</title>
  <subtitle>没有到不了的远方</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://peilinghui.com/"/>
  <updated>2017-02-15T04:42:58.000Z</updated>
  <id>http://peilinghui.com/</id>
  
  <author>
    <name>向阳</name>
    <email>peilinghuibest@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端框架</title>
    <link href="http://peilinghui.com/2017/02/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    <id>http://peilinghui.com/2017/02/15/前端框架/</id>
    <published>2017-02-15T03:08:01.000Z</published>
    <updated>2017-02-15T04:42:58.000Z</updated>
    
    <content type="html">&lt;p&gt;前端框架。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Bootstrap：&quot;&gt;&lt;a href=&quot;#Bootstrap：&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap：&quot;&gt;&lt;/a&gt;Bootstrap：&lt;/h1&gt;&lt;p&gt;简洁，直观，强悍的前端开发框架，让web开发更迅速，简单。&lt;br&gt;2.优点：&lt;br&gt;快速，简单，灵活的栅格系统，小而强大，响应式布局，跨平台等。&lt;br&gt;下载&lt;br&gt;登陆BootStrap的官方网站下载：&lt;a href=&quot;http://getbootstrap.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://getbootstrap.com/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面使用Bootstrap官方提供的模板来设计一个响应式布局。&lt;br&gt;（1）从下载的BootStrap中找出bootstrap.min.css文件复制到项目中。&lt;br&gt;（2）新建一个style.css文件，&lt;/p&gt;
&lt;h1 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h1&gt;&lt;p&gt;React.js是用于构建模块化开发的一个js库。&lt;br&gt;&lt;a href=&quot;http://reactjs.cn/react/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://reactjs.cn/react/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前端框架。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript高级程序设计读书笔记</title>
    <link href="http://peilinghui.com/2017/02/13/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2017/02/13/JavaScript高级程序设计读书笔记/</id>
    <published>2017-02-13T07:37:24.000Z</published>
    <updated>2017-02-15T12:59:51.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章-JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章-JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章 JavaScript简介&quot;&gt;&lt;/a&gt;第一章 JavaScript简介&lt;/h1&gt;&lt;p&gt;JavaScript有下列三个不同的部分组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;核心（ECMAScript），由ECMA-262定义，提供核心语言功能；
文档对象模型（DOM），提供访问和操作网页内容的方法和接口；
浏览器对象模型（BOM），提供与浏览器交互的方法和接口。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMA-262规定的语言组成部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;语法
类型
语句
关键字
保留字
操作符
对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DOM：&lt;br&gt;DOM把真个页面映射为一个多层结点结构。&lt;br&gt;DOM1级：DOM核心和DOM HTML 。目标：映射文档的结构。&lt;br&gt;DOM2级：DOM视图，DOM事件，DOM样式，DOM遍历和范围。&lt;br&gt;DOM3级：以统一方式加载和保存文档的方法。验证文档的方法&lt;br&gt;BOM：&lt;br&gt;处理浏览器窗口和框架。&lt;/p&gt;
&lt;h1 id=&quot;第二章-在HTML中使用JavaScript&quot;&gt;&lt;a href=&quot;#第二章-在HTML中使用JavaScript&quot; class=&quot;headerlink&quot; title=&quot;第二章 在HTML中使用JavaScript&quot;&gt;&lt;/a&gt;第二章 在HTML中使用JavaScript&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;把JavaScript插入到HTML页面中要使用&amp;lt;script&amp;gt;元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：

    在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。
    所有&amp;lt;script&amp;gt;元素都会按照他们在页面中出现的先后顺序依次被解析。在不使用defer和asycn属性的情况下，只有在解析完前面&amp;lt;script&amp;gt;元素中的代码之后，才会开始解析后面的&amp;lt;script&amp;gt;元素中的代码。
    由于浏览器会先解析完不适用defer属性的&amp;lt;script&amp;gt;元素中的代码，然后再解析后面的内容，所以一般应该把&amp;lt;script&amp;gt;元素放在页面最后，即主要内容后面，&amp;lt;/body&amp;gt;标签前面。
    使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照制定它们的顺序执行。
    使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第三章-基本概念&quot;&gt;&lt;a href=&quot;#第三章-基本概念&quot; class=&quot;headerlink&quot; title=&quot;第三章 基本概念&quot;&gt;&lt;/a&gt;第三章 基本概念&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。
与其他语言不同，ECMAScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。
ECMAScript中也有一种复杂的数据结构，即Object类型，该类型是这门语言中所有对象的基础类型。
严格模式为这门语言中容易出错的地方施加了限制。
ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算数操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
ECMAScript从其他语言中借鉴了许多流控制语句，例如if语句、for语句和switch语句等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript中的函数与其他语言中的函数有诸多不同之处。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
实际上，未指定返回值的函数返回的是一个特殊的undefined值。
ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。
由于不存在函数签名的特性，ECMAScript函数不能重载。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;驼峰式大小写格式，标识符是按照下列规则组合起来的一或多个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
其他字符可以是字母、下划线、美元符号或数字。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h2&gt;&lt;p&gt;ECMAScript的变量是松散类型的，使用var操作符定义变量，省略var操作符会创建一个全局变量。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;ECMAScript中有5中简单数据类型：Undefined、Null、Boolean、Number和String。对一个值使用typeof操作符可以检测给定变量的数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Undefined类型&lt;/strong&gt;&lt;br&gt;Undefined只有一个值，即特殊的undefined。使用var声明变量但未对其加以初始化时，变量的值就是undefined。对未初始化的变量执行typeof操作符也会返回undefined。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Null类型&lt;/strong&gt;&lt;br&gt;Null类型是第二个只有一个值的数据类型，这个特殊值时null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;br&gt;该类型只有两个字面值：true和false。&lt;br&gt;虽然Boolean类型字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()，如下例所示：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; message&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; messageAsBoolean&lt;/span&gt; = &lt;span class=&quot;typename&quot;&gt;Boolean&lt;/span&gt;(message);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给出各数据类型及其转换的规则：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-13%20%E4%B8%8B%E5%8D%884.20.09.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种类型使用IEEE754格式来表示整数和浮点数值。
ECMAScript并不能保存世界上所有的数值，它能够表示的最小数值保存在Number.MIN_VALUE中——在大多数浏览器中，这个值时5e-324；对应的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果计算结果超出，正的被转为Infinity，负的被转为-Infinity。想确定一个数是不是有穷的，可以使用isFinity()函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NaN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，任何数值除以0会返回NaN。NaN有两个非同寻常的特点，任何涉及NaN的操作（例如NaN/10）都会返回NaN。其次，NaN与任何值都不相等，包括NaN本身。可以用isNaN()确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值得值会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。例如：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alert(isNaN(NaN));              //true&lt;br&gt;alert(isNaN(10));               //false（10是一个数值）&lt;br&gt;alert(isNaN(“10”));             //false（可以被转换成数值10）&lt;br&gt;alert(isNaN(“blue”));           //false（不能被转换成数值）&lt;br&gt;alert(isNaN(true));             //false（可以被转换成数值1）&lt;/p&gt;
&lt;p&gt;有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个则专门用于把字符串转换成数值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，两者等价。ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
任何字符串的长度都可以通过访问其length属性取得。
把一个值转换为一个字符串有两种方式。一种是使用几乎每个值都有的toString()方法，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数；在不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Object类型&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的对象其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。Object类型是所有它的实例的基础，Object的每个实例都具有下列属性和方法。

    constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。
    hasOwnProperty(propertyName)：用于检测给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(&amp;quot;name&amp;quot;)）。
    isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5章将讨论原型）。
    propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
    toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。
    toString()：返回对象的字符串表示。
    valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;操作符&quot;&gt;&lt;a href=&quot;#操作符&quot; class=&quot;headerlink&quot; title=&quot;操作符&quot;&gt;&lt;/a&gt;操作符&lt;/h2&gt;&lt;p&gt;一元操作符&lt;br&gt;递增操作符     ++&lt;br&gt;递减操作符     –&lt;br&gt;一元加操作符     +&lt;br&gt;一元减操作符     -&lt;br&gt;位操作符&lt;br&gt;按位非     NOT(~)&lt;br&gt;按位与     AND(&amp;amp;)&lt;br&gt;按位或     OR(|)     var result=25 | 3;alert(result);//27&lt;br&gt;按位异或     XOR(^)     var result=25 ^ 3;alert(result);//26&lt;br&gt;左移     &amp;lt;&amp;lt;     var oldValue=2;var newValue=oldValue &amp;lt;&amp;lt; 5;//64&lt;br&gt;有符号的右移     &amp;gt;&amp;gt;     var oldValue=64;var newValue=oldValue &amp;gt;&amp;gt; 5;//2&lt;br&gt;无符号的右移     &amp;gt;&amp;gt;&amp;gt;     var oldValue=-64;var newValue=oldValue &amp;gt;&amp;gt;&amp;gt; 5;//134217726&lt;br&gt;布尔操作符&lt;br&gt;逻辑非     !     alert(!false);//true&lt;br&gt;逻辑与     &amp;amp;&amp;amp;     var result=true &amp;amp;&amp;amp; false;//false&lt;br&gt;逻辑或     ||     var found=true;var result=(found || someUndefinedVariable);//true&lt;br&gt;乘性操作符（略）&lt;br&gt;加性操作符（略）&lt;br&gt;关系操作符（略）&lt;br&gt;条件操作符（略）&lt;br&gt;赋值操作符（略）&lt;br&gt;逗号操作符（略）         &lt;/p&gt;
&lt;p&gt;相等操作符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ECMAScript中的相等操作符由两个等于号（==）表示，不等操作符右叹号后跟等于号（！=）表示。
在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

    如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；
    如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转为数值；
    如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较；

这两个操作符在进行比较时则要遵循下列规则。

    null和undefined是相等的。
    要比较相等性之前，不能将null和undefined转换成其他任何值。
    如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，结果不变。
    如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符没有什么区别。全等操作符（===），不全等操作符（！==）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。&lt;/p&gt;
&lt;h2 id=&quot;语句&quot;&gt;&lt;a href=&quot;#语句&quot; class=&quot;headerlink&quot; title=&quot;语句&quot;&gt;&lt;/a&gt;语句&lt;/h2&gt;&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h1 id=&quot;第四章-变量、作用域和内存问题&quot;&gt;&lt;a href=&quot;#第四章-变量、作用域和内存问题&quot; class=&quot;headerlink&quot; title=&quot;第四章 变量、作用域和内存问题&quot;&gt;&lt;/a&gt;第四章 变量、作用域和内存问题&lt;/h1&gt;&lt;p&gt;JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
引用类型的值是对象，保存在堆内存中；
包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有变量（包括基本类型和引用类型）都存在于一个执行环境（也成为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行环境有全局执行环境（也成为全局环境）和函数执行环境之分；
每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
变量的执行环境有助于确定应该何时释放内存。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有制被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集机制也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，在JavaScript中，String为基本类型，如果有C++或者Java编程经验，会发现这一点不同于以前我们的认知。&lt;/p&gt;
&lt;h1 id=&quot;第五章-引用类型&quot;&gt;&lt;a href=&quot;#第五章-引用类型&quot; class=&quot;headerlink&quot; title=&quot;第五章 引用类型&quot;&gt;&lt;/a&gt;第五章 引用类型&lt;/h1&gt;&lt;h2 id=&quot;Object类型&quot;&gt;&lt;a href=&quot;#Object类型&quot; class=&quot;headerlink&quot; title=&quot;Object类型&quot;&gt;&lt;/a&gt;Object类型&lt;/h2&gt;&lt;p&gt;大多数引用类型值都是Object类型的实例，Object是ECMAScript中使用最多的一个类型。创建Object实例的方式有两种。&lt;br&gt;第一种是使用new操作符后跟Object构造函数，如&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.name = &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.age = &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种是使用对象字面量表示法，如&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;name :&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;age :&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一般来说，访问对象属性时使用的都是点表示法，JavaScript中也可以使用方括号表示法来访问对象的属性。如&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert(person[&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;]);              &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.name);                 &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Array类型&quot;&gt;&lt;a href=&quot;#Array类型&quot; class=&quot;headerlink&quot; title=&quot;Array类型&quot;&gt;&lt;/a&gt;Array类型&lt;/h2&gt;&lt;p&gt;但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示方法&lt;/strong&gt;&lt;br&gt;创建数组的基本方式有两种。&lt;br&gt;第一种是使用Array构造函数，如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值；给构造函数传递值也可以创建数组。如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;span class=&quot;comment&quot;&gt;//空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含三个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; names = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//创建一个包含一个字符串值的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第二种是使用数组字面量表示法。如&lt;/p&gt;
&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;]&lt;span class=&quot;comment&quot;&gt;;//创建一个包含3个字符串的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var names = []&lt;span class=&quot;comment&quot;&gt;;//创建一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含2或3项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var options = [, , , , ,]&lt;span class=&quot;comment&quot;&gt;;//禁忌，会创建一个包含5或6项的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;length属性&lt;/strong&gt;&lt;br&gt;数组length的属性不是只读的，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测数组&lt;/strong&gt;&lt;br&gt;自从ECMAScript3作出规定后，就出现了确定某个对象是不是数组的经典问题。&lt;br&gt;对于一个网页，或者一个全局作用域而言，使用instanceof操作符就能得到满意结果。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数。为了解决这个问题，ECMAScript5新增了Array.isArray()方法。&lt;/p&gt;
&lt;figure class=&quot;highlight sqf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.&lt;span class=&quot;built_in&quot;&gt;isArray&lt;/span&gt;(value)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//对数组执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;转换方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;toLocaleString() :&lt;br&gt;toString() :&lt;br&gt;valueOf() : &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈方法和队列方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript提供了一种让数组的行为类似于其他数据结构的方法。&lt;/p&gt;
&lt;p&gt;实现栈的方式（LIFO）后进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()： 栈中项插入
pop()：栈中项移除
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现队列的方法（FIFO）先进先出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()：向数组末端添加项
shift()：从数组前段取得项
使用unshift()和pop()方法可以模拟队列：从该数组前端添加任意个项，从该数组末端移除项
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重排序方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组中已经存在两个可以直接用来重排序的方法：&lt;br&gt;reverse()和sort()方法。&lt;/p&gt;
&lt;p&gt;reverse()方法会反转数组项的顺序。&lt;/p&gt;
&lt;p&gt;默认情况下，sort()方法按升序排列数组项。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。&lt;br&gt;另外，sort()方法可以接收一个比较函数作为参数。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。实际操作可以根据需要自行定义。如最简单的一个例子&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只需将其作为参数传递给sort()方法即可。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;values.sort(compare);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(values);  &lt;span class=&quot;comment&quot;&gt;//0, 1, 5, 10, 15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另外，对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; - &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h3&gt;&lt;p&gt;ECMAScript为操作已经包含在数组中的项提供了很多内置方法。&lt;/p&gt;
&lt;p&gt;concat()：&lt;br&gt;该方法基于当前数组的所有项创建一个新数组。在没有参数时返回副本，接收参数会添加到数组末尾，如果接收的是数组，则数组每一项添加到末尾。如&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.concat(&lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, [&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;brown&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);  &lt;span class=&quot;comment&quot;&gt;//red, green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//red, green, blue, yellow, black, brown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;slice()：  &lt;/p&gt;
&lt;p&gt;该方法能够基于当前数组的一或多个项创建一个新数组。slice()方法接收一或两个参数，即要返回项的起始和结束位置。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors&lt;/span&gt; = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors2&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; colors3&lt;/span&gt; = colors.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors2);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow, purple&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors3);     &lt;span class=&quot;comment&quot;&gt;//green, blue, yellow&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;splice()：&lt;br&gt;该方法非常强大，用法很多。它的主要用途是向数组的中部插入项，使用方式有3中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;删除：可以删除任意数量的项， 只需指定两个参数：要删除的第一项的位置和要删除的项数。例如，splice(0, 2)会删除数组中的前两项。
插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 0, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会从当前数组的位置2开始插入字符串”red”和”green”。
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需提供三个参数：起始位置、要删除的项数和要插入的项。如果要插入多个项，可以再传入第四、第五，甚至任意多个项。例如splice(2, 1, &amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;)会删除当前数组位置2的项，然后再从当前数组的位置2开始插入字符串”red”和”green”。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。下面的代码展示了上述3中用法：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var removed = colors.splice(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//删除第一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//red, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;orange&quot;&lt;/span&gt;);      &lt;span class=&quot;comment&quot;&gt;//从位置1开始插入两项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, yellow, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//返回的是一个空数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;removed = colors.splice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;purple&quot;&lt;/span&gt;);     &lt;span class=&quot;comment&quot;&gt;//插入两项，删除一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(colors);      &lt;span class=&quot;comment&quot;&gt;//green, red, purple, orange, blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(removed); &lt;span class=&quot;comment&quot;&gt;//yellow, 返回的数组中只包含一项&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;位置方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。不同的是，indexOf()方法从数组的开头向后查找，laseIndexOf()方法则从数组的末尾开始向前查找。&lt;br&gt;这两个方法都返回要查找的项在数组中的位置，没找到返回-1.在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要查找的项必须严格相等。&lt;/p&gt;
&lt;p&gt;var person = {  name: “Nicholas” };&lt;br&gt;var people = [{ name: “Nicholas” }];&lt;/p&gt;
&lt;p&gt;var morePeople = [person];&lt;/p&gt;
&lt;p&gt;alert(people.indexOf(person));          //-1&lt;br&gt;alert(morePeople.indexOf(person));  //0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5为数组定义了5个迭代方法。每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域——影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该想在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。
some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。
forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。
map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上方法都不会修改数组中的包含的值。&lt;/p&gt;
&lt;p&gt;其中，every()和filter()方法最相似。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var everyResult = numbers.every(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(everyResult);     &lt;span class=&quot;comment&quot;&gt;//false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var someResult = numbers.some(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(someResult);      &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;filter()简称为滤波器，作用也有点类似滤波器。可以用来过滤出符合条件项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var filterResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (item &amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(filterResult);            &lt;span class=&quot;comment&quot;&gt;//[3, 4, 5, 4, 3]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;map()可以用来创建包含的项与另一个数组一一对应的项。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var mapResult = numbers.filter(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(mapResult);           &lt;span class=&quot;comment&quot;&gt;//[2, 4, 6, 8, 10, 8, 6, 4, 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;forEach()本质上和使用for循环迭代数组一样。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var numbers = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;numbers.forEach(function(item, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行某些操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;归并方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript5还新增了两个归并数组的方法：reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()从前到后，reduceRight()从后到前。&lt;br&gt;这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。&lt;br&gt;使用reduce()方法可以执行数组中所有值求和操作。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var values = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var sum = values.reduce(function(prev, cur, index, &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; prev + cur;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(sum);     &lt;span class=&quot;comment&quot;&gt;//15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Date类型&quot;&gt;&lt;a href=&quot;#Date类型&quot; class=&quot;headerlink&quot; title=&quot;Date类型&quot;&gt;&lt;/a&gt;Date类型&lt;/h2&gt;&lt;p&gt;创建日期对象，使用new操作符和Date构造函数即可。&lt;/p&gt;
&lt;p&gt;var now = new Date()&lt;/p&gt;
&lt;p&gt;根据特定日期时间创建日期对象，传入该日期毫秒数。为简化计算过程，ECMPScript提供两个方法：Date.parse()和Date.UTC()。&lt;br&gt;Date.parse()接收一个表示日期的字符串。ECMA-262没有定义 Date.parse()应该支持哪种日期格式&lt;br&gt;var someDate = new Date(Date.parse(“May 25, 2004”));&lt;/p&gt;
&lt;p&gt;Date.UTC()方法同样也返回表示日期的毫秒数。 Date.UTC()的参数分别是年份、基于0的月份（0-11）、月中的哪一天、小时数（0-23）、分钟、秒以及毫秒数。前两个参数是必须的，其他默认为0。&lt;/p&gt;
&lt;p&gt;//GMT时间2000年1月1日午夜零时&lt;br&gt;var y2k = new Date(Date.UTC(2000, 0));&lt;/p&gt;
&lt;p&gt;//GMT时间2005年5月5日下午5:55:55&lt;br&gt;var allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));&lt;/p&gt;
&lt;p&gt;Date类型还有一些专门用于将日期格式化为字符串的方法，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toDateString()——以特定于实现的格式显示星期几、月、日和年；
toTimeString()——以特定于时间的格式显示时、分、秒和时区；
toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；
toLocaleTimeString()——以特定于实现的格式显示时、分、秒；
toUTCString()——以特定于实现的格式显示完整的UTC日期。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他相关日期/时间组件方法，可参考w3cschool的JavaScript Date对象.&lt;/p&gt;
&lt;h2 id=&quot;RegExp对象&quot;&gt;&lt;a href=&quot;#RegExp对象&quot; class=&quot;headerlink&quot; title=&quot;RegExp对象&quot;&gt;&lt;/a&gt;RegExp对象&lt;/h2&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。&lt;/p&gt;
&lt;p&gt;var expression = / pattern / flags ;&lt;/p&gt;
&lt;p&gt;其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以表明正则表达式的行为。正则表达式匹配模式支持3个标志。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g：表示全局模式（global），即模式将被用于所有字符串，而非在发现第一个匹配项是立即停止；
i：表示不区分大小写（case-insensitive）模式，即在确定匹配项是忽略模式与字符串的大小写；
m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。&lt;br&gt;关于正则表达式的基本介绍，参考菜鸟教程上的正则表达式教程。&lt;br&gt;另外，关于RegExp对象的介绍，可以参考w3cschool上的JavaScript RegExp对象。在这里，就不赘述了。无论哪一门语言，在对字符串的处理上，正则表达式都是一个强大的工具，一定需要掌握。&lt;/p&gt;
&lt;h2 id=&quot;Function类型&quot;&gt;&lt;a href=&quot;#Function类型&quot; class=&quot;headerlink&quot; title=&quot;Function类型&quot;&gt;&lt;/a&gt;Function类型&lt;/h2&gt;&lt;p&gt;ECMAScript中最特殊的当属函数了，因为，函数实际上是对象，每个函数都是Function类型的实例，而且和其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。&lt;/p&gt;
&lt;p&gt;函数声明与函数表达式&lt;/p&gt;
&lt;p&gt;解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其执行代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。因此，除了什么时候可以通过变量访问函数这一点区别外，函数声明与函数表达式的语法其实是等价的。&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例能够正常运行，因为在代码执行前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的带码后面，JavaScript引擎也能把函数声明提升到顶部。而下例函数表达式则不能运行&lt;/p&gt;
&lt;figure class=&quot;highlight scilab&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(&lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var &lt;span class=&quot;built_in&quot;&gt;sum&lt;/span&gt; = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;没有重载！&lt;/strong&gt;&lt;br&gt;由于函数是对象，函数名实际上是一个指向函数对象的指针，不会与某个函数绑定，这正是ECMAScript中没有函数重载概念的原因。个人理解，除此之外，由于ECMAScript中的变量为松散类型，因此对于传入函数的参数类型无法加以限制，因此无法像C++或者Java那样根据传入参数类型或者数量选择调用函数，这也是造成ECMAScript无法重载的原因之一。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作为返回值的函数&lt;/strong&gt;&lt;br&gt;由于ECMAScript中的函数名本身就是变量，因此函数也可以作为值来使用。即可以作为参数或者返回值。&lt;br&gt;函数作为返回值是极有用的技术，是“闭包”技术的基础之一。&lt;br&gt;比较典型的如数组sort()方法的比较函数，它需要接收两个参数，比较它们的值。可以使假设有一个对象数组，要根据某个对象属性排序，怎么办呢？&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction (propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该函数接收一个属性名，然后根据这个属性名来创建一个比较函数。使用如下&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var data = [&amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Zachary&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;&amp;#125;, &amp;#123;name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, age: &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据name来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Nicholas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data.sort(createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;));&lt;span class=&quot;comment&quot;&gt;//根据age来排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(data[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].name);        &lt;span class=&quot;comment&quot;&gt;//Zachary&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数内部属性（重点）&lt;/strong&gt;&lt;br&gt;在函数内部，有两个特殊的对象：arguments和this。&lt;/p&gt;
&lt;p&gt;arguments的主要用途是保存函数参数，这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。它可以完成函数体与函数名的解耦，如下面这个阶乘函数的应用：&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//与函数名紧紧耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用arguments.callee替代函数名，消除耦合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function factorial (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; &amp;lt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; * arguments.callee (&lt;span class=&quot;built_in&quot;&gt;num&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。如&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; trueFactorial = factorial;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;factorial = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(trueFactiorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));           &lt;span class=&quot;comment&quot;&gt;//120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(factorial(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;));                    &lt;span class=&quot;comment&quot;&gt;//0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数内部另一个特殊对象是this，其行为与Java和C#中的this大致类似。即，this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。如下例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();             &lt;span class=&quot;comment&quot;&gt;//&quot;red&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor = sayColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.sayColor();           &lt;span class=&quot;comment&quot;&gt;//&quot;blue&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;sayColor()在全局域中定义，当在全局域中调用时，this引用的是全局对象window；当把这个函数赋给对象o并调用o.sayColor()是，this引用的是对象o。&lt;/p&gt;
&lt;p&gt;ECMAScript 5也规范化了另一个函数对象的属性：caller。这个属性保存着调用当前函数的函数的引用，如果是在全局域中调用当前函数，它的值为null。使用方式类似于callee，在此不赘述。为了分清arguments.caller和函数的caller属性(不能为函数的caller属性赋值)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数属性和方法（重点）&lt;/strong&gt;&lt;br&gt;ECMAScript中函数是对象，因此也有属性和方法。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个属性：length和prototype。其中，length表示函数希望接收的命名参数的个数；对于ECMAScript中的引用类型来说，prototype是保存他们所有实例方法的真正所在。&lt;br&gt;诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问它们罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用极为重要。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。&lt;/p&gt;
&lt;p&gt;每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。&lt;br&gt;apply()方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//传入arguments对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum2&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;num1, num2&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.apply(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, [num1, num2]);       &lt;span class=&quot;comment&quot;&gt;//传入数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum1(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum2(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));        &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;call()方法与apply()方法的作用相同，他们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。即，在使用call()方法时，传递给函数的参数必须逐个列举出来，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num1 + num2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;callSum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num1, num2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sum.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, num1, num2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(callSum(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;));     &lt;span class=&quot;comment&quot;&gt;//20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;事实上，传递参数并非apply()和call()真正用武之地，它们真正强大的地方是能够扩充函数赖以运行的作用域。对象不需要与方法有任何耦合关系。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor();                     &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);            &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;);          &lt;span class=&quot;comment&quot;&gt;//red&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayColor.call(o);               &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind() 函数的值。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &amp;#123; color: &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.color);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; objectSayColor = sayColor.bind(o);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objectSayColor();           &lt;span class=&quot;comment&quot;&gt;//blue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;基本包装类型&quot;&gt;&lt;a href=&quot;#基本包装类型&quot; class=&quot;headerlink&quot; title=&quot;基本包装类型&quot;&gt;&lt;/a&gt;基本包装类型&lt;/h2&gt;&lt;p&gt;ECMAScript也提供了3个特殊的引用类型：Boolean、Number和String。每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。有点类似于Java的自动拆装箱过程,以String类型为例&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2&lt;/span&gt; = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在访问s1时，访问过程处于读取模式，后台自动完成下列处理：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建String类型的一个实例；
在实例上调用指定的方法；
销毁这个实例。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上三个步骤可以想象成下列代码&lt;/p&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;some text&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2 = s1.substring(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三个步骤同样适用于Boolean和Number类型对应的布尔值和数字值。&lt;br&gt;引用类型与基本包装类型主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前引用域之前一直都保存在内存中。而自动创建的基本包装类型的对象，则只存在一行代码的执行瞬间，然后立即销毁。这意味着不能在运行时为基本类型值添加属性和方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boolean类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Boolean类型是与布尔值对应的引用类型，建议永远不要使用Boolean对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Number类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了继承的方法外，Number类型还提供了一些用于将数值格式化为字符串的方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;toFixed()：按指定小数位返回数值的字符串表示。&lt;/li&gt;
&lt;li&gt;toExponential()：返回以指数表示法表示的数值的字符串形式。&lt;/li&gt;
&lt;li&gt;toPrecision()：返回固定大小格式，也可能返回指数格式，具体规则是看哪种格式比较合适。该方法接收一个参数指定表示数值的所有数字的位数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;String类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符方法&lt;/strong&gt;&lt;br&gt;两个用于访问字符串中特定字符的方法时：charAt()和charCodeAt()。两个方法都接收一个参数，即基于0饿字符位置。charAt()返回指定位置字符，charCodeAt()返回指定位置字符编码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串操作方法&lt;/strong&gt;&lt;br&gt;concat()：&lt;br&gt;用于将一或多个字符串拼接起来，接受任意多个参数。&lt;/p&gt;
&lt;p&gt;slice()、substr()和substring()：&lt;br&gt;这三个方法基于字符串创建新字符串。它们都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substr()的第二个参数指定的是子字符串最后一个字符后面的位置。而substr()的第二个参数指定的则是返回的字符数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。&lt;/p&gt;
&lt;p&gt;当传递的参数是负值时，它们的行为就不尽相同了。其中，slice()方法会将传入的赋值与字符串长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0.最后，substring()方法会把所有负值参数都转换为0.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串位置方法&lt;/strong&gt;&lt;br&gt;有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。前者从前往后搜索，后者反之。&lt;br&gt;两个方法都可接收可选的第二个参数，表明从字符串哪个位置开始搜索。&lt;br&gt;在使用第二个参数的情况下，可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;trim()方法&lt;/strong&gt;&lt;br&gt;该方法创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串大小写转换方法&lt;/strong&gt;&lt;br&gt;ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串的模式匹配方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;match()：&lt;br&gt;在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同。match()只接受一个参数，正则表达式或者RegExp对象。和RegExp对象的exec()方法一样，match()方法会返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串。&lt;/p&gt;
&lt;p&gt;search()：&lt;br&gt;参数与match()方法相同，返回字符串中第一个匹配项的索引，如果没有返回-1。&lt;/p&gt;
&lt;p&gt;replace()：&lt;br&gt;接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换为正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串，想替换所有字符串只能提供一个正则表达式，并且要指定全局（g）标志。&lt;/p&gt;
&lt;p&gt;split()：&lt;br&gt;该方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。&lt;/p&gt;
&lt;p&gt;localeCompare()方法;&lt;br&gt;该方法比较两个字符串，并返回下列值中的一个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
如果字符串等于字符串参数，则返回0；
如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要使实现而定）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;fromCharCode()方法：&lt;/p&gt;
&lt;p&gt;String构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上讲，这个方法与实例方法charCodeAt()执行的是相反的操作。&lt;/p&gt;
&lt;h2 id=&quot;单体内置对象&quot;&gt;&lt;a href=&quot;#单体内置对象&quot; class=&quot;headerlink&quot; title=&quot;单体内置对象&quot;&gt;&lt;/a&gt;单体内置对象&lt;/h2&gt;&lt;p&gt;除了前面介绍的大多数内置对象，例如Object、Array和String.ECMA-262还定义了两个单体内置对象：两个单体内置对象：Global和Math。&lt;/p&gt;
&lt;h3 id=&quot;Global对象&quot;&gt;&lt;a href=&quot;#Global对象&quot; class=&quot;headerlink&quot; title=&quot;Global对象&quot;&gt;&lt;/a&gt;Global对象&lt;/h3&gt;&lt;p&gt;所有在全局作用域中定义的属性和函数，都是Global对象的属性。前面介绍过的isNaN()&lt;br&gt;isFinite()、parseInt()以及parseFloat()，实际上都是Global对象的方法。除此之外，Global对象还包含其他一些方法。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI编码方法&lt;/strong&gt;&lt;br&gt;Global对象的encodeURI()和encodeURIComponent()方法可以对URI（Uniform Resource Indentifiers，通用资源标识符）进行编码，以便发送给浏览器。与这两个方法对象的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval()方法&lt;/strong&gt;&lt;br&gt;eval()是ECMAScript中非常强大的一个方法。它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。&lt;br&gt;当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过eval()执行的代码可以引用在包含环境中定义的变量，例如：&lt;/p&gt;
&lt;p&gt;var msg = “hello world”;&lt;br&gt;eval(“alert(msg)”);     //“hello world”&lt;/p&gt;
&lt;p&gt;变量msg在eval()调用的环境之外定义，但其中调用的alert()仍然能够显示”hello world”。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Global对象的属性&lt;/strong&gt;&lt;br&gt;Global对象的所有属性：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%889.42.36.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window对象&lt;/strong&gt;&lt;br&gt;ECMAScript 虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。&lt;/p&gt;
&lt;h3 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math()对象&quot;&gt;&lt;/a&gt;Math()对象&lt;/h3&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Math对象的属性&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Math对象的方法&lt;/strong&gt;&lt;br&gt;min()和max()确定一组数值中的最小值和最大值，可接受任意多个数值参数.&lt;br&gt;Math对象有三个将小数值舍入为整数的几个方法：Math.ceil()、Math.floor()和Math.round()。&lt;br&gt;Math.random()方法返回大于等于0小于1的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//选择一个介于2到10之间的值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var num = Math.&lt;span class=&quot;built_in&quot;&gt;floor&lt;/span&gt;(Math.random() * &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下函数可以直接指定随机范围（整数）&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;selectFrom&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;lowerValue, upperValue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; choices = upperValue - lowerValue +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.floor(&lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.random() * choices + lowerValue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = selectFrom(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(num);     &lt;span class=&quot;comment&quot;&gt;//介于2和10之间（包括2和10）的一个数值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;其他方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.abs(num)     返回num的绝对值&lt;br&gt;Math.asin(x)     返回x的反正弦值&lt;br&gt;Math.exp(num)     返回Math.E的num次幂&lt;br&gt;     Math.atan(x)     返回x的反正切值&lt;br&gt;Math.log(num)     返回num的自然对数&lt;br&gt;Math.atan2(y,x)     返回y/x的反正切值&lt;br&gt;Math.pow(num, power)     返回num的power次幂&lt;br&gt;Math.cos(x)     返回x的余弦值&lt;br&gt;Math.sqrt(num)     返回num的平方根&lt;br&gt;Math.sin(x)     返回x的正弦值&lt;br&gt;Math.acos(x)     返回x的反余弦值&lt;br&gt;Math.tan(x)     返回x的正切值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小结：
对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：

    引用类型与传统面向对象程序设计中的类相似，但实现不同；
    Object是一个基础类型，其他所有类型都从Object继承了基本的行为；
    Array类型是一组值得有序列表，同时还提供了操作和转换这些值的功能；
    Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
    RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式工功能。

函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。
因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和String。以下是他们共同的特征：

    每个包装类型都映射到同名的基本类型；
    在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据的操作；
    操作基本类型值的语句一经执行完毕，就会立即销毁新创建的对象。

在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;第六章-面向对象的程序设计&quot;&gt;&lt;a href=&quot;#第六章-面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;第六章 面向对象的程序设计&quot;&gt;&lt;/a&gt;第六章 面向对象的程序设计&lt;/h1&gt;&lt;h2 id=&quot;理解对象&quot;&gt;&lt;a href=&quot;#理解对象&quot; class=&quot;headerlink&quot; title=&quot;理解对象&quot;&gt;&lt;/a&gt;理解对象&lt;/h2&gt;&lt;h3 id=&quot;属性类型&quot;&gt;&lt;a href=&quot;#属性类型&quot; class=&quot;headerlink&quot; title=&quot;属性类型&quot;&gt;&lt;/a&gt;属性类型&lt;/h3&gt;&lt;p&gt;ECMAScript中有两种属性：数据属性和访问器属性。&lt;br&gt;&lt;strong&gt;数据属性&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Writable]]：表示能否修改属性的值。
[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置度；写入属性值的时候，把新值保存在这个位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为特定的值。&lt;br&gt;要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对性的特性值。例如：&lt;br&gt;注意，把configurable设置为false，表示不能从对象中删除属性，即一旦把属性定义为不可配置的，就不能再把它变回可配置的了。再调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误：&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//抛出错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(person, &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configurable: &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问器属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问器属性不包含数据值；它们包含一对儿getter和setter函数（不是必需的）。在读取访问器属性是，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。
[[Enumerable]]：表示能否通过for-in循环返回属性。
[[Get]]：在读取属性时调用的函数。
[[Set]]：在写入属性时调用的函数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]、[[Get]]和[[Set]]特性默认值分别是true、true、undefined和undefined。&lt;br&gt;访问器属性不能直接定义，必须使用Object.defineProperty()来定义。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; book = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _year: &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edition: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Object.defineProperty(book, &lt;span class=&quot;string&quot;&gt;&quot;year&quot;&lt;/span&gt;, &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(newValue)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._year = newValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.edition += newValue - &lt;span class=&quot;number&quot;&gt;2004&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;book.year = &lt;span class=&quot;number&quot;&gt;2005&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(book.edition);        &lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置一个属性的值会导致其他属性发生变化。&lt;br&gt;注：_year前面的下划线是一种常用的记号，表示只能通过对象方法访问的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义多个属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5定义了一个Object.defineProperties()，可以通过描述符一次定义多个属性。接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读取属性的特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。方法接受两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据对象，这个对象的属性有configurable、enumerable、writable和value。&lt;/p&gt;
&lt;p&gt;注：在JavaScript中，可以针对任何对象——包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。&lt;/p&gt;
&lt;h2 id=&quot;创建对象&quot;&gt;&lt;a href=&quot;#创建对象&quot; class=&quot;headerlink&quot; title=&quot;创建对象&quot;&gt;&lt;/a&gt;创建对象&lt;/h2&gt;&lt;h3 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h3&gt;&lt;p&gt;解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age, job&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;构造函数模式&quot;&gt;&lt;a href=&quot;#构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;构造函数模式&quot;&gt;&lt;/a&gt;构造函数模式&lt;/h3&gt;&lt;p&gt;像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。我们也可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age, job)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.job = job;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Software Engineer&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Doctor&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;没有显式地创建对象；
直接将属性和方法赋给了this对象；
没有return语句。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其它OO语言，主要是为了区别ECMAScript中的其它函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。&lt;br&gt;要创建Person的新实例，必须使用new操作符。以这种方式调用构造函数实际上经历以下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(1)创建一个新对象；
(2)将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；
(3)执行构造函数中的代码（为这个新对象添加属性）；
(4)返回新对象。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在前面例子的最后，person1和person2分别保存着Person的一个不同实例。这两个对象都有一个constructor（构造函数）属性，该属性指向Person。&lt;br&gt;创建自定义的构造函数意味着将来可以将它的实例标志为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将构造函数当做函数&lt;/strong&gt;&lt;br&gt;任何函数，只要通过new操作符来调用，那它就可以作为构造函数；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造函数的问题&lt;/strong&gt;&lt;br&gt;构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。&lt;/p&gt;
&lt;h3 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h3&gt;&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按照字面意思来理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。即不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中.&lt;/p&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。以上例来说，Person.prototype.constructor指向Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;br&gt;创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。&lt;br&gt;如上图，展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系。其中，Person.prototype指向了原型对象，而Person.prototype.constructor又指回了Person。原型对象中除了包含constructor属性之外，还包括后来添加的其他属性。Person的每个实例——person1和person2都包含了一个内部属性，该属性仅仅指向了Person.prototype；换句话说，它们与构造函数没有直接关系。&lt;/p&gt;
&lt;p&gt;isPrototypeOf()：确定对象原型方法。&lt;br&gt;&lt;code&gt;alert(Person.prototype.isPrototypeOf(person1)); //true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; Object.getPrototypeOf()：ECMAScript 5新增方法。&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt; == Person.prototype)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;  //true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;Object&lt;/span&gt;.getPrototypeOf&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;person1&lt;/span&gt;)&lt;/span&gt;.name)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;; //&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;原型与in操作符&lt;/strong&gt;&lt;br&gt;有两种方式使用in操作符：单独使用何在for-in循环中使用。单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。&lt;/p&gt;
&lt;p&gt;而同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function hasPrototypeProperty(&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;hasOwnProperty&lt;/span&gt;(&lt;/span&gt;name) &amp;amp;&amp;amp; (name in &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。&lt;/p&gt;
&lt;p&gt;Object.keys()：该方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。&lt;/p&gt;
&lt;p&gt;如果想得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更简单的原型语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了减少不必要的输入，从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型的动态性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此对原型对象所做的任何修改都能够立即从实例上反映出来——即使先创建了实例后修改原型也照样如此。但是如果重写了原型对象就会切断现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原生对象的原型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。&lt;/p&gt;
&lt;h3 id=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;a href=&quot;#组合使用构造函数模式和原型模式&quot; class=&quot;headerlink&quot; title=&quot;组合使用构造函数模式和原型模式&quot;&gt;&lt;/a&gt;组合使用构造函数模式和原型模式&lt;/h3&gt;&lt;p&gt;创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。&lt;/p&gt;
&lt;h3 id=&quot;动态原型模式&quot;&gt;&lt;a href=&quot;#动态原型模式&quot; class=&quot;headerlink&quot; title=&quot;动态原型模式&quot;&gt;&lt;/a&gt;动态原型模式&lt;/h3&gt;&lt;p&gt;动态原型模式把所有信息都封装在了构造函数中，而通过构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。&lt;/p&gt;
&lt;h3 id=&quot;寄生构造函数模式&quot;&gt;&lt;a href=&quot;#寄生构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;寄生构造函数模式&quot;&gt;&lt;/a&gt;寄生构造函数模式&lt;/h3&gt;&lt;p&gt;这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。&lt;/p&gt;
&lt;h3 id=&quot;稳妥构造函数模式&quot;&gt;&lt;a href=&quot;#稳妥构造函数模式&quot; class=&quot;headerlink&quot; title=&quot;稳妥构造函数模式&quot;&gt;&lt;/a&gt;稳妥构造函数模式&lt;/h3&gt;&lt;p&gt;所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this；二是不适用new操作符调用构造函数。&lt;/p&gt;
&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;p&gt;许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());    &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码定义了两个类型：SuperType和SubType。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型链的问题&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;原型链虽然强大，可以用它来实现继承，但它也存在一些问题。其一，最主要的问题来自包含引用类型值得原型。包含引用类型值的原型属性会被所有实例共享；而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。&lt;br&gt;原型链的第二个问题是：在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链。&lt;/p&gt;
&lt;h3 id=&quot;借用构造函数&quot;&gt;&lt;a href=&quot;#借用构造函数&quot; class=&quot;headerlink&quot; title=&quot;借用构造函数&quot;&gt;&lt;/a&gt;借用构造函数&lt;/h3&gt;&lt;p&gt;在解决原型中包含引用类型值所带来的问题的过程中，开发人员开始使用一种叫做借用构造函数（constructor stealing）的技术（有时候也叫伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承了SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第7行代码“借调”了超类型的构造函数。通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传递参数&lt;/strong&gt;&lt;br&gt;相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;借用构造函数的问题&lt;/strong&gt;&lt;br&gt;如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。因此，借用构造函数的技术也是很少单独使用的。&lt;/p&gt;
&lt;h3 id=&quot;组合继承&quot;&gt;&lt;a href=&quot;#组合继承&quot; class=&quot;headerlink&quot; title=&quot;组合继承&quot;&gt;&lt;/a&gt;组合继承&lt;/h3&gt;&lt;p&gt;组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//继承属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SupType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.colors.push(&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance1.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green, black&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Nicolas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance1.sayAge();         &lt;span class=&quot;comment&quot;&gt;//29&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;27&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance2.colors);    &lt;span class=&quot;comment&quot;&gt;//&quot;red, blue, green&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayName();        &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instance2.sayAge();         &lt;span class=&quot;comment&quot;&gt;//27&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SuperType构造函数定义了两个属性：name和colors。SuperType的原型定义了一个方法sayName()。SubType构造函数在调用SuperType构造函数时传入了name参数，紧接着又定义了它自己的属性age。然后，将SuperType的实例赋值给SubType的原型，然后又在该新原型上定义了方法sayAge()。这样一来，就可以让两个不同的SubType的原型既分别拥有自己属性——包括colors属性，又可以使用相同的方法了。&lt;br&gt;组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为了JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf()也能够用于识别基于组合继承创建的对象。&lt;/p&gt;
&lt;h3 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;/h3&gt;&lt;p&gt;借助原型可以基于已有的对象创建新对象，同事还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(o)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    F.prototype = o;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; F();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在object()函数内部，先创建了一个临时的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anttherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Rob&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; yetAnotherPerosn&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.name = &lt;span class=&quot;string&quot;&gt;&quot;Linda&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yetAnotherPerson.friends.push(&lt;span class=&quot;string&quot;&gt;&quot;Barbie&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.friends);  &lt;span class=&quot;comment&quot;&gt;//&quot;Shelby, Court, Van, Rob, Barbie&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。其中，person.friends不仅属于person所有，而且也会被anotherPerson以及yetAnotherPerson共享。&lt;br&gt;ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。&lt;br&gt;object.create()方法的第二个参数与object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。&lt;/p&gt;
&lt;h3 id=&quot;寄生式继承&quot;&gt;&lt;a href=&quot;#寄生式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生式继承&quot;&gt;&lt;/a&gt;寄生式继承&lt;/h3&gt;&lt;p&gt;寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是有克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(original)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt; = object(original);    &lt;span class=&quot;comment&quot;&gt;//通过调用函数创建一个新对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;.sayHi = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;       &lt;span class=&quot;comment&quot;&gt;//以某种方式来增强这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(&lt;span class=&quot;string&quot;&gt;&quot;hi&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;clone&lt;/span&gt;;                    &lt;span class=&quot;comment&quot;&gt;//返回这个对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    friends: [&lt;span class=&quot;string&quot;&gt;&quot;Shelby&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Court&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Van&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; anotherPerson = createAnother(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;anotherPerson.sayHi();  &lt;span class=&quot;comment&quot;&gt;//&quot;hi&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的object()函数不是必需的；任何能够返回新对象的函数都适用于此模式。&lt;br&gt;注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。&lt;/p&gt;
&lt;h3 id=&quot;寄生组合式继承&quot;&gt;&lt;a href=&quot;#寄生组合式继承&quot; class=&quot;headerlink&quot; title=&quot;寄生组合式继承&quot;&gt;&lt;/a&gt;寄生组合式继承&lt;/h3&gt;&lt;p&gt;组合继承是JavaScript最常用的继承模式；不过，它也有自己的不足。组合继承最大的问题就是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。子类型最终会包含超类型对象的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);             &lt;span class=&quot;comment&quot;&gt;//第二次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();        &lt;span class=&quot;comment&quot;&gt;//第一次调用SuperType()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.constructor = SubType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第一次调用SuperType()构造函数时，SubType.prototype会得到两个属性：name和colors；它们都是SuperType的实例属性，只不过现在位于SubType的原型中。当调用SubType构造函数时，又会调用一次SuperType构造函数，这一次又在新对象上创建了实例属性name和colors。于是，这两个属性就屏蔽了原型中的两个同名属性。&lt;br&gt;而寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(subType, superType)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; prototype = object(superType.prototype);    &lt;span class=&quot;comment&quot;&gt;//创建对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prototype.constructor = subType;                &lt;span class=&quot;comment&quot;&gt;//增强对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subType.prototype = prototype;                  &lt;span class=&quot;comment&quot;&gt;//指定对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该示例中inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写圆形而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，就可以调用inheritPrototype()函数的语句，去替换前面例子中为子类型原型赋值的语句了。如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.colors = [&lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;green&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name, age)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SuperType.call(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inheritPrototype(SubType, SuperType);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.sayAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该例的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;支持面向对象编程，但不使用类或者接口。在没有类的情况下，可以采用下列模式创建对象：&lt;br&gt;1.工厂模式。使用简单的函数创建对象。为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。&lt;br&gt;2.构造函数模式和，可以创建自定义引用类型，可以向创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。&lt;br&gt;3.原型模式。使用构造函数的prototype属性来者丁那些应该共享的属性和方法。组合使用个构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。&lt;br&gt;JavaScript主要使用原型链实现继承。&lt;strong&gt;原型链的构造是通过将一个类型的实例赋值给另一个构造函数的原型实现的&lt;/strong&gt;。这样，子类型就能访问超卡】类型的所有属性和方法，原型链的问题是对象实例共享所有继承的属性和方法，因此不适合单独使用，解决：借用构造函数，在子类型构造函数的内部调用超类型构造函数。这样就做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。&lt;br&gt;使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。&lt;br&gt;此外，还存在下列可供选择的继承模式：&lt;br&gt;1.原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。&lt;br&gt;2.寄生式继承，与原型式继承分成相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。&lt;br&gt;3.寄生组合式继承，寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;h1 id=&quot;第七章-函数表达式&quot;&gt;&lt;a href=&quot;#第七章-函数表达式&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数表达式&quot;&gt;&lt;/a&gt;第七章 函数表达式&lt;/h1&gt;&lt;p&gt;定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;functionName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; functionName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg0, arg1, arg2)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//函数体&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h2&gt;&lt;p&gt;递归函数是在一个函数通过名字调用自身的情况下构成的。为了和函数名称解耦，arguments.callee来表示正在执行的函数的指针，因此可以用它来实现对函数的递归调用，&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num * arguments.callee(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但在严格模式下，不能通过脚本访问arguments.callee，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。如：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var factorial = (&lt;span class=&quot;function&quot;&gt;function &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;num * &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(num-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个名为f()的命名函数表达式，然后将它赋值给factorial。即便把函数赋值给了另一个变量，函数的名字f仍然有效，所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通。&lt;/p&gt;
&lt;h2 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; title=&quot;闭包&quot;&gt;&lt;/a&gt;闭包&lt;/h2&gt;&lt;p&gt;不少开发人员总是搞不清匿名函数和闭包这两个概念。&lt;br&gt;&lt;strong&gt;闭包是指有权访问另一个函数作用域中的变量的函数。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;而匿名函数是指没有函数名称的函数。&lt;/strong&gt;&lt;br&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，以前面createComparisonFunction()函数为例：&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(propertyName) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; createComparisonFunction(&lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了彻底理解闭包，了解如何创建作用域链以及作用域链有什么作用十分重要。当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用arguments和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。&lt;br&gt;在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。&lt;/p&gt;
&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; compare(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;gt;&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var result = compare(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码先定义了compare()函数，然后又在全局作用域中调用了它。当第一次调用compare()时，会创建一个包含this、arguments、value1和value2的活动对象。全局执行环境的变量对象（包含this、result和compare）在compare()执行环境的作用域链中则处于第二位。下图展示了包含上述关系的compare()函数执行时的作用域链。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.06.51.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像compare()函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。 &lt;/p&gt;
&lt;p&gt;无论什么时候在函数中访问一个变量时，都会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。&lt;br&gt;在另一个函数内部定义的函数将会包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在createComparisonFunction()函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数createComparisonFunction()的活动对象。下图展示了当下列代码执行时，包含函数与内部匿名函数的作用域链。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compare = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compare(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在匿名函数从createComparisFunction()中返回后，它的作用域链被初始化为包含createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在createComparisonFunction()中定义的所有变量。更为重要的是，createComparisonFunction()函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当createComparisonFunction()函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；知道匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; compareNames = createComparisonFunction(&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = compareNames(&amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt; &amp;#125;, &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//解除对匿名函数的引用（以便释放内存）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compareNames = null;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先，创建的比较函数被保存在变量compareNames中。而通过将compareNames设置为等于null解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域链（除了全局作用域）也都可以安全地销毁了。下图展示了调用compareNames()的过程中产生的作用域链之间的关系。&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%886.12.48.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭包与变量&quot;&gt;&lt;a href=&quot;#闭包与变量&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的值。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数会返回一个函数数组，而其中的每个函数都返回10。&lt;br&gt;我们可以通过创建另一个匿名函数强制让闭包的行为符合预期。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function createFunctions() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt; = new &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //匿名函数直接赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;[i] = function(num) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;result&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于this对象&quot;&gt;&lt;a href=&quot;#关于this对象&quot; class=&quot;headerlink&quot; title=&quot;关于this对象&quot;&gt;&lt;/a&gt;关于this对象&lt;/h3&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，因此其this对象通常指向window。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;The Window&quot;（在非严格模式下）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;getNameFunc()返回一个匿名函数，因此object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串”The Window”。而如果访问object的属性，就需要把外部作用域中的this对象保存在一个闭包能够访问到的变量里。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;The Window&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; object = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;My Object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getNameFunc: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; that = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; that.name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(object.getNameFunc()());  &lt;span class=&quot;comment&quot;&gt;//&quot;My Object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在定义匿名函数之前，我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量。即使在函数返回之后，that也仍然引用着object，所以调用object.getNameFunc()()就返回了”My Object”。&lt;/p&gt;
&lt;p&gt;每个函数在被调用时都会自动取得两个特殊变量：this和arguments。如果想访问作用域中的arguments对象，同样的，必须将该对象的引用保存到另一个闭包能够访问到的变量中。&lt;/p&gt;
&lt;h3 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h3&gt;&lt;p&gt;由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集例程，因此闭包在IE的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML元素，那么就意味着该元素将无法被销毁。例如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(element.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码创建了一个作为element元素事件处理程序的闭包，而这个闭包则又创建了一个循环引用。由于匿名函数保存了一个对assingHandler()的活动对象的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element的引用数至少也是1，因此它所占用的内存就永远不会被回收。不过，可以通过该写代码来解决，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//防止内存泄露&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assignHandler&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; element = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;someElement&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id = element.id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element.onclick = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    element = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码中，通过把element.id的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。必须要记住：闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭包不直接引用element，包含函数的活动对象中也仍然会保存一个应用。因此，有必要把element变量设置为null。这样就能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。&lt;/p&gt;
&lt;h2 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h2&gt;&lt;p&gt;JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，他会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。&lt;br&gt;用作块级作用域（通常称为私用作用域）的匿名函数的语法如下所示。&lt;/p&gt;
&lt;figure class=&quot;highlight delphi&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//立即调用函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里是块级作用域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码定义并立即调用了一个匿名函数。&lt;br&gt;函数表达式的后面可以跟圆括号。因此，这里通过给函数声明加上一对圆括号将其转换成函数表达式。&lt;/p&gt;
&lt;p&gt;无论在什么地方，只要临时需要一些变量，就可以使用私有作用域，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;outputNumbers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(count)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(i);    &lt;span class=&quot;comment&quot;&gt;//导致一个错误！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个有很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。&lt;/p&gt;
&lt;h2 id=&quot;私有变量&quot;&gt;&lt;a href=&quot;#私有变量&quot; class=&quot;headerlink&quot; title=&quot;私有变量&quot;&gt;&lt;/a&gt;私有变量&lt;/h2&gt;&lt;p&gt;严格来讲，JavaScript中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其它函数。&lt;br&gt;如果在函数内部创建闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。&lt;br&gt;我们把有权访问私有变量和私有函数的公有方法成为&lt;strong&gt;特权方法&lt;/strong&gt;（privileged method）。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法，基本模式如下。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式在构造函数内部定义了所有私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。&lt;br&gt;利用私有和特权成员，可以隐藏那些不应该被直接修改的数据，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nihcholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person.getName());    &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码的构造函数中定义了两个特权方法：getName()和setName()。这两个方法都可以在构造函数外部使用，而且都有权访问私有变量name。但在Person构造函数外部，没有任何办法访问name。&lt;br&gt;构造函数定义特权方法也有一个缺点，就是必须使用构造函数模式来达到这个目的。而构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。&lt;/p&gt;
&lt;h3 id=&quot;静态私有变量&quot;&gt;&lt;a href=&quot;#静态私有变量&quot; class=&quot;headerlink&quot; title=&quot;静态私有变量&quot;&gt;&lt;/a&gt;静态私有变量&lt;/h3&gt;&lt;p&gt;通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公有/特权方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MyObject.prototype.publicMethod = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明MyObject时使用var关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此，MyObject就成了一个全局变量，能够在私有作用域之外被访问到。但是严格模式下将会报错。&lt;br&gt;这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototye.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Person.prototype.setName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Nicholas&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;person1.setName(&lt;span class=&quot;string&quot;&gt;&quot;Greg&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Greg&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;Michael&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person1.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(person2.getName());   &lt;span class=&quot;comment&quot;&gt;//&quot;Michael&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中的Person构造函数与getName()和setName()方法一样，都有权访问私有变量name。在这种模式下，变量name就变成了一个静态的、由所有实例共享的属性。也就是说，在一个实例上调用setName()会影响所有实例。而调用setName()或创建一个Person实例都会赋予name属性一个新值。结果就是所有实例都会返回相同的值。&lt;br&gt;以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。&lt;/p&gt;
&lt;h3 id=&quot;模块模式&quot;&gt;&lt;a href=&quot;#模块模式&quot; class=&quot;headerlink&quot; title=&quot;模块模式&quot;&gt;&lt;/a&gt;模块模式&lt;/h3&gt;&lt;p&gt;前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）则是为单例创建私有变量和特权方法。所谓单例（singleton），指的就是只有一个实例的对象。按照惯例，JavaScript是以字面量的方式来创建单例对象的。&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name : value,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;method&lt;/span&gt; : function() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //这里是方法的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法格式如下：&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; singleton = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和私有函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; privateVariable = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;privateFunction&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//特权/公有方法和属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicProperty: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        publicMethod: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            privateVariable++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; privateFunction();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; application = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//私有变量和函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; components = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    components.push(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaseComponent());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//公共&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getComponentCount : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; components.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerComponent : &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; component == &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                components.push(component);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的application对象。在创建这个对象的过程中，首先声明了一个私有的components数组，并向数组中添加了一个BaseComponent的新实例（在这里不需要关心BaseComponent的代码，我们只是用它来展示初始化操作）。而返回对象的getComponentCount()和registerComponent()方法，都是有权访问数组components的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。&lt;br&gt;简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是object的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用instanceof操作符来检查其对象类型了。&lt;/p&gt;
&lt;h3 id=&quot;增强的模块模式&quot;&gt;&lt;a href=&quot;#增强的模块模式&quot; class=&quot;headerlink&quot; title=&quot;增强的模块模式&quot;&gt;&lt;/a&gt;增强的模块模式&lt;/h3&gt;&lt;p&gt;有人进一步改进了模块模式，即在返回对象之前加入对其增强的代码。这种增强的模块模式是和那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况。&lt;/p&gt;
&lt;h2 id=&quot;小结：&quot;&gt;&lt;a href=&quot;#小结：&quot; class=&quot;headerlink&quot; title=&quot;小结：&quot;&gt;&lt;/a&gt;小结：&lt;/h2&gt;&lt;p&gt;在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫作匿名函数；
在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
递归函数应该始终使用argument.callee来递归调用自身，不要使用函数名——函数名可能会发生变化。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当函数内部定义了其它函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域；
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁；
但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;闭包还可以用于在对象中创建私有变量，相关概念和要点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;及时JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量；
有权访问私有变量的公有方法叫做特权方法；
可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用块级模式、增强的模块模式来实现单例的特权方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。&lt;/p&gt;
&lt;h1 id=&quot;BOM&quot;&gt;&lt;a href=&quot;#BOM&quot; class=&quot;headerlink&quot; title=&quot;BOM&quot;&gt;&lt;/a&gt;BOM&lt;/h1&gt;&lt;h2 id=&quot;Window对象&quot;&gt;&lt;a href=&quot;#Window对象&quot; class=&quot;headerlink&quot; title=&quot;Window对象&quot;&gt;&lt;/a&gt;Window对象&lt;/h2&gt;&lt;p&gt;window有双重的角色，既可以通过JavaScript访问浏览器窗口的接口，又是ECMAScript规定的Global对象。&lt;/p&gt;
&lt;h3 id=&quot;全局作用域&quot;&gt;&lt;a href=&quot;#全局作用域&quot; class=&quot;headerlink&quot; title=&quot;全局作用域&quot;&gt;&lt;/a&gt;全局作用域&lt;/h3&gt;&lt;p&gt;由于window对象同时扮演者ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会成为window对象的属性和方法。&lt;/p&gt;
&lt;p&gt;定义全局变量与在window对象上直接定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上的定义的属性更可以删除。&lt;br&gt;尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在 ，&lt;/p&gt;
&lt;h3 id=&quot;窗口关系及框架&quot;&gt;&lt;a href=&quot;#窗口关系及框架&quot; class=&quot;headerlink&quot; title=&quot;窗口关系及框架&quot;&gt;&lt;/a&gt;窗口关系及框架&lt;/h3&gt;&lt;p&gt;如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中。&lt;br&gt;每个window对象都有一个name属性，其中包含框架的名称。&lt;br&gt;top对象始终指向最高（最外）层的框架，也就是浏览器窗口。&lt;br&gt;与top相对的另一个window对象是parent。parent（父）对象始终指向当前框架的直接上层框架，在没有框架的情况下，parent一定等于top，此时它们都等于window。&lt;/p&gt;
&lt;h3 id=&quot;窗口的位置&quot;&gt;&lt;a href=&quot;#窗口的位置&quot; class=&quot;headerlink&quot; title=&quot;窗口的位置&quot;&gt;&lt;/a&gt;窗口的位置&lt;/h3&gt;&lt;p&gt;使用如下代码可以取得窗口左边和上边的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; leftPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenLeft : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenX;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; topPos = (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop == &lt;span class=&quot;string&quot;&gt;&quot;number&quot;&lt;/span&gt;) ? &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenTop : &lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.screenY;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;moveTo():接收新位置的x,y坐标值&lt;/p&gt;
&lt;p&gt;moveBy():接收在水平和垂直方向上移动的像素数&lt;/p&gt;
&lt;h3 id=&quot;窗口大小&quot;&gt;&lt;a href=&quot;#窗口大小&quot; class=&quot;headerlink&quot; title=&quot;窗口大小&quot;&gt;&lt;/a&gt;窗口大小&lt;/h3&gt;&lt;p&gt;四个浏览器都提供了四个属性: innerWidth,innerHeight,outerWidth,outerHeight.&lt;/p&gt;
&lt;p&gt;resizeTo():接收浏览器窗口的新宽度和新高度&lt;/p&gt;
&lt;p&gt;resizeBy():接收新窗口与原窗口的宽度和高度之差&lt;/p&gt;
&lt;p&gt;innerWidth和innerHeight表示该容器中页面视图区的大小&lt;/p&gt;
&lt;h3 id=&quot;导航和打开新窗口&quot;&gt;&lt;a href=&quot;#导航和打开新窗口&quot; class=&quot;headerlink&quot; title=&quot;导航和打开新窗口&quot;&gt;&lt;/a&gt;导航和打开新窗口&lt;/h3&gt;&lt;p&gt;使用window.open( )方法既可以导航到一个特定的URL，也可以打开一个新的浏览器窗口。接收4个额参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况边使用。&lt;/p&gt;
&lt;h3 id=&quot;间歇调用和超时调用&quot;&gt;&lt;a href=&quot;#间歇调用和超时调用&quot; class=&quot;headerlink&quot; title=&quot;间歇调用和超时调用&quot;&gt;&lt;/a&gt;间歇调用和超时调用&lt;/h3&gt;&lt;p&gt;javascript是单线程语言，它允许设置超时值和间歇时间来调度代码在特定时刻执行。&lt;br&gt;超时调用需要使用window对象的setTimeout()方法，它接受两个参数，要执行的代码以及毫秒。&lt;/p&gt;
&lt;p&gt;间歇调用会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。传递参数，与用法同setTimeout( )。也会返回一个间歇调用ID，该ID用来取消。也可使用clearInterval( )方法并传入相应的间歇调用ID。取消间歇调用的重要性远高于取消超时调用。可使用超时调用来模拟接卸调用。&lt;/p&gt;
&lt;h3 id=&quot;系统对话框&quot;&gt;&lt;a href=&quot;#系统对话框&quot; class=&quot;headerlink&quot; title=&quot;系统对话框&quot;&gt;&lt;/a&gt;系统对话框&lt;/h3&gt;&lt;p&gt;浏览器通过alert( )、confirm( )和prompt( )方法可以调用系统该对话框向用户显示消息。它们的而外观由操作系统及浏览器设置决定，而不是由CSS决定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;调用alert()方法的结果就是向用户显示一个系统对话框，其中更包含指定的文本和一个“ok/确定”按钮。

调用confirm( )，点击了OK返回true，点击了cancel或右上角的x按钮，返回false。

prompt( )方法接收两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。用户单击ok按钮，则prompt( )返回文本输入域的值，如果单击了Cancel或没有单击OK而是通过其他方式关闭了对话框，则该方法返回null。
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;location对象&quot;&gt;&lt;a href=&quot;#location对象&quot; class=&quot;headerlink&quot; title=&quot;location对象&quot;&gt;&lt;/a&gt;location对象&lt;/h2&gt;&lt;p&gt;location对象也是BOM对象，提供了与当前窗口中加载的文档有关的信息，还提供一些导航功能。事实上，location对象是一个特殊的对象，因为它既是window对象的属性，也是document对象的属性，即window.location和document.location引用的是同一个对象。location对象不仅保存着当前文档的信息，还将URL解析为独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;查询字符串参数&quot;&gt;&lt;a href=&quot;#查询字符串参数&quot; class=&quot;headerlink&quot; title=&quot;查询字符串参数&quot;&gt;&lt;/a&gt;查询字符串参数&lt;/h3&gt;&lt;p&gt;location.search返回从问号到URL末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。  &lt;/p&gt;
&lt;h3 id=&quot;位置操作&quot;&gt;&lt;a href=&quot;#位置操作&quot; class=&quot;headerlink&quot; title=&quot;位置操作&quot;&gt;&lt;/a&gt;位置操作&lt;/h3&gt;&lt;p&gt;用location对象改变浏览器位置的多种方式：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;location.assign(&amp;quot;http://www.wrox.com&amp;quot;);  
window.location=&amp;quot;htttp://www.wrox.com&amp;quot;;  
location.href=&amp;quot;htttp://www.wrox.com&amp;quot;;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 还可以修改location对象的其他属性来改变当前加载的页面，任何一种方式修改URL之后，页面都会以新URL重新加载，浏览器的历史记录就会生成一条新记录。调用replace( )方法，将禁用此种行为，用户回不到前一个页面。&lt;/p&gt;
&lt;p&gt;  reload( )方法的作用格式重新加载当前显示的页面。如果没有传递参数，页面就会以最有效的方式重新加载，一般会从浏览器缓存中重新加载，如果要强制从服务器重新加载，则需要向该方法传递参数true。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;&lt;a href=&quot;#navigator对象&quot; class=&quot;headerlink&quot; title=&quot;navigator对象&quot;&gt;&lt;/a&gt;navigator对象&lt;/h2&gt;&lt;p&gt;navigator对象是识别客户端浏览器的事实标准，其属性通常用于检测显示网页的浏览器类型。&lt;/p&gt;
&lt;h3 id=&quot;检测插件&quot;&gt;&lt;a href=&quot;#检测插件&quot; class=&quot;headerlink&quot; title=&quot;检测插件&quot;&gt;&lt;/a&gt;检测插件&lt;/h3&gt;&lt;p&gt;navigator.plugins[]表示浏览器所用的插件的集合。&lt;br&gt;name: 插件的名字&lt;/p&gt;
&lt;p&gt;description:插件的描述&lt;/p&gt;
&lt;p&gt;filename:插件的文件名&lt;/p&gt;
&lt;p&gt;length:插件所处理的MIME类型数量&lt;/p&gt;
&lt;h3 id=&quot;注册处理程序&quot;&gt;&lt;a href=&quot;#注册处理程序&quot; class=&quot;headerlink&quot; title=&quot;注册处理程序&quot;&gt;&lt;/a&gt;注册处理程序&lt;/h3&gt;&lt;p&gt;FireFox 2.0为navigator新增registerContentHandler 和 registerProtocolHandler 的方法。(这两个方法在html5中有定义)。这两个方法可以让一个站点指明它可以处理特定类型的信息。&lt;/p&gt;
&lt;p&gt;registerContentHandler接受三个参数：要处理的MIME类型、可以处理该MIME类型的页面的URL以及应用程序的名字。&lt;/p&gt;
&lt;p&gt;navigator.registerContentHandler(‘application/rss+xml’, ‘&lt;a href=&quot;http://www.sohu.com?feed=%s’&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.sohu.com?feed=%s’&lt;/a&gt;, ‘some Reader’);&lt;/p&gt;
&lt;p&gt;FireFox 2.0 虽然实现了registerProtocolHandler，但该方法还不能用。&lt;/p&gt;
&lt;h2 id=&quot;screen对象&quot;&gt;&lt;a href=&quot;#screen对象&quot; class=&quot;headerlink&quot; title=&quot;screen对象&quot;&gt;&lt;/a&gt;screen对象&lt;/h2&gt;&lt;p&gt;screen 用处不是很大，主要存储浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含着各不相同的属性&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;&lt;a href=&quot;#history对象&quot; class=&quot;headerlink&quot; title=&quot;history对象&quot;&gt;&lt;/a&gt;history对象&lt;/h2&gt;&lt;p&gt;history.go(-1) | history.back(); //后退一页&lt;/p&gt;
&lt;p&gt;history.go(1) | history.forward();//前进一页&lt;/p&gt;
&lt;p&gt;history.go(n);//前进n页&lt;/p&gt;
&lt;p&gt;history.go(‘sohu.com’);//跳转到最后的sohu页面&lt;/p&gt;
&lt;p&gt;history还有一个length属性，保存着历史记录的数量。如果history.lenght 等于 0,那么应该是用户打开窗口后的第一个页面.back( )和forward( )代替go( )。&lt;/p&gt;
&lt;h1 id=&quot;第9章，客户端检测&quot;&gt;&lt;a href=&quot;#第9章，客户端检测&quot; class=&quot;headerlink&quot; title=&quot;第9章，客户端检测&quot;&gt;&lt;/a&gt;第9章，客户端检测&lt;/h1&gt;&lt;p&gt;尽量不使用客户端检测。先设计最通用的方案，再使用特定的浏览器方法增强该方案&lt;/p&gt;
&lt;h2 id=&quot;能力检测&quot;&gt;&lt;a href=&quot;#能力检测&quot; class=&quot;headerlink&quot; title=&quot;能力检测&quot;&gt;&lt;/a&gt;能力检测&lt;/h2&gt;&lt;p&gt;检测浏览器是否具备某一能力。&lt;/p&gt;
&lt;p&gt;尽可能使用typeof进行能力检测，对所要使用的函数或者属性进行是否符合预期的检测，可以降低出错的风险&lt;/p&gt;
&lt;p&gt;并不需要知道用户使用的是什么浏览器，只需要知道用户的浏览器是否具备某些开发所需的功能即可，毕竟浏览器的功能是会改变的，并不能保证现在独有的属性未来不会有其他浏览器实现。&lt;/p&gt;
&lt;h2 id=&quot;怪癖检测&quot;&gt;&lt;a href=&quot;#怪癖检测&quot; class=&quot;headerlink&quot; title=&quot;怪癖检测&quot;&gt;&lt;/a&gt;怪癖检测&lt;/h2&gt;&lt;p&gt;检测浏览器的特殊行为，与能力检测类似，不过，怪癖检测是想要知道浏览器存在什么缺陷。&lt;/p&gt;
&lt;h2 id=&quot;用户代理检测&quot;&gt;&lt;a href=&quot;#用户代理检测&quot; class=&quot;headerlink&quot; title=&quot;用户代理检测&quot;&gt;&lt;/a&gt;用户代理检测&lt;/h2&gt;&lt;p&gt;通过检测用户代理字符串来确定实际使用的浏览器。在每一次的http请求过程中，用户代理字符串是作为响应首部发送的，可以通过js的navigator.userAgent属性访问。这服务端这是常见而广为接受的做法，客户端是万不得已的做法。&lt;br&gt;识别呈现引擎&lt;/p&gt;
&lt;p&gt;注意检测五大呈现引擎：IE，Gecko，WebKit，KHTML和Opera&lt;/p&gt;
&lt;p&gt;注意识别顺序Opera，WebKit，KHTML，Gecko，IE，前一个引擎有包含后一个引擎的某些属性，顺序错误将不能正确识别&lt;br&gt;识别浏览器&lt;br&gt;识别平台&lt;br&gt;识别windows操作系统&lt;br&gt;识别移动设备&lt;br&gt;识别游戏系统&lt;br&gt;完整的用户代理检测代码&lt;/p&gt;
&lt;h1 id=&quot;第10章-DOM&quot;&gt;&lt;a href=&quot;#第10章-DOM&quot; class=&quot;headerlink&quot; title=&quot;第10章 DOM&quot;&gt;&lt;/a&gt;第10章 DOM&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;JavaScript高级程序设计读书笔记&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Quartz2D的使用</title>
    <link href="http://peilinghui.com/2016/12/20/Quartz2D%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://peilinghui.com/2016/12/20/Quartz2D的使用/</id>
    <published>2016-12-20T03:45:17.000Z</published>
    <updated>2017-02-21T01:08:02.000Z</updated>
    
    <content type="html">&lt;p&gt;Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统，在App中需要绘制各种之定义的UI就需要用到这个，例如在淘宝或者百度外卖的头部的波浪线的使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Quartz 2D能绘制图形 : 线条\三角形\矩形\圆\弧等.&lt;br&gt;裁剪图片、手势解锁、自定义UIView控件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图形上下文（Graphics Context)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是一个CGContextRef类型的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图形上下文的作用:保存绘图信息、绘图状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;决定绘制的输出目标（绘制到什么地方去？）&lt;br&gt;（输出目标可以是PDF文件、Bitmap或者显示器的窗口上）&lt;/p&gt;
&lt;p&gt;绘制好的图形——-保存到—–&amp;gt;图形上下文—-输出—&amp;gt;目标&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相同的一套绘图序列，指定不同的Graphics Context，就可将相同的图像绘制到不同的目标上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Quartz2D提供了以下几种类型的Graphics Context：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Bitmap Graphics Context
PDF Graphics Context
Window Graphics Context
Layer Graphics Context
Printer Graphics Context
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如何利用Quartz2D自定义UI控件？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如何利用Quartz2D绘制东西到view上？&lt;br&gt;首先，得有图形上下文，因为它能保存绘图信息，并且决定着绘制到什么地方去&lt;br&gt;其次，那个图形上下文必须跟view相关联，才能将内容绘制到view上面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义UI控件的步骤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;新建一个类，继承自UIView
实现-(void)drawRect:(CGRect)rect方法，然后在这个方法中，可以：
        1.取得跟当前view相关联的图形上下文
        2.绘制相应的图形内容，绘制时产生的线条称为路径。 路径由一个或多个直线段或曲线段组成。
        3.利用图形上下文将绘制的所有内容渲染显示到view上面
    也可以：
        利用UIKit封装的绘图函数直接绘图.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;drawRect&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么要实现drawRect:方法才能绘图到view上？&lt;br&gt;因为在drawRect:方法中才能取得跟view相关联的图形上下文.rect相当于self.bounds。&lt;br&gt;【补充】viewDidLoad先调用，drawRect后调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;drawRect:方法在什么时候被调用？&lt;br&gt;当view第一次显示到屏幕上时（被加到UIWindow上显示出来）&lt;br&gt;调用view的setNeedsDisplay或者setNeedsDisplayInRect:时。&lt;br&gt;UIView的内容需要更新时，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;绘制直线&quot;&gt;&lt;a href=&quot;#绘制直线&quot; class=&quot;headerlink&quot; title=&quot;绘制直线&quot;&gt;&lt;/a&gt;绘制直线&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// 1.获取上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; ctx = &lt;span class=&quot;built_in&quot;&gt;UIGraphicsGetCurrentContext&lt;/span&gt;();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.拼接路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; *path = [&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; bezierPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置起点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [path moveToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;)];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加一条线到某个点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [path addLineToPoint:&lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;230&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3.把路径添加到上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextAddPath&lt;/span&gt;(ctx, path&lt;span class=&quot;variable&quot;&gt;.CGPath&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextAddPath&lt;/span&gt;(ctx, path1&lt;span class=&quot;variable&quot;&gt;.CGPath&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置绘图状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置线宽&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextSetLineWidth&lt;/span&gt;(ctx, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextSetLineCap&lt;/span&gt;(ctx, k&lt;span class=&quot;built_in&quot;&gt;CGLineCapRound&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//CGContextSetRGBStrokeColor(ctx, 1, 0, 0, 1);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; redColor] set];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4.渲染上下文到视图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextStrokePath&lt;/span&gt;(ctx);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;绘制曲线&quot;&gt;&lt;a href=&quot;#绘制曲线&quot; class=&quot;headerlink&quot; title=&quot;绘制曲线&quot;&gt;&lt;/a&gt;绘制曲线&lt;/h2&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)drawRect:(&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt;)rect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.获取上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; ctx = &lt;span class=&quot;built_in&quot;&gt;UIGraphicsGetCurrentContext&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.拼接路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; *path = [&lt;span class=&quot;built_in&quot;&gt;UIBezierPath&lt;/span&gt; bezierPath];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; startP = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; endP = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;240&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt; controlP = &lt;span class=&quot;built_in&quot;&gt;CGPointMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;125&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [path moveToPoint:startP];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [path addQuadCurveToPoint:endP controlPoint:controlP];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3.把路径添加到上下文&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextAddPath&lt;/span&gt;(ctx, path&lt;span class=&quot;variable&quot;&gt;.CGPath&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 4.渲染上下文到视图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextStrokePath&lt;/span&gt;(ctx);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统，在App中需要绘制各种之定义的UI就需要用到这个，例如在淘宝或者百度外卖的头部的波浪线的使用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二维码</title>
    <link href="http://peilinghui.com/2016/12/20/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://peilinghui.com/2016/12/20/二维码/</id>
    <published>2016-12-20T03:08:34.000Z</published>
    <updated>2017-02-20T03:43:15.000Z</updated>
    
    <content type="html">&lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的生成&quot;&gt;&lt;a href=&quot;#二维码的生成&quot; class=&quot;headerlink&quot; title=&quot;二维码的生成&quot;&gt;&lt;/a&gt;二维码的生成&lt;/h1&gt;&lt;h2 id=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;a href=&quot;#从服务器获取data地址再生成二维码&quot; class=&quot;headerlink&quot; title=&quot;从服务器获取data地址再生成二维码&quot;&gt;&lt;/a&gt;从服务器获取data地址再生成二维码&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;网络请求后处理data:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;attr_selector&quot;&gt;[self.progressHud hide:YES]&lt;/span&gt;;         &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; ([response.responseObject &lt;span class=&quot;attribute&quot;&gt;objectForKey&lt;/span&gt;:@&lt;span class=&quot;string&quot;&gt;&quot;data&quot;&lt;/span&gt;]) &amp;#123;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;attr_selector&quot;&gt;[self createImgWith:[response.responseObject objectForKey:@&quot;data&quot;]&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;生成二维码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)createImgWith:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)str &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.实例化二维码滤镜&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; *filter = [&lt;span class=&quot;built_in&quot;&gt;CIFilter&lt;/span&gt; filterWithName:&lt;span class=&quot;string&quot;&gt;@&quot;CIQRCodeGenerator&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.恢复滤镜的默认属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setDefaults];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 3.将字符串转换成NSData&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *info = str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *infoData = [info dataUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//4.通过KVO设置滤镜inputMessage数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [filter setValue:infoData forKey:&lt;span class=&quot;string&quot;&gt;@&quot;inputMessage&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 5.获得滤镜输出的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *outputImage = [filter outputImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//6. 将CIImage转换成UIImage，并放大显示,方法如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.qrCode&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.image&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:outputImage withSize:&lt;span class=&quot;number&quot;&gt;300&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//return [UIImage imageWithCIImage:outputImage scale:20.0 orientation:UIImageOrientationUp];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  根据CIImage生成指定大小的UIImage 生成清晰的二维码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param image CIImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param size  图片宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; *)createNonInterpolated&lt;span class=&quot;built_in&quot;&gt;UIIamgeFormCIImage&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;CIImage&lt;/span&gt; *)image withSize:(&lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt;)size&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; extent = &lt;span class=&quot;built_in&quot;&gt;CGRectIntegral&lt;/span&gt;(image&lt;span class=&quot;variable&quot;&gt;.extent&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGFloat&lt;/span&gt; scale = MIN(size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent), size / &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 1.创建bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t width = &lt;span class=&quot;built_in&quot;&gt;CGRectGetWidth&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    size_t height = &lt;span class=&quot;built_in&quot;&gt;CGRectGetHeight&lt;/span&gt;(extent) * scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceRef&lt;/span&gt; cs = &lt;span class=&quot;built_in&quot;&gt;CGColorSpaceCreateDeviceCMYK&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRef&lt;/span&gt; bitmapRef = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreate&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, width, height, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, cs, (&lt;span class=&quot;built_in&quot;&gt;CGBitmapInfo&lt;/span&gt;)k&lt;span class=&quot;built_in&quot;&gt;CGImageAlphaNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; *context = [&lt;span class=&quot;built_in&quot;&gt;CIContext&lt;/span&gt; contextWithOptions:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; bitmapImage = [context create&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:image fromRect:extent];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextSetInterpolationQuality&lt;/span&gt;(bitmapRef, k&lt;span class=&quot;built_in&quot;&gt;CGInterpolationNone&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextScaleCTM&lt;/span&gt;(bitmapRef, scale, scale);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextDrawImage&lt;/span&gt;(bitmapRef, extent, bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 2.保存bitmap&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRef&lt;/span&gt; scaledImage = &lt;span class=&quot;built_in&quot;&gt;CGBitmapContextCreateImage&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGContextRelease&lt;/span&gt;(bitmapRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;CGImageRelease&lt;/span&gt;(bitmapImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageWith&lt;span class=&quot;built_in&quot;&gt;CGImage&lt;/span&gt;:scaledImage];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;二维码的扫描&quot;&gt;&lt;a href=&quot;#二维码的扫描&quot; class=&quot;headerlink&quot; title=&quot;二维码的扫描&quot;&gt;&lt;/a&gt;二维码的扫描&lt;/h1&gt;&lt;p&gt;读取二维码需要导入AVFoundation框架&lt;br&gt;利用摄像头识别二维码中的内容（模拟器不行）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入（摄像头）
由会话将摄像头采集到的二维码图像转换成字符串数据
输出（数据）
由预览图层显示扫描场景
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扫码主要用到的是AVFoundation用到的东西和相机基本相同，相机。遵守AVCaptureMetadataOutputObjectsDelegate.&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@interface&lt;/span&gt; ScanQRViewController ()&amp;lt;AVCaptureMetadataOutputObjectsDelegate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//捕获设备，通常是前置摄像头，后置摄像头，麦克风（音频输入）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDevice *device;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//AVCaptureDeviceInput 代表输入设备，他使用AVCaptureDevice 来初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureDeviceInput *input;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置输出类型为Metadata，因为这种输出类型中可以设置扫描的类型，譬如二维码//当启动摄像头开始捕获输入时，如果输入中包含二维码，就会产生输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureMetadataOutput *output;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//session：由他把输入输出结合在一起，并开始启动捕获设备（摄像头）关键用来操作扫描结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureSession *session;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图像预览层，实时显示捕获的图像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@property&lt;/span&gt;(nonatomic)AVCaptureVideoPreviewLayer *previewLayer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;开始扫描：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginScan&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//iOS 判断应用是否有使用相机的权限&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *mediaType = &lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//读取媒体类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatus&lt;/span&gt; authStatus = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; authorizationStatusForMediaType:mediaType];&lt;span class=&quot;comment&quot;&gt;//读取设备授权状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusRestricted&lt;/span&gt; || authStatus == &lt;span class=&quot;built_in&quot;&gt;AVAuthorizationStatusDenied&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (TARGET_IPHONE_SIMULATOR) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//生成会话，用来结合输入输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  	 _session =[[&lt;span class=&quot;built_in&quot;&gt;AVCaptureSession&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session setSessionPreset:&lt;span class=&quot;built_in&quot;&gt;AVCaptureSessionPresetHigh&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用AVMediaTypeVideo 默认使用后置摄像头进行初始化**实例化拍摄设备**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; *device           = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDevice&lt;/span&gt; defaultDeviceWithMediaType:&lt;span class=&quot;built_in&quot;&gt;AVMediaTypeVideo&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用设备初始化输入(设置输入设备)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; *input       = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureDeviceInput&lt;/span&gt; deviceInputWithDevice:device error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session addInput:input];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//生成输出对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; *output   = [[&lt;span class=&quot;built_in&quot;&gt;AVCaptureMetadataOutput&lt;/span&gt; alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//设置代理，一旦扫描到指定类型的数据，就会通过代理输出 //在扫描的过程中，会分析扫描的内容，分析成功后就会调用代理方法在队列中输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [output setMetadataObjectsDelegate:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; queue:dispatch_get_main_queue()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [_session addOutput:output];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//指定当扫描到二维码的时候，产生输出 //AVMetadataObjectTypeQRCode 指定二维码 //指定识别类型一定要放到添加到session之后&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [output setMetadataObjectTypes:@[&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeQRCode&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN13Code&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeEAN8Code&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;AVMetadataObjectTypeCode128Code&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//设置扫描信息的识别区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;CGRect&lt;/span&gt; scanCrop = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; getRectOfInterest:_scanWindowView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; ViewoHoleBounds:_cameraView&lt;span class=&quot;variable&quot;&gt;.bounds&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;x:%f y:%f width:%f height:%f&quot;&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.x&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.origin&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.y&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;,scanCrop&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    output&lt;span class=&quot;variable&quot;&gt;.rectOfInterest&lt;/span&gt;             = scanCrop;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//layer负责把图像渲染显示&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; *layer = [&lt;span class=&quot;built_in&quot;&gt;AVCaptureVideoPreviewLayer&lt;/span&gt; layerWithSession:_session];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.videoGravity&lt;/span&gt;                = &lt;span class=&quot;built_in&quot;&gt;AVLayerVideoGravityResizeAspectFill&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    layer&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;                       = _cameraView&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_cameraView&lt;span class=&quot;variable&quot;&gt;.layer&lt;/span&gt; insertSublayer:layer atIndex:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//开始启动&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_session startRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现代理方法：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#pragma mark - 得到扫描二维码结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)captureOutput:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureOutput&lt;/span&gt; *)captureOutput didOutputMetadataObjects:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; *)metadataObjects fromConnection:(&lt;span class=&quot;built_in&quot;&gt;AVCaptureConnection&lt;/span&gt; *)connection&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (metadataObjects&lt;span class=&quot;variable&quot;&gt;.count&lt;/span&gt;&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_session stopRunning];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;comment&quot;&gt;//数组中包含的都是AVMetadataMachineReadableCodeObject 类型的对象，该对象中包含解码后的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;AVMetadataMachineReadableCodeObject&lt;/span&gt; * metadataObject = [metadataObjects objectAtIndex : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SystemSoundID completeSound;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; *audioPath = [[&lt;span class=&quot;built_in&quot;&gt;NSBundle&lt;/span&gt; mainBundle] URLForResource:&lt;span class=&quot;string&quot;&gt;@&quot;beep&quot;&lt;/span&gt; withExtension:&lt;span class=&quot;string&quot;&gt;@&quot;ogg&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesCreateSystemSoundID((__bridge &lt;span class=&quot;built_in&quot;&gt;CFURLRef&lt;/span&gt; _Nonnull)(audioPath), &amp;amp;completeSound);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AudioServicesPlaySystemSound(completeSound);        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sendRequestWithBarcode:metadataObject&lt;span class=&quot;variable&quot;&gt;.stringValue&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫码范围：&lt;/p&gt;
&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - 根据参数取得扫面范围reck&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGRect)getRectOfInterest:(CGRect)rectFrame ViewoHoleBounds:(CGRect)holeBounds &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat x,y,&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;,heigth;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = (rectFrame.origin.x)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    y = (rectFrame.origin.y)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt; = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    heigth = (rectFrame.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;)/(holeBounds.&lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;.&lt;span class=&quot;variable&quot;&gt;height&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; CGRectMake(y, x, heigth, &lt;span class=&quot;variable&quot;&gt;width&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;扫描动画：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;pragma&lt;/span&gt; mark - 扫描器开始进行动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)beginAnimated &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *lineImgView = [[UIImageView alloc]initWithFrame:CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    lineImgView.image        = [UIImage imageNamed:@&lt;span class=&quot;string&quot;&gt;&quot;barcodeline&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_scanWindowView addSubview:lineImgView]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [UIView animateWithDuration:&lt;span class=&quot;number&quot;&gt;2.0&lt;/span&gt; delay:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; options:UIViewAnimationOptionRepeat animations:^&amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lineImgView.frame    = CGRectMake(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; completion:^(BOOL finished) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://my.oschina.net/u/2340880/blog/405847&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://my.oschina.net/u/2340880/blog/405847&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://strivingboy.github.io/blog/2014/11/08/scan-qrcode/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://c0ming.me/qr-code-scan/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://c0ming.me/qr-code-scan/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://yimouleng.com/2016/01/13/ios-QRCode/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yimouleng.com/2016/01/13/ios-QRCode/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类似支付宝二维码Demo：&lt;br&gt;&lt;a href=&quot;https://github.com/mokey1422/GBAliScan&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/mokey1422/GBAliScan&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;二维码的&quot;&gt;&lt;a href=&quot;#二维码的&quot; class=&quot;headerlink&quot; title=&quot;二维码的&quot;&gt;&lt;/a&gt;二维码的&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中涉及到二维码的相关知识。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何封装一个自定义键盘的控件</title>
    <link href="http://peilinghui.com/2016/08/04/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E7%9A%84%E6%8E%A7%E4%BB%B6/"/>
    <id>http://peilinghui.com/2016/08/04/如何封装一个自定义键盘的控件/</id>
    <published>2016-08-04T15:25:50.000Z</published>
    <updated>2016-08-04T15:37:09.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义控件，刚刚学起来。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;可以封装一个键盘控件，然后作为一个pod，引入所需要使用的工程里面。&lt;br&gt;写法：&lt;br&gt;&lt;code&gt;pod &amp;quot;TDFKeyboard&amp;quot;, :git =&amp;gt; &amp;#39;git@git.....:ios/TDFKeyboard.git&amp;#39;, :branch =&amp;gt; &amp;#39;master&amp;#39;&lt;/code&gt;&lt;br&gt;对于podfile文件的格式可以参考这篇文章：&lt;a href=&quot;http://www.jianshu.com/p/8af475c4f717&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/8af475c4f717&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此键盘主要用于输入整数和浮点数还有IP地址。&lt;br&gt;主要是写了两种键盘，一种是不带“-”号的数字键盘1，一种是带“-”号的数字键盘2。如图：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E9%94%AE%E7%9B%981&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E9%94%AE%E7%9B%982&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面的响应的是系统的UITextField的输入，下面的响应的是自定义的TextView。  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先在ViewController的viewDidLoad方法中：&lt;br&gt;初始化键盘1，然后把键盘的responder设置为系统的textField。&lt;br&gt;然后初始化自定义的TextView，初始化键盘2，然后把自定义的inputView设置为自定义键盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两个键盘的父类：Keyboard（UIView的子类）&lt;br&gt;其中用枚举设置键盘输入类型有整数，浮点型和IP地址型。&lt;br&gt;&lt;code&gt;@property(weak,nonatomic)UIView&amp;lt;UIKeyInput&amp;gt; *responder;&lt;/code&gt;&lt;br&gt;在UIKit中有UIKeyInput(是一个协议@protocol)&lt;br&gt;UIView 的首要问题就是既能从代码中初始化，也能从 xib 中初始化，两者有何不同?&lt;br&gt;UIView 是支持 NSCoding 协议的，当在 xib 或 storyboard 里存在一个 UIView 的时候，其实是将 UIView 序列化到文件里（xib 和 storyboard 都是以 XML 格式来保存的），加载的时候反序列化出来，所以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当从代码实例化 UIView 的时候，initWithFrame 会执行；
当从文件加载 UIView 的时候，initWithCoder 会执行。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置view的布局：&lt;br&gt;&lt;code&gt;self.autoresizingMask = UIViewAutoresizingNone;&lt;/code&gt;&lt;br&gt;解释：UIView中的autoresizingMask属性，枚举类型，定义如下：主要作用是自动调整子控件与父控件中间的位置，宽和高。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NS_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NSUInteger, UIViewAutoresizing)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingNone                 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//不自动调整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleLeftMargin   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,   &lt;span class=&quot;comment&quot;&gt;// 自动调整与superView左边的距离，保证与superView右边的距离不变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleWidth        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleRightMargin  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleTopMargin    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//自动调整与superView顶部的距离，保证与superView底部的距离不变。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleHeight       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,    &lt;span class=&quot;comment&quot;&gt;//自动调整自己的高度，保证与superView顶部和底部的距离不变&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIViewAutoresizingFlexibleBottomMargin = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;UIViewAutoresizingFlexibleLeftMargin  |UIViewAutoresizingFlexibleRightMargin 自动调整与superView左边的距离，保证与左边的距离和右边的距离和原来距左边和右边的距离的比例不变。比如原来距离为20，30，调整后的距离应为68，102，即68/20=102/30。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子类有键盘1(TDFNumbericKeyboard)和键盘2(TDFSymbolNumbericKeyboard):&lt;br&gt;在子类中实现了UIKeyInput协议方法，其中默认的方法有：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;BOOL&lt;/span&gt;)hasText;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (void)&lt;span class=&quot;symbol&quot;&gt;insertText:&lt;/span&gt;(&lt;span class=&quot;constant&quot;&gt;NSString&lt;/span&gt; *)text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (void)deleteBackward;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后实现xib中的按钮的点击action事件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在自定义textView中定义协议代理并实现其方法：&lt;br&gt;其中有手势：UITapGestureRecognizer，当然这只是手势的其中一个。&lt;br&gt;下面还有几个如：&lt;br&gt;UITapGestureRecognizer&lt;br&gt;UIPinchGestureRecognizer&lt;br&gt;UIRotationGestureRecognizer&lt;br&gt;UISwipeGestureRecognizer&lt;br&gt;UIPanGestureRecognizer&lt;br&gt;UILongPressGestureRecognizer&lt;br&gt;从命名上不难了解這些类別所对应代表的手势，分別是 Tap（点一下）、Pinch（二指往內或往外拨动）、Rotation（旋转）、Swipe（滑动，快速移动）、Pan （拖移，慢速移动）以及 LongPress（长按）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; *tap = [[&lt;span class=&quot;built_in&quot;&gt;UITapGestureRecognizer&lt;/span&gt; alloc]initWithTarget:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; action:&lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(becomeFirstResponder)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; addGestureRecognizer:tap];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; addSubview:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.textLabel&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/peilinghui/PLHKeyboard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/PLHKeyboard&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;如何设计一个 iOS 控件?(iOS 控件完全解析) ：&lt;a href=&quot;http://blog.csdn.net/zhangao0086/article/details/45622875&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/zhangao0086/article/details/45622875&lt;/a&gt;      ·&lt;br&gt;ios手势：&lt;a href=&quot;http://blog.sina.com.cn/s/blog_7c336a8301011b3e.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sina.com.cn/s/blog_7c336a8301011b3e.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义控件，刚刚学起来。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RunLoop的学习</title>
    <link href="http://peilinghui.com/2016/07/19/RunLoop%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/07/19/RunLoop的学习/</id>
    <published>2016-07-19T14:45:17.000Z</published>
    <updated>2016-07-19T14:45:17.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Runtime的学习</title>
    <link href="http://peilinghui.com/2016/07/05/Runtime%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/07/05/Runtime的学习/</id>
    <published>2016-07-05T08:22:32.000Z</published>
    <updated>2016-12-30T12:29:58.000Z</updated>
    
    <content type="html">&lt;p&gt;官方源代码地址：&lt;a href=&quot;http://opensource.apple.com//source/objc4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://opensource.apple.com//source/objc4/&lt;/a&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;runtime&quot;&gt;&lt;a href=&quot;#runtime&quot; class=&quot;headerlink&quot; title=&quot;runtime&quot;&gt;&lt;/a&gt;runtime&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;什么是runtime？&lt;br&gt;1&amp;gt; runtime是一套比较底层的纯C语言API, 属于1个C语言库&lt;br&gt;2&amp;gt; 平时编写的OC代码, 在程序运行过程中, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者&lt;br&gt;3&amp;gt; 举例:&lt;br&gt;OC：&lt;code&gt;[[Person alloc] init]&lt;/code&gt;&lt;br&gt;runtime: &lt;code&gt;objc_msgSend(objc_msgSend(&amp;quot;Person&amp;quot; , &amp;quot;alloc&amp;quot;), &amp;quot;init&amp;quot;)&lt;/code&gt;&lt;br&gt;OC：&lt;code&gt;[target doSomething];&lt;/code&gt;&lt;br&gt;Runtime(objc)：&lt;code&gt;msgSend(target,@selector(doSomething))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;有什么用？&lt;br&gt;runtime是属于OC的底层, 可以进行一些非常底层的操作。&lt;br&gt;1&amp;gt; 动态创建一个类（比如KVO的底层实现）&lt;br&gt;2&amp;gt; 动态的为某个类添加属性\方法，修改属性\方法.遍历一个类的所有的成员变量(属性)\方法&lt;br&gt;3&amp;gt; 写代码能更加灵活，可以把消息转发给想要的对象，或者随意交换一个方法的实现。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;常见的头文件：&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/runtime.h&amp;gt; : 成员变量、类、方法&lt;/code&gt;&lt;br&gt; &lt;code&gt;#import &amp;lt;objc/message.h&amp;gt;: 消息机制&lt;/code&gt;&lt;br&gt; 常见的方法：&lt;br&gt; &lt;code&gt;Ivar class_copyIvarList : 获得某个类内部的所有成员变量&lt;/code&gt;（Ivar是成员变量）&lt;br&gt; &lt;code&gt;Method * class_copyMethodList : 获得某个类内部的所有方法&lt;/code&gt; （Method是成员方法）&lt;br&gt; &lt;code&gt;Method class_copyPropertyList: 获得属性列表&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_copyProtocolList: 获得协议列表&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getInstanceMethod: 获得某个实例方法（对象方法，减号-开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;Method class_getClassMethod : 获得某个类方法（加号+开头）&lt;/code&gt;&lt;br&gt; &lt;code&gt;method_exchangeImplementations : 交换2个方法的具体实现&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;code&gt;objc_msgSend(....)：给对象发送消息&lt;/code&gt;&lt;br&gt; ``&lt;br&gt;相关应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSCoding(利用runtime遍历模型对象的所有属性来归档和解档）&lt;/li&gt;
&lt;li&gt;字典–&amp;gt;模型（利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上）&lt;/li&gt;
&lt;li&gt;KVO（利用runtime动态产生一个类）&lt;ul&gt;
&lt;li&gt;用于封装框架（想怎么改就怎么改）&lt;br&gt;示例第一种应用：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png&quot; alt=&quot;&quot;&gt;    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优秀博客学习：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Objective-C Runtime 1小时入门教程：&lt;a href=&quot;https://www.ianisme.com/ios/2019.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;Objective-C Runtime：&lt;a href=&quot;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;南峰子有一系列：&lt;a href=&quot;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;快速上手Runtime（附MJExtension的底层实现:&lt;a href=&quot;http://www.tuicool.com/articles/YzeiEna&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/YzeiEna&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;iOS运行时Runtime浅析：&lt;a href=&quot;http://blog.csdn.net/chenyufeng1991/article/details/51931320&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/chenyufeng1991/article/details/51931320&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;官方源代码地址：&lt;a href=&quot;http://opensource.apple.com//source/objc4/&quot;&gt;http://opensource.apple.com//source/objc4/&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TableView的一些事</title>
    <link href="http://peilinghui.com/2016/07/02/TableView%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://peilinghui.com/2016/07/02/TableView的一些事/</id>
    <published>2016-07-02T02:32:49.000Z</published>
    <updated>2016-10-12T12:07:46.000Z</updated>
    
    <content type="html">&lt;p&gt;UITableView的基本信息&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;UITableView的基本信息&quot;&gt;&lt;a href=&quot;#UITableView的基本信息&quot; class=&quot;headerlink&quot; title=&quot;UITableView的基本信息&quot;&gt;&lt;/a&gt;UITableView的基本信息&lt;/h2&gt;&lt;h3 id=&quot;初始化方法&quot;&gt;&lt;a href=&quot;#初始化方法&quot; class=&quot;headerlink&quot; title=&quot;初始化方法&quot;&gt;&lt;/a&gt;初始化方法&lt;/h3&gt;&lt;p&gt; &lt;code&gt;- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;&lt;/code&gt;&lt;br&gt;这个方法初始化表视图的frame大小并且设置一个风格，UITableViewStyle是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;,                  &lt;span class=&quot;comment&quot;&gt;// 标准的表视图风格    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewStyleGrouped&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;// 分组的表视图风格&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用属性&quot;&gt;&lt;a href=&quot;#常用属性&quot; class=&quot;headerlink&quot; title=&quot;常用属性&quot;&gt;&lt;/a&gt;常用属性&lt;/h3&gt;&lt;p&gt;获取表视图的风格(只读属性)&lt;br&gt;&lt;code&gt;@property(nonatomic, readonly) UITableViewStyle    style;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图代理和数据源代理(代理方法后面讨论)&lt;br&gt;&lt;code&gt;@property (nonatomic, assign)id &amp;lt;UITableViewDataSource&amp;gt; dataSource;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property(nonatomic, assign)id &amp;lt;UITableViewDelegate&amp;gt;   delegate;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置表示图的行高(默认为44)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat rowHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分区的头视图高度和尾视图高度(当代理方法没有实现时才有效)&lt;br&gt;&lt;code&gt;@property(nonatomic)CGFloat  sectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  sectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置一个行高的估计值(默认为0，表示没有估计,7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedRowHeight;&lt;/code&gt;&lt;br&gt;注意：这个属性官方的解释是如果你的tableView的行高是可变的，那么设计一个估计高度可以加快代码的运行效率。&lt;/p&gt;
&lt;p&gt;下面这两个属性和上面相似，分别设置分区头视图和尾视图的估计高度(7.0之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionHeaderHeight;&lt;/code&gt;&lt;br&gt;&lt;code&gt;@property (nonatomic)CGFloat  estimatedSectionFooterHeight;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的位置&lt;br&gt;&lt;code&gt;@property (nonatomic)UIEdgeInsets  separatorInset;&lt;/code&gt;&lt;br&gt;如果细心，你可能会发现系统默认的tableView的分割线左端并没有顶到边沿。通过这个属性，可以手动设置分割线的位置偏移，比如你向让tableView的分割线只显示右半边，可以如下设置：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tab=[[&lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; alloc]initWithFrame:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.view&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt; style:&lt;span class=&quot;built_in&quot;&gt;UITableViewStylePlain&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tab&lt;span class=&quot;variable&quot;&gt;.separatorInset&lt;/span&gt;=&lt;span class=&quot;built_in&quot;&gt;UIEdgeInsetsMake&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, tab&lt;span class=&quot;variable&quot;&gt;.frame&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.size&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.width&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置tableView背景view视图&lt;br&gt;&lt;code&gt;@property(nonatomic, readwrite, retain) UIView *backgroundView;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用方法详解&quot;&gt;&lt;a href=&quot;#常用方法详解&quot; class=&quot;headerlink&quot; title=&quot;常用方法详解&quot;&gt;&lt;/a&gt;常用方法详解&lt;/h3&gt;&lt;p&gt;重载tableView&lt;br&gt;&lt;code&gt;- (void)reloadData;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重载索引栏&lt;br&gt;&lt;code&gt;- (void)reloadSectionIndexTitles;&lt;/code&gt;&lt;br&gt;这个方法常用语新加或者删除了索引类别而无需刷新整个表视图的情况下。&lt;/p&gt;
&lt;p&gt;获取分区数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSections;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取行数&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取分区的大小(包括头视图，所有行和尾视图)&lt;br&gt;&lt;code&gt;- (CGRect)rectForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区分别获取头视图，尾视图和行的高度&lt;br&gt;&lt;code&gt;- (CGRect)rectForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个点在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取某个cell在tableView中的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据一个矩形范围返回一个信息数组，数组中是每一行row的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过位置路径获取cell&lt;br&gt;&lt;code&gt;- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见的cell&lt;br&gt;&lt;code&gt;- (NSArray *)visibleCells;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取所有可见行的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForVisibleRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取头视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据分区获取尾视图&lt;br&gt;&lt;code&gt;- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到某一位置(行)&lt;br&gt;&lt;code&gt;- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt; 注意：indexPah参数是定位的位置，决定于分区和行号。animated参数决定是否有动画。scrollPosition参数决定定位的相对位置，它使一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPosition&lt;/span&gt;) &amp;#123;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//同UITableViewScrollPositionTop   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的顶部        &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionMiddle&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView的中间      &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewScrollPositionBottom&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//定位完成后，将定位的行显示在tableView最下面&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使表示图定位到选中行&lt;br&gt;&lt;code&gt;- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;这个函数与上面的非常相似，只是它是将表示图定位到选中的行。&lt;/p&gt;
&lt;h2 id=&quot;tableView操作刷新块的应用&quot;&gt;&lt;a href=&quot;#tableView操作刷新块的应用&quot; class=&quot;headerlink&quot; title=&quot;tableView操作刷新块的应用&quot;&gt;&lt;/a&gt;tableView操作刷新块的应用&lt;/h2&gt;&lt;p&gt;在介绍动画块之前，我们先看几个函数：&lt;br&gt;插入分区&lt;br&gt;&lt;code&gt;- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;animation参数是一个枚举，枚举的动画类型如下&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimation&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationFade&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//淡入淡出  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationRight&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从右滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationLeft&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从左滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationTop&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从上滑入    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationBottom&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//从下滑入   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationNone&lt;/span&gt;,  &lt;span class=&quot;comment&quot;&gt;//没有动画   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationMiddle&lt;/span&gt;,           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;built_in&quot;&gt;UITableViewRowAnimationAutomatic&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 自动选择合适的动画&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除分区&lt;br&gt;&lt;code&gt;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一个分区&lt;br&gt;&lt;code&gt;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation ;&lt;/code&gt;&lt;br&gt;移动一个分区&lt;br&gt;&lt;code&gt;- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;&lt;/code&gt;&lt;br&gt;插入一些行&lt;br&gt;&lt;code&gt;- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;删除一些行&lt;br&gt;&lt;code&gt;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;重载一些行&lt;br&gt;&lt;code&gt;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;&lt;/code&gt;&lt;br&gt;移动某行&lt;br&gt;&lt;code&gt;- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;&lt;/code&gt;&lt;br&gt;了解了上面几个函数，我们来看什么是操作刷新块：&lt;br&gt;当我们调用的上面的函数时，tableView会立刻调用代理方法进行刷新，如果其中我们所做的操作是删除某行，而然数据源数组我们可能并没有刷新，程序就会崩溃掉，原因是代理返回的信息和我们删除后不符。&lt;br&gt;IOS为我们提供了下面两个函数解决这个问题：&lt;br&gt;开始块标志&lt;br&gt;&lt;code&gt;- (void)beginUpdates;&lt;/code&gt;&lt;br&gt;结束快标志&lt;br&gt;&lt;code&gt;- (void)endUpdates;&lt;/code&gt;&lt;br&gt;我们可以将我们要做的操作全部写在这个块中，那么，只有当程序执行到结束快标志后，才会调用代理刷新方法。代码示例如下：&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab beginUpdates]&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr_selector&quot;&gt;[tab deleteRowsAtIndexPaths:@[[NSIndexPath indexPathForRow:1 inSection:0]&lt;/span&gt;] &lt;span class=&quot;tag&quot;&gt;withRowAnimation&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:UITableViewRowAnimationLeft&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[dataArray removeObjectAtIndex:1]&lt;/span&gt;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;attr_selector&quot;&gt;[tab endUpdates]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意：不要在这个块中调用reloadData这个方法，它会使动画失效。&lt;/p&gt;
&lt;h2 id=&quot;tableView的编辑操作&quot;&gt;&lt;a href=&quot;#tableView的编辑操作&quot; class=&quot;headerlink&quot; title=&quot;tableView的编辑操作&quot;&gt;&lt;/a&gt;tableView的编辑操作&lt;/h2&gt;&lt;p&gt;设置是否是编辑状态(编辑状态下的cell左边会出现一个减号，点击右边会划出删除按钮)&lt;br&gt;&lt;code&gt;@property (nonatomic, getter=isEditing) BOOL editing;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)setEditing:(BOOL)editing animated:(BOOL)animated;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以被选中(默认为YES)&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell编辑模式下是否可以被选中&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelection;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑模式下是否支持多选&lt;br&gt;&lt;code&gt;@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;选中cell的相关操作&quot;&gt;&lt;a href=&quot;#选中cell的相关操作&quot; class=&quot;headerlink&quot; title=&quot;选中cell的相关操作&quot;&gt;&lt;/a&gt;选中cell的相关操作&lt;/h2&gt;&lt;p&gt;获取选中cell的位置信息&lt;br&gt;&lt;code&gt;- (NSIndexPath *)indexPathForSelectedRow;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取多选cell的位置信息&lt;br&gt;&lt;code&gt;- (NSArray *)indexPathsForSelectedRows;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码手动选中与取消选中某行&lt;br&gt;&lt;code&gt;- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;&lt;/code&gt;&lt;br&gt;注意：这两个方法将不会回调代理中的方法。 &lt;/p&gt;
&lt;h2 id=&quot;tableView附件的相关方法&quot;&gt;&lt;a href=&quot;#tableView附件的相关方法&quot; class=&quot;headerlink&quot; title=&quot;tableView附件的相关方法&quot;&gt;&lt;/a&gt;tableView附件的相关方法&lt;/h2&gt;&lt;p&gt;设置索引栏最小显示行数&lt;br&gt;&lt;code&gt;@property (nonatomic) NSInteger sectionIndexMinimumDisplayRowCount;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;设置索引栏字体颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏背景颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏被选中时的颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor *sectionIndexTrackingBackgroundColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线的风格&lt;br&gt;&lt;code&gt;@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle;&lt;/code&gt;&lt;br&gt;这个风格是一个枚举，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyle&lt;/span&gt;) &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//无线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLine&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//有线    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellSeparatorStyleSingleLineEtched&lt;/span&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置分割线颜色&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIColor           *separatorColor;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置分割线毛玻璃效果(IOS8之后可用)&lt;br&gt;&lt;code&gt;@property (nonatomic, copy) UIVisualEffect      *separatorEffect;&lt;/code&gt;&lt;br&gt;注意：这个属性是IOS8之后新的。&lt;/p&gt;
&lt;p&gt;设置tableView头视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableHeaderView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView尾视图&lt;br&gt;&lt;code&gt;@property (nonatomic, retain) UIView *tableFooterView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池中取cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;获取一个已注册的cell&lt;br&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从复用池获取头视图或尾视图&lt;br&gt;&lt;code&gt;- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过xib文件注册cell&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过OC类注册cell&lt;br&gt; &lt;code&gt;- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier&lt;/code&gt;&lt;br&gt;上面两个方法是IOS6之后的方法。&lt;/p&gt;
&lt;p&gt;通过xib文件和OC类获取注册头视图和尾视图&lt;br&gt;&lt;code&gt;- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-UITableView的代理方法&quot;&gt;&lt;a href=&quot;#iOS-UITableView的代理方法&quot; class=&quot;headerlink&quot; title=&quot;iOS UITableView的代理方法&quot;&gt;&lt;/a&gt;iOS UITableView的代理方法&lt;/h2&gt;&lt;h3 id=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;a href=&quot;#UITableViewDataSource（数据源代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDataSource（数据源代理）&quot;&gt;&lt;/a&gt;UITableViewDataSource（数据源代理）&lt;/h3&gt;&lt;p&gt;1、必须实现的回调方法&lt;br&gt;返回每个分区的行数&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每一行的cell&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、可选实现的方法&lt;br&gt;返回分区数(默认为1)&lt;br&gt;&lt;code&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区头部的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回每个分区的尾部标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可编辑&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置某行是否可以被移动&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题数组（实现这个方法，会在tableView右边显示每个分区的索引）&lt;br&gt;&lt;code&gt;- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置索引栏标题对应的分区&lt;br&gt;&lt;code&gt;- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;tableView接受编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;这个方法中的editingStyle参数是一个枚举，代表了cell被编辑的模式，如下：&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyle&lt;/span&gt;) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleNone&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//没有编辑操作  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleDelete&lt;/span&gt;,&lt;span class=&quot;comment&quot;&gt;//删除操作    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UITableViewCellEditingStyleInsert&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//插入操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;tableView的cell被移动时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;a href=&quot;#UITableViewDelegate（tableView代理）&quot; class=&quot;headerlink&quot; title=&quot;UITableViewDelegate（tableView代理）&quot;&gt;&lt;/a&gt;UITableViewDelegate（tableView代理）&lt;/h3&gt;&lt;p&gt;cell将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;头视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;尾视图将要显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;和上面的方法对应，这三个方法分别是cell，头视图，尾视图已经显示时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的方法&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置行高，头视图高度和尾视图高度的估计值(对于高度可变的情况下，提高效率)&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置自定义头视图和尾视图&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置cell是否可以高亮&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;cell高亮和取消高亮时分别调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当即将选中某行和取消选中某行时调用的函数，返回一直位置，执行选中或者取消选中&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;已经选中和已经取消选中后调用的函数&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置tableView被编辑时的状态风格，如果不设置，默认都是删除风格&lt;br&gt;&lt;code&gt;- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义删除按钮的标题&lt;br&gt;&lt;code&gt;- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面这个方法是IOS8中的新方法，用于自定义创建tableView被编辑时右边的按钮，按钮类型为UITableViewRowAction。&lt;br&gt;&lt;code&gt;- (NSArray *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath*)indexPath ;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置编辑时背景是否缩进&lt;br&gt;&lt;code&gt;- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath*)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将要编辑和结束编辑时调用的方法&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移动特定的某行&lt;br&gt;&lt;code&gt;- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;TableView性能优化&quot;&gt;&lt;a href=&quot;#TableView性能优化&quot; class=&quot;headerlink&quot; title=&quot;TableView性能优化&quot;&gt;&lt;/a&gt;TableView性能优化&lt;/h2&gt;&lt;p&gt;tableview优化两个思路：缓存操作和异步操作。&lt;br&gt;最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。&lt;/p&gt;
&lt;h3 id=&quot;cell复用机制。&quot;&gt;&lt;a href=&quot;#cell复用机制。&quot; class=&quot;headerlink&quot; title=&quot;cell复用机制。&quot;&gt;&lt;/a&gt;cell复用机制。&lt;/h3&gt;&lt;p&gt;如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先注册cell&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt; ()&amp;lt;&lt;span class=&quot;title&quot;&gt;UITableViewDataSource&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;UITableViewDelegate&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;UITableView&lt;/span&gt; *tableView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *cellId = &lt;span class=&quot;string&quot;&gt;@&quot;Cell&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HomeVC&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.delegate&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myTableView&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.dataSource&lt;/span&gt; = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第一种注册cell&amp;lt;nib文件类HomeTableViewCell&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.tableView&lt;/span&gt; registerNib:[&lt;span class=&quot;built_in&quot;&gt;UINib&lt;/span&gt; nibWithNibName:&lt;span class=&quot;string&quot;&gt;@&quot;HomeTableViewCell&quot;&lt;/span&gt; bundle:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;] forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//第二种注册Cell&amp;lt;纯手工打造的HomeVC&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// [self.tableView registerClass:[HomeVC class]forCellReuseIdentifier:cellId];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;重用相关API&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Cell：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forCellReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forIndexPath:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 复用 Section 的 Header/Footer：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerNib:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;registerClass:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;forHeaderFooterViewReuseIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- [UITableView &lt;span class=&quot;string&quot;&gt;dequeueReusableHeaderFooterViewWithIdentifier:&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UITableViewCell *)&lt;span class=&quot;string&quot;&gt;tableView:&lt;/span&gt;(UITableView *)tableView &lt;span class=&quot;string&quot;&gt;cellForRowAtIndexPath:&lt;/span&gt;(NSIndexPath *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//获取重用池中的cell&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HomeTableViewCell *cell = [tableView &lt;span class=&quot;string&quot;&gt;dequeueReusableCellWithIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//如果没有取到,就初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cell) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cell = [[HomeTableViewCell alloc] &lt;span class=&quot;string&quot;&gt;initWithStyle:&lt;/span&gt;UITableViewCellStyleDefault &lt;span class=&quot;string&quot;&gt;reuseIdentifier:&lt;/span&gt;cellId];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cell.cellNameLab.text = @&lt;span class=&quot;string&quot;&gt;&quot;Name&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;a href=&quot;#cell使用drawRect方法添加子控件&quot; class=&quot;headerlink&quot; title=&quot;cell使用drawRect方法添加子控件&quot;&gt;&lt;/a&gt;cell使用drawRect方法添加子控件&lt;/h3&gt;&lt;p&gt;如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。&lt;/p&gt;
&lt;h3 id=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;a href=&quot;#高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot; class=&quot;headerlink&quot; title=&quot;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&quot;&gt;&lt;/a&gt;高度计算方法时不做复杂的计算，尽量只使用加减乘除。&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;- (CGSize)systemLayoutSizeFittingSize: (CGSize)targetSize&lt;/code&gt;&lt;br&gt;方法计算。&lt;/p&gt;
&lt;h3 id=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;a href=&quot;#避免快速滑动情况下开过多线程。&quot; class=&quot;headerlink&quot; title=&quot;避免快速滑动情况下开过多线程。&quot;&gt;&lt;/a&gt;避免快速滑动情况下开过多线程。&lt;/h3&gt;&lt;p&gt;cell中的图片开线程异步加载&lt;sdwebimage(异步操作)&gt;。但是线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UITableViewCell&lt;/span&gt; *)cellForRowAtIndexPath:(&lt;span class=&quot;built_in&quot;&gt;NSIndexPath&lt;/span&gt; *)indexPath&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt; canLoad:Bool = !tableView&lt;span class=&quot;variable&quot;&gt;.dragging&lt;/span&gt; &amp;amp;&amp;amp; !tableView&lt;span class=&quot;variable&quot;&gt;.declearating&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;  canLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//开始loaddata，异步加载图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)scrollViewDidScroll:(&lt;span class=&quot;built_in&quot;&gt;UIScrollView&lt;/span&gt; *)sender&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//刷新tableview&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//在此刷新的是屏幕上显示的cell的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.table&lt;/span&gt; reloadData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/sdwebimage(异步操作)&gt;&lt;/p&gt;
&lt;h3 id=&quot;图片处理&quot;&gt;&lt;a href=&quot;#图片处理&quot; class=&quot;headerlink&quot; title=&quot;图片处理&quot;&gt;&lt;/a&gt;图片处理&lt;/h3&gt;&lt;p&gt;1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。&lt;br&gt;2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示&lt;br&gt;3）避免对layer做过多的操作，尽量设置图片为不透明&lt;/p&gt;
&lt;h2 id=&quot;tableView的数据刷新&quot;&gt;&lt;a href=&quot;#tableView的数据刷新&quot; class=&quot;headerlink&quot; title=&quot;tableView的数据刷新&quot;&gt;&lt;/a&gt;tableView的数据刷新&lt;/h2&gt;&lt;p&gt;对tableView的刷新直接就是reloadData.调用这个方法之后,控制器会把数据源方法重新执行一遍,如果前面我们的数据需要保存,reloadData重新执行一遍,我们的数据都会被刷新掉,那么我改如何解决这个问题呢 ? 这就我们对其中某一个分组,或者某一个指定的Cell进行刷新.具体的代码实现如下,&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个section刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexSet *indexSet=[[NSIndexSet alloc]&lt;span class=&quot;string&quot;&gt;initWithIndex:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableview &lt;span class=&quot;string&quot;&gt;reloadSections:&lt;/span&gt;indexSet &lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationAutomatic];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个指定cell刷新    &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSIndexPath *indexPath=[NSIndexPath &lt;span class=&quot;string&quot;&gt;indexPathForRow:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;inSection:&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[tableView &lt;span class=&quot;string&quot;&gt;reloadRowsAtIndexPaths:&lt;/span&gt;[NSArray &lt;span class=&quot;string&quot;&gt;arrayWithObjects:&lt;/span&gt;indexPath,nil] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;withRowAnimation:&lt;/span&gt;UITableViewRowAnimationNone];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多参考资料：&quot;&gt;&lt;a href=&quot;#更多参考资料：&quot; class=&quot;headerlink&quot; title=&quot;更多参考资料：&quot;&gt;&lt;/a&gt;更多参考资料：&lt;/h3&gt;&lt;p&gt;优化UITableViewCell高度计算的那些事：&lt;a href=&quot;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/&lt;/a&gt;&lt;br&gt;objc的期刊：更轻量的View Controller：&lt;a href=&quot;https://objccn.io/issue-1-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-1-1/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;UITableView的基本信息&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中页面传值和页面跳转 </title>
    <link href="http://peilinghui.com/2016/07/02/iOS%E4%B8%AD%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E5%92%8C%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/"/>
    <id>http://peilinghui.com/2016/07/02/iOS中页面传值和页面跳转/</id>
    <published>2016-07-02T02:32:09.000Z</published>
    <updated>2016-10-12T14:03:54.000Z</updated>
    
    <content type="html">&lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios的页面通信&quot;&gt;&lt;a href=&quot;#ios的页面通信&quot; class=&quot;headerlink&quot; title=&quot;ios的页面通信&quot;&gt;&lt;/a&gt;ios的页面通信&lt;/h2&gt;&lt;p&gt;开发过程中我们在页面传值时我们通常使用的方法有:属性传值法,block传值法,代理传值法,以及单例传值法,通知传值法。&lt;/p&gt;
&lt;h3 id=&quot;属性传值&quot;&gt;&lt;a href=&quot;#属性传值&quot; class=&quot;headerlink&quot; title=&quot;属性传值&quot;&gt;&lt;/a&gt;属性传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;属性传值多用于在将前一个页面的值传到后一个页面去,也就是我们通常说的从前往后传值，  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当第一个页面push到第二个页面的时候.我们在第二个页面声明一个属性用于接受从第一个页面传递过去的值,然后在push这个事件被触发的时候进行赋值.&lt;br&gt;也就是说,先初始化创建第二个控制器(页面),然后通过创建的控制器来访问它所对应的属性,将即将传递的值赋给它,这样就完成了属性传值.于是当页面(控制器)被push到第二个页面之后我们访问它的属性的时候,也就顺便获取到了传递过来的值.&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;next:&lt;/span&gt;(UINavigationController *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ScondViewController *secondNC = [[ScondViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将第一个界面的输入框信息赋值给第二个页面的Label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondNC.tfString = _firstTF.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.navigationController &lt;span class=&quot;string&quot;&gt;pushViewController:&lt;/span&gt;secondNC &lt;span class=&quot;string&quot;&gt;animated:&lt;/span&gt;YES];   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;代理传值&quot;&gt;&lt;a href=&quot;#代理传值&quot; class=&quot;headerlink&quot; title=&quot;代理传值&quot;&gt;&lt;/a&gt;代理传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代理传值多用于从后往前传值.只要在协议中声明一个协议方法，然后两个类一个作为委托方一个作为遵守方来调用和实现方法就可以实现传值。十分高效而且针对性很强。委托者：声明delegate属性，调用协议方法。被委托者：遵守协议，设定被委托者，覆写协议方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的.h中创建一个协议,并且设置代理属性,让其遵循该协议.&lt;br&gt;// 设置一个协议方法&lt;br&gt;@protocol SecondVCDelegate&lt;br&gt; // 代理传值    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)passValue:(NSString *)value;&lt;br&gt;@end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;声明代理属性进行代理传值&lt;br&gt;@property(nonatomic,weak)id delegate;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SecondViewController的导航控制器设置了右按钮(返回按钮),那么,我们只需要在其触发事件(back:)中调用代理方法去执行传值即可.&lt;br&gt;代码如下:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt; (void)&lt;span class=&quot;tag&quot;&gt;back&lt;/span&gt;:(UINavigationController *)&lt;span class=&quot;tag&quot;&gt;sender&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[_delegate passValue:_secondTF.text]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;attr_selector&quot;&gt;[self.navigationController popViewControllerAnimated:YES]&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;然后在FirstViewController的next方法中为SecondNC制定其代理为其自身即可.&lt;/li&gt;
&lt;li&gt;实现其代理方法&lt;figure class=&quot;highlight ceylon&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)passValue:(NSString *)&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;_f&lt;/span&gt;irstLab.text = &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样我们就可以在第一个页面得到第二个页面的值了.&lt;/p&gt;
&lt;h3 id=&quot;block传值&quot;&gt;&lt;a href=&quot;#block传值&quot; class=&quot;headerlink&quot; title=&quot;block传值&quot;&gt;&lt;/a&gt;block传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;block的本质就和其他OC中变量类似,只不过,block中存储的数据是函数体,但是在使用block时完全可以像调用其他函数似的,传入参数,然后得到返回值.从后往前传值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在SecondViewController中定义并声明block属性.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义有参无返回值的匿名函数(传递字符串)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(^MyBlock)(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SecondViewController&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)MyBlock block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们在SecondViewController的back方法中调用block,并且将在这个控制器的textField中的文字作为block的参数传递给block.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 代理去执行传值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt;(_secondTF&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;FirstViewController的next方法中,也就是alloc出SecondViewController的时候调用SecondViewController的block,实现传值&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)back:(&lt;span class=&quot;built_in&quot;&gt;UINavigationController&lt;/span&gt; *)sender&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)temp = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secVC&lt;span class=&quot;variable&quot;&gt;.block&lt;/span&gt; = ^(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 通过回调将传进来的字符串赋值给label&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp&lt;span class=&quot;variable&quot;&gt;.firstLab&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt; = string;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.navigationController&lt;/span&gt; popViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt;]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述代码中,因为block里面不能直接使用属性,实例变量和方法(因为会造成循环引用),所以我们重新用__weak修饰self并重新命名为temp.这样我们就实现了传值.&lt;/p&gt;
&lt;h3 id=&quot;通知传值&quot;&gt;&lt;a href=&quot;#通知传值&quot; class=&quot;headerlink&quot; title=&quot;通知传值&quot;&gt;&lt;/a&gt;通知传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类似于广播的一种传值模式，十分简单易用。一般负责在两个不同的类之间传值，且耦合度很低。这种方式中NSNotificationCenter担任一个中介者的身份，已提供观察者与被观察者相互传递信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Objective-C中使用NSNotifation表示通知，每个NSNotifation对象都具有名称name（NSNotificationCenter根据该名称检索此通知的所有观察者）、来源对象Poster-object（发布该通知的对象）和可选的userInfo字典（来源对象需要告诉观察者的额外信息NSDictionary）。&lt;/p&gt;
&lt;p&gt;NSNotificationCenter就相当于一个俱乐部，只要一行代码一个类就能加入其中成为会员(Observer向NSNotificationCenter注册感兴趣信息)，当然这个类要告诉俱乐部它对哪些信息感兴趣，当有新的信息出现时，俱乐部会询问每一位会员这个信息是否是它们所需要的(Poster向NSNotificationCenter发送通知)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在ViewController中添加观察者&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt;)&lt;span class=&quot;string&quot;&gt;prepareForSegue:&lt;/span&gt;(UIStoryboardSegue *)segue &lt;span class=&quot;string&quot;&gt;sender:&lt;/span&gt;(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心添加观察者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[NSNotificationCenter defaultCenter] &lt;span class=&quot;string&quot;&gt;addObserver:&lt;/span&gt;self &lt;span class=&quot;string&quot;&gt;selector:&lt;/span&gt;&lt;span class=&quot;annotation&quot;&gt;@selector&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;changeLabelText:&lt;/span&gt;) &lt;span class=&quot;string&quot;&gt;name:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;改变名称&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;object:&lt;/span&gt;nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中实现观察者接到消息之后执行的方法&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)changeLabelText:(&lt;span class=&quot;built_in&quot;&gt;NSNotification&lt;/span&gt;*)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.NameLabel&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;=sender&lt;span class=&quot;variable&quot;&gt;.userInfo&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在NextViewController.m中发送消息&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//通知中心发送通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSNotificationAction&lt;/span&gt;:(&lt;span class=&quot;built_in&quot;&gt;UIButton&lt;/span&gt; *)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt;* dic=@&amp;#123;&lt;span class=&quot;string&quot;&gt;@&quot;名字&quot;&lt;/span&gt;:&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.nameTextField&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.text&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [[&lt;span class=&quot;built_in&quot;&gt;NSNotificationCenter&lt;/span&gt; defaultCenter] postNotificationName:&lt;span class=&quot;string&quot;&gt;@&quot;改变名称&quot;&lt;/span&gt; object:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; userInfo:dic];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; dismissViewControllerAnimated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在ViewController.m中要移除观察者&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//移除通知中心&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;(void)&lt;span class=&quot;tag&quot;&gt;dealloc&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr_selector&quot;&gt;[[NSNotificationCenter defaultCenter]&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;removeObserver&lt;/span&gt;&lt;span class=&quot;pseudo&quot;&gt;:self&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ (NSNotificationCenter *)defaultCenter;&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)postNotification:(NSNotification *)notification;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)postNotificationName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)removeObserver:(id)observer;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)removeObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;本地通知和远程推送通知&quot;&gt;&lt;a href=&quot;#本地通知和远程推送通知&quot; class=&quot;headerlink&quot; title=&quot;本地通知和远程推送通知&quot;&gt;&lt;/a&gt;本地通知和远程推送通知&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;本地通知：由本应用负责调用，只能从当前设备上的iOS发出。&lt;br&gt;远程通知：由远程服务器上的程序发送至Apple Push Notification service(APNs)，再由APNs把消息推送住设备上对应的程序。&lt;/li&gt;
&lt;li&gt;本地通知是一个UILocalNotification对象，创建这个对象以后，就可以通过UIApplication的两个方法来发送通知了。&lt;br&gt;&lt;code&gt;- (void)presentLocalNotificationNow:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)scheduleLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;  // copies notification&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)cancelLocalNotification:(UILocalNotification *)notification NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (void)cancelAllLocalNotifications NS_AVAILABLE_IOS(4_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程通知&lt;br&gt;UIApplication中注册远程push通知：&lt;br&gt;&lt;code&gt;- (void)registerForRemoteNotifications NS_AVAILABLE_IOS(8_0);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;- (void)unregisterForRemoteNotifications NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;br&gt;调用下面方法：(重写应用程序委托类的3个方法)&lt;br&gt; &lt;code&gt;- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)notificationSettings NS_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken NS_AVAILABLE_IOS(3_0);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error NS_AVAILABLE_IOS(3_0);&lt;/code&gt;- &lt;/p&gt;
&lt;h3 id=&quot;单例传值&quot;&gt;&lt;a href=&quot;#单例传值&quot; class=&quot;headerlink&quot; title=&quot;单例传值&quot;&gt;&lt;/a&gt;单例传值&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;由于单例在内存中只创建一次的并且可以全局访问的属性,我们可以在必要的时候将数据存放在单例的属性中,并且在必要的时候从单例中通过访问其属性进行调用,这样就实现值的传递&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *Str;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataHandle&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明静态区对象的原因,希望程序运行期间,在内存中一直存在,这样对外界来说,可以随时读取数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DataHandle *dataHandle = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建单例(全局区)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)sharedDataHandle&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; == dataHandle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 我们创建单例使用加号方法的原因是因为,在创建之前,无法存在一个实例对象去调用动态方法来创建它本身&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataHandle = [[DataHandle alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; dataHandle; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们只需要在需要的时候通过其类方法(+ (instancetype)sharedDataHandle)来创建出单例对象来,然后将textField的text属性以赋值的方式赋给单例的Srt属性即可.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于各种软件来说，都离不开页面的跳转和页面的传值。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MVVM学习</title>
    <link href="http://peilinghui.com/2016/06/30/MVVM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/06/30/MVVM学习/</id>
    <published>2016-06-30T02:30:06.000Z</published>
    <updated>2016-07-01T15:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;大都APP是MVC的架构，而比如厚重的ViewController、遗失的网络逻辑（没有属于它的位置）、较差的可测试性等。。。&lt;br&gt;因此也就会有维护性较强、耦合性很低的一种新架构MVVM (MVC 引申出得新的架构)的流行。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;git地址：&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveViewModel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ReactiveCocoa/ReactiveViewModel&lt;/a&gt;&lt;br&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;View models are testable. Since they don’t need a view to do their work, presentation behavior can be tested without any UI automation or stubbing.&lt;/li&gt;
&lt;li&gt;View models can be used like models. If desired, view models can be copied or serialized just like a domain model. This can be used to quickly implement UI restoration and similar behaviors.&lt;/li&gt;
&lt;li&gt;View models are (mostly) platform-agnostic. Since the actual UI code lives in the view, well-designed view models can be used on the iPhone, iPad, and Mac, with only minor tweaking for each platform.&lt;br&gt;Views and view controllers are simpler. Once the important logic is moved elsewhere, views and VCs become dumb UI objects. This makes them easier to understand and redesign.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;大都APP是MVC的架构，而比如厚重的ViewController、遗失的网络逻辑（没有属于它的位置）、较差的可测试性等。。。&lt;br&gt;因此也就会有维护性较强、耦合性很低的一种新架构MVVM (MVC 引申出得新的架构)的流行。&lt;br&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://peilinghui.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习笔记</title>
    <link href="http://peilinghui.com/2016/06/29/ReactiveCocoa%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://peilinghui.com/2016/06/29/ReactiveCocoa学习笔记/</id>
    <published>2016-06-29T08:24:44.000Z</published>
    <updated>2016-07-04T01:40:17.000Z</updated>
    
    <content type="html">&lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;官网文档地址：&lt;a href=&quot;https://github.com/peilinghui/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/peilinghui/ReactiveCocoa&lt;/a&gt;&lt;br&gt;学习一些优秀的博客地址：&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://benbeng.leanote.com/post/ReactiveCocoaTutorial-part2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;入门教程二&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa简介&quot;&gt;&lt;a href=&quot;#ReactiveCocoa简介&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa简介&quot;&gt;&lt;/a&gt;ReactiveCocoa简介&lt;/h1&gt;&lt;p&gt;ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架.&lt;/p&gt;
&lt;p&gt;ReactiveCocoa结合了几种编程风格：&lt;/p&gt;
&lt;p&gt;函数式编程（Functional Programming）：使用高阶函数，例如函数用其他函数作为参数。&lt;br&gt;响应式编程（Reactive Programming）：关注于数据流和变化传播。&lt;br&gt;ReactiveCocoa就被开发者们描述为响应式函数编程框架(FRP);使用RAC就不需要考虑调用的顺序,直接考虑结果,使得代码高聚合,方便管理.&lt;br&gt;一个优点提供了一个单一的、统一的方法去处理异步的行为，包括delegate方法,blocks回调,target-action机制,notifications和KVO.&lt;/p&gt;
&lt;h1 id=&quot;ReactiveCocoa使用&quot;&gt;&lt;a href=&quot;#ReactiveCocoa使用&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa使用&quot;&gt;&lt;/a&gt;ReactiveCocoa使用&lt;/h1&gt;&lt;h2 id=&quot;RACSiganl-RAC的核心类-信号类-用来数据传递&quot;&gt;&lt;a href=&quot;#RACSiganl-RAC的核心类-信号类-用来数据传递&quot; class=&quot;headerlink&quot; title=&quot;RACSiganl(RAC的核心类):信号类 用来数据传递&quot;&gt;&lt;/a&gt;RACSiganl(RAC的核心类):信号类 用来数据传递&lt;/h2&gt;&lt;p&gt;注：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 该信号默认是一个冷信号,当值改变了,也并不会触发改信号,只有订阅了该信号,才会触发改信号.
- 订阅信号的方法: subscribeNext:
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//1.创建一个信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RACSignal *singal = [RACSignal createSignal:^RACDisposable *(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;&amp;lt;RACSubscriber&amp;gt; subscriber) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//2. 发送一个信号.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;Signal&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [subscriber sendCompleted];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [RACDisposable disposableWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;//信号取消&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;信号被销毁&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//3. 订阅信号 ,激活信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [singal subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//x : 就是信号发送到数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;error:^(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;error = %@&quot;&lt;/span&gt;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; completed:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;completed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;a href=&quot;#RACSubject-信号提供者，自己可以充当信号，又能发送信号。&quot; class=&quot;headerlink&quot; title=&quot;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&quot;&gt;&lt;/a&gt;RACSubject:信号提供者，自己可以充当信号，又能发送信号。&lt;/h2&gt;&lt;p&gt;使用场景:通常用来代替代理，有了它，就不必要定义代理了。&lt;br&gt;RACReplaySubject:重复提供信号类，RACSubject的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject与RACSubject区别:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。
- 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。
- 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;RACSubject和RACReplaySubject简单使用&quot;&gt;&lt;a href=&quot;#RACSubject和RACReplaySubject简单使用&quot; class=&quot;headerlink&quot; title=&quot;RACSubject和RACReplaySubject简单使用:&quot;&gt;&lt;/a&gt;RACSubject和RACReplaySubject简单使用:&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RACSubject使用步骤&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。
2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
3.发送信号 sendNext:(id)value

**RACSubject:底层实现和RACSignal不一样**
1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。
2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1.创建信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RACSubject *subject = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 2.订阅信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第一个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// block调用时刻：当信号发出新值，就会调用.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;第二个订阅者%@&quot;&lt;/span&gt;,x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 3.发送信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[subject sendNext:&lt;span class=&quot;string&quot;&gt;@&quot;1&quot;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;RACReplaySubject使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.创建信号 [RACSubject subject]，跟RACSignal不一样，创建信号时没有block。
2.可以先订阅信号，也可以先发送信号。
   2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock
   2.2 发送信号 sendNext:(id)value

// RACReplaySubject:底层实现和RACSubject不一样。
// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。
// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock

// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。
// 也就是先保存值，在订阅值。

// 1.创建信号
RACReplaySubject *replaySubject = [RACReplaySubject subject];

// 2.发送信号
[replaySubject sendNext:@1];
[replaySubject sendNext:@2];

// 3.订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第一个订阅者接收到的数据%@&amp;quot;,x);
}];

// 订阅信号
[replaySubject subscribeNext:^(id x) {

    NSLog(@&amp;quot;第二个订阅者接收到的数据%@&amp;quot;,x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RACSubject替换代理&lt;br&gt;    // 需求:&lt;br&gt;    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面&lt;br&gt;    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器&lt;/p&gt;
&lt;p&gt;步骤一：在第二个控制器.h，添加一个RACSubject代替代理。&lt;br&gt;@interface TwoViewController : UIViewController&lt;/p&gt;
&lt;p&gt;@property (nonatomic, strong) RACSubject *delegateSignal;&lt;/p&gt;
&lt;p&gt;@end&lt;/p&gt;
&lt;p&gt;步骤二：监听第二个控制器按钮点击&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@implementation&lt;/span&gt; TwoViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)&lt;span class=&quot;attribute&quot;&gt;notice&lt;/span&gt;:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 通知第一个控制器，告诉它，按钮被点了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 通知代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;// 判断代理信号是否有值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;if&lt;/span&gt; (self.delegateSignal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 有值，才需要通知&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;attr_selector&quot;&gt;[self.delegateSignal sendNext:nil]&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.&lt;br&gt;&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OneViewController&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;IBAction&lt;/span&gt;)btnClick:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 创建第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TwoViewController *twoVc = [[TwoViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; = [RACSubject subject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 订阅代理信号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [twoVc&lt;span class=&quot;variable&quot;&gt;.delegateSignal&lt;/span&gt; subscribeNext:^(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;点击了通知按钮&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 跳转到第二个控制器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; presentViewController:twoVc animated:&lt;span class=&quot;literal&quot;&gt;YES&lt;/span&gt; completion:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;替换Target和Action&quot;&gt;&lt;a href=&quot;#替换Target和Action&quot; class=&quot;headerlink&quot; title=&quot;替换Target和Action&quot;&gt;&lt;/a&gt;替换Target和Action&lt;/h2&gt;&lt;h3 id=&quot;TextField的字符变化&quot;&gt;&lt;a href=&quot;#TextField的字符变化&quot; class=&quot;headerlink&quot; title=&quot;TextField的字符变化&quot;&gt;&lt;/a&gt;TextField的字符变化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[self.textFild.rac_textSignal map:^id(id value) {
    NSLog(@&amp;quot;%@&amp;quot;, value);
    return @1;
}] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;, x);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;构造的映射块value的值就是控件中的字符变化，根据这个功能我们就可以对我们监测的东西和我们需求的东西进行转换。比如监听了字符串变化，我们需要的时变化后的字符串长度而不是变化的字符串本身，则可以在map的返回值中返回text.length，就可以实时捕获到字符串长度；甚至做一个映射表，将各个变化进行一对一或者一对多或者多对一的处理。&lt;br&gt;&lt;strong&gt;filter&lt;/strong&gt;就是过滤，它可以帮助你筛选出你需要的信号变化。&lt;br&gt;take是获取，skip是跳过，这两个方法后面跟着的都是NSInteger。所以take 2就是获取前两个信号，skip 2就是跳过前两个。repeat是重复发送信号。&lt;br&gt;&lt;strong&gt;delay&lt;/strong&gt;延时信号，顾名思义，即延迟发送信号.&lt;br&gt;&lt;strong&gt;throttle&lt;/strong&gt;搜索框的时候，有时候需求的时实时搜索，即用户每每输入字符，view都要求展现搜索结果。这时如果用户搜索的字符串较长，那么由于网络请求的延时可能造成UI显示错误，并且多次不必要的请求还会加大服务器的压力，这显然是不合理的，此时我们就需要用到节流。&lt;br&gt;&lt;strong&gt;distinctUntilChanged&lt;/strong&gt;网络请求中为了减轻服务器压力，无用的请求我们应该尽可能不发送。distinctUntilChanged的作用是使RAC不会连续发送两次相同的信号，这样就解决了这个问题。&lt;br&gt;&lt;strong&gt;timeout&lt;/strong&gt;超时信号，当超出限定时间后会给订阅者发送error信号。&lt;br&gt;&lt;strong&gt;ignore&lt;/strong&gt;忽略信号，指定一个任意类型的量（可以是字符串，数组等），当需要发送信号时讲进行判断，若相同则该信号会被忽略发送。&lt;/p&gt;
&lt;h3 id=&quot;UIButton的事件的监听&quot;&gt;&lt;a href=&quot;#UIButton的事件的监听&quot; class=&quot;headerlink&quot; title=&quot;UIButton的事件的监听&quot;&gt;&lt;/a&gt;UIButton的事件的监听&lt;/h3&gt;&lt;p&gt;  [[button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {&lt;br&gt;        //这个x就是button,已经知道了类型就可以把id x 修改成UIButton *button&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }]; &lt;/p&gt;
&lt;h3 id=&quot;手势事件&quot;&gt;&lt;a href=&quot;#手势事件&quot; class=&quot;headerlink&quot; title=&quot;手势事件&quot;&gt;&lt;/a&gt;手势事件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UITapGestureRecognizer *tap =[[UITapGestureRecognizer alloc]init];
[[tap rac_gestureSignal] subscribeNext:^(id x) {
    NSLog(@&amp;quot;%@&amp;quot;,x);
}];
[self.view addGestureRecognizer:tap];   
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RAC的通知不需要移除remove observer，因为在rac_add方法中他已经写了remove&lt;/strong&gt;&lt;br&gt;[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];  &lt;/p&gt;
&lt;h3 id=&quot;定时器&quot;&gt;&lt;a href=&quot;#定时器&quot; class=&quot;headerlink&quot; title=&quot;定时器&quot;&gt;&lt;/a&gt;定时器&lt;/h3&gt;&lt;p&gt;//延迟一定时间做某事&lt;br&gt;    [[RACScheduler mainThreadScheduler]afterDelay:2 schedule:^{&lt;br&gt;        NSLog(@”Ricky”);&lt;br&gt;    }];&lt;br&gt;//每个多长时间调用一次事件&lt;br&gt;    [[RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];&lt;/p&gt;
&lt;h3 id=&quot;KVO&quot;&gt;&lt;a href=&quot;#KVO&quot; class=&quot;headerlink&quot; title=&quot;KVO&quot;&gt;&lt;/a&gt;KVO&lt;/h3&gt;&lt;p&gt;RACObserve(TARGET, KEYPATH)这种形式，TARGET是监听目标，KEYPATH是要观察的属性值&lt;br&gt;&lt;strong&gt;监听UIScrollView的contentOffset&lt;/strong&gt;&lt;br&gt;UIScrollView *scroller =[[UIScrollView alloc]initWithFrame:CGRectMake(100, 100, 100, 200)];&lt;br&gt;    [self.view addSubview:scroller];&lt;br&gt;    [RACObserve(scroller, contentOffset) subscribeNext:^(id x) {&lt;br&gt;        NSLog(@”%@”,x);&lt;br&gt;    }];   &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  ReactiveCocoa是Github团队开发的第三方函数式响应式编程框架.&lt;br&gt;
    
    </summary>
    
      <category term="RAC" scheme="http://peilinghui.com/categories/RAC/"/>
    
    
      <category term="RAC,学习笔记" scheme="http://peilinghui.com/tags/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS中的单元测试</title>
    <link href="http://peilinghui.com/2016/06/03/iOS%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>http://peilinghui.com/2016/06/03/iOS中的单元测试/</id>
    <published>2016-06-03T08:34:43.000Z</published>
    <updated>2016-06-03T10:32:01.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发中，我们不光有测试QA姐姐，还要自己测试一下自己的代码，这时测试就显得非常重要。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;软件测试有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单元测试：测试范围最小，仅仅是测试一个小单元(比如一个方法或一个函数)，对软件的稳定性有很大的帮助。&lt;/li&gt;
&lt;li&gt;集群测试：测试范围比较大，测试项目中的所有功能&lt;/li&gt;
&lt;li&gt;压力测试：模拟大批量数据\大批量用户&lt;br&gt;下面主要说一下单元测试的内容：&lt;br&gt;参考：&lt;a href=&quot;http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html&lt;/a&gt;&lt;br&gt;Xcode5以后默认有单元测试：&lt;br&gt;单元测试2大颜色:&lt;br&gt;1.红色 : 测试失败&lt;br&gt;2.绿色 : 测试通过&lt;br&gt;好处：轻量级的测试，不用完全跑程序；及时看到错误的地方；不像NSLog，不需要运行整个程序，更快；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;断言\猜测\估计：&lt;br&gt;XCTAssertEqual&lt;br&gt;XCTAssertTrue&lt;br&gt;XCTAssertFalse&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，我们不光有测试QA姐姐，还要自己测试一下自己的代码，这时测试就显得非常重要。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS调试技巧</title>
    <link href="http://peilinghui.com/2016/05/14/iOS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://peilinghui.com/2016/05/14/iOS调试技巧/</id>
    <published>2016-05-14T09:50:17.000Z</published>
    <updated>2016-05-23T01:31:21.000Z</updated>
    
    <content type="html">&lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;对于bug,我们要合理的假设，找原因；对原因与bug之间的因果关系进行分析。&lt;/p&gt;
&lt;h2 id=&quot;lldb的使用&quot;&gt;&lt;a href=&quot;#lldb的使用&quot; class=&quot;headerlink&quot; title=&quot;lldb的使用&quot;&gt;&lt;/a&gt;lldb的使用&lt;/h2&gt;&lt;p&gt;主要是打断点的时候使用lldb.&lt;/p&gt;
&lt;h3 id=&quot;查看值&quot;&gt;&lt;a href=&quot;#查看值&quot; class=&quot;headerlink&quot; title=&quot;查看值&quot;&gt;&lt;/a&gt;查看值&lt;/h3&gt;&lt;p&gt;1&amp;gt;非对象的值&lt;br&gt;&lt;code&gt;int a = 10;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) p a&lt;br&gt;(原始命令：p = print = expression –)&lt;br&gt;输出：(int)$0 = 10&lt;br&gt;(lldb)p 10 + 10&lt;br&gt;输出：$1 = 20  &lt;/p&gt;
&lt;p&gt;2&amp;gt;对象的值&lt;br&gt;&lt;code&gt;NSString *string = @“Hello，world”;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;(lldb) po string&lt;br&gt;(原始命令：po = expression -o – = e -o –string)&lt;br&gt;输出：Hello，world  &lt;/p&gt;
&lt;p&gt;注意：清空控制台：command+K  &lt;/p&gt;
&lt;h3 id=&quot;修改变量的值&quot;&gt;&lt;a href=&quot;#修改变量的值&quot; class=&quot;headerlink&quot; title=&quot;修改变量的值&quot;&gt;&lt;/a&gt;修改变量的值&lt;/h3&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第一个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog(@&lt;span class=&quot;string&quot;&gt;&quot;第二个if被执行了&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) e(代表expression表达式) a=11&lt;br&gt;输出：(int) $0 = 11  &lt;/p&gt;
&lt;h3 id=&quot;定义一个变量&quot;&gt;&lt;a href=&quot;#定义一个变量&quot; class=&quot;headerlink&quot; title=&quot;定义一个变量&quot;&gt;&lt;/a&gt;定义一个变量&lt;/h3&gt;&lt;p&gt;(lldb) e int $b = 20&lt;br&gt;(lldb) e int $b + $0&lt;br&gt;输出：(int) $1 = 31&lt;/p&gt;
&lt;h3 id=&quot;调用一个函数&quot;&gt;&lt;a href=&quot;#调用一个函数&quot; class=&quot;headerlink&quot; title=&quot;调用一个函数&quot;&gt;&lt;/a&gt;调用一个函数&lt;/h3&gt;&lt;p&gt;代码中：&lt;br&gt;&lt;figure class=&quot;highlight scheme&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;list&quot;&gt;[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; test]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;test&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	NSLog&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;test被调用了&quot;&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;(lldb) call [self init]&lt;br&gt;输出：test被调用了&lt;/p&gt;
&lt;h3 id=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;a href=&quot;#函数提前返回，返回一个特定值&quot; class=&quot;headerlink&quot; title=&quot;函数提前返回，返回一个特定值&quot;&gt;&lt;/a&gt;函数提前返回，返回一个特定值&lt;/h3&gt;&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt; returnValue = [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; testReturn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;)testReturn&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;(lldb) thread return 100&lt;br&gt;(lldb) p returnValue&lt;br&gt;输出：(NSInteger) $1 = 0&lt;br&gt;(NSInteger) $2 = 100&lt;/p&gt;
&lt;h3 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h3&gt;&lt;p&gt;1&amp;gt;继续运行 (相当于控制台第一个按钮)&lt;br&gt;c = continue = process continue&lt;br&gt;2&amp;gt;step over&lt;br&gt;n = next = thread step-over&lt;br&gt;3&amp;gt;step in(跳入函数)&lt;br&gt;s = thread step-in&lt;br&gt;4&amp;gt;step out(跳出函数)&lt;br&gt;finish = thread step-over&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程中，难免会遇到一些bug，那么遇到bug该怎么办？如何找bug呢？&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS网络编程</title>
    <link href="http://peilinghui.com/2016/04/14/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://peilinghui.com/2016/04/14/iOS网络编程/</id>
    <published>2016-04-14T14:07:11.000Z</published>
    <updated>2016-07-16T00:56:39.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS网络编程知识总结&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;iOS网络编程&quot;&gt;&lt;a href=&quot;#iOS网络编程&quot; class=&quot;headerlink&quot; title=&quot;iOS网络编程&quot;&gt;&lt;/a&gt;iOS网络编程&lt;/h1&gt;&lt;h2 id=&quot;检测网络状态&quot;&gt;&lt;a href=&quot;#检测网络状态&quot; class=&quot;headerlink&quot; title=&quot;检测网络状态&quot;&gt;&lt;/a&gt;检测网络状态&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;检查网络状态。&lt;br&gt;1&amp;gt;下载和添加Reachablity类.&lt;br&gt;2&amp;gt;为项目添加SystemConfiguration.framework框架。&lt;br&gt;若要手动禁用ARC源文件，输入框添加“-fno-objc-arc”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;a href=&quot;#使用CFNetwork实现TCP协议的通信&quot; class=&quot;headerlink&quot; title=&quot;使用CFNetwork实现TCP协议的通信&quot;&gt;&lt;/a&gt;使用CFNetwork实现TCP协议的通信&lt;/h2&gt;&lt;p&gt;CFNetwork对基于TCP协议的网络通信提供了良好的封装，CFNetwork使用CFSocket来代表两端的通信端口，还可以通过CFStream读/写数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;IP地址是32位整数，分为A，B,C,D,E五类。用于唯一标识网络上的一个通信实体&lt;br&gt;A类：10.0.0.0~10.255.255.255&lt;br&gt;B类：172.16.0.0~172.31.255.255&lt;br&gt;C类：192.168.0.0~192.168.255.255&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;端口是16为整数，表示数据交给哪个通信程序处理，是应用程序和外界交流的出入口，包括一些数据结构和I/O。&lt;br&gt;公认端口：从0到1023，紧紧绑定一些特定的服务。&lt;br&gt;注册端口：从1024到49151，松散的绑定一些服务，适用于应用程序。&lt;br&gt;动态和/私有端口：从49152到65535.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP服务器端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个监听Socket Accept的CFSocket,并为kCFSocketAcceptCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketSetAddress()函数，将服务器的CFSocket绑定到本地IP地址和端口。&lt;br&gt;3&amp;gt;将CFSocket作为source添加到指定线程的CFRunLoop上，并运行该线程的CFRunLoop，从而保证该CFSocket能持续不断的接受来自客户端的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CFSocket实现TCP客户端&lt;br&gt;步骤：&lt;br&gt;1&amp;gt;创建一个不监听任何事件或监听Connection的CFSocket。如果要监听Connection，则需要为kCFSocketConnectCallBack事件绑定回调函数。&lt;br&gt;2&amp;gt;调用CFSocketConnectionToAddress()函数，将客户端的CFSocket；连接到指定IP地址和端口的服务器上。&lt;br&gt;3&amp;gt;得到客户端CFSocket之后，既可直接使用CFSocketNativeHandle进行读/写，也可通过CFSocket获取CFReadStreamRef、CFWriteStreamRef后进行读、写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用CocoaAsyncSocket实现TCP客户端&lt;br&gt;降低直接使用CFSocket编程的复杂度，另外有开发者提供了一套开源的CocoaAsyncSocket库。&lt;br&gt;CocoaAsyncSocket封装了CFNetwork底层的CFSocket和CFStream，并提供了异步操作，支持TCP和UDP。&lt;br&gt;特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞方式的读和写，而且可设置超时时长。&lt;/li&gt;
&lt;li&gt;自动的socket接受，如果调用它接受连接，它将为每个连接启动新的实例，当然也可以立即关闭这些连接。&lt;/li&gt;
&lt;li&gt;委托支持，错误、连接、接收、完整的读取、完整的写入、进度以及断开连接，都可通过代理模式调用。&lt;/li&gt;
&lt;li&gt;所有操作都封装在一个类中，开发者无需操作socket或流，该类封装了所有操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用NSURLConnection&quot;&gt;&lt;a href=&quot;#使用NSURLConnection&quot; class=&quot;headerlink&quot; title=&quot;使用NSURLConnection&quot;&gt;&lt;/a&gt;使用NSURLConnection&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用NSURLConnection从网络获取数据&lt;br&gt;方法:&lt;br&gt;&lt;code&gt;- (NSURLRequest *)originalRequest://获取该NSURLConnection最初的NSURLRequest对象的深拷贝&lt;/code&gt;&lt;br&gt;&lt;code&gt;- (NSURLRequest *)currentRequest://返回该该NSURLConnection当前使用的NSURLRequest对象。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1&amp;gt;同步请求获取网络数据：&lt;br&gt;&lt;code&gt;+ sendSynchronousRequest:returningResponse:error:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2&amp;gt;异步请求获取网络数据：&lt;br&gt;总指定一个NSURLConnectionDelegate对象，将该对象作为NSURLConnection的delegate，负责服务器响应到来的各种事件。&lt;br&gt;&lt;code&gt;+ connectionWithRequest:delegate://异步请求的方式获取数据&lt;/code&gt;&lt;br&gt;&lt;code&gt;- initWithRequest:delegate//实例方法，必须先调用alloc,再调用该方法。&lt;/code&gt;&lt;br&gt;&lt;code&gt;+ sendAsynchronousRequest:queue:CompletionHandler://表明将请求交给指定的NSOperationQueue处理&lt;/code&gt;&lt;br&gt;&lt;code&gt;- start://开始发送请求&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用使用NSURLConnection从网络获取数据的步骤：&lt;br&gt;1&amp;gt;创建NSURLRequest对象，该对象代表对远程服务器的请求。包括：请求的URL，缓存策略，超时时长等。&lt;br&gt;2&amp;gt;调用NSURLConnection的实例方法或类方法，以NSURLRequest对象为参数创建NSURLConnection即可发送请求。&lt;br&gt;3&amp;gt;以异步方式加载服务器响应，则需要为NSURLConnection对象指定delegate对象，因此还需要为delegate对象实现特定的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用NSMutableURLRequest向服务器发送请求&lt;br&gt;NSURLRequest只能想服务器发送简单的请求，不能添加请求头和请求参数，使用NSMutableURLRequest可以。&lt;br&gt;&lt;code&gt;-addValue:forHTTPHeaderField:为使用NSMutableURLRequest添加请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setAllHTTPHeaderField:通过一个NSDictionary一次性为NSMutableURLRequest设置多个请求头。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBody:设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPBodyStream:以NSInputStream为参数设置NSMutableURLRequest的请求参数&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPMethod:设置提交请求方式，要么是POST，要么是GET。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setHTTPShouldHandleCookies:设置该HTTP请求是否处理Cookie。&lt;/code&gt;&lt;br&gt;&lt;code&gt;-setValue：forHTTPHeaderField：为指定的请求头设置请求值。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;XML解析&quot;&gt;&lt;a href=&quot;#XML解析&quot; class=&quot;headerlink&quot; title=&quot;XML解析&quot;&gt;&lt;/a&gt;XML解析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DOM与SAX&lt;br&gt;DOM：Document Object Model。文档对象模型、&lt;br&gt;SAX：Simple API for XML。&lt;br&gt;iOS SDK提供了NSXMLParser和libxml2两个类库，还有第三方库GDataXML，TBXML，TouchXML，KissXML等。&lt;br&gt;需要读取和修改XML文档，使用GDataXML，KissXML。&lt;br&gt;需要读取非常大的XML文档，使用libxml2或TBXML。&lt;/li&gt;
&lt;li&gt;NSXMLParser解析XML文档&lt;br&gt;步骤：&lt;ul&gt;
&lt;li&gt;创建NSXMLParser对象。&lt;/li&gt;
&lt;li&gt;为NSXMLParser对象指定delegate对象，该delegate对象必须实现NSXMLParserDelegate协议，并根据需要实现协议中特定的方法。&lt;/li&gt;
&lt;li&gt;调用NSXMLParser对象的parse方法开始解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;libxml2解析XML文档&lt;br&gt;使用C语言的库，准备步骤：&lt;ul&gt;
&lt;li&gt;为项目添加libxml2.dylib库&lt;/li&gt;
&lt;li&gt;添加头文件的搜索路径&lt;br&gt;步骤：    &lt;/li&gt;
&lt;li&gt;创建XMLTextReaderPtr对象.如果以本地XML文档来创建XMLTextReaderPtr对象，则调用XMLTextReaderFilename()函数即可。如果以内存中XML文档来创建该对象，则调用XMLReaderForMemeory（）函数即可。&lt;/li&gt;
&lt;li&gt;依次调用XMLTextReaderxxx()函数来读取XML文档的元素名，元素值，属性等各种内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML解析XML文档&lt;br&gt;第三方开源库，对libxml2的宝座，底层依赖libxml2，既支持解析XML文档 ，也支持修改XML文档，支持XPath方式查询，提供了更好的面向对象的封装。&lt;br&gt;准备步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 调用GDataXMLDocument的初始化方法根据XML文档或XML字符初始化GDataXMLDocument对象。（GDataXMLDocument对象就是XML文档转换得到的DOM树）
- 调用GDataXMLDocument对象的rootElement方法即可获取该文档的根元素
- 获取根元素后，就可以根据XML元素之间的父子关系来逐层遍历，访问该XML文档中的每一个元素，从而获取XML元素的内容。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;GDataXML生成XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法创建 GDataXMLelement对象，并以该对象作为XML文档的根元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLNode的elementWithName：方法不断创建 GDataXMLelement对象（XML元素），并利用元素之间的父子关系组织这些XML元素。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLData方法获取XML文档对应的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GDataXML修改XML文档  &lt;ul&gt;
&lt;li&gt;调用GDataXMLDocument方法根据指定的XML文档或者XML字符串来生成对应的GDataXMLDocument对象–它代表了XML文档在内存中的形式。&lt;/li&gt;
&lt;li&gt;获取GDataXMLDocument对象的根元素，然后利用元素之间父子关系添加子元素、删除子元素或修改元素的内容。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对应的NSData 对象，调用NSdata的输出方法将XML文档输出到指定文件或其他存储介质。&lt;/li&gt;
&lt;li&gt;调用GDataXMLDocument对象的XMLdata的方法获取XML文档对的NSData对象，调用NSData的输出方法将XML文档输出到指定文件或其他存储介质&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;JSON解析&quot;&gt;&lt;a href=&quot;#JSON解析&quot; class=&quot;headerlink&quot; title=&quot;JSON解析&quot;&gt;&lt;/a&gt;JSON解析&lt;/h2&gt;&lt;p&gt;JSON具有跨平台，跨语言的优势。两种数据结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 由key-value对组成的数据结构。
- 有序集合  
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;使用JSON语法创建对象&lt;br&gt;直接创建一个JavaScript对象，&lt;/li&gt;
&lt;li&gt;使用JSON语法创建数组&lt;br&gt;&lt;code&gt;var a = [&amp;#39;yeeku&amp;#39;,&amp;#39;nono&amp;#39;];&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用NSJSONSerialization处理JSON数据 (系统自带)&lt;br&gt;满足条件：&lt;br&gt;顶级对象只能是NSArray或NSDictionary。&lt;br&gt;集合中包含对象只能是NSString，NSNumber，NSArray，NSDictionary或NSNull对象。&lt;br&gt;所有NSDictionary的key只能是NSString。&lt;br&gt;NSNumber保证的数值不是NaN或Infinity。  &lt;/li&gt;
&lt;li&gt;使用SBJson解析JSON数据&lt;br&gt;提供了两个工具类：SBJsonParser和SBJsonWriter.&lt;br&gt;SBJsonParser负责吧NSData或NSString形式的JSON数据转换为objective-c对象。&lt;br&gt;SBJSonWriter负责把objective-c对象转换为NSData或NSString形式的JSON数据。&lt;/li&gt;
&lt;li&gt;第三方类库解析JSON， 使用JSONKit解析JSON数据&lt;br&gt;地址：&lt;a href=&quot;https://github.com/johnezang/JSONKit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/johnezang/JSONKit&lt;/a&gt;&lt;br&gt;JSONKit速度快，JsonKit1.4不支持ARC，需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;JSONKit采用分类方式为已有的类增加了新方法。用于将JSON数据恢复为objective-c对象。&lt;br&gt;研究一下第三方框架就可以发现:&lt;br&gt;JSONKit用分类为NSString和NSDate增加了如下方法，&lt;br&gt;把JSON数据转换为OC对象：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)objectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)mutableObjectFromJSO&lt;span class=&quot;built_in&quot;&gt;NStringWithParseOptions&lt;/span&gt;:(JKParseOptionFlags)parseOptionFlags error:(&lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; **)error;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;JSONKit用分类为NSString、NSStringArray和NSDictionary增加了如下方法：将OC对象装潢为NSString和NSData形式的JSON数据。&lt;br&gt;&lt;figure class=&quot;highlight haml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSData&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONData&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;-&lt;span class=&quot;ruby&quot;&gt; (&lt;span class=&quot;constant&quot;&gt;NSString&lt;/span&gt; *)&lt;span class=&quot;constant&quot;&gt;JSONString&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;a href=&quot;#使用AFNetworking实现网络通信&quot; class=&quot;headerlink&quot; title=&quot;使用AFNetworking实现网络通信&quot;&gt;&lt;/a&gt;使用AFNetworking实现网络通信&lt;/h2&gt;&lt;p&gt;只是需要向web某个站点的某个简单页面提交请求并获取服务器响应，则使用NSURLConnection来完成。为了更好的处理web站点请求，包括处理Session,Cookie，可以用AFNetworking，用于发送HTTP请求，接受HTTP响应。但不会缓存服务器响应，不能执行HTML页面中嵌入的JavaScript代码，也不会对页面内容进行任何解析处理。AFNetworking还支持JSON、Plist属性文件和XML解析。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提交GET请求与提交POST请求&lt;br&gt;步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建AFHTTRequestOperationManager对象。&lt;/li&gt;
&lt;li&gt;根据服务器响应内容不同，为HTTORequestOperationManager对象指定不同的解析器。（JSON或Plist数据）&lt;/li&gt;
&lt;li&gt;如果需要发送GET请求，调用AFHTTRequestOperationManager对象的GET：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;如果要发送POST请求，调用AFHTTRequestOperationManager对象的POST：parameters:success：failure：方法即可 。&lt;/li&gt;
&lt;li&gt;在success：参数指定的代码块中处理服务器响应成功的正确数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理JSON和Plist响应&lt;br&gt;可以直接将JSON和Plist转化为NSArray或NSDictionary对象。  AFHTTORequestOperationManager默认可以处理JSON或Plist对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理XML响应&lt;br&gt;为AFHTTORequestOperationManager显示使用&lt;br&gt;AF X MLParserResponseSerializer响应解析器，当使用AF X MLParserResponseSerializer解析器时，服务器返回的数据是一个NSXMLParser对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传文件&lt;br&gt;AFHTTRequestOperationManager对象的POST：    parameters:constructingBodyWithBlock:success：failure：方法提交POST请求即可，多了三个参数，一个是带AFMultipartFormData形参的代码块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;a href=&quot;#使用ASIHTTPRequest框架实现网络编程&quot; class=&quot;headerlink&quot; title=&quot;使用ASIHTTPRequest框架实现网络编程&quot;&gt;&lt;/a&gt;使用ASIHTTPRequest框架实现网络编程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发送同步或异步的GET请求&lt;br&gt;准备步骤：&lt;br&gt;目前不支持ARC，应该需要在支持ARC的项目中设置‘fno-objc-arc’选项来禁用ARC。&lt;br&gt;步骤：&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;使用代码块&lt;br&gt;ASIHTTPRequest发送异步请求，即可使用delegate为ASIHTTPRequest设置回调处理代码，也可用代码块来设置回调处理代码。&lt;br&gt;&lt;code&gt;-setCompletionBlock:设置发送请求、获取服务器响应完成时激发的代码块。&lt;/code&gt;&lt;br&gt;`-setFailedBlock:获取发送请求失败时激发的代码块。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS网络编程知识总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://peilinghui.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS读书笔记</title>
    <link href="http://peilinghui.com/2016/04/01/iOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0md/"/>
    <id>http://peilinghui.com/2016/04/01/iOS读书笔记md/</id>
    <published>2016-04-01T05:01:49.000Z</published>
    <updated>2017-02-22T10:39:48.000Z</updated>
    
    <content type="html">&lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;effective-objective-c-2-0&quot;&gt;&lt;a href=&quot;#effective-objective-c-2-0&quot; class=&quot;headerlink&quot; title=&quot;effective objective-c 2.0&quot;&gt;&lt;/a&gt;effective objective-c 2.0&lt;/h1&gt;&lt;p&gt;作者网站：&lt;a href=&quot;http://www.galloway.me.uk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.galloway.me.uk/&lt;/a&gt;&lt;br&gt;英文原版：&lt;a href=&quot;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.gitbook.com/book/xiaoxueying/effective-objective-c-2-0/details&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就把重点的几个摘录出来了。&lt;/p&gt;
&lt;h2 id=&quot;熟悉Objective-c&quot;&gt;&lt;a href=&quot;#熟悉Objective-c&quot; class=&quot;headerlink&quot; title=&quot;熟悉Objective-c&quot;&gt;&lt;/a&gt;熟悉Objective-c&lt;/h2&gt;&lt;h3 id=&quot;Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot;&gt;&lt;a href=&quot;#Objective-C是一门动态语言-该语言使用的是”消息结构”而非”函数调用”&quot; class=&quot;headerlink&quot; title=&quot;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&quot;&gt;&lt;/a&gt;Objective-C是一门动态语言, 该语言使用的是”消息结构”而非”函数调用”.&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;消息结构 : 运行时所执行的代码由运行时环境决定
函数调用 : 运行时所执行的代码由编译期决定.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;code&gt;[person run];&lt;/code&gt;&lt;br&gt;给person对象发送一条run消息 : 不到程序运行的时候你都不知道他究竟会执行什么代码. 而且, person这个对象究竟是Person类的对象, 还是其他类的对象, 也要到运行时才能确定, 这个过程叫动态绑定.&lt;/p&gt;
&lt;p&gt;对象所占内存总是分配在堆空间中. 不能在栈中分配Objective-C对象.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;栈空间 : 栈空间的内存不用程序员管理.
堆空间 : 堆空间的内存需要程序员管理.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;a href=&quot;#第2条：在类的头文件中尽量少引入其他头文件&quot; class=&quot;headerlink&quot; title=&quot;第2条：在类的头文件中尽量少引入其他头文件&quot;&gt;&lt;/a&gt;第2条：在类的头文件中尽量少引入其他头文件&lt;/h3&gt;&lt;p&gt;在.h文件中用@Class,在.m文件中再引入头文件。来缩短编译时间，降低彼此的依赖程度，降低类之间的耦合。&lt;/p&gt;
&lt;h3 id=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;a href=&quot;#第3条：多用字面量语法，少用与之等价的方法&quot; class=&quot;headerlink&quot; title=&quot;第3条：多用字面量语法，少用与之等价的方法&quot;&gt;&lt;/a&gt;第3条：多用字面量语法，少用与之等价的方法&lt;/h3&gt;&lt;p&gt;字面量数值：&lt;code&gt;NSNumber *someNumber = @1;&lt;/code&gt;&lt;br&gt;字面量数组：&lt;code&gt;NSArray *animals=@[@&amp;quot;cat&amp;quot;,@&amp;quot;dog&amp;quot;,@&amp;quot;mouse&amp;quot;];&lt;/code&gt;  取某个下标所对应的对象更方便：&lt;code&gt;NSString *dog = animals[1]&lt;/code&gt;&lt;br&gt;字面量字典：&lt;code&gt;NSDictionary *personData = @{
                @&amp;quot;firstname&amp;quot;: @&amp;quot;pei&amp;quot;,
                @&amp;quot;lastname&amp;quot;: @&amp;quot;linghui&amp;quot;,
                @&amp;quot;age&amp;quot;: @&amp;quot;21&amp;quot;;
     };&lt;/code&gt;取值：&lt;code&gt;mutableDictionary[@&amp;quot;firstname&amp;quot;] = @&amp;quot;pei&amp;quot;;&lt;/code&gt;&lt;br&gt;使用字面量语法创建出来的字符串、数组、字典对象都是不可变的，若想变成可变的需在后面添加mutableCopy;&lt;/p&gt;
&lt;p&gt;我用们字面量语法替代传统的alloc-init来创建对象的好处 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;方便直观
更加安全
更利于debug
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;局限性 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;只有NSString, NSArray, NSDictionary, NSNumber支持字面量语法
若想用字面量语法创建出可变对象, 则需要再次调用mutableCopy方法复制多一份(多调用了一个方法, 多创建了一个对象. 不必要)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第4条：多用类型常量，少用-define预处理指令&quot;&gt;&lt;a href=&quot;#第4条：多用类型常量，少用-define预处理指令&quot; class=&quot;headerlink&quot; title=&quot;第4条：多用类型常量，少用#define预处理指令&quot;&gt;&lt;/a&gt;第4条：多用类型常量，少用#define预处理指令&lt;/h3&gt;&lt;p&gt;一般在工程中，会把常量定义在prefix.pch或者是一些接口常量定义在Constants.h文件中。更好的方法是在.m文件中用static与const来声明&lt;code&gt;static const NSTimeInterval Duration = 0.3&lt;/code&gt;&lt;br&gt;若是全局变量，则在.h中用extern关键字修饰，在.m文件中赋值。&lt;br&gt;&lt;code&gt;extern NSString *const TDFConstants&lt;/code&gt;&lt;br&gt;&lt;code&gt;NSString *const TDFConstants = @&amp;quot;VALUE&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高.  &lt;/p&gt;
&lt;p&gt;宏能做到const不能办到的事.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;宏能定义函数
OC的单例模式用到宏
宏还能根据传入的参数生成字符串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么少用#define预处理指令?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;用预处理指令定义的常量不含类型信息
编译时只会进行简单查找与替代操作, 会分配多次内存
如果有人重新定义了常量值, 则会导致程序中常量值不一致
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么多用类型常量?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在实现文件中使用static const定义只在该文件内可见的常量, 其他文件无法使用(无需给常量名称加前缀)
在头文件中使用extern来声明全局常量, 并在实现文件中定义其值, 可以供整个程序使用(需要给常量名称加前缀)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;a href=&quot;#第5条：用枚举表示状态、选项、状态码&quot; class=&quot;headerlink&quot; title=&quot;第5条：用枚举表示状态、选项、状态码&quot;&gt;&lt;/a&gt;第5条：用枚举表示状态、选项、状态码&lt;/h3&gt;&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CASH&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;现金&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CARD&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,      &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;银行卡&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;constant&quot;&gt;KIND_CREDIT_ACCOUNT&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,   &lt;span class=&quot;regexp&quot;&gt;//&lt;/span&gt;挂账&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;constant&quot;&gt;KindPay_Kind&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项不需要组合使用, 则用NS_ENUM&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;NS_ENUM&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;NSInteger&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransition&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionNone&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromLeft&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionFlipFromRight&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlUp&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;UIViewAnimationTransitionCurlDown&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举类型的多个选项可能组合使用, 则用NS_OPTIONS&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NS_OPTIONS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NSUInteger, UIViewAutoresizing)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingNone                 = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleLeftMargin   = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleWidth        = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleRightMargin  = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleTopMargin    = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleHeight       = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewAutoresizingFlexibleBottomMargin = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码为苹果源码.&lt;strong&gt;使用NS_ENUM和NS_OPTIONS来替代C语言的enum的好处&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可以自定义枚举的底层数据类型
在C中使用C的语法, 在OC中使用OC的语法, 保持语法的统一
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外, 在处理枚举的switch语句中, 不要使用default分支, 因为以后你加入新枚举之后, 编译器会提示开发者 : switch语句没有处理所有枚举(没使用default的情况下).&lt;/p&gt;
&lt;h2 id=&quot;对象、消息、运行期&quot;&gt;&lt;a href=&quot;#对象、消息、运行期&quot; class=&quot;headerlink&quot; title=&quot;对象、消息、运行期&quot;&gt;&lt;/a&gt;对象、消息、运行期&lt;/h2&gt;&lt;h3 id=&quot;第6条：属性&quot;&gt;&lt;a href=&quot;#第6条：属性&quot; class=&quot;headerlink&quot; title=&quot;第6条：属性&quot;&gt;&lt;/a&gt;第6条：属性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;@property, @synthesize, @dynamic&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;@property&lt;/strong&gt;可以自动创建存取方法，帮我们分解成setter和getter方法声明&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@synthesize firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上代码相当于给Person类添加一个_firstName的实例变量并为该实例变量生成setter和getter方法的实现(存取方法).&lt;br&gt;手动调用@synthesize可以用来修改实例变量的名称&lt;br&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;&lt;br&gt;&lt;code&gt;@implementation Person
@dynamic firstName;
@end&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该代码会告诉编译器 : 不要自动创建实现属性(property)所用的实例变量(_property)和存取方法实现(setter和getter).&lt;br&gt;也就是说, 实例变量不存在了, 因为编译器不会自动帮你创建了. 而且如果你不手动实现setter和getter, 使用者用点语法或者对象方法调用setter和getter时, 程序会直接崩溃, 崩溃原因很简单 : unrecognized selector sent to instance&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 原子性：nonatomic不使用同步锁。
- 读写权限：readwrite(读写)有setter和getter由@synthesize自动实现；readonly(只读)只有getter方法
- 内存管理：assign：简单赋值(纯量)；strong：先保留新值，再释放旧值，然后再将新值设置上去。weak:不保留新值，也不释放旧值，在属性所指对象遭到摧毁时，属性值也会清空。unsafe_retained:在属性所指对象遭到摧毁时，属性值不会清空，与assign类似，不过只用于对象。copy：与strong类似，但是不保留新值，而是拷贝，用于NSString。
- 方法名：getter=&amp;lt;name&amp;gt;;  setter=&amp;lt;name&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;a href=&quot;#第7条：在对象内部尽量直接访问实例变量&quot; class=&quot;headerlink&quot; title=&quot;第7条：在对象内部尽量直接访问实例变量&quot;&gt;&lt;/a&gt;第7条：在对象内部尽量直接访问实例变量&lt;/h3&gt;&lt;p&gt;为什么呢? 使用点语法不好吗? 这里说说区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;直接用_xxx访问实例变量而不用点语法可以绕过OC的&amp;quot;方法派发&amp;quot;, 效率比用点语法来访问快
直接用_xxx访问实例变量而不用点语法不会调用setter方法, 所以不会触发KVO(Key Value Observing), 同时如果你访问的该属性是声明为copy的属性, 则不会进行拷贝, 而是直接保留新值, 释放旧值.
使用点语法访问有助于debug, 因为可以在setter或getter中增加断点来监控方法的调用
属性使用懒加载时, 必须使用点语法, 否则实例变量永远不会初始化(因为懒加载实际就是调用getter方法, 直接访问实例变量绕过了该方法, 所以该变量则永远为nil)
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;在&lt;strong&gt;读取&lt;/strong&gt;实例变量的时候采用&lt;strong&gt;直接访问&lt;/strong&gt;的形式，在&lt;strong&gt;设置&lt;/strong&gt;实例变量的时候采用通过&lt;strong&gt;属性&lt;/strong&gt;。 &lt;/li&gt;
&lt;li&gt;在初始化方法以及dealloc方法中，直接通过实例变量来读写数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第8条：对象等同性&quot;&gt;&lt;a href=&quot;#第8条：对象等同性&quot; class=&quot;headerlink&quot; title=&quot;第8条：对象等同性&quot;&gt;&lt;/a&gt;第8条：对象等同性&lt;/h3&gt;&lt;p&gt;比较两个对象是否相同.&lt;br&gt;我们可以重写isEqual方法自定义对象等同的条件&lt;/p&gt;
&lt;h3 id=&quot;第9条：类族模式&quot;&gt;&lt;a href=&quot;#第9条：类族模式&quot; class=&quot;headerlink&quot; title=&quot;第9条：类族模式&quot;&gt;&lt;/a&gt;第9条：类族模式&lt;/h3&gt;&lt;p&gt;Objective-C的系统框架中普遍使用此模式, 用子类来隐藏”抽象基类”的内部实现细节.&lt;br&gt;我们肯定使用过UIButton的这个类方法&lt;/p&gt;
&lt;p&gt; &lt;code&gt;+ (UIButton *)buttonWithType:(UIButtonType)type;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这就是UIButton类实现的”工厂方法”, 根据传入的枚举创建并返回合乎条件的子类.&lt;/p&gt;
&lt;p&gt;Foundation框架中大部分容器类都是类族, 如NSArray与NSMutableArray, NSSet与NSMutableSet, NSDictionary与NSMutableDictionary.&lt;/p&gt;
&lt;p&gt;用isKindOfClass方法可以判断对象所属的类是否位于类族之中.&lt;/p&gt;
&lt;p&gt;在类族中实现子类时所需遵循的规范一般都会定义于基类的文档之中, 使用前应先看看.&lt;/p&gt;
&lt;p&gt;具体类族的使用方法大家请看书~~&lt;/p&gt;
&lt;h3 id=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;a href=&quot;#第10条：在既有类中使用关联对象存放自定义数据&quot; class=&quot;headerlink&quot; title=&quot;第10条：在既有类中使用关联对象存放自定义数据&quot;&gt;&lt;/a&gt;第10条：在既有类中使用关联对象存放自定义数据&lt;/h3&gt;&lt;p&gt;在类的内部利用哈希表映射技术, 关联一个与该类毫无耦合的对象.&lt;br&gt;使用场景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为现有的类添加私有变量以帮助实现细节
为现有的类添加公有属性
为KVO创建一个关联的观察者
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;鉴于书中所说, 容易出现循环引用, 以及关联对象释放和移除不同步等缺陷,&lt;/p&gt;
&lt;h3 id=&quot;第11条：理解objc-msgSend的作用&quot;&gt;&lt;a href=&quot;#第11条：理解objc-msgSend的作用&quot; class=&quot;headerlink&quot; title=&quot;第11条：理解objc_msgSend的作用&quot;&gt;&lt;/a&gt;第11条：理解objc_msgSend的作用&lt;/h3&gt;&lt;p&gt;消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。&lt;br&gt;OC的消息机制&lt;br&gt;&lt;code&gt;[someObject messageName: parameter]&lt;/code&gt;&lt;br&gt;&lt;code&gt;id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&amp;quot;方法列表&amp;quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&amp;quot;消息转发&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一些函数：&lt;br&gt;objc_msgSend_stret:待发送的消息要返回结构体&lt;br&gt;objc_msgSend_fpret:消息返回的是浮点数&lt;br&gt;objc_msgSendSuper:要给超类发送消息&lt;/p&gt;
&lt;h3 id=&quot;第12条：消息转发机制&quot;&gt;&lt;a href=&quot;#第12条：消息转发机制&quot; class=&quot;headerlink&quot; title=&quot;第12条：消息转发机制&quot;&gt;&lt;/a&gt;第12条：消息转发机制&lt;/h3&gt;&lt;p&gt;消息转发分为两大阶段：第一阶段：征询接受者，动态方法解析。&lt;br&gt;第二阶段：完整的消息转发机制，请接收者看看有没有其他对象能处理这条消息，若有，则把消息转给那个对象。若没有，则启动完整的消息转发机制，会把消息有关的细节全都封装到NSInvocation中去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态方法解析：对象收到无法解读的消息后，调用类方法：&lt;br&gt;&lt;code&gt;+(BOOL)resolveInstanceMethod:(SEL)selector&lt;/code&gt;&lt;br&gt;要访问CoreData框架中的NSManagedObjects对象时，用resolveInstanceMethod来实现@dynamic属性。  &lt;/li&gt;
&lt;li&gt;备援接收者：能不能把这条消息传给其他接收者来处理&lt;br&gt;&lt;code&gt;-(id)forwardingTargetForSelector:(SEL)selctor;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;完整的消息转发：首先，创建NSInvocation对象，把选择子，目标(target)及参数都封装于其中，在触发NSInvocation对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。&lt;br&gt;&lt;code&gt;-(void)forwardInvocation:(NSInvocation *)invocation;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消息转发的全流程：&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;以完整的例子演示动态方法解析&lt;br&gt;由开发者来添加属性定义，并将其声明为@dynamic，而类则会自动处理相关属性值的存放于获取操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第13条：用method-swizzling调试黑盒方法&quot;&gt;&lt;a href=&quot;#第13条：用method-swizzling调试黑盒方法&quot; class=&quot;headerlink&quot; title=&quot;第13条：用method swizzling调试黑盒方法&quot;&gt;&lt;/a&gt;第13条：用method swizzling调试黑盒方法&lt;/h3&gt;&lt;p&gt;method swizzling：与给定的选择子名称相对应得方法也可以在运行期改变。（不需要源码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能）可用在本类的所有实例中。&lt;strong&gt;使用另一份实现来替换原有的方法实现&lt;/strong&gt;&lt;br&gt;IMP指针：id(*IMP)(id,SEL,….)类的方法列表会吧选择子的名称映射到相关方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示。&lt;br&gt;互换两个方法的实现：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;互换两个已经写好方法实现：(两个参数为待交换的两个方法实现)&lt;br&gt;&lt;code&gt;void method_exchangeImplementations(Method m1,Method m2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获得方法实现：&lt;br&gt;&lt;code&gt;Method class_getInstanceMethod(Class aClass,SEL aselector)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用途：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 来为既有的方法添加新功能，新方法添加在NSString的一个“分类”中，在方法中实现所需的附加功能，并调用原有的实现。
- 为完全不知道其具体实现的黑盒方法增加日志记录，有助于程序调试。不宜乱用
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;a href=&quot;#第14条：理解“类对象”的用意&quot; class=&quot;headerlink&quot; title=&quot;第14条：理解“类对象”的用意&quot;&gt;&lt;/a&gt;第14条：理解“类对象”的用意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Objective-c对象的本质：都是指向某块内存数据的指针，所以声明变量时，类型后面要加“&lt;em&gt;”字符。`NSString &lt;/em&gt;point= @“string”；&lt;code&gt;id类型本身就是指针。可以改写为&lt;/code&gt;id point= @“string”;`&lt;br&gt;描述objective-c对象所用的数据结构定义在runtime.h文件中，对于id，Class，还有is a 指针，涉及到runtime的机制，可以看这篇文章：&lt;a href=&quot;https://www.ianisme.com/ios/2019.html?utm_source=tuicool&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.ianisme.com/ios/2019.html?utm_source=tuicool&amp;amp;utm_medium=referral&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在类继承体系中查询类型信息&lt;br&gt;“isMemberOfClass”:能够判断出对象是否为某个特定类的实例。&lt;br&gt;“isKindOfClass”:能够判断出对象是否为某类或某派生类的实例。&lt;br&gt;通过使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。
如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。
尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;接口与API设计&quot;&gt;&lt;a href=&quot;#接口与API设计&quot; class=&quot;headerlink&quot; title=&quot;接口与API设计&quot;&gt;&lt;/a&gt;接口与API设计&lt;/h2&gt;&lt;h3 id=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;a href=&quot;#第15条：用前缀避免命名空间的冲突&quot; class=&quot;headerlink&quot; title=&quot;第15条：用前缀避免命名空间的冲突&quot;&gt;&lt;/a&gt;第15条：用前缀避免命名空间的冲突&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;选择与你公司、应用程序或者二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。
若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。
Apple宣称保留使用所有两字母前缀的权利，所以自己所选用的前缀最好是三字母的。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;a href=&quot;#第16条：提供“全能初始化方法”&quot; class=&quot;headerlink&quot; title=&quot;第16条：提供“全能初始化方法”&quot;&gt;&lt;/a&gt;第16条：提供“全能初始化方法”&lt;/h3&gt;&lt;h3 id=&quot;第17条：实现description方法&quot;&gt;&lt;a href=&quot;#第17条：实现description方法&quot; class=&quot;headerlink&quot; title=&quot;第17条：实现description方法&quot;&gt;&lt;/a&gt;第17条：实现description方法&lt;/h3&gt;&lt;p&gt;调试程序时，LLDB调试，在封装的JSONHelper中看到了这样的方法：&lt;br&gt;&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//对象转换为json对象.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSString *) &lt;span class=&quot;string&quot;&gt;transJson:&lt;/span&gt;(Jastor *) obj&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *returnDic = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *array =[JastorRuntimeHelper &lt;span class=&quot;string&quot;&gt;propertyNames:&lt;/span&gt;[obj &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;NSString&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;array&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;([key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;description&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;debugDescription&quot;&lt;/span&gt;] || [key &lt;span class=&quot;string&quot;&gt;isEqualToString:&lt;/span&gt;@&lt;span class=&quot;string&quot;&gt;&quot;superclass&quot;&lt;/span&gt;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [returnDic &lt;span class=&quot;string&quot;&gt;setValue:&lt;/span&gt;[obj &lt;span class=&quot;string&quot;&gt;valueForKey:&lt;/span&gt;key] &lt;span class=&quot;string&quot;&gt;forKey:&lt;/span&gt;key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *returnString = [returnDic JSONString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; returnString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中description在Foundation框架的NSString.h中&lt;br&gt;&lt;code&gt;@property (readonly, copy) NSString *description;&lt;/code&gt;&lt;br&gt;在objc的NSObject.h中&lt;br&gt;`+ (NSString *)description;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(NSString *)debugDescription;`&lt;br&gt;在Foundation框架的NSproxy.h中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;a href=&quot;#第18条：尽量使用不可变对象&quot; class=&quot;headerlink&quot; title=&quot;第18条：尽量使用不可变对象&quot;&gt;&lt;/a&gt;第18条：尽量使用不可变对象&lt;/h3&gt;&lt;h3 id=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;a href=&quot;#第19条：使用清晰而协调的命名方式&quot; class=&quot;headerlink&quot; title=&quot;第19条：使用清晰而协调的命名方式&quot;&gt;&lt;/a&gt;第19条：使用清晰而协调的命名方式&lt;/h3&gt;&lt;h3 id=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;a href=&quot;#第20条：为私有方法名加前缀&quot; class=&quot;headerlink&quot; title=&quot;第20条：为私有方法名加前缀&quot;&gt;&lt;/a&gt;第20条：为私有方法名加前缀&lt;/h3&gt;&lt;p&gt;便于修改方法名或方法签名，可以使用- (void)p_private{};私有方法只在实现的时候声明。&lt;br&gt;不要单用一个下划线做私有方法的前缀，因为这种做法的预留给苹果公司用的。&lt;/p&gt;
&lt;h3 id=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;a href=&quot;#第21条：理解Objective-C错误模型&quot; class=&quot;headerlink&quot; title=&quot;第21条：理解Objective-C错误模型&quot;&gt;&lt;/a&gt;第21条：理解Objective-C错误模型&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;ARC下,想生成“异常安全”的代码，需要打开的编译器标志叫做-fobjc-arc-exception.&lt;/li&gt;
&lt;li&gt;objective-c所采用的方法：只在极其罕见的情况下抛出异常，异常抛出后，无需考虑恢复问题，而且应用程序此时也应该退出。最好的方法：在那些子类必须覆写的超类方法里抛出异常。令方法返回nil/0.或是使用NSError，以表明其中有错误发生。如：  &lt;/li&gt;
&lt;li&gt;初始化方法无法根据传入的参数来初始化当前实例，那么就可以令其返回nil/0。&lt;/li&gt;
&lt;li&gt;NSError：&lt;ul&gt;
&lt;li&gt;Error domain（类型为字符串）：用全局变量定义，在从URL中解析或取得数据时出错了，就使用NSURLErrorDomain来表示错误范围。&lt;/li&gt;
&lt;li&gt;Error code（类型为整数）：用enum定义，当HTTP请求出错时，可能会把HTTP状态码设置为错误码。&lt;/li&gt;
&lt;li&gt;User Info（类型为字典）：可将错误串成“错误链”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NSError的用法：&lt;ul&gt;
&lt;li&gt;通过委托协议来传递此错误。NSURLConnection在NSURLConnectionDelegate中定义了：&lt;code&gt;-(void)connection:(NSURLConnection *)connection didFail WithError:(NSError *)error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;经由方法的“输出参数”返回给调用者&lt;code&gt;-(BOOL)doSomething:(NSError **)error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总结：&lt;br&gt; 只有发生了可使整个应用程序崩溃的严重错误时，才使用异常。&lt;br&gt; 在错误不那么严重的情况下，可以指派委托方法来处理错误，也可把错误信息放在NSError对象里，经由输出参数返回给调用者。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;a href=&quot;#第22条：理解NSCopying协议&quot; class=&quot;headerlink&quot; title=&quot;第22条：理解NSCopying协议&quot;&gt;&lt;/a&gt;第22条：理解NSCopying协议&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;若想令自己所写的对象具有拷贝功能，则需遵循NSCopying协议。&lt;br&gt;实现方法：&lt;code&gt;-(id)copyWithZone:(NSZone *)zone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。&lt;/li&gt;
&lt;li&gt;深拷贝：在拷贝对象自身时，将其底层数据也一并复制过去。&lt;br&gt;浅拷贝：在拷贝对象时，只拷贝容器对象本身，而不复制其中每个对象。（Foundation框架中的所有collection类在默认情况下执行浅拷贝）&lt;br&gt;复制对象时，一般执行浅拷贝。&lt;/li&gt;
&lt;li&gt;如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;协议与分类&quot;&gt;&lt;a href=&quot;#协议与分类&quot; class=&quot;headerlink&quot; title=&quot;协议与分类&quot;&gt;&lt;/a&gt;协议与分类&lt;/h2&gt;&lt;h3 id=&quot;第23条：通过delegate与data-source协议进行对象间通信&quot;&gt;&lt;a href=&quot;#第23条：通过delegate与data-source协议进行对象间通信&quot; class=&quot;headerlink&quot; title=&quot;第23条：通过delegate与data source协议进行对象间通信&quot;&gt;&lt;/a&gt;第23条：通过delegate与data source协议进行对象间通信&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Delegate pattern：定义一套接口，某对象若想接受另一个对象的委托，需遵从该接口，以便成为其“委托对象”。而这“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象。    &lt;/li&gt;
&lt;li&gt;好处：可将数据与业务解耦，如：页面有个显示一系列数据所用的视图，此视图只需要包含显示数据所需的逻辑代码，而不应该决定要显示何种数据以及数据之间如何交互。  &lt;/li&gt;
&lt;li&gt;委托协议名要在相关类名@protocol后面加Delegate，类中用一个用一个属性来存放其委托对象，&lt;code&gt;@property(nonatomic,weak)id&amp;lt;TDFNetworkingDelegate&amp;gt;delegate;&lt;/code&gt;必须设置为weak或unsafe_unretained（使用strong容易引入“保留环”）&lt;br&gt;委托协议常用@option来标注大部分或全部方法。&lt;/li&gt;
&lt;li&gt;委托模式：对象把应对某个行为的责任委托给另外一个类了。&lt;/li&gt;
&lt;li&gt;数据源模式：信息从data source流向Class再流向delegate。&lt;/li&gt;
&lt;li&gt;若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;a href=&quot;#第24条：将类的实现代码分散到便于管理的数个分类之中&quot; class=&quot;headerlink&quot; title=&quot;第24条：将类的实现代码分散到便于管理的数个分类之中&quot;&gt;&lt;/a&gt;第24条：将类的实现代码分散到便于管理的数个分类之中&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用category机制把类的实现代码划分成易于管理的小块。&lt;/li&gt;
&lt;li&gt;将应该视为私有的方法归入名叫Private的分类中，以隐藏实现细节。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;a href=&quot;#第25条：总是为第三方类的分类名称加前缀&quot; class=&quot;headerlink&quot; title=&quot;第25条：总是为第三方类的分类名称加前缀&quot;&gt;&lt;/a&gt;第25条：总是为第三方类的分类名称加前缀&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其名称加上你专用的前缀。&lt;/li&gt;
&lt;li&gt;向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;a href=&quot;#第26条：勿在分类中声明属性&quot; class=&quot;headerlink&quot; title=&quot;第26条：勿在分类中声明属性&quot;&gt;&lt;/a&gt;第26条：勿在分类中声明属性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;把封装数据所用的全部属性都定义在主接口里。&lt;/li&gt;
&lt;li&gt;在class-continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性。&lt;/li&gt;
&lt;li&gt;如果需要在分类中为该属性实现存取方法，可以把存取方法声明为@dynamic。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;a href=&quot;#第27条：使用class-continuation分类隐藏实现细节&quot; class=&quot;headerlink&quot; title=&quot;第27条：使用class-continuation分类隐藏实现细节&quot;&gt;&lt;/a&gt;第27条：使用class-continuation分类隐藏实现细节&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;class-continuation分类与普通分类不同，它必须定义在其所接续的那个类的实现文件中，唯一能声明实例变量的分类。&lt;/li&gt;
&lt;li&gt;作用：定义方法和实例变量。&lt;/li&gt;
&lt;li&gt;可以实现OC和C++的混编，如：网页浏览器的框架WebKit，大部分代码是C++，而对外显示的却是OC代码，CoreAnimation里面后端代码使用C++，对外公布却是OC接口。&lt;/li&gt;
&lt;li&gt;将public接口中声明为“只读”的属性扩展为“可读写”以便在类的内部使用其属性。（我们通常不直接访问实例变量，而是通过设置访问方法来做，因为这样能触发KVO通知，其他对象有可能监听此事件）&lt;h3 id=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;a href=&quot;#第28条：通过协议提供匿名对象&quot; class=&quot;headerlink&quot; title=&quot;第28条：通过协议提供匿名对象&quot;&gt;&lt;/a&gt;第28条：通过协议提供匿名对象&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h2&gt;&lt;h3 id=&quot;第29条：理解引用计数&quot;&gt;&lt;a href=&quot;#第29条：理解引用计数&quot; class=&quot;headerlink&quot; title=&quot;第29条：理解引用计数&quot;&gt;&lt;/a&gt;第29条：理解引用计数&lt;/h3&gt;&lt;h3 id=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;a href=&quot;#第30条：以ARC简化引用计数&quot; class=&quot;headerlink&quot; title=&quot;第30条：以ARC简化引用计数&quot;&gt;&lt;/a&gt;第30条：以ARC简化引用计数&lt;/h3&gt;&lt;h3 id=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;a href=&quot;#第31条：在dealloc方法中只释放引用并解除监听&quot; class=&quot;headerlink&quot; title=&quot;第31条：在dealloc方法中只释放引用并解除监听&quot;&gt;&lt;/a&gt;第31条：在dealloc方法中只释放引用并解除监听&lt;/h3&gt;&lt;h3 id=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;a href=&quot;#第32条：编写异常安全代码时留意内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第32条：编写异常安全代码时留意内存管理问题&quot;&gt;&lt;/a&gt;第32条：编写异常安全代码时留意内存管理问题&lt;/h3&gt;&lt;h3 id=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;a href=&quot;#第33条：以弱引用避免重复引用&quot; class=&quot;headerlink&quot; title=&quot;第33条：以弱引用避免重复引用&quot;&gt;&lt;/a&gt;第33条：以弱引用避免重复引用&lt;/h3&gt;&lt;h3 id=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;a href=&quot;#第34条：以自动释放池块降低内存峰值&quot; class=&quot;headerlink&quot; title=&quot;第34条：以自动释放池块降低内存峰值&quot;&gt;&lt;/a&gt;第34条：以自动释放池块降低内存峰值&lt;/h3&gt;&lt;h3 id=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;a href=&quot;#第35条：用“僵尸对象”调试内存管理问题&quot; class=&quot;headerlink&quot; title=&quot;第35条：用“僵尸对象”调试内存管理问题&quot;&gt;&lt;/a&gt;第35条：用“僵尸对象”调试内存管理问题&lt;/h3&gt;&lt;h3 id=&quot;第36条：不要使用retainCount&quot;&gt;&lt;a href=&quot;#第36条：不要使用retainCount&quot; class=&quot;headerlink&quot; title=&quot;第36条：不要使用retainCount&quot;&gt;&lt;/a&gt;第36条：不要使用retainCount&lt;/h3&gt;&lt;h2 id=&quot;block与GCD&quot;&gt;&lt;a href=&quot;#block与GCD&quot; class=&quot;headerlink&quot; title=&quot;block与GCD&quot;&gt;&lt;/a&gt;block与GCD&lt;/h2&gt;&lt;h3 id=&quot;第37条：理解block的概念&quot;&gt;&lt;a href=&quot;#第37条：理解block的概念&quot; class=&quot;headerlink&quot; title=&quot;第37条：理解block的概念&quot;&gt;&lt;/a&gt;第37条：理解block的概念&lt;/h3&gt;&lt;h3 id=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;a href=&quot;#第38条：为常用的block类型创建typedef&quot; class=&quot;headerlink&quot; title=&quot;第38条：为常用的block类型创建typedef&quot;&gt;&lt;/a&gt;第38条：为常用的block类型创建typedef&lt;/h3&gt;&lt;h3 id=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;a href=&quot;#第39条：用handler块降低代码分散程度&quot; class=&quot;headerlink&quot; title=&quot;第39条：用handler块降低代码分散程度&quot;&gt;&lt;/a&gt;第39条：用handler块降低代码分散程度&lt;/h3&gt;&lt;h3 id=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;a href=&quot;#第40条：用block引用其所属对象时不要出现循环引用&quot; class=&quot;headerlink&quot; title=&quot;第40条：用block引用其所属对象时不要出现循环引用&quot;&gt;&lt;/a&gt;第40条：用block引用其所属对象时不要出现循环引用&lt;/h3&gt;&lt;h3 id=&quot;第41条：多用派发队列，少用同步锁&quot;&gt;&lt;a href=&quot;#第41条：多用派发队列，少用同步锁&quot; class=&quot;headerlink&quot; title=&quot;第41条：多用派发队列，少用同步锁&quot;&gt;&lt;/a&gt;第41条：多用派发队列，少用同步锁&lt;/h3&gt;&lt;h3 id=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;a href=&quot;#第42条：用GCD，少用performSelector系列方法&quot; class=&quot;headerlink&quot; title=&quot;第42条：用GCD，少用performSelector系列方法&quot;&gt;&lt;/a&gt;第42条：用GCD，少用performSelector系列方法&lt;/h3&gt;&lt;h3 id=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;a href=&quot;#第43条：掌握GCD及操作队列的使用时机&quot; class=&quot;headerlink&quot; title=&quot;第43条：掌握GCD及操作队列的使用时机&quot;&gt;&lt;/a&gt;第43条：掌握GCD及操作队列的使用时机&lt;/h3&gt;&lt;h3 id=&quot;第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot;&gt;&lt;a href=&quot;#第44条：通过Dispatch-Group机制根据系统资源状况来执行任务&quot; class=&quot;headerlink&quot; title=&quot;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&quot;&gt;&lt;/a&gt;第44条：通过Dispatch Group机制根据系统资源状况来执行任务&lt;/h3&gt;&lt;h3 id=&quot;第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot;&gt;&lt;a href=&quot;#第45条：使用dispatch-once来执行只需运行一次的线程安全代码&quot; class=&quot;headerlink&quot; title=&quot;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&quot;&gt;&lt;/a&gt;第45条：使用dispatch_once来执行只需运行一次的线程安全代码&lt;/h3&gt;&lt;h3 id=&quot;第46条：不要使用dispatch-get-current-queue&quot;&gt;&lt;a href=&quot;#第46条：不要使用dispatch-get-current-queue&quot; class=&quot;headerlink&quot; title=&quot;第46条：不要使用dispatch_get_current_queue&quot;&gt;&lt;/a&gt;第46条：不要使用dispatch_get_current_queue&lt;/h3&gt;&lt;h2 id=&quot;系统框架&quot;&gt;&lt;a href=&quot;#系统框架&quot; class=&quot;headerlink&quot; title=&quot;系统框架&quot;&gt;&lt;/a&gt;系统框架&lt;/h2&gt;&lt;h3 id=&quot;第47条：熟悉系统框架&quot;&gt;&lt;a href=&quot;#第47条：熟悉系统框架&quot; class=&quot;headerlink&quot; title=&quot;第47条：熟悉系统框架&quot;&gt;&lt;/a&gt;第47条：熟悉系统框架&lt;/h3&gt;&lt;h3 id=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;a href=&quot;#第48条：多用块枚举，少用for循环&quot; class=&quot;headerlink&quot; title=&quot;第48条：多用块枚举，少用for循环&quot;&gt;&lt;/a&gt;第48条：多用块枚举，少用for循环&lt;/h3&gt;&lt;h3 id=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;a href=&quot;#第49条：队自定义其内存管理语义的collection使用无缝桥接&quot; class=&quot;headerlink&quot; title=&quot;第49条：队自定义其内存管理语义的collection使用无缝桥接&quot;&gt;&lt;/a&gt;第49条：队自定义其内存管理语义的collection使用无缝桥接&lt;/h3&gt;&lt;h3 id=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;a href=&quot;#第50条：构建缓存是选用NSCachae而非NSDictionary&quot; class=&quot;headerlink&quot; title=&quot;第50条：构建缓存是选用NSCachae而非NSDictionary&quot;&gt;&lt;/a&gt;第50条：构建缓存是选用NSCachae而非NSDictionary&lt;/h3&gt;&lt;h3 id=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;a href=&quot;#第51条：精简initialize与load的实现代码&quot; class=&quot;headerlink&quot; title=&quot;第51条：精简initialize与load的实现代码&quot;&gt;&lt;/a&gt;第51条：精简initialize与load的实现代码&lt;/h3&gt;&lt;h3 id=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;a href=&quot;#第52条：别忘了NSTimer会保留其目标对象&quot; class=&quot;headerlink&quot; title=&quot;第52条：别忘了NSTimer会保留其目标对象&quot;&gt;&lt;/a&gt;第52条：别忘了NSTimer会保留其目标对象&lt;/h3&gt;&lt;h1 id=&quot;Objective-C高级编程&quot;&gt;&lt;a href=&quot;#Objective-C高级编程&quot; class=&quot;headerlink&quot; title=&quot;Objective-C高级编程&quot;&gt;&lt;/a&gt;Objective-C高级编程&lt;/h1&gt;&lt;h2 id=&quot;ARC自动引用计数&quot;&gt;&lt;a href=&quot;#ARC自动引用计数&quot; class=&quot;headerlink&quot; title=&quot;ARC自动引用计数&quot;&gt;&lt;/a&gt;ARC自动引用计数&lt;/h2&gt;&lt;p&gt;  Automatic Reference Counting，降低了程序崩溃、内存泄露的风险，很大程度上减少了开发程序的工作量。&lt;br&gt; 使用条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Xcode4.2或以上版本&lt;/li&gt;
&lt;li&gt;使用LLVM编译器3.0或以上版本&lt;/li&gt;
&lt;li&gt;编译器选项中设置ARC为有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在LLVM编译器中设置ARC为有效状态，就无需再次键入retain或release代码&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存管理的思考方式&lt;br&gt;1&amp;gt; 自己生成的对象，自己持有&lt;br&gt;alloc,new,copy,mutablecopy(copy方法利用NSCopying方法约定，由各类实现copyWithZone：方法生成并持有不可变对象的副本)&lt;br&gt;2&amp;gt; 非自己生成的对象，自己持有&lt;br&gt;NSMutableArray类的array方法。使用retain方法可以持有&lt;br&gt;&lt;code&gt;id obj = [NSMutableArray array];
 [obj retain];&lt;/code&gt;&lt;br&gt;3&amp;gt;不再需要自己持有的对象时释放&lt;br&gt;用alloc\new\copy\mutableCopy方法生成并持有的对象，或用retain方法持有的对象，一旦不再需要，务必要用release进行释放。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4&amp;gt;无法释放非自己持有的对象&lt;br&gt;&lt;strong&gt;程序崩溃情况&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 再度释放已经释放了的对象
- 访问已经释放的对象时。
- 释放了非自己持有的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;alloc/retain/release/dealloc在GUNstep中的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在objective-c的对象中存有引用计数这一整数值&lt;/li&gt;
&lt;li&gt;调用alloc或是retain方法后，引用计数值加1.&lt;/li&gt;
&lt;li&gt;调用release后，引用计数值减1.&lt;/li&gt;
&lt;li&gt;引用计数值为0时，调用dealloc方法废弃对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GNUstep将用内存块头部管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;少量代码即可完成&lt;/li&gt;
&lt;li&gt;能够统一管理引用计数用内存块与对象用内存块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;苹果实现通过引用技术表来管理引用计数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象用内存块的分配无需考虑内存块头部&lt;/li&gt;
&lt;li&gt;引用计数表各记录中存有内存块地址，可以从各个记录追溯到各对象的内存块。（在调试的时候，只要内存技术表没有被破坏，就可以确认各内存块的位置；使用工具检测内存泄露时，引用计数表的各记录也有助于检测各对象的持有者是否存在）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;autorelease的具体使用方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成并持有NSAutoreleasePool对象。&lt;/li&gt;
&lt;li&gt;调用已分配对象的autorelease实例方法。&lt;/li&gt;
&lt;li&gt;废弃NSAutoreleasePool对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;RunLoop开始 -&amp;gt; 创建autoreleasepool -&amp;gt; 线程处理事件循环 -&amp;gt; 废弃autoreleasepool -&amp;gt; RunLoop结束 -&amp;gt; 等待下一个Loop开始&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;autorelease简介&lt;br&gt;1&amp;gt;autorelease方法的基本作用&lt;br&gt;给对象发送一条autorelease消息, 会将对象放到一个自动释放池中&lt;br&gt;当自动释放池被销毁时，会对池子里面的所有对象做一次release操作&lt;br&gt;会返回对象本身&lt;br&gt;调用完autorelease方法后，对象的计数器不变&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;autorelease的好处&lt;br&gt;不用再关心对象释放的时间&lt;br&gt;不用再关心什么时候调用release&lt;/p&gt;
&lt;p&gt;3&amp;gt;autorelease的使用注意&lt;br&gt;占用内存较大的对象不要随便使用autorelease&lt;br&gt;占用内存较小的对象使用autorelease，没有太大影响&lt;br&gt; &lt;strong&gt;release和autorelease区别&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;release立即释放，autorelease不立即释放，先放到autoreleasepool中，当pool结束后自动调用release。&lt;/p&gt;
&lt;p&gt;一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;autorelease的实现&lt;br&gt;autorelease实例方法的本质就是调用了NSAutoreleasePool对象的addObjective类方法。&lt;br&gt;可通过objc4库的runtime/objc-arr.mm来确认苹果中autorelease的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;内存不足的产生的例子？如何解决？&lt;br&gt;在for循环中读入大量图片的同时，改变其尺寸。图像文件读入到NSData对象，并从中产生UIImage对象，改变该尺寸后生成新的UIImage对象，这种情况就会产生大量的autorelease的对象。不废弃NSAutoreleasePool对象，那么生成的对象就不能释放，就会产生内存不足。&lt;br&gt;解决：在适当的地方生成、持有或废弃NSAutoreleasePool对象；&lt;br&gt;返回NSMutableArray类的arrayWithCapcity方法。来返回autorelease对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有权修饰符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__strong
__weak
__unsafe_unretained
__autoreleasing
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;__strong&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ARC中, id及其他对象默认就是&lt;strong&gt;strong修饰符修饰&lt;br&gt;MRC中, 使用&lt;/strong&gt;strong修饰符, 不必再次键入retain/release. 持有强引用的变量超出其作用域时被废弃, 随着强引用的失效, 引用的对象会随之释放.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__weak&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决循环引用问题. 并且弱引用的对象被废弃时, 则此弱引用将自动失效并等于nil&lt;/p&gt;
&lt;p&gt;通过__weak变量访问对象实际上必定是访问注册到autoreleasepool的对象, 因为该修饰符只持有对象的弱引用, 在访问对象的过程中, 该对象可能被废弃, 如果把要访问的对象注册到autoreleasepool中, 那么在block结束之前都能确保该对象存在.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__unsafe_unretained&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不安全的修饰符, 附有该修饰符的变量不属于编译器的内存管理对象. 该修饰符与__weak一样, 是弱引用, 并不能持有对象.并且访问该修饰符的变量时如果不能确保其确实存在, 则应用程序会崩溃!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__autoreleasing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象赋值给&lt;strong&gt;autoreleasing修饰的变量相当于MRC下手动调用autorelease方法.可理解为, ARC下用@autoreleasepool block代替NSAutoreleasePool类, 用&lt;/strong&gt;autoreleasing修饰符的变量代替autorelease方法.&lt;br&gt;但是, 显式使用&lt;strong&gt;autoreleasing修饰符跟&lt;/strong&gt;strong一样罕见,&lt;/p&gt;
&lt;p&gt;ps : id的指针或者对象的指针会被隐式附上__autoreleasing修饰符, 如 :&lt;/p&gt;
&lt;figure class=&quot;highlight gherkin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == id __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj == NSObject &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt; __autoreleasing &lt;span class=&quot;keyword&quot;&gt;*&lt;/span&gt;obj;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;ARC的规则&quot;&gt;&lt;a href=&quot;#ARC的规则&quot; class=&quot;headerlink&quot; title=&quot;ARC的规则&quot;&gt;&lt;/a&gt;ARC的规则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;设置ARC有效的编译方法：&lt;ul&gt;
&lt;li&gt;使用clang（LLVM编译器）3.0或以上版本&lt;/li&gt;
&lt;li&gt;指定编译器属性为“-fobjc-arc”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有权修饰符&lt;br&gt;变量类型定义为id类型和各种对象类型。&lt;br&gt;对象类型：指向NSobject这样的OC指针，如：“NSObject &lt;em&gt;”&lt;br&gt;id类型：用于隐藏对象类型的类名部分，相当于C语言的“void &lt;/em&gt;”&lt;br&gt;1&amp;gt;&lt;strong&gt;strong修饰符（默认的）强引用，适用于普通对象,相当于MRC中的retain&lt;br&gt;2&amp;gt;&lt;/strong&gt;weak修饰符，弱引用，解决循环引用(很容易发生内存泄露), 相当于MRC中的assign.&lt;br&gt;3&amp;gt;&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符，和&lt;strong&gt;weak一样，自己生成并持有的对象不能继续为自己所有，所以生成的对象会立即释放。&lt;br&gt;4&amp;gt;&lt;/strong&gt;autorelease修饰符。&lt;br&gt;在ARC有效时，用@autorelease块代替NSAutoreleasePool类，用附有__autorelease修饰符的变量代替autorelease方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARC规则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能使用retain/release/retainCount/autorelease&lt;/li&gt;
&lt;li&gt;不能使用NSAllocateObject/NSDeallocateObject(alloc实现实际上是通过直接调用NSAllocateObject函数来生成并持有对象, ARC下禁止使用NSAllocateObject函数与NSDeallocateObject函数)&lt;/li&gt;
&lt;li&gt;需遵循内存管理的方法命名规则&lt;/li&gt;
&lt;li&gt;不要显示调用dealloc(可以重写dealloc，但是不能调用[super dealloc])&lt;/li&gt;
&lt;li&gt;使用@autoreleasepool块代替NSAutoreleasePool&lt;/li&gt;
&lt;li&gt;不能使用区域（NSZone）&lt;/li&gt;
&lt;li&gt;对象型变量不能作为C语言结构体(struct/union)的成员(可强制转换为void *或者是添加&lt;strong&gt;unsafe&lt;/strong&gt;retained修饰符)&lt;/li&gt;
&lt;li&gt;显示转换id和“void &lt;em&gt;”（通过__bridge可以id和void &lt;/em&gt;相互转换，&lt;strong&gt;bridge&lt;/strong&gt;retain可使要转换赋值的变量也持有所赋值的对象相当于retain，&lt;strong&gt;bridge&lt;/strong&gt;transfer被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放相当于release）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;br&gt;&lt;strong&gt; bridge_retained转换与retain类似, &lt;/strong&gt; bridge_transfer转换与release类似. 该两种转换多用于Foundation对象与Core Foundation对象之间的转换.&lt;br&gt;在ARC下, 以下可作为这种属性声明中使用的属性来用.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%888.13.46.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中.&lt;/p&gt;
&lt;h3 id=&quot;ARC的实现&quot;&gt;&lt;a href=&quot;#ARC的实现&quot; class=&quot;headerlink&quot; title=&quot;ARC的实现&quot;&gt;&lt;/a&gt;ARC的实现&lt;/h3&gt;&lt;p&gt;ARC是由编译器+运行时库共同完成的.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;strong&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_release(obj);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;objc_retainAutoreleasedReturnValue函数主要用于最优化程序运行. 它是用来持有返回注册在autoreleasepool中对象的方法.这个函数是成对的, 另外一个objc_autoreleaseReturnValue函数则用于alloc/new/copy/mutableCopy方法以外的类方法返回对象的实现上, 如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; objc_autoreleaseReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么objc_autoreleaseReturnValue函数和objc_retainAutoreleasedReturnValue函数有什么用?&lt;/p&gt;
&lt;p&gt;可以这样来总结 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果调用autorelease之后又紧接着调用retain的话, 这两部就显得多余, 所以以上两个函数就发挥其作用了.
用objc_autoreleaseReturnValue函数替代autorelease, 该函数检测如果对象紧接着会调用retain, 他就不调用autorelease了(并设置一个标志)
用objc_retainAutoreleasedReturnValue函数来替代retain, 该函数会检测对象的标志是否被设置, 如被设置, 则不调用retain; 反之则调用retain方法.
通过这两个函数能优化程序, 减少不必要的多余的操作.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;__weak修饰符&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;若附有__weak修饰符的变量所引用的对象被废弃, 则将nil赋值给该变量.
使用附有__weak修饰符的变量, 即是使用注册到autoreleasepool中的对象.
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id __weak obj1 = obj&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id obj1&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1 = 0&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, obj)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_storeWeak(&amp;amp;obj1, 0)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;访问__weak变量时, 相当于访问注册到autoreleasepool的对象&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; obj1 = obj;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_initWeak(&amp;amp;obj1, obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; tmp = objc_loadWeakRetained(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_destroyWeak(&amp;amp;obj1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objc_loadWeakRetained函数取出附有__weak修饰符变量所引用对象并retain&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意的是, 通过&lt;strong&gt;weak变量访问所引用的对象几次, 对象就被注册到autoreleasepool里几次. (将附有&lt;/strong&gt;weak修饰符的变量赋值给附有&lt;strong&gt;strong修饰符的变量后再使用可避免此问题)
&lt;/strong&gt;autoreleasing修饰符&lt;/p&gt;
&lt;p&gt;将对象赋值给附有__autoreleasing修饰符的变量等同于MRC下调用对象的autorelease方法.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [[&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(alloc));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(obj, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(init));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么调用alloc/new/&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;/mutableCopy以外的方法会怎样呢?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; __autoreleasing obj = [&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt; array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可转换为以下代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; pool = objc_autoreleasePoolPush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = objc_msgSend(&lt;span class=&quot;built_in&quot;&gt;NSMutableArray&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;@selector&lt;/span&gt;(array));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_retainAutoreleasedReturnValue(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autorelease(obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_autoreleasePoolPop(pool);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可见注册autorelease的方法没有改变, 仍是objc_autorelease函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何获取引用计数值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取引用数值的函数&lt;br&gt;uinptr_t _objc_rootRetainCount(id obj)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSUInteger)retainCount;
该方法返回的引用计数不一定准确, 因为有时系统会优化对象的释放行为, 在保留计数为1的时候就把它回收. 所以你用这个方法打印出来的引用计数可能永远不会出现0. 我们不应该根据retainCount来调试程序!!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在的工程几乎都运行在ARC下, 所以大部分内存管理代码都不需要我们自己写, 而由编译器帮我们搞定. 所以在ARC下我们只需要怎样不要去破坏这个生态即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;避免循环引用(使用__weak修饰符)
遵循ARC方法命名规则
适时清空指针(赋值nil即可, 避免野指针错误)
如用到Core Foundation对象, 则在dealloc方法中释放
在dealloc方法中只释放引用并移除监听(不能在dealloc中开启异步任务)
对于内存开销较大的资源, 如file descriptor, socket, 大块内存等应在不需要使用的时候调用close方法释放掉而不是在dealloc中处理.
适当使用@autoreleasepool block来降低内存峰值(之前我写的一篇文章中有demo)
必要时开启&amp;quot;僵尸对象&amp;quot;调试内存管理问题
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Block&quot;&gt;&lt;a href=&quot;#Block&quot; class=&quot;headerlink&quot; title=&quot;Block&quot;&gt;&lt;/a&gt;Block&lt;/h2&gt;&lt;h3 id=&quot;Block的概要&quot;&gt;&lt;a href=&quot;#Block的概要&quot; class=&quot;headerlink&quot; title=&quot;Block的概要&quot;&gt;&lt;/a&gt;Block的概要&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Block是带有自动变量(局部变量)的匿名函数(不带名称的函数)。Blocks 是闭包在 OC 语言中的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同而已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Block语法：&lt;/p&gt;
&lt;figure class=&quot;highlight clojure&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;^void&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;&lt;/span&gt; event)&lt;/span&gt;&lt;span class=&quot;collection&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	print&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;buttonId:%d event = %d\n&quot;&lt;/span&gt;,i,event)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;特点：a.没有函数名  b.带有“^”号&lt;br&gt;&lt;code&gt;^  返回值类型  参数列表  表达式&lt;/code&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;优势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;可代替 Delegate 完成回调，而不需要像 Delegate 那样繁琐
在某些方面，可代替 selector（如 NSNotificationCenter 在 addObserver 的时候，可以使用 block，而不用单独定义方法）
延长对象的生命周期（Block 会自动持有对象）
提高代码的复用性和可读性
常用于：View 动画、GCD、网络异步请求
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Block模式—block特性&quot;&gt;&lt;a href=&quot;#Block模式—block特性&quot; class=&quot;headerlink&quot; title=&quot;Block模式—block特性&quot;&gt;&lt;/a&gt;Block模式—&lt;strong&gt;block特性&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;截获自动变量值&quot;&gt;&lt;a href=&quot;#截获自动变量值&quot; class=&quot;headerlink&quot; title=&quot;截获自动变量值&quot;&gt;&lt;/a&gt;截获自动变量值&lt;/h4&gt;&lt;p&gt;“带有自动变量值”在Block中表现为“截获自动变量值”&lt;/p&gt;
&lt;p&gt;1&amp;gt; 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的. 也就是说block的自动变量截获只针对block内部使用的自动变量, 不使用则不截获, 因为截获的自动变量会存储于block的结构体内部, 会导致block体积变大.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.14.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 10&lt;/p&gt;
&lt;p&gt;2&amp;gt; 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%884.08.20.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__block int age = 10&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myBlock block = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&quot;age = %d&quot;, age)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;age = 18&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block()&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;输出为&lt;br&gt;age = 18&lt;/p&gt;
&lt;p&gt;第一种情况block内部不允许修改变量的值, 第二种情况下可以. (有例外, 静态变量, 静态全局变量, 全局变量即使不使用&lt;strong&gt;block修饰符也可以在block内部修改其值)&lt;br&gt;附有&lt;/strong&gt;block说明符的自动变量可在Block中赋值，该变量成为__block变量。&lt;/p&gt;
&lt;h4 id=&quot;截获对象&quot;&gt;&lt;a href=&quot;#截获对象&quot; class=&quot;headerlink&quot; title=&quot;截获对象&quot;&gt;&lt;/a&gt;截获对象&lt;/h4&gt;&lt;p&gt;对象不同于自动变量, 就算对象不加上&lt;strong&gt;block修饰符, 在block内部能够修改对象的属性.&lt;br&gt;block截获对象与截获自动变量有所不同.&lt;br&gt;堆块会持有对象, 而不会持有&lt;/strong&gt;block修饰的对象, 而栈块永远不会持有对象, 为什么呢?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;堆块作用域不同于栈块, 堆块可以超出其作用域地方使用, 所以堆块结构体内部会保留对象的强指针, 保证堆块在生命周期结束之前都能访问对象. 而对于__block对象为什么不会持有呢? 原因很简单, 因为__block对象会跟随block被复制到堆中, block再去引用堆中的__对象(后面会讲这个过程)..
栈块只能在当前作用域下使用, 所以其内部不会持有对象. 因为不存在在作用域之外访问对象的可能(栈离开当前作用域立马被销毁)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Block的实现&quot;&gt;&lt;a href=&quot;#Block的实现&quot; class=&quot;headerlink&quot; title=&quot;Block的实现&quot;&gt;&lt;/a&gt;Block的实现&lt;/h3&gt;&lt;h4 id=&quot;Block的实质&quot;&gt;&lt;a href=&quot;#Block的实质&quot; class=&quot;headerlink&quot; title=&quot;Block的实质&quot;&gt;&lt;/a&gt;Block的实质&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Blocks 的数据结构&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.35.54.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对应的结构体定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*&lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *dst, &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *src);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*dispose)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_layout &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *isa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; flags;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; reserved;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*invoke)(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; *, ...);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; Block_descriptor *descriptor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/* Imported variables. */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过该图，我们可以知道，一个 Block 实例实际上由 6 部分构成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;isa 指针: 所有对象都有该指针，用于实现对象相关的功能

flags: 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用；

reserved: 保留变量；

invoke: 函数指针，指向具体的 block 实现的函数调用地址；

descriptor: 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针；

variables: capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中；
copy : 用于保留捕获的对象
dispose : 用于释放捕获的对象
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Objective-C 中的 Stack 和 Heap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先所有的 Objective-C 对象都是分配在 Heap(堆) 的。 在 OC 最典型的内存分配与初始化就是这样的：&lt;/p&gt;
&lt;p&gt;NSObject *obj = [[NSObject alloc] init];&lt;/p&gt;
&lt;p&gt;一个对象在 alloc 的时候，就在 Heap 分配了内存空间。&lt;/p&gt;
&lt;p&gt;Stack 对象通常有速度的优势，而且不会发生内存泄露问题。那么为什么 OC 的对象都是分配在 Heap 的呢？ 原因在于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stack 对象的生命周期所导致的问题。例如一旦函数返回，则所在的 Stack Frame（栈帧）就会被销毁。那么此时返回的对象也会一并销毁。这个时候我们去 retain 这个对象是无效的。因为整个 Stack Frame 都已经被销毁了。简单而言，就是 Stack 对象的生命周期不适合 OC 的引用计数内存管理方法。

Stack 对象不够灵活，不具备足够的扩展性。创建时长度已经是固定的,而stack对象的拥有者也就是所在的 Stack Frame。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;Block-存储域&quot;&gt;&lt;a href=&quot;#Block-存储域&quot; class=&quot;headerlink&quot; title=&quot;Block 存储域&quot;&gt;&lt;/a&gt;Block 存储域&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;全局块(_NSConcreteGlobalBlock)程序的数据区域(.data区)
栈块(_NSConcreteStackBlock)
堆块(_NSConcreteMallocBlock)

全局块存在于全局内存中, 相当于单例.
栈块存在于栈内存中, 超出其作用域则马上被销毁
堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;全局块(_NSConcreteGlobalBlock)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block定义在全局变量的地方
block没有截获任何自动变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两个情况满足任意一个则该block为全局块, 全局块的生命周期贯穿整个程序, 相当于单例.全局的静态 Block，不会访问任何外部变量。&lt;br&gt;简单地讲，如果一个block钟没有引用外部变量并且没有被其他对象持有，就是NSConcreteGlobalBlock。NSConcreteGlobalBlock是全局的block，在编译期间就已经决定了，如同宏一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈块(_NSConcreteStackBlock)&lt;/strong&gt;&lt;br&gt;保存在栈中的 Block，当函数返回时会被销毁。（ARC 中系统实现了自动 copy, 将创建在栈上的 Block 自动拷贝到堆上，所以不存在此类型的 Block）NSConcreteStackBlock就是引用了外部变量的block，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆块(_NSConcreteMallocBlock)&lt;/strong&gt;&lt;br&gt;栈块copy之后就变成堆块，一个block被copy时，将生成NSConcreteMallocBlock（block没有retain）&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%889.51.44.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;只要这个NSConcreteMallocBlock存在，内部对象的引用计数就会+1。&lt;/p&gt;
&lt;h4 id=&quot;block变量的存储域&quot;&gt;&lt;a href=&quot;#block变量的存储域&quot; class=&quot;headerlink&quot; title=&quot;__block变量的存储域&quot;&gt;&lt;/a&gt;__block变量的存储域&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8A%E5%8D%8811.14.42.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;block的copy操作究竟做了什么呢?&lt;/p&gt;
&lt;p&gt;由上图可知, 对一个栈块进行copy操作会连同block与&lt;strong&gt;block变量(不管有没有使用)在内一同copy到堆上, 并且block会持有&lt;/strong&gt;block变量(使用).&lt;br&gt;ps : 堆上的block及__block变量均为对象, 都有各自的引用计数&lt;/p&gt;
&lt;p&gt;当然, 当block被销毁时, block持有的__block也会被释放&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.12.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;到这里我们能知道, 此思考方式与Objective-C的引用计数内存管理完全相同.&lt;/p&gt;
&lt;p&gt;那么有人就会问了, 既然&lt;strong&gt;block变量也被复制到堆上去了, 那么访问该变量是访问栈上的还是堆上的呢?? &lt;/strong&gt;forwarding 终于要闪亮登场了.&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%882.38.19.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;通过&lt;strong&gt;forwarding, 无论实在block中, block外访问&lt;/strong&gt;block变量, 也不管该变量在栈上或堆上, 都能顺利地访问同一个__block变量. &lt;/p&gt;
&lt;p&gt;那么Blocks提供的复制方法究竟是什么？&lt;br&gt;ARC有效的时候，大多数轻型下编译器会恰当的进行判断，自动生成将Block从栈上复制到堆上的代码。&lt;br&gt;ARC下, 以下几种情况下, 编译器会帮我们把栈上的block复制到堆中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;block作为函数返回值返回时
将block赋值给__strong修饰符id类型或block类型成员变量时
在方法名中含有usingBlock的Cocoa框架方法或GCD的API中传递block时
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用Block的copy实例方法时&lt;br&gt;&lt;strong&gt;此外的情况需要手动对block调用copy方法&lt;/strong&gt;&lt;br&gt;把block作为函数/方法的参数传入时才需要对block进行copy操作.&lt;br&gt;我们对不同地方的block调用copy会产生什么效果呢?&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%883.12.58.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以, 不管block是什么类型, 在什么地方, 用copy方法都不会引起任何问题.如下表格所示. 就算是反复多次调用copy方法, 如&lt;/p&gt;
&lt;p&gt; &lt;code&gt;blk = [[[[blk copy] copy] copy] copy];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该源码可解释如下 :&lt;/p&gt;
&lt;figure class=&quot;highlight nimrod&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; tmp = [blk copy]; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blk = tmp; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// tmp超出作用域, 其指向的&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;也被释放, &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt; tmp = [blk copy]; // &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blk = tmp; // blk指向的旧&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;释放, 并强引用新&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;, 最终&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被tmp和blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// tmp超出作用域, 其指向的&lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;也被释放, &lt;span class=&quot;keyword&quot;&gt;block&lt;/span&gt;被blk持有&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...下面不断重复该过程&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们知道, 这只是一个循环的过程, block被tmp持有 -&amp;gt; block被tmp和blk持有 -&amp;gt; block被blk持有 -&amp;gt; block被tmp和blk持有 -&amp;gt; ……&lt;/p&gt;
&lt;p&gt;由此可得知, 在ARC下该代码也没有任何问题. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结 : 如果block需要给作用域外的地方使用, 但是你不知道需不需要copy, 那就copy吧. 反正不会错&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;Block-循环引用&quot;&gt;&lt;a href=&quot;#Block-循环引用&quot; class=&quot;headerlink&quot; title=&quot;Block 循环引用&quot;&gt;&lt;/a&gt;Block 循环引用&lt;/h4&gt;&lt;p&gt;如果在 Block 中使用附有 __strong 修饰符的对象类型自动变量，那么当 Block 从栈复制到堆时，该对象为 Block 所持有，于是便导致了循环引用的产生。&lt;br&gt;self 持有 Block，Block 持有 self，这正是循环引用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面对使用 block 变量避免循环引用的方法和使用 weak 修饰符及 __unsafe_unretained 修饰符避免循环引用的方法做个比较。  &lt;/p&gt;
&lt;p&gt;使用 __block 变量的优点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;通过 __block 变量可控制对象的持有期间

在不能使用 __weak 修饰符的环境中不使用 __unsafe_unretained 修饰符即可（不必担心 悬垂指针 ）

在执行 Block 时可动态地决定是否将 nil 或其他对象赋值在 __block 变量中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 __block 变量的缺点如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为避免循环引用必须执行 Block

存在执行了 Block 语法，却不执行 Block 的路径时，无法避免循环引用。若由于 Block 引发了循环引用时，根据 Block 的用途选择使用 __block 变量、 __weak 修饰符或 __unsafe_unretained 修饰符来避免循环引用。

MRC下用__block可以避免循环引用(原因见上面block特性之截获自动变量值)
ARC下用__weak来避免循环引用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要提醒大家的是, 只有堆块(_NSConcreteMallocBlock)才可能会造成循环引用, 其他两种block不会&lt;/p&gt;
&lt;h3 id=&quot;要点总结&quot;&gt;&lt;a href=&quot;#要点总结&quot; class=&quot;headerlink&quot; title=&quot;要点总结&quot;&gt;&lt;/a&gt;要点总结&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Block 执行的代码其实在编译的时候就已经准备好了

本身 Block 就是一个普通的 OC 对象。正因为它是对象，Block 可以被作为参数传递，可以作为返回值从一个方法返回，可以用来给变量赋值

__block 修饰符在 MRC 下不会进行引用计数加 1，而 ARC 下则会加 1

对于 Block 外的变量引用，Block 默认是将其复制到其数据结构中来实现访问的

对于用 __block 修饰的外部变量引用，Block 是复制其引用地址来实现访问的
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考：&lt;br&gt;&lt;http: 28=&quot;&quot; 2013=&quot;&quot; blog.devtang.com=&quot;&quot; 07=&quot;&quot; a-look-inside-blocks=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/abeb5848b57a#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/abeb5848b57a#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/e03292674e60#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/e03292674e60#&lt;/a&gt;&lt;/http:&gt;&lt;/p&gt;
&lt;h2 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h2&gt;&lt;h3 id=&quot;GCD概要&quot;&gt;&lt;a href=&quot;#GCD概要&quot; class=&quot;headerlink&quot; title=&quot;GCD概要&quot;&gt;&lt;/a&gt;GCD概要&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;br&gt;异步执行的技术之一，开发者只需要定义向执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。&lt;br&gt;&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(queue,^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;dispatch_async&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(),^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//主线程可以执行的处理：用户页面更新&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程, 并发&lt;/strong&gt;&lt;br&gt; 一个应用就相当于一个进程, 而一个进程可以同时分发几个线程同时处理任务.而并发正是一个进程开启多个线程同时执行任务的意思, 主线程专门用来刷新UI,处理触摸事件等 而子线程呢, 则用来执行耗时的操作, 例如访问数据库, 下载数据等..&lt;br&gt;1个CPU执行的CPU命令列为一条无分叉路径，即为“线程”。&lt;br&gt;由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行上下文切换，因此看上去就好像1个CPU能够并列执行多个线程一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的优势&lt;/strong&gt;&lt;br&gt;说到优势, 当然有比较, 才能显得出优势所在. 事实上, iOS中我们能使用的多线程管理技术有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pthread(来自Clang, 纯C语言, 需要手动创建线程, 销毁线程, 手动进行线程管理. 而且代码极其恶心, )
NSThread(Foundation框架下的OC对象, 依旧需要自己进行线程管理，线程同步。 线程同步对数据的加锁会有一定的开销。)
GCD(两个字, 牛逼, 虽然是纯C语言, 但是它用难以置信的非常简洁的方式实现了极其复杂的多线程编程, 而且还支持block内联形式进行制定任务. 简洁! 高效! 而且我们再也不用手动进行线程管理了.)
NSOperationQueue(相当于Foundation框架的GCD, 以面向对象的语法对GCD进行了封装. 效率一样高)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;GCD的API&quot;&gt;&lt;a href=&quot;#GCD的API&quot; class=&quot;headerlink&quot; title=&quot;GCD的API&quot;&gt;&lt;/a&gt;GCD的API&lt;/h3&gt;&lt;p&gt;在介绍GCD的API之前, 我们先搞清楚四个名词: 串行, 并行, 同步, 异步&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;串行 : 一个任务执行完, 再执行下一个任务
并行 : 多个任务同时执行
同步 : 在当前线程中执行任务, 不具备开启线程的能力
异步 : 在新的线程中执行任务, 具备开启线程的能力
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Dispatch Queue&lt;/strong&gt;&lt;br&gt;Dispatch Queue是执行处理的等待队列, 按照先进先出(FIFO, First-In-First-Out)的顺序进行任务处理.队列分两种.&lt;br&gt;一种是串行队列(Serial Dispatch Queue),&lt;br&gt;一种是并行队列(Concurrent Dispatch Queue).  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Dispatch Queue的种类            说明  
Serial Dispatch Queue            等待现在执行中处理结束  
Concurrent Dispatch Queue       不等待现在执行中处理结束
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并发队列 : 让多个任务同时执行(自动开启多个线程执行任务)&lt;br&gt;并发功能只有在异步函数(dispatch_async)下才有效(想想看为什么?)&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-16%20%E4%B8%8B%E5%8D%885.08.16.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建队列&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)&lt;/code&gt;&lt;br&gt; 手动创建一个队列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label : 队列的标识符, 日后可用来调试程序
attr : 队列类型
DISPATCH_QUEUE_CONCURRENT : 并发队列
DISPATCH_QUEUE_SERIAL 或 NULL : 串行队列
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是, 通过dispatch_queue_create函数生成的queue在使用结束后需要通过dispatch_release函数来释放.(只有在MRC下才需要释放)&lt;/p&gt;
&lt;p&gt;并不是什么时候都需要手动创建队列, 事实上系统给我们提供2个很常用的队列. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主队列&lt;/strong&gt;&lt;br&gt;dispatch_get_main_queue();&lt;br&gt;该方法返回的是主线程中执行的同步队列. 用户界面的更新等一些必须在主线程中执行的操作追加到此队列中.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全局并发队列&lt;/strong&gt;&lt;br&gt;dispatch_get_global_queue(long identifier, unsigned long flags);&lt;br&gt;该方法返回的是全局并发队列. 使用十分广泛.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;identifier : 优先级
DISPATCH_QUEUE_PRIORITY_HIGH : 高优先级
DISPATCH_QUEUE_PRIORITY_DEFAULT : 默认优先级
DISPATCH_QUEUE_PRIORITY_LOW : 低优先级
DISPATCH_QUEUE_PRIORITY_BACKGROUND : 后台优先级
flags : 暂时用不上, 传 0 即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意 : 对Main Dispatch Queue和Global Dispatch Queue执行dispatch_release和dispatch_retain没有任何问题. (MRC)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_sync(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下同步执行block&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步函数&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_async(dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;br&gt;在参数queue队列下异步执行block(开启新线程)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_time(dispatch_time_t when, int64_t delta);&lt;/code&gt;&lt;br&gt;根据传入的时间(when)和延迟(delta)计算出一个未来的时间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;when :
DISPATCH_TIME_NOW : 现在
DISPATCH_TIME_FOREVER : 永远(别传这个参数, 否则该时间很大)
delta : 该参数接收的是纳秒, 可以用一个宏NSEC_PER_SEC来进行转换, 例如你要延迟3秒, 则为 3 * NSEC_PER_SEC.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;延迟执行&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_after(dispatch_time_t when, dispatch_queue_t queue, ^(void)block);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有了上述获取时间的函数, 则可以直接把时间传入, 然后定义该延迟执行的block在哪一个queue队列中执行.&lt;br&gt;苹果还给我们提供了一个在主队列中延迟执行的代码块, 如下&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_time&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_TIME_NOW&lt;/span&gt;, &lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int64_t&lt;/span&gt;)&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;delayInSeconds&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;* NSEC_PER_SEC)), dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            code to be executed after a specified delay&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们只需要传入需要延迟的秒数(delayInSeconds)和执行的任务block就可以直接调用了, 方便吧~&lt;/p&gt;
&lt;p&gt;注意 : 延迟执行不是在指定时间后执行任务处理, 而是在指定时间后将处理追加到队列中, 这个是要分清楚的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列组&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_group_create();&lt;/code&gt;&lt;br&gt;有时候我们想要在队列中的多个任务都处理完毕之后做一些事情, 就能用到这个Group. 同队列一样, Group在使用完毕也是需要dispatch_release掉的(MRC).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栅栏&lt;/strong&gt;&lt;br&gt; &lt;code&gt;dispatch_barrier_async(dispatch_queue_t queue, ^(void)block)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在访问数据库或文件时, 为了提高效率, 读取操作放在并行队列中执行. 但是写入操作必须在串行队列中执行(避免资源抢夺问题). 为了避免麻烦, 此时dispatch_barrier_async函数作用就出来了, 在这函数里进行写入操作, 写入操作会等到所有读取操作完毕后, 形成一道栅栏, 然后进行写入操作, 写入完毕后再把栅栏移除, 同时开放读取操作. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快速迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index){
    // code here
});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行10次代码, index顺序不确定. dispatch_apply会等待全部处理执行结束才会返回. 意味着dispatch_apply会阻塞当前线程. 所以dispatch_apply一般用于异步函数的block中.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次性代码&lt;/strong&gt;&lt;br&gt;&lt;code&gt;static dispatch_once_t onceToken;
dispatch_once(&amp;amp;onceToken, ^{
// 只执行1次的代码(这里面默认是线程安全的)
});&lt;/code&gt;&lt;br&gt;该代码在整个程序的生命周期中只会执行一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挂起和恢复&lt;/strong&gt;&lt;br&gt;&lt;code&gt;dispatch_suspend(queue)&lt;/code&gt;&lt;br&gt;挂起指定的queue队列, 对已经执行的没有影响, 追加到队列中尚未执行的停止执行.&lt;/p&gt;
&lt;p&gt; &lt;code&gt;dispatch_resume(queue)&lt;/code&gt;&lt;br&gt;恢复指定的queue队列, 使尚未执行的处理继续执行. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCD的注意点&lt;/strong&gt;&lt;br&gt;因为在ARC下, 不需要我们释放自己创建的队列, 所以GCD的注意点就剩下死锁&lt;br&gt;&lt;strong&gt;死锁&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;111&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;dispatch_sync&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;dispatch_get_main_queue&lt;/span&gt;(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;222&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;at_rule&quot;&gt;@&lt;span class=&quot;string&quot;&gt;&quot;333&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上三行代码将输出什么?&lt;br&gt;111&lt;br&gt;222&lt;br&gt;333 ?&lt;br&gt;还是&lt;br&gt;111&lt;br&gt;333 ?&lt;br&gt;其实都不对, 输出结果是&lt;br&gt;111&lt;br&gt;无疑问会先输出111, 然后在当前队列下调用dispatch_sync函数, dispatch_sync函数会把block追加到当前队列上, 然后等待block调用完毕该函数才会返回, 不巧的是, block在队列的尾端, 而队列正在执行的是dispatch_sync函数. 现在的情况是, block不执行完毕, dispatch_sync函数就不能返回, dispatch_sync不返回, 就没机会执行block函数. 这种你等我, 我也等你的情况就是死锁, 后果就是大家都执行不了, 当前线程卡死在这里.   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何避免死锁?&lt;/strong&gt;&lt;br&gt;不要在当前队列使用同步函数, 在队列嵌套的情况下也不允许. 如下图,&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AD%BB%E9%94%81.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;队列嵌套调用同步函数引发死锁&lt;/p&gt;
&lt;p&gt;大家可以想象, 队列1执行完NSLog后到队列2中执行NSLog, 队列2执行完后又跳回队列1中执行NSLog, 由于都是同步函数, 所以最内层的NSLog(“333”); 追加到队列1中, 实际上最外层的dispatch_sync是还没返回的, 所以它没有执行的机会. 也形成死锁. 运行程序, 果不其然, 打印如下 :&lt;br&gt;111&lt;br&gt;222&lt;/p&gt;
&lt;h3 id=&quot;GCD实现-GCD的使用场景&quot;&gt;&lt;a href=&quot;#GCD实现-GCD的使用场景&quot; class=&quot;headerlink&quot; title=&quot;GCD实现.(GCD的使用场景)&quot;&gt;&lt;/a&gt;GCD实现.(GCD的使用场景)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是GCD最常用的使用场景了, 如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight lisp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_global_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 执行耗时操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async&lt;span class=&quot;list&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class=&quot;list&quot;&gt;()&lt;/span&gt;, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 回到主线程作刷新UI等操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了不阻塞主线程, 我们总是在后台线程中发送网络请求, 处理数据, 然后再回到主线程中刷新UI界面.  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例&lt;/strong&gt;&lt;br&gt;     &lt;br&gt;单例也就是在程序的整个生命周期中, 该类有且仅有一个实例对象, 此时为了保证只有一个实例对象, 我们这里用到了dispatch_once函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列和锁&lt;/strong&gt;&lt;br&gt;利用队列, 实现getter方法可以并发执行, 而setter方法串行执行并且setter和getter不能并发执行呢??? 没错, 我们这里用到了dispatch_barrier_async函数.&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; )myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __block &lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; localMyString = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_sync&lt;/span&gt;(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        localMyString = &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;.myString&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; localMyString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)setMyString:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)myString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_barrier_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _myString = myString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里利用了栅栏块必须单独执行, 不能与其他块并行的特性, 写入操作就必须等当前的读取操作都执行完毕, 然后单独执行写入操作, 等待写入操作执行完毕后再继续处理读取. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dispatch Source&lt;/strong&gt;&lt;br&gt;它是BSD系内核惯有功能kqueue的包装. kqueue的CPU负荷非常小, 可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种. &lt;/p&gt;
&lt;h1 id=&quot;objective-c编程之道ios设计模式解析&quot;&gt;&lt;a href=&quot;#objective-c编程之道ios设计模式解析&quot; class=&quot;headerlink&quot; title=&quot;objective-c编程之道ios设计模式解析&quot;&gt;&lt;/a&gt;objective-c编程之道ios设计模式解析&lt;/h1&gt;&lt;h2 id=&quot;第七章-单例模式&quot;&gt;&lt;a href=&quot;#第七章-单例模式&quot; class=&quot;headerlink&quot; title=&quot;第七章 单例模式&quot;&gt;&lt;/a&gt;第七章 单例模式&lt;/h2&gt;&lt;p&gt;单例模式：它可以保证某个类创建出来的对象永远只有1个。类的一个对象成为系统中的唯一实例。&lt;strong&gt;一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;/strong&gt;&lt;br&gt;定义包含三层含义：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须向整个系统提供这个实例。&lt;/p&gt;
&lt;h3 id=&quot;何时使用单例&quot;&gt;&lt;a href=&quot;#何时使用单例&quot; class=&quot;headerlink&quot; title=&quot;何时使用单例&quot;&gt;&lt;/a&gt;何时使用单例&lt;/h3&gt;&lt;p&gt;1.类只能有一个实例。&lt;br&gt;2.这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。&lt;/p&gt;
&lt;h3 id=&quot;单例模式的实现&quot;&gt;&lt;a href=&quot;#单例模式的实现&quot; class=&quot;headerlink&quot; title=&quot;单例模式的实现&quot;&gt;&lt;/a&gt;单例模式的实现&lt;/h3&gt;&lt;p&gt;在Objective-C中实现单例模式，需要完成如下四个步骤：&lt;/p&gt;
&lt;p&gt;第一步：定义一个静态实例变量mySingleton(名字可以自己取)，初始化为nil，代码如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static MySingleton *mySingleton = nil;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二步：实现一个类方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// mySingleton = [[super allocWithZone:NULL]init];    如果在self中重载了基本的对象分配方法，就需要借用父类(NSObject)的功能，来帮助处理底层内存分配的杂务   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; dispatch_once函数是GCD中的API，它保证应用程序即使在多线程环境下，也只执行一次。当然，也可以使用@synchronize来达到线程安全的目的，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第三步：重写allocWithZone方法，用来保证使用alloc和init试图获得一个新实例的时候不产生新实例，代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;dispatch_once_t&lt;/span&gt; onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;dispatch_once&lt;/span&gt;(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:zone];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;第四步：适当实现copyWithZone，release和autorelease等方法。代码如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 如果有其他初始化操作，可在这里进行初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; = [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 其他初始化操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 防止外界拷贝造成多个实例，保证实例的唯一性。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)copyWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，所以retain不能增加引用计数。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)retain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 因为只有一个实例对象，设置默认引用计数。这里是取的NSUinteger的最大值，当然也可以设置成1或其他值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;NSUInteger&lt;/span&gt;)retainCount&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UINT_MAX&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// denotes an object that cannot be released&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// oneway是用于多线程编程中，表示单向执行，不能“回滚”，即原子操作。该方法是空的,不让用户release掉这个对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;oneway&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//除了返回单例外，什么也不做。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)autorelease&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 该方法永远不会被调用,因为在程序的生命周期内容，该单例一直都存在。（所以该方法可以不实现）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; dealloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;子类化Singleton&quot;&gt;&lt;a href=&quot;#子类化Singleton&quot; class=&quot;headerlink&quot; title=&quot;子类化Singleton&quot;&gt;&lt;/a&gt;子类化Singleton&lt;/h3&gt;&lt;p&gt;【补充】说明，对于第二步和第三步可以这样实现：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)sharedInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@synchronized&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(mySingleton == &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mySingleton = [[&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; allocWithZone:&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;allocWithZone&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mySingleton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过返回当前的sharedInstance实例，就能防止实例化一个新的对象。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)allocWithZone:(&lt;span class=&quot;built_in&quot;&gt;NSZone&lt;/span&gt; *)zone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; [[&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; sharedInstance] retain];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;alloc调用被转发给super，意味着NSObject晖处理对象分配，如果不做修改的子类化Singleton，返回的实例总是Single。因为Singleton重载了所以实例化相关的方法，实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingletonSon&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Singleton *shareSingleton=&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//向上转型，重定义自己的sharedsingleton类变量，不与父类共享。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(SingletonSon *) shareInstance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(sharedSingleton==&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;comment&quot;&gt;//不调用父类alloc方法，在此调用父类alloc方法可能回调此方法，从而产生死循环，我们直接创建对象。(重点下面函数)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     sharedSingleton=[&lt;span class=&quot;built_in&quot;&gt;NSAllocateObject&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; class),&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;) init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;span class=&quot;comment&quot;&gt;// 子类可以重写一下retain copy release autorelease进行合适的内存管理。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;单例模式在IOS中的应用&quot;&gt;&lt;a href=&quot;#单例模式在IOS中的应用&quot; class=&quot;headerlink&quot; title=&quot;单例模式在IOS中的应用&quot;&gt;&lt;/a&gt;单例模式在IOS中的应用&lt;/h3&gt;&lt;p&gt;单例模式在IOS中的应用非常广泛，如&lt;br&gt;　　[NSNotificationCenter defaultCenter]、&lt;br&gt;　　[UIApplication sharedApplication]、&lt;br&gt;　　[NSFileManager defaultManager]&lt;br&gt;　　[UIAccelerometer sharedAccelerometer]接收来自单例实例的加速度数据等。
　　
　　
　　
　　
　　
　　
　　
　　&lt;/p&gt;
&lt;h1 id=&quot;精通iOS开发&quot;&gt;&lt;a href=&quot;#精通iOS开发&quot; class=&quot;headerlink&quot; title=&quot;精通iOS开发&quot;&gt;&lt;/a&gt;精通iOS开发&lt;/h1&gt;&lt;h3 id=&quot;响应者链&quot;&gt;&lt;a href=&quot;#响应者链&quot; class=&quot;headerlink&quot; title=&quot;响应者链&quot;&gt;&lt;/a&gt;响应者链&lt;/h3&gt;&lt;p&gt;以UIResponder作为超类的任何类都是响应者。&lt;br&gt;iOS中的响应者链的概念:&lt;br&gt;每一个应用有一个响应者链，我们的视图结构是一个N叉树(一个视图可以有多个子视图，一个子视图同一时刻只有一个父视图),而每一个继承UIResponder的对象都可以在这个N叉树中扮演一个节点。当叶节点成为最高响应者的时候，从这个叶节点开始往其父节点开始追朔出一条链，那么对于这一个叶节点来讲，这一条链就是当前的响应者链。响应者链将系统捕获到的UIEvent与UITouch从叶节点开始层层向下分发，期间可以选择停止分发，也可以选择继续向下分发。&lt;br&gt; 例子:&lt;/p&gt;
&lt;p&gt;我用SingleView模板创建了一个新的工程，它的主Window上只有一个UIViewController，其View之上有一个Button。这个项目中所有UIResponder的子类所构成的N叉树为这样的结构:&lt;br&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/responseder.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;事件传递机制：  &lt;/p&gt;
&lt;p&gt;1.当iOS程序中发生触摸事件后，系统会将事件加入到UIApplication管理的一个任务队列中&lt;br&gt;2.UIApplication将处于任务队列最前端的事件向下分发。即UIWindow。&lt;br&gt;3.UIWindow将事件向下分发，即UIView。&lt;br&gt;4.UIView首先看自己是否能处理事件，触摸点是否在自己身上。如果能，那么继续寻找子视图。&lt;br&gt;5.遍历子控件，重复以上两步。&lt;br&gt;6.如果没有找到，那么自己就是事件处理者。&lt;br&gt;7.如果自己不能处理，那么不做任何处理。&lt;br&gt;其中 UIView不接受事件处理的情况主要有以下三种&lt;br&gt;1）alpha &amp;lt;0.01&lt;br&gt;2)userInteractionEnabled = NO&lt;br&gt;3).hidden ＝ YES&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;发现自己OC的一些底层还是不是很理解，iOS的很多概念还是没有搞清楚，决心好好读几本书来加强一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://peilinghui.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>常用算法</title>
    <link href="http://peilinghui.com/2016/03/28/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://peilinghui.com/2016/03/28/常用算法/</id>
    <published>2016-03-28T14:31:18.000Z</published>
    <updated>2016-04-25T06:40:15.000Z</updated>
    
    <content type="html">&lt;p&gt;常用的算法题总结一下。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;h3 id=&quot;排序题与sort函数的应用&quot;&gt;&lt;a href=&quot;#排序题与sort函数的应用&quot; class=&quot;headerlink&quot; title=&quot;排序题与sort函数的应用&quot;&gt;&lt;/a&gt;排序题与sort函数的应用&lt;/h3&gt;&lt;p&gt;用C++中的sort来实现排序，定义结构体struct存放学生信息；cmp函数的编写，提供cmp函数实现的排序规则；排名的实现：主要是分数相同的占用同一个排位。&lt;/p&gt;
&lt;h4 id=&quot;A1025-PAT排序&quot;&gt;&lt;a href=&quot;#A1025-PAT排序&quot; class=&quot;headerlink&quot; title=&quot;A1025.PAT排序&quot;&gt;&lt;/a&gt;A1025.PAT排序&lt;/h4&gt;&lt;p&gt;题意：n个考场，每个考场有若干数量的考生，给出考生的准考证号和成绩然后按顺序输出所以考生的准考证号，排名、考场号、考场内排名。&lt;br&gt;Sample Input:&lt;br&gt;2&lt;br&gt;5&lt;br&gt;1234567890001 95&lt;br&gt;1234567890005 100&lt;br&gt;1234567890003 95&lt;br&gt;1234567890002 77&lt;br&gt;1234567890004 85&lt;br&gt;4&lt;br&gt;1234567890013 65&lt;br&gt;1234567890011 25&lt;br&gt;1234567890014 100&lt;br&gt;1234567890012 85&lt;/p&gt;
&lt;p&gt;Sample Output:&lt;br&gt;9&lt;br&gt;1234567890005 1 1 1&lt;br&gt;1234567890014 1 2 1&lt;br&gt;1234567890001 3 1 2&lt;br&gt;1234567890003 3 1 2&lt;br&gt;1234567890004 5 1 4&lt;br&gt;1234567890012 5 2 2&lt;br&gt;1234567890002 7 1 5&lt;br&gt;1234567890013 8 2 3&lt;br&gt;1234567890011 9 2 4&lt;br&gt;思路：1.按考场读入各个考生的信息，对当前考场所有考生进行排序，将排名写入结构体中。2.对所有考生进行排序。3.一边计算总排名，一边输出考生信息。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; student&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; id[&lt;span class=&quot;number&quot;&gt;14&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//准考证号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; grade;&lt;span class=&quot;comment&quot;&gt;//分数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location;&lt;span class=&quot;comment&quot;&gt;//考场号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; location_rank;&lt;span class=&quot;comment&quot;&gt;//考场内排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rank;&lt;span class=&quot;comment&quot;&gt;//排名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;stu[&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(student a,student b)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a.grade != b.grade)  &lt;span class=&quot;comment&quot;&gt;//分数从高到低排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.grade &amp;gt;b.grade;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;                 &lt;span class=&quot;comment&quot;&gt;//分数相同按准考证号从小到大排&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;strcmp&lt;/span&gt;(a.id,b.id) &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,k,m=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//num为总考生数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;span class=&quot;comment&quot;&gt;//考场数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;k);&lt;span class=&quot;comment&quot;&gt;//考场内人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;k;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d&quot;&lt;/span&gt;,stu[m].id,&amp;amp;stu[m].grade);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[m].location = i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            m++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(stu+m-k,stu+m,cmp);&lt;span class=&quot;comment&quot;&gt;//将该考场的考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stu[m-k].location_rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//该考场的第一名学生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=m-k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;j&amp;lt;m;j++)&lt;span class=&quot;comment&quot;&gt;//对该考生剩余的考生&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[j].grade == stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;span class=&quot;comment&quot;&gt;//分数相同排名也相同&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = stu[j-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].location_rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//分数不同，排名为该考生前的人数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stu[j].location_rank = j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-(m-k);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(stu,stu+m,cmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stu[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].rank = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将所有考生排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(stu[i].grade == stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].grade)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = stu[i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].rank;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stu[i].rank = i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;m;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%s %d %d %d\n&quot;&lt;/span&gt;,stu[i].id,stu[i].rank,stu[i].location,stu[i].location_rank);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;应用：&lt;ul&gt;
&lt;li&gt;对数据的某种性质进行统计&lt;/li&gt;
&lt;li&gt;使用hash函数H(key)=value将一个元素映射为一个整数，其中哈希函数的选取需要利用元素分布的特点使得值value比较唯一。&lt;br&gt;将较大数据范围的元素（数据个数不多）映射到较小的数据范围内，或者是吧非整数类型的元素映射为整数类型，使得增删改查变得高效。O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用hash进行统计&lt;blockquote&gt;
&lt;p&gt;题目：给出N个正整数，再给出M个正整数，问这M个正整数中的每个数分别是否在N个正整数中出现过。(M,N&amp;lt;=10^5)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路：遍历所有N个数，看是否有一个数与x相等，时间复杂度O(MN)太大。&lt;/p&gt;
&lt;p&gt;用hash：开一个bool型数组hashtable[N+1],其中hashtable[x]==true表示正整数x在N个正整数中出现过。时间复杂度O(M+N)&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; hashTable[maxn]=&amp;#123;&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,m,x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %d&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        hashTable[x]=&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//数字x出现过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;m; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hashTable[x]==&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;YES\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;NO\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;哈希法的应用：对数据的某种性质进行统计。对图进行DFS遍历时就需要设置bool型数组VIS[maxn]来记录结点是否已经被访问。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用哈希进行区间映射&lt;br&gt;使用hash函数H(key)=value将一个元素映射为一个整数。&lt;br&gt;一个例子：如何将一个二维整点P坐标映射为一个整数，是整点P可以由该整数唯一的代表。P(x,y)x&amp;gt;=0,y&amp;lt;=range,可以设计hash函数H(p)=x*range+y,用H(p)来唯一的代表坐标。&lt;br&gt;一个例子：字符串hash是将一个字符串S映射为一个整数，使该整数可以唯一的代表字符串S。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h3&gt;&lt;p&gt;分治：将原问题划分成k个规模较小而结构与原问题相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解。&lt;br&gt;步骤：  复杂度O（nlogn）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 分解  
- 解决
- 合并  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决的问题必须满足最优子结构.&lt;br&gt;递归来实现分治思想，（1）递归边界（2）递归式&lt;br&gt;例子1：使用递归求解n的阶乘&lt;/p&gt;
&lt;p&gt;例子2：求斐波那契数列的第N项&lt;/p&gt;
&lt;h3 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h3&gt;&lt;h4 id=&quot;月饼-PATB&quot;&gt;&lt;a href=&quot;#月饼-PATB&quot; class=&quot;headerlink&quot; title=&quot;月饼 (PATB)&quot;&gt;&lt;/a&gt;月饼 (PATB)&lt;/h4&gt;&lt;p&gt;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。&lt;br&gt;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。&lt;br&gt;输入样例：&lt;br&gt;3 20&lt;br&gt;18 15 10&lt;br&gt;75 72 45&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;94.50&lt;br&gt;思路：此为贪心算法。如何获得最大收益，先根据库存量和总售价算出每种月饼的单价，然后从单价高的开始枚举，全部卖出足够需求量，则提供需求量就够了；如果不够需求量，则收益值增加需求量×单价，需求量-这种库存，再看单价第二高的月饼；&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; mooncake&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; store;&lt;span class=&quot;comment&quot;&gt;//库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; sell;&lt;span class=&quot;comment&quot;&gt;//总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; price;&lt;span class=&quot;comment&quot;&gt;//单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;cake[&lt;span class=&quot;number&quot;&gt;1010&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(mooncake a,mooncake b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//按单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a.price&amp;gt;b.price;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;span class=&quot;comment&quot;&gt;//月饼种类数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; D;&lt;span class=&quot;comment&quot;&gt;//需求量同上用浮点数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%lf&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;D);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//先输入每种月饼的库存量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].store);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//再输入每种月饼的总售价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%lf&quot;&lt;/span&gt;,&amp;amp;cake[i].sell);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cake[i].price = cake[i].sell/cake[i].store;&lt;span class=&quot;comment&quot;&gt;//计算单价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(cake, cake+n, cmp);&lt;span class=&quot;comment&quot;&gt;//单价从高到低排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; ans=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//收益&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cake[i].store&amp;lt;=D) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量小于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            D-=cake[i].store;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].sell;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//月饼库存量大于需求量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans+=cake[i].price*D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,ans);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;组个最小数-PATB&quot;&gt;&lt;a href=&quot;#组个最小数-PATB&quot; class=&quot;headerlink&quot; title=&quot;组个最小数 (PATB)&quot;&gt;&lt;/a&gt;组个最小数 (PATB)&lt;/h4&gt;&lt;p&gt;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。&lt;/p&gt;
&lt;p&gt;现给定数字，请编写程序输出能够组成的最小的数。&lt;/p&gt;
&lt;p&gt;输入格式：&lt;br&gt;每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，&lt;strong&gt;顺序表示我们拥有数字0、数字1、……数字9的个数&lt;/strong&gt;。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;br&gt;在一行中输出能够组成的最小的数。&lt;br&gt;输入样例：&lt;br&gt;2 2 0 0 0 3 0 0 1 0&lt;/p&gt;
&lt;p&gt;输出样例：&lt;br&gt;10015558&lt;br&gt;思路：此为贪心算法。就是从最高位开始输出，先从1到9中选择个数不为0的最小数输出，然后从0到9输出数字，每个数字输出次数为剩余个数。&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//记录数字0-9的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;count[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从1-9中选择Count不为0的最小数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count[i]&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            count[i]--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从0-9输出对应个数的数字&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;count[i]; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：贪心算法用来解决最优化问题，希望由局部最优策略来推得全局最优结果，贪心算法适用的问题一定满足最优子结构性质。（组成原问题最优解的子问题的解也是最优的）&lt;/p&gt;
&lt;h3 id=&quot;二分&quot;&gt;&lt;a href=&quot;#二分&quot; class=&quot;headerlink&quot; title=&quot;二分&quot;&gt;&lt;/a&gt;二分&lt;/h3&gt;&lt;h4 id=&quot;二分查找&quot;&gt;&lt;a href=&quot;#二分查找&quot; class=&quot;headerlink&quot; title=&quot;二分查找&quot;&gt;&lt;/a&gt;二分查找&lt;/h4&gt;&lt;p&gt;在有序序列中。时间复杂度O(logn)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A[mid]==x,查找成功，退出查询。
- A[mid]&amp;gt;x,说明x一定在中间位置的左边，在[left,mid-1]继续查找
- A[mid]&amp;lt;x，说明x一定在中间位置的右边，在[mid+1,right]继续查找
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归：  &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = n,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (left&amp;lt;=right) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]==x) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[mid]&amp;gt;x)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d%d\n&quot;&lt;/span&gt;,binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;),binarySearch(A, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际更多的是使用非递归。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;序列中哟重复数字，求序列中第一个x的位置。&lt;/li&gt;
&lt;li&gt;序列中第一个大于x的数的位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;a href=&quot;#扩展（求根号2的近似值）&quot; class=&quot;headerlink&quot; title=&quot;扩展（求根号2的近似值）&quot;&gt;&lt;/a&gt;扩展（求根号2的近似值）&lt;/h4&gt;&lt;p&gt;F(x)=x*x；比较F(x)与2 的大小。&lt;br&gt;若F(x)&amp;gt;2,则令right=mid;&lt;br&gt;若F(x)&lt;2,则令left=mid; 代码：=&quot;&quot; &lt;figure=&quot;&quot; class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; eps=&lt;span class=&quot;number&quot;&gt;1e-5&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//精度为10的-5次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x*x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;calSql&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; left =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (right - left &amp;gt; eps) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (left + right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (f(mid)&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            right = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            left = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/2,则令left=mid;&gt;&lt;/p&gt;
&lt;h3 id=&quot;two-pointers&quot;&gt;&lt;a href=&quot;#two-pointers&quot; class=&quot;headerlink&quot; title=&quot;two pointers&quot;&gt;&lt;/a&gt;two pointers&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;题目：给定一个&lt;strong&gt;递增&lt;/strong&gt;的正整数序列和一个正整数M,求序列中的两个不同位置的数a和b,使他们的和恰好为M，输出所有满足条件的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：令下标i的初值为0，下标j的初值为n-1，令i，j分别指向序列的第一个元素和最后一个元素，接下来根据a[i]+a[j]与M的大小来进行下面三种选择，i向右移动，j向左移动，直到i&amp;gt;=j成立。&lt;br&gt;1&amp;gt;如果a[i]+a[j]==M，令i=i+1，j=j-1;&lt;br&gt;2&amp;gt;如果a[i]+a[j]&amp;gt;M,j=j-1;&lt;br&gt;3&amp;gt;如果a[i]+a[j]&amp;lt;M,i=i+1; &lt;/p&gt;
&lt;p&gt;代码：时间复杂度O(n)&lt;br&gt;&lt;figure class=&quot;highlight autohotkey&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]==M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&lt;span class=&quot;string&quot;&gt;&quot;%d %d\n&quot;&lt;/span&gt;,i,j)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[i]+&lt;span class=&quot;literal&quot;&gt;a&lt;/span&gt;[j]&amp;lt;M)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目：假设有两个递增序列A和B，要求将它们合并为一个递增序列C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：两个下标i和j，初值均为0，表示分别指向序列A的第一个元素和序列B的第一个元素，然后根据A[i]和B[j]的大小来决定哪一个放入序列C。&lt;br&gt;1&amp;gt;A[i]&lt;b[j],a[i]加入到序列c，i加1. 2=&quot;&quot;&gt;A[i]&amp;gt;B[j],B[i]加入到序列C，j加1.&lt;br&gt;3&amp;gt;A[i]==B[j],任选一个加入到序列C，下标加1.&lt;/b[j],a[i]加入到序列c，i加1.&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;br&gt;&lt;figure class=&quot;highlight axapta&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; merge(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; B[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n &amp;amp;&amp;amp; j&amp;lt;m) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=B[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//序列A或B的剩余元素加入序列C&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;n) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=A[i++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;m) C[&lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;++]=B[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;index&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回C的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;例如：归并排序和快速排序&lt;/p&gt;
&lt;h3 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h3&gt;&lt;p&gt;一种用来解决最优化问题的思想。动态规划将一个复杂的问题分解成若干个简单的子问题，通过综合子问题的求解结果来得到原问题的解。&lt;br&gt;本质:通过记录曾经计算过的内容，来避免重复计算。&lt;br&gt;1&amp;gt;递归&lt;br&gt;斐波那契数列&lt;/p&gt;
&lt;p&gt;2&amp;gt;递推&lt;br&gt;数塔DP问题：将一些数字排成数塔形状，其中第一层有一个数字，第二层有两个数字。。。。。第N层有N个数字，形状要从第一层走到第N层，每次只能走向下一层连接的两个数字中的一个，问最后将路径上所以数字相加后得到的和最大是多少？&lt;/p&gt;
&lt;h4 id=&quot;最大练习子序列和&quot;&gt;&lt;a href=&quot;#最大练习子序列和&quot; class=&quot;headerlink&quot; title=&quot;最大练习子序列和&quot;&gt;&lt;/a&gt;最大练习子序列和&lt;/h4&gt;&lt;p&gt;题目：输入一个数字序列a1,a2,求i,j（1&amp;lt;=i&amp;lt;=j&amp;lt;=n）,使得ai+…….aj最大，输出最大和。&lt;/p&gt;
&lt;h4 id=&quot;0-1背包问题&quot;&gt;&lt;a href=&quot;#0-1背包问题&quot; class=&quot;headerlink&quot; title=&quot;0-1背包问题&quot;&gt;&lt;/a&gt;0-1背包问题&lt;/h4&gt;&lt;p&gt;题目：有N件物品，每件物品的重量为W[i],价值为C[i],现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的价值最大，其中每种物品都只有一件。&lt;/p&gt;
&lt;h4 id=&quot;最长不下降子序列&quot;&gt;&lt;a href=&quot;#最长不下降子序列&quot; class=&quot;headerlink&quot; title=&quot;最长不下降子序列&quot;&gt;&lt;/a&gt;最长不下降子序列&lt;/h4&gt;&lt;h4 id=&quot;最长公共子序列（LCS）&quot;&gt;&lt;a href=&quot;#最长公共子序列（LCS）&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列（LCS）&quot;&gt;&lt;/a&gt;最长公共子序列（LCS）&lt;/h4&gt;&lt;p&gt;题目：给定两个字符串A和B，求一个字符串，使得这个字符串是A和B的最长公共部分&lt;/p&gt;
&lt;h4 id=&quot;最长回文字串&quot;&gt;&lt;a href=&quot;#最长回文字串&quot; class=&quot;headerlink&quot; title=&quot;最长回文字串&quot;&gt;&lt;/a&gt;最长回文字串&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常用的算法题总结一下。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PAT练习(Advanced Level)</title>
    <link href="http://peilinghui.com/2016/03/15/PAT%E7%BB%83%E4%B9%A0-Advanced-Level/"/>
    <id>http://peilinghui.com/2016/03/15/PAT练习-Advanced-Level/</id>
    <published>2016-03-15T03:31:10.000Z</published>
    <updated>2016-03-27T11:20:08.000Z</updated>
    
    <content type="html">&lt;p&gt;PAT练习(Advanced Level)&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1020树的遍历（25）&quot;&gt;&lt;a href=&quot;#1020树的遍历（25）&quot; class=&quot;headerlink&quot; title=&quot;1020树的遍历（25）&quot;&gt;&lt;/a&gt;1020树的遍历（25）&lt;/h3&gt;&lt;p&gt;假设在二叉树所有的按键是不同的正整数。考虑到后序和中序遍历序列，你应该输出相应的二叉树的层次序遍历序列。&lt;/p&gt;
&lt;p&gt;输入规格：&lt;br&gt;每个输入文件包含一个测试用例。对于每一种情况下，第一行给出一个正整数N（&amp;lt;= 30），在该二进制树的节点的总数。第二行给出了后序序列和第三行给出的序序列。在一条线上所有的号码都用空格隔开。&lt;/p&gt;
&lt;p&gt;输出规格：&lt;br&gt;对于每一个测试的情况下，打印一行相应的二进制树的级别顺序遍历顺序。在一条线的所有数字，必须通过一个空格分开，并且必须有在该行的末尾没有额外的空间。&lt;/p&gt;
&lt;p&gt;样品输入：&lt;br&gt;7&lt;br&gt;2 3 1 5 7 6 4&lt;br&gt;1 2 3 4 5 6 7&lt;br&gt;示例输出：&lt;br&gt;4 1 6 3 5 7 2&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *lchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *rchild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;Node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; post[maxn],in[maxn];&lt;span class=&quot;comment&quot;&gt;//中序，后序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;span class=&quot;comment&quot;&gt;//结点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//当前二叉树的后序序列区间[postL,postR],中序序列区间[inL,inR]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//create函数返回构建出的二叉树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;node *&lt;span class=&quot;title&quot;&gt;creat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; postL,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; postR,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; inL,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; inR)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(postL &amp;gt; postR)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node * root = (node *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(node));&lt;span class=&quot;comment&quot;&gt;//根节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;data = post[postR];&lt;span class=&quot;comment&quot;&gt;//根节点值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(k=inL;k&amp;lt;=inR;k++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(in[k] == root-&amp;gt;data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; numLeft = k - inL;&lt;span class=&quot;comment&quot;&gt;//左子树节点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回左子树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;lchild = creat(postL,postL+numLeft-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,inL,k-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回右子树的根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root-&amp;gt;rchild = creat(postL+numLeft,postR-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,k+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,inR);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//返回根节点地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//已输出的结点个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BFS&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(node *root)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;node *&amp;gt; q;&lt;span class=&quot;comment&quot;&gt;//注意队列里是存地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    q.push(root);&lt;span class=&quot;comment&quot;&gt;//将根节点地址入队&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node *top = q.front();&lt;span class=&quot;comment&quot;&gt;//取出队首元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        q.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num != n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,top-&amp;gt;data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,top-&amp;gt;data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(top-&amp;gt;lchild != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//左子树非空,左子树入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q.push(top-&amp;gt;lchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(top-&amp;gt;rchild != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//右子树非空,右子树入队列&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            q.push(top-&amp;gt;rchild);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    node *root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;post[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;n;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;in[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    root = creat(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BFS(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;1059-Prime-Factors-25&quot;&gt;&lt;a href=&quot;#1059-Prime-Factors-25&quot; class=&quot;headerlink&quot; title=&quot;1059. Prime Factors (25)&quot;&gt;&lt;/a&gt;1059. Prime Factors (25)&lt;/h1&gt;&lt;p&gt;Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p1^k1 &lt;em&gt; p2^k2 &lt;/em&gt;…*pm^km.&lt;/p&gt;
&lt;p&gt;Input Specification:&lt;br&gt;Each input file contains one test case which gives a positive integer N in the range of long int.&lt;/p&gt;
&lt;p&gt;Output Specification:&lt;br&gt;Factor N in the format N = p1^k1 &lt;em&gt; p2^k2 &lt;/em&gt;…*pm^km, where pi’s are prime factors of N in increasing order, and the exponent ki is the number of pi – hence when there is only one pi, ki is 1 and must NOT be printed out.&lt;/p&gt;
&lt;p&gt;Sample Input:&lt;br&gt;97532468&lt;/p&gt;
&lt;p&gt;Sample Output:&lt;br&gt;97532468=2^2&lt;em&gt; 11 &lt;/em&gt; 17 &lt;em&gt; 101 &lt;/em&gt; 1291&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn = &lt;span class=&quot;number&quot;&gt;100010&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isPrime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//判断n是否为素数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sqr = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;*n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=sqr;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n%i == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; prime[maxn],pNum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Find_Prime&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//求素数表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;lt;maxn;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(isPrime(i))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            prime[pNum++] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; factor&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x,cn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;fac[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Find_Prime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,num = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//num为不同质因子的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1=1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d=&quot;&lt;/span&gt;,n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sqr = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;sqrt&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;*n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//枚举根号n以内的质因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;pNum &amp;amp;&amp;amp; prime[i] &amp;lt;= sqr;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n%prime[i] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;span class=&quot;comment&quot;&gt;//是质因子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fac[num].x = prime[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fac[num].cn = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(n%prime[i] == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;//计算出质因子prime[i]的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    fac[num].cn++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    n /= prime[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                num++;&lt;span class=&quot;comment&quot;&gt;//不同质因子个数加1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n != &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fac[num].x = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            fac[num++].cn = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;num;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,fac[i].x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(fac[i].cn &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;^%d&quot;&lt;/span&gt;,fac[i].cn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;PAT练习(Advanced Level)&lt;br&gt;
    
    </summary>
    
      <category term="算法编程" scheme="http://peilinghui.com/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PAT" scheme="http://peilinghui.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>ViewController的生命周期</title>
    <link href="http://peilinghui.com/2016/03/14/ViewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://peilinghui.com/2016/03/14/ViewController的生命周期/</id>
    <published>2016-03-14T14:40:25.000Z</published>
    <updated>2017-02-19T14:43:18.000Z</updated>
    
    <content type="html">&lt;p&gt;ViewController的生命周期&lt;!--more&gt;
![屏幕快照 2016-11-30 下午4.57.03.png](http://upload-images.jianshu.io/upload_images/1436896-16bffaa910655097.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
当你alloc并init了一个ViewController时，这个ViewController应该是还没有创建view的。ViewController的view是使用了lazyInit方式创建，就是说你调用的view属性的getter：［self view］。在getter里会先判断view是否创建，如果没有创建，那么会调用loadView来创建view。loadView完成时会继续调用viewDidLoad。loadView和viewDidLoad的一个区别就是：loadView时还没有view。而viewDidLoad时view以及创建好了。
loadView 此方法在控制器的view为nil的时候被调用。 此方法用于以编程的方式创建view的时候用到。 如：
 &lt;figure class=&quot;highlight inform7&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- ( void ) loadView &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIView *view = &lt;span class=&quot;comment&quot;&gt;[ &lt;span class=&quot;comment&quot;&gt;[ UIView alloc]&lt;/span&gt; initWithFrame:&lt;span class=&quot;comment&quot;&gt;[ UIScreen mainScreen]&lt;/span&gt; .applicationFrame]&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;[ view setBackgroundColor:_color]&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.view = view;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;[ view release]&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;三、代码组织（如何设计良好的viewcontroller）&lt;br&gt;ViewController生命周期中有那么多函数，一个重要问题就是什么代码该写在什么地方。&lt;br&gt;1、init里不要出现创建view的代码。良好的设计，在init里应该只有相关数据的初始化，而且这些数据都是比较关键的数据。init里不要掉self.view，否则会导致viewcontroller创建view。（因为view是lazyinit的）。&lt;br&gt;2、loadView中只初始化view，一般用于创建比较关键的view如tableViewController的tabView，UINavigationController的navgationBar，不可掉用view的getter（在掉super loadView前），最好也不要初始化一些非关键的view。如果你是从nib文件中创建的viewController在这里一定要首先调用super的loadView方法，但建议不要重载这个方法。&lt;br&gt;3、viewDidLoad 这时候view已经有了，最适合创建一些附加的view和控件了。有一点需要注意的是，viewDidLoad会调用多次（viewcontroller可能多次载入view，参见图2）。&lt;br&gt;4、viewWillAppear 这个一般在view被添加到superview之前，切换动画之前调用。在这里可以进行一些显示前的处理。比如键盘弹出，一些特殊的过程动画（比如状态条和navigationbar颜色）。&lt;br&gt;5、viewDidAppear 一般用于显示后，在切换动画后，如果有需要的操作，可以在这里加入相关代码。&lt;br&gt;6、viewDidUnload 这时候viewController的view已经是nil了。由于这一般发生在内存警告时，所以在这里你应该将那些不在显示的view释放了。比如你在viewcontroller的view上加了一个label，而且这个label是viewcontroller的属性，那么你要把这个属性设置成nil，以免占用不必要的内存，而这个label在viewDidLoad时会重新创建。&lt;/p&gt;
&lt;h2 id=&quot;一、-ARC环境&quot;&gt;&lt;a href=&quot;#一、-ARC环境&quot; class=&quot;headerlink&quot; title=&quot;一、 ARC环境&quot;&gt;&lt;/a&gt;一、 ARC环境&lt;/h2&gt;&lt;h3 id=&quot;单个viewController的生命周期&quot;&gt;&lt;a href=&quot;#单个viewController的生命周期&quot; class=&quot;headerlink&quot; title=&quot;单个viewController的生命周期&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;单个viewController的生命周期&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;initWithCoder:(NSCoder *)aDecoder：（如果使用storyboard或者xib）&lt;/li&gt;
&lt;li&gt;loadView：加载view&lt;/li&gt;
&lt;li&gt;viewDidLoad：view加载完毕&lt;/li&gt;
&lt;li&gt;viewWillAppear：控制器的view将要显示&lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews：控制器的view将要布局子控件&lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews：控制器的view布局子控件完成&lt;br&gt;这期间系统可能会多次调用viewWillLayoutSubviews 、  viewDidLayoutSubviews 俩个方法&lt;/li&gt;
&lt;li&gt;viewDidAppear:控制器的view完全显示&lt;/li&gt;
&lt;li&gt;viewWillDisappear：控制器的view即将消失的时候&lt;br&gt;这期间系统也会调用viewWillLayoutSubviews 、viewDidLayoutSubviews 两个方法&lt;/li&gt;
&lt;li&gt;viewDidDisappear：控制器的view完全消失的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;多个viewControllers跳转&quot;&gt;&lt;a href=&quot;#多个viewControllers跳转&quot; class=&quot;headerlink&quot; title=&quot;多个viewControllers跳转&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;多个viewControllers跳转&lt;/em&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initWithCoder:(NSCoder *)aDecoder：ViewController2&lt;br&gt;(如果用xib创建的情况下）  &lt;/li&gt;
&lt;li&gt;loadView：ViewController2  &lt;/li&gt;
&lt;li&gt;viewDidLoad：ViewController2  &lt;/li&gt;
&lt;li&gt;viewWillDisappear：&lt;strong&gt;ViewController1&lt;/strong&gt; 将要消失  &lt;/li&gt;
&lt;li&gt;viewWillAppear：ViewController2将要出现  &lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews：ViewController2  &lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews：ViewController2  &lt;/li&gt;
&lt;li&gt;viewWillLayoutSubviews:&lt;strong&gt;ViewController1&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;viewDidLayoutSubviews:&lt;strong&gt;ViewController1&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;viewDidDisappear:&lt;strong&gt;ViewController1&lt;/strong&gt; 完全消失  &lt;/li&gt;
&lt;li&gt;viewDidAppear:ViewController2完全出现  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小结：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个控制器声明周期： viewDidLoad -&amp;gt; viewWillAppear -&amp;gt; viewWillLayoutSubviews -&amp;gt; viewDidLayoutSubviews -&amp;gt; viewDidAppear -&amp;gt; viewWillDisappear -&amp;gt; viewDidDisappear&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、非ARC环境下  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;didReceiveMemoryWarning：当app收到内存警告的时候会发消息给视图控制器。&lt;br&gt;app从来不会直接调用这个方法，而是当系统确定可用内存不足的时候采取调用。&lt;br&gt;&lt;strong&gt;如果你想覆写这个方法来释放一些控制器使用的额外内存，你应该在你的实现方法中调用父类的实现方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;viewWillUnload：（iOS6废除）&lt;br&gt;当消除掉控制器的视图之前调用&lt;br&gt;视图不会再在低内存条件下被清除所以这个方法不会再被调用。&lt;br&gt;在iOS5之前，当低的内存情况发生的时候，当前控制器的视图们不再被需要的时候，系统会有选择性的将这些视图从这些内存移除。这个方法被调用的目的是在视图被真正的销毁前你可以执行一些清空的任务。比如，你想要使用这个方法去清空视图的观察者或通知或者记录视图的状态以便当重新读取的时候恢复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在iOS6之后，不再需要清空视图的引用。因此，其他一些关于清理的方法，比如清空观察者，也不是必要的了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;viewDidUnload：（iOS6废除）&lt;br&gt;当视图从内存中被消除后调用&lt;br&gt;视图在地的内存情况下不再被销毁所以这个方法也不再会调用&lt;br&gt;在iOS5之前，地的内存状况发生之后，当前的试图控制器的视图不再被需要，系统会选择性的在视图控制器的视图被销毁后调用。这个方法使你执行一些最后清空任务的最后机会如果你的视图控制器存储着对视图的或子控件的单独引用，你应该使用这个方法去释放这些引用。你也可以使用这个方法去消除一些你再创建视图时候所创建的但是当视图不再的时候不再需要的关于对象的引用。你不应该使用这个方法去释放用户数据或者一些不能轻易被重新创建的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在iOS6之后，清空在试图控制器中对views和其他对象的引用已经没有必要了。&lt;br&gt;当这个方法被调用的时候，视图的属性是空的。                   &lt;/p&gt;
--&gt;&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;ViewController的生命周期&lt;!--more&gt;
![屏幕快照 2016-11-30 下午4.57.03.png](http://upload-images.jianshu.io/upload_images/1436896-16bffaa910655097.png?
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://peilinghui.com/2016/03/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://peilinghui.com/2016/03/14/数据结构/</id>
    <published>2016-03-14T14:10:13.000Z</published>
    <updated>2017-02-22T07:22:48.000Z</updated>
    
    <content type="html">&lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;黑盒测试：&lt;br&gt;1&amp;gt;单点测试(PAT)&lt;br&gt;该组数据通过测试&lt;br&gt;2&amp;gt;多点测试(ACM)&lt;br&gt;程序一次能运行所有数据，并要求输出的结果必须正确。&lt;br&gt;while(scanf(“%d %d”, &amp;amp;n, &amp;amp;a) != EOF){}EOF为end of file返回值为-1.&lt;/p&gt;
&lt;h2 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h2&gt;&lt;h3 id=&quot;顺序表&quot;&gt;&lt;a href=&quot;#顺序表&quot; class=&quot;headerlink&quot; title=&quot;顺序表&quot;&gt;&lt;/a&gt;顺序表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定义 ：&lt;br&gt;静态分配:&lt;br&gt;#define MaxSize 50&lt;br&gt;typedef  struct{//静态分配&lt;br&gt; ElemType data[MaxSize];//顺序表元素&lt;br&gt; int length;//当前长度&lt;br&gt;}SqList;&lt;br&gt;动态分配:&lt;br&gt;#define InitSize 100&lt;br&gt;typedef  struct{//动态分配&lt;br&gt; ElemType *data;//指示动态分配数组的指针&lt;br&gt; int MaxSize,length;//数组最大容量和当前个数&lt;br&gt;}SeqList;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;//初始动态分配&lt;br&gt;&lt;code&gt;L.data=(ElemType *)malloc(sizeof(Elemtype)*InitSize);&lt;/code&gt;&lt;br&gt;//C++动态分配&lt;br&gt;&lt;code&gt;L.data=new ElemType[InitSize];&lt;/code&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;操作&lt;br&gt;顺序表最主要的特点就是随机访问特性&lt;br&gt;1&amp;gt;插入&lt;br&gt;bool ListInsert(SqList &amp;amp;L,int i,Element e){&lt;br&gt; if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length+1) return false;&lt;br&gt; if (L.length&amp;gt;=MaxSize) return false;&lt;br&gt; //将第i个位置以及以后的元素后移&lt;br&gt; for (int j=L.length; j&amp;gt;=i; j–)&lt;pre&gt;&lt;code&gt;L.data[j]=L.data[j-1];
&lt;/code&gt;&lt;/pre&gt; L.data[i-1]=e;//在位置i处放入e&lt;br&gt; l.length++;//表长加1&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2&amp;gt;删除&lt;br&gt;bool ListDelete(SqList &amp;amp;L,int i,int &amp;amp;e){&lt;br&gt;    if (i&lt;1 ||=&quot;&quot; i=&quot;&quot;&gt;L.length) return false;&lt;br&gt;    e=L.data[i-1];&lt;br&gt;    //将第i个位置以后的元素前移&lt;br&gt;    for (int j=i; j&amp;lt;L.length; j++)&lt;br&gt;        L.data[j-1]=L.data[j];&lt;br&gt;    L.length–;&lt;br&gt;    return true;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n)  &lt;/1&gt;&lt;/p&gt;
&lt;p&gt;3&amp;gt;按值查找&lt;br&gt;int LocateElem(SqList L,ElemType e){&lt;br&gt;    int i;&lt;br&gt;    for (i=0; i&amp;lt;L.length; i++)&lt;br&gt;        if (L.data[i]==e) return i+1;&lt;br&gt;    return 0;&lt;br&gt;}&lt;/p&gt;
&lt;h3 id=&quot;单链表&quot;&gt;&lt;a href=&quot;#单链表&quot; class=&quot;headerlink&quot; title=&quot;单链表&quot;&gt;&lt;/a&gt;单链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义&lt;br&gt;typedef struct LNode{&lt;br&gt; ElemType data;//数据域&lt;br&gt; struct LNode &lt;em&gt;next;//指针域&lt;br&gt;}LNode,&lt;/em&gt;LinkList;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;头插法建立单链表&lt;br&gt;LinkList CreateList1(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; LNode *s;int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; L-&amp;gt;next= NULL;//初始为空链表&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
s-&amp;gt;next=L-&amp;gt;next;
L-&amp;gt;next=s;
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; return L;&lt;br&gt;}&lt;br&gt;时间复杂度：O(n) &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尾插法建立单链表&lt;br&gt;LinkList CreateList2(LinkList &amp;amp;L){&lt;br&gt; //从表尾到表头逆向建立单链表，每次均在头结点之后插入元素&lt;br&gt; int x;&lt;br&gt; L=(LinkList)malloc(sizeof(LNode));//创建头结点&lt;br&gt; LNode &lt;em&gt;s,&lt;/em&gt;r=L;&lt;br&gt; scanf(“%d”,x);&lt;br&gt; while (x!=9999) {//创建新结点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s=(LNode *)malloc(sizeof(LNode));
s-&amp;gt;data = x;
r-&amp;gt;next=s;
r=s;//r指向新的表尾结点
scanf(&amp;quot;%d&amp;quot;,&amp;amp;x);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; r-&amp;gt;next=NUll;&lt;br&gt; return L;&lt;br&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;按序号查找表结点值&lt;br&gt;LNode &lt;em&gt;GetElem(LinkList L,int i){&lt;br&gt; int j=1;&lt;br&gt; LNode &lt;/em&gt;p=L-&amp;gt;next;&lt;br&gt; if(i==0)return L;&lt;br&gt; if (i&amp;lt;1)return NUll;&lt;br&gt; while (p&amp;amp;&amp;amp;j&amp;lt;i) {&lt;pre&gt;&lt;code&gt;p=p-&amp;gt;next;
j++;
&lt;/code&gt;&lt;/pre&gt; }&lt;br&gt; return p;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;双链表&quot;&gt;&lt;a href=&quot;#双链表&quot; class=&quot;headerlink&quot; title=&quot;双链表&quot;&gt;&lt;/a&gt;双链表&lt;/h3&gt;&lt;h3 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h3&gt;&lt;p&gt;顺序栈 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void InitStack(&amp;amp;S){&lt;br&gt; s.top=-1;//将栈顶指针置为空&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;判断栈空&lt;br&gt;bool empty(S){&lt;br&gt; if (s.top==-1) return true;//栈空&lt;br&gt; else return false;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;进栈&lt;br&gt;bool push(x){&lt;br&gt; if (S.top==MaxSize-1) return false;//栈满，报错&lt;br&gt; S.data[++S.top]=x;//指针先加1，再入栈&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;出栈&lt;br&gt;bool pop(x){&lt;br&gt; if (S.top==-1) return false;//栈空，报错&lt;br&gt; x=S.data[S.top–];//先出栈，指针再减1&lt;br&gt; return true;&lt;br&gt;}  &lt;/li&gt;
&lt;li&gt;读栈顶元素&lt;br&gt;void GetTop(x){&lt;br&gt; if (S.top==-1)return false;//栈空，报错&lt;br&gt; x= S.data[S.top];//x记录栈顶元素&lt;br&gt; return false;&lt;br&gt;}&lt;h4 id=&quot;简单计算器（ACM）&quot;&gt;&lt;a href=&quot;#简单计算器（ACM）&quot; class=&quot;headerlink&quot; title=&quot;简单计算器（ACM）&quot;&gt;&lt;/a&gt;简单计算器（ACM）&lt;/h4&gt;读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输入&lt;br&gt;测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。&lt;/p&gt;
&lt;p&gt;样例输入&lt;br&gt;30 / 90 - 26 + 97 - 5 - 6 - 13 / 88 &lt;em&gt; 6 + 51 / 29 + 79 &lt;/em&gt; 87 + 57 * 92&lt;br&gt;0&lt;br&gt;样例输出&lt;br&gt;12178.21&lt;br&gt;思路：题目给出的是中缀表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 中缀表达式转后缀表达式 
 1&amp;gt;设立一个操作符栈，存放操作符，设立一个队列，存放后缀表达式
 2&amp;gt;扫描中缀表达式，遇到操作数放入后缀表达式。
 3&amp;gt;遇到操作符op，则将其优先级与操作符栈顶操作符优先级比较; 
 若高于，则压入栈，若低于，则弹出到后缀表达式。
 4&amp;gt;重复直到扫描完，若仍有，放到后缀表达式
- 计算后缀表达式
扫描后缀表达式，若是操作数，就压入栈，若是操作符，就弹出两个操作数，进行计算，计算后的数压入栈。直到扫描完，栈中只有一个数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;答案：&lt;a href=&quot;http://blog.csdn.net/ccj2020/article/details/7749450&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/ccj2020/article/details/7749450&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &amp;lt;iostream&amp;gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stack&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;queue&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;map&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; node &amp;#123;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; num;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; op;	&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; flag;&amp;#125;;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; str;&lt;span class=&quot;built_in&quot;&gt;stack&lt;/span&gt;&amp;lt;node&amp;gt; s;&lt;span class=&quot;built_in&quot;&gt;queue&lt;/span&gt;&amp;lt;node&amp;gt; q;&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&amp;gt; op;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node temp;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;str.length();)&amp;#123;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			temp.num = str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;			i++;			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i&amp;lt;str.length() &amp;amp;&amp;amp; str[i] &amp;gt;= &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt; &amp;amp;&amp;amp; str[i] &amp;lt;= &lt;span class=&quot;string&quot;&gt;&#39;9&#39;&lt;/span&gt;)&amp;#123;				temp.num = temp.num * &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; + str[i] - &lt;span class=&quot;string&quot;&gt;&#39;0&#39;&lt;/span&gt;;				i++;			&amp;#125;			q.push(temp);		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp.flag = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;			temp.op = str[i];			&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty() &amp;amp;&amp;amp; op[temp.op] &amp;lt;= op[s.top().op])&amp;#123;				q.push(s.top());				s.pop();			&amp;#125;			s.push(temp);			i++;		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!s.empty())&amp;#123;		q.push(s.top());		s.pop();	&amp;#125;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	node cur,temp;	&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; temp1,temp2;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(!q.empty())&amp;#123;		cur = q.front();		q.pop();		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.flag == &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)			s.push(cur);		&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;			temp2 = s.top().num;			s.pop();			temp1 = s.top().num;			s.pop();			temp.flag = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;)				temp.num = temp1 + temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;)				temp.num = temp1 - temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;)				temp.num = temp1 * temp2;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(cur.op == &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;)				temp.num = temp1 / temp2;			s.push(temp);		&amp;#125;	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s.top().num;&amp;#125;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;	op[&lt;span class=&quot;string&quot;&gt;&#39;+&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;	op[&lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;] = op[&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;	str = &lt;span class=&quot;string&quot;&gt;&quot;1+1*9-2+1&quot;&lt;/span&gt;;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;ni hao&quot;&lt;/span&gt;);	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(getline(&lt;span class=&quot;built_in&quot;&gt;cin&lt;/span&gt;,str))&amp;#123;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;_______&quot;&lt;/span&gt;);		change();		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%.2f&quot;&lt;/span&gt;,cal());	&amp;#125;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;循环队列&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt;void Initqueue(&amp;amp;Q){&lt;br&gt; Q.rear=Q.front=0;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;判队空&lt;br&gt;bool isEmpty(Q){&lt;br&gt; if (Q.rear==Q.front) return true;&lt;br&gt; else return false;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;入队&lt;br&gt;bool EnQueue(Queue &amp;amp;Q,x){&lt;br&gt; if ((Q.rear+1)%MaxSize==Q.front) return false;//队满&lt;br&gt; Q.data[Q.rear]=x;&lt;br&gt; Q.rear=(Q.rear+1)%MaxSize;//队尾指针加1取模&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;li&gt;出队&lt;br&gt;bool DeQueue(Queue &amp;amp;Q,&amp;amp;x){&lt;br&gt; if (Q.rear==Q.front)return false;&lt;br&gt; x=Q.data[Q.front];&lt;br&gt; Q.front=(Q.front+1)%MaxSize;&lt;br&gt; return true;&lt;br&gt;}&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;树与二叉树&quot;&gt;&lt;a href=&quot;#树与二叉树&quot; class=&quot;headerlink&quot; title=&quot;树与二叉树&quot;&gt;&lt;/a&gt;树与二叉树&lt;/h2&gt;&lt;p&gt;满二叉树和完全二叉树用顺序存储。&lt;br&gt;一般二叉树都用链式存储&lt;br&gt;struct node{&lt;br&gt;    typename data;&lt;br&gt;    node &lt;em&gt;lchild,&lt;/em&gt;rchild;&lt;br&gt;};&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二叉树的遍历&lt;br&gt;1.先序遍历&lt;br&gt;2.中序遍历&lt;br&gt;3.后序遍历&lt;br&gt;4.层序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;排序（内排）&quot;&gt;&lt;a href=&quot;#排序（内排）&quot; class=&quot;headerlink&quot; title=&quot;排序（内排）&quot;&gt;&lt;/a&gt;排序（内排）&lt;/h2&gt;&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h3&gt;&lt;h4 id=&quot;直接插入排序&quot;&gt;&lt;a href=&quot;#直接插入排序&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h4&gt;&lt;p&gt;思想：表长L[1…..N],有序序列L[1..i-1],L(i),无序序列L[n+1……N],将L(i)插入有序L[1..i-1]。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 找出L(i)插入有序L[1..i-1]的位置k。  
- 将L[k..i-1]中所有元素后移一位  
- 将L(i)复制给L(k)。  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;空间效率：O（1）&lt;br&gt;时间效率：O（N2） &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InsertSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;i&amp;lt;=n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp=A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j=i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; temp&amp;lt;A[j]; j--) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//从后往前查找待插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=A[j];&lt;span class=&quot;comment&quot;&gt;//向后移一位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//复制到插入位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;折半插入排序&quot;&gt;&lt;a href=&quot;#折半插入排序&quot; class=&quot;headerlink&quot; title=&quot;折半插入排序&quot;&gt;&lt;/a&gt;折半插入排序&lt;/h4&gt;&lt;h4 id=&quot;希尔排序&quot;&gt;&lt;a href=&quot;#希尔排序&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h4&gt;&lt;p&gt;思想：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。&lt;br&gt;时间复杂度：O(n^1.3)&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ShellSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *data,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len = right -left +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; d = len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(d&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		d=(d+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =left;i&amp;lt;right+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;-d;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(data[i+d]&amp;lt;data[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = data[i+d];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				data[i+d]=data[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				data[i]=tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ShellSort2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *data,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; d =len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(d&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		d = (d+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;len-d;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(data[i+d]&amp;lt;data[i])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = data[i+d];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				data[i+d] = data[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				data[i] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%5d&quot;&lt;/span&gt;,data[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,m =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;input 10 number:&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ShellSort2(&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//ShellSort(list,0,9);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	print(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%5d&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;交换排序&quot;&gt;&lt;a href=&quot;#交换排序&quot; class=&quot;headerlink&quot; title=&quot;交换排序&quot;&gt;&lt;/a&gt;交换排序&lt;/h3&gt;&lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;p&gt;思想：表长n，从前往后或（从后往前）两两比较相邻元素的值，逆序则交换，这是第一趟，需要n-1趟。&lt;br&gt;空间效率：O（1）&lt;br&gt;时间效率：平均和最坏都是：O（N2） &lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]= &amp;#123;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;-i; j++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//第i趟时从a[0]到a[n-i]都与他们的下一个数比较&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123;&lt;span class=&quot;comment&quot;&gt;//如果左边的数更大，则交换a[j]和a[j+1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j] = a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i ++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d &quot;&lt;/span&gt;,a[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;题目：要求输入10个整数，输出冒泡排序的结果&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#incllude&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maopao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,j,temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;=i;j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j]&amp;gt;&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 			temp = &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 			&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j]=&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 			&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;main()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,m=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;input 10 number:&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		maopao(&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;5%d&quot;&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;list&lt;/span&gt;[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h4&gt;&lt;p&gt;是所有排序算法中平均时间最好的一种算法，O(nlogn)思想是基于分治法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调整序列中的元素，使得当前序列最左短的元素在调整后满足左侧所以元素均不超过该元素、右侧所有元素均大于该元素。  &lt;/li&gt;
&lt;li&gt;对该元素的左侧和右侧分别递归进行1的调整，直到当前调整区间的长度不超过1.&lt;br&gt;时间复杂度：O(n2)&lt;br&gt;空间复杂度：O(logn)&lt;br&gt;递归实现：&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int temp = &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将表中第一个元素设为枢轴值，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]&amp;gt;temp) &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值小的元素移动到左边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]&amp;lt;=temp) &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;]=&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;];&lt;span class=&quot;comment&quot;&gt;//将比枢轴值大的元素移动到右边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;]=temp;&lt;span class=&quot;comment&quot;&gt;//枢轴放到最终位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//返回下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(int &lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;[],int &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,int &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int pos = &lt;span class=&quot;type&quot;&gt;Partition&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//将[left,right]按A[left]一分为二&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt;, pos);&lt;span class=&quot;comment&quot;&gt;//对左子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;quickSort&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;A&lt;/span&gt;, pos+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;right&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//对右子区间递归进行快速排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;h4 id=&quot;简单选择排序&quot;&gt;&lt;a href=&quot;#简单选择排序&quot; class=&quot;headerlink&quot; title=&quot;简单选择排序&quot;&gt;&lt;/a&gt;简单选择排序&lt;/h4&gt;&lt;p&gt;思想：表长N[1…..N],第i趟排序则从[i……N]中选择关键字最小的元素与i交换，每一趟确定一个元素的最终位置，需要n-1趟。&lt;br&gt;空间效率：O(1)&lt;br&gt;时间效率：平均和最坏都是：O（N2）&lt;br&gt;&lt;figure class=&quot;highlight glsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; selectSort()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;n; i++) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//进行n-1趟&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = i;&lt;span class=&quot;comment&quot;&gt;//记录最小元素的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=i; j&amp;lt;=n; j++) &lt;span class=&quot;comment&quot;&gt;//从i...n中选择最小元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[j]&amp;lt;A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;]) &lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt; = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = A[i];&lt;span class=&quot;comment&quot;&gt;//最小元素与A[i]交换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[i] = A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A[&lt;span class=&quot;built_in&quot;&gt;min&lt;/span&gt;] = A[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h4&gt;&lt;p&gt;时间复杂度：O(nlogn)&lt;/p&gt;
&lt;p&gt;建立堆的复杂度是O(n)，只建立一次&lt;br&gt;调整堆的时间复杂度是o(logn)，调用n-1次  所以是nlogn&lt;br&gt;不稳定&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//array是待调整的堆数组，i是待调整的数组元素的位置，nlength是数组的长度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//本函数功能是：根据数组array构建大根堆&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HeapAdjust&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nLength)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nChild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nTemp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;nLength;i=nChild)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//子结点的位置=2*（父结点位置）+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nChild=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//得到子结点中较大的结点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nChild&amp;lt;nLength-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;amp;&amp;amp;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[nChild+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&amp;gt;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[nChild])++nChild;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i]&amp;lt;&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[nChild])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nTemp=&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[i]=&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[nChild];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[nChild]=nTemp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//否则退出循环&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//堆排序算法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HeapSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//length/2-1是最后一个非叶节点，此处&quot;/&quot;为整除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=length/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;--i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HeapAdjust(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;,i,length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;--i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//把第一个元素和当前的最后一个元素交换，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//保证当前的最后一个位置的元素都是在现在的这个序列之中最大的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        交换arry[i] arry[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        HeapAdjust(&lt;span class=&quot;built_in&quot;&gt;array&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h3&gt;&lt;p&gt;含义：将两个或俩个以上的有序表合并成为一个新的有序表。&lt;br&gt;2-路归并排序&lt;br&gt;时间复杂度：O(nlogn)稳定！&lt;/p&gt;
&lt;p&gt;思想：&lt;br&gt;第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;br&gt;第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;br&gt;第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;br&gt;重复步骤3直到某一指针超出序列尾&lt;/p&gt;
&lt;p&gt;将另一序列剩下的所有元素直接复制到合并序列尾&lt;br&gt;递归实现：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxn=&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将数组A的[L1,R1]与[L2,R2]区间合并为有序区间L2=R1+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R1,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L2,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R2)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=L1,j=L2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp[maxn],index=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//temp存放合并后的数组，index为其下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1&amp;amp;&amp;amp;j&amp;lt;=R2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (A[i]&amp;lt;=A[j]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将A[i]加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp[index++]=A[j++];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i&amp;lt;=R1)temp[index++]=A[i++];&lt;span class=&quot;comment&quot;&gt;//将区间[L1,R1]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (j&amp;lt;=R2)temp[index++]=A[j++];&lt;span class=&quot;comment&quot;&gt;//将区间[L2,R2]的剩余元素加入序列temp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;index; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A[L1+i]=temp[i]; &lt;span class=&quot;comment&quot;&gt;//将合并后的序列赋值回数组A&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将Array数组当前区间[left,right]进行归并排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (left&amp;lt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mid = (left+right)/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, left, mid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mergeSort(A, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        merge(A, left, mid, mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;非递归：&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;figcaption&gt;&lt;span&gt;mergeSort(int A[])&amp;#123;&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    //step&amp;#20026;&amp;#32452;&amp;#20869;&amp;#20803;&amp;#32032;&amp;#20010;&amp;#25968;&amp;#10;    for (int step= 2; step/2 &amp;#60;= n; step*=2) &amp;#123;&amp;#10;        //&amp;#27599;step&amp;#20010;&amp;#20803;&amp;#32032;&amp;#19968;&amp;#32452;&amp;#65292;&amp;#32452;&amp;#20869;&amp;#36827;&amp;#34892;&amp;#25490;&amp;#24207;&amp;#10;        for (int i =1; i&amp;#60;=n; i+=step) &amp;#123;&amp;#10;            int mid = i +step/2 -1;&amp;#10;            if (mid +1&amp;#60;=n) &amp;#123;&amp;#10;                merge(A,mid,mid+1,min(i+step-1,n));&amp;#10;            &amp;#125;&amp;#10;        &amp;#125;&amp;#10;    &amp;#125;&amp;#10;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者是：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;mergeSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; A[])&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//step为组内元素个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; step= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; step/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;lt;= n; step*=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//每step个元素一组，组内进行排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;=n; i+=step) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sort(A+i,A+min(i+step,n+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;基数排序&quot;&gt;&lt;a href=&quot;#基数排序&quot; class=&quot;headerlink&quot; title=&quot;基数排序&quot;&gt;&lt;/a&gt;基数排序&lt;/h3&gt;&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h2&gt;&lt;h3 id=&quot;线性结构&quot;&gt;&lt;a href=&quot;#线性结构&quot; class=&quot;headerlink&quot; title=&quot;线性结构&quot;&gt;&lt;/a&gt;线性结构&lt;/h3&gt;&lt;h4 id=&quot;顺序查找&quot;&gt;&lt;a href=&quot;#顺序查找&quot; class=&quot;headerlink&quot; title=&quot;顺序查找&quot;&gt;&lt;/a&gt;顺序查找&lt;/h4&gt;&lt;h4 id=&quot;折半查找&quot;&gt;&lt;a href=&quot;#折半查找&quot; class=&quot;headerlink&quot; title=&quot;折半查找&quot;&gt;&lt;/a&gt;折半查找&lt;/h4&gt;&lt;p&gt;适用于：有序的顺序表&lt;br&gt;时间复杂度：O(logn)&lt;/p&gt;
&lt;h4 id=&quot;分块查找&quot;&gt;&lt;a href=&quot;#分块查找&quot; class=&quot;headerlink&quot; title=&quot;分块查找&quot;&gt;&lt;/a&gt;分块查找&lt;/h4&gt;&lt;h3 id=&quot;树形结构&quot;&gt;&lt;a href=&quot;#树形结构&quot; class=&quot;headerlink&quot; title=&quot;树形结构&quot;&gt;&lt;/a&gt;树形结构&lt;/h3&gt;&lt;h4 id=&quot;二叉排序树&quot;&gt;&lt;a href=&quot;#二叉排序树&quot; class=&quot;headerlink&quot; title=&quot;二叉排序树&quot;&gt;&lt;/a&gt;二叉排序树&lt;/h4&gt;&lt;h4 id=&quot;二叉平衡数&quot;&gt;&lt;a href=&quot;#二叉平衡数&quot; class=&quot;headerlink&quot; title=&quot;二叉平衡数&quot;&gt;&lt;/a&gt;二叉平衡数&lt;/h4&gt;&lt;h4 id=&quot;B树，B-树&quot;&gt;&lt;a href=&quot;#B树，B-树&quot; class=&quot;headerlink&quot; title=&quot;B树，B+树&quot;&gt;&lt;/a&gt;B树，B+树&lt;/h4&gt;&lt;h3 id=&quot;散列结构&quot;&gt;&lt;a href=&quot;#散列结构&quot; class=&quot;headerlink&quot; title=&quot;散列结构&quot;&gt;&lt;/a&gt;散列结构&lt;/h3&gt;&lt;h4 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h4&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了那本天勤的书，总结一下内容，就当读书笔记了。&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://peilinghui.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://peilinghui.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ACM练习</title>
    <link href="http://peilinghui.com/2016/03/14/ACM%E7%BB%83%E4%B9%A0/"/>
    <id>http://peilinghui.com/2016/03/14/ACM练习/</id>
    <published>2016-03-14T07:59:15.000Z</published>
    <updated>2016-03-28T14:37:23.000Z</updated>
    
    <content type="html">&lt;p&gt;做一些简单的ACM题。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1928-日期差值&quot;&gt;&lt;a href=&quot;#1928-日期差值&quot; class=&quot;headerlink&quot; title=&quot;1928. 日期差值&quot;&gt;&lt;/a&gt;1928. 日期差值&lt;/h3&gt;&lt;p&gt;有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天。&lt;br&gt;输入&lt;br&gt;有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;每组数据输出一行，即日期差值&lt;/p&gt;
&lt;p&gt;样例输入&lt;br&gt;20130101&lt;br&gt;20130105&lt;br&gt;样例输出&lt;br&gt;5&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;math.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//预先存好每个月的天数，第一列为平年的天数，第二列为闰年的天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; m[&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]=&amp;#123;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;29&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断某一年是不是闰年&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;leap&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (y%&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;amp;&amp;amp;y%&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;!=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)||(y%&lt;span class=&quot;number&quot;&gt;400&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//计算某个日期在本年已经过了多少天&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;day&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Y,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; D)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i,d;&lt;span class=&quot;comment&quot;&gt;//k为标识平年还是闰年，闰年为1，i为月份，d为天数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(Y)) k=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (d=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;M;i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d+=m[i][k];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d+=D;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Y1,M1,D1,Y2,M2,D2,i,d1,d2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%4d%2d%2d&quot;&lt;/span&gt;,&amp;amp;Y1,&amp;amp;M1,&amp;amp;D1)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//读取第一个日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%4d%2d%2d&quot;&lt;/span&gt;,&amp;amp;Y2,&amp;amp;M2,&amp;amp;D2);&lt;span class=&quot;comment&quot;&gt;//读取第二个日期&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d1 = day(Y1, M1, D1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d2 = day(Y2, M2, D2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//选一个基准从0年1月1日到Y1-1年的12月31日一共有多少天，并累加到d1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Y1; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(i))d1 +=&lt;span class=&quot;number&quot;&gt;366&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; d1 +=&lt;span class=&quot;number&quot;&gt;365&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//选一个基准从0年1月1日到Y2-1年的12月31日一共有多少天，并累加到d1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; Y2; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leap(i))d2 +=&lt;span class=&quot;number&quot;&gt;366&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; d2 +=&lt;span class=&quot;number&quot;&gt;365&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//最后俩个天数做差绝对值加1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;built_in&quot;&gt;fabs&lt;/span&gt;(d1-d2)+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;1933-输出梯形&quot;&gt;&lt;a href=&quot;#1933-输出梯形&quot; class=&quot;headerlink&quot; title=&quot;1933. 输出梯形&quot;&gt;&lt;/a&gt;1933. 输出梯形&lt;/h3&gt;&lt;p&gt;输出一个高度h，输出一个高为h，上底边为h的梯形。&lt;br&gt;输入&lt;br&gt;一个整数h(1&amp;lt;=h&amp;lt;=1000)&lt;br&gt;输出&lt;br&gt;h所对应的梯形。&lt;br&gt;样例输入&lt;br&gt;5&lt;br&gt;样例输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    *****
  *******
*********
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h,i,j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;h)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//当题目没有说明有多少数据需要读入时，用这种方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= h; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; ; j &amp;lt;=(h-i)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++)&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j&amp;gt;(h-i)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j &amp;lt;=h+(h-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; j++) &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;*&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;1934-找x&quot;&gt;&lt;a href=&quot;#1934-找x&quot; class=&quot;headerlink&quot; title=&quot;1934.找x&quot;&gt;&lt;/a&gt;1934.找x&lt;/h3&gt;&lt;p&gt;题目：输入一个数n&lt;strong&gt;(1=&amp;lt;n&amp;lt;=200)&lt;/strong&gt;,然后输入n个数值各不相同的数，再输入一个值x,输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）&lt;br&gt;样例输入：&lt;br&gt;4&lt;br&gt;1 2 3 4&lt;br&gt;3&lt;br&gt;样例输出：2&lt;br&gt;思路：遍历查找，找到x的时候就停止&lt;br&gt;答案：&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;preprocessor&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n,x,i,a[&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;n)!=EOF) &amp;#123;&lt;span class=&quot;comment&quot;&gt;//当题目没有说明有多少数据需要读入时，用这种方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;a[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d&quot;&lt;/span&gt;,&amp;amp;x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (a[i]==x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i == n)  &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;-1&quot;&lt;/span&gt;);           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;做一些简单的ACM题。&lt;br&gt;
    
    </summary>
    
      <category term="算法编程" scheme="http://peilinghui.com/categories/%E7%AE%97%E6%B3%95%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="ACM" scheme="http://peilinghui.com/tags/ACM/"/>
    
  </entry>
  
</feed>
