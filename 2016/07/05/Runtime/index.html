<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Runtime | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RunTime运行时，最主要的就是消息机制，根据函数的名称找到对应的函数来调用。">
<meta property="og:type" content="article">
<meta property="og:title" content="Runtime">
<meta property="og:url" content="http://peilinghui.com/2016/07/05/Runtime/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="RunTime运行时，最主要的就是消息机制，根据函数的名称找到对应的函数来调用。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-07%20%E4%B8%8B%E5%8D%883.09.36.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/objective-runtime-1.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8A%E5%8D%889.16.01.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png">
<meta property="og:updated_time" content="2019-02-01T02:28:53.171Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Runtime">
<meta name="twitter:description" content="RunTime运行时，最主要的就是消息机制，根据函数的名称找到对应的函数来调用。">
<meta name="twitter:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-07%20%E4%B8%8B%E5%8D%883.09.36.png">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-Runtime" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/05/Runtime/" class="article-date">
      <time datetime="2016-07-05T08:22:32.000Z" itemprop="datePublished">2016-07-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Runtime
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>RunTime运行时，最主要的就是消息机制，根据函数的名称找到对应的函数来调用。<br><a id="more"></a><br>有什么用？<br> runtime是属于OC的底层, 可以进行一些非常底层的操作。 </p>
<pre><code>1&gt; 发送消息(objc_msgSend)
2&gt; 交换方法(method_exchangeImplementations)
3&gt; 动态创建一个类（比如KVO的底层实现）  
4&gt; 动态添加方法，（performSelector）
5&gt; 给分类添加属性。(其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间) objc_setAssociatedObject与objc_getAssociatedObject
6&gt; 字典转模型（利用runtime,遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。）
6&gt; 可以把消息转发给想要的对象，或者随意交换一个方法的实现。
</code></pre><p>objc的文件夹中的源码文件，看完就能明白runtime和对象消息转发机制。</p>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-07%20%E4%B8%8B%E5%8D%883.09.36.png" alt></p>
<h2 id="Objective-C的元素"><a href="#Objective-C的元素" class="headerlink" title="Objective-C的元素"></a>Objective-C的元素</h2><p>你创建的每个类（派生形式NSObject / NSObject子类）将在堆上分配并将返回一个指针。<br>先看objc.h文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_TYPES_DEFINED</span></span><br><span class="line"><span class="comment">/// An opaque type that represents an Objective-C class.**Class是一个指向objc_class结构体的指针**</span></span><br><span class="line"><span class="comment">//我们所说的类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.isa是一个指向objc_class结构体的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.id是一个指向objc_object结构体的指针</span></span><br><span class="line"><span class="comment">//我们所说的对象</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>再看runtime.h文件中关于objc_class的定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span> </span><br><span class="line"> Class isa                                 OBJC_ISA_AVAILABILITY; <span class="comment">// metaclass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line"> Class super_class                         OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">char</span> *name                          OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line"> <span class="keyword">long</span> version                              OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取</span></span><br><span class="line"> <span class="keyword">long</span> info                                 OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行时期使用的一些位标识，如CLS_CLASS (0x1L) 表示该类为普通 class，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"> <span class="keyword">long</span> instance_size                        OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小（包括从父类继承下来的实例变量）</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>              <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 该类的成员变量地址列表</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>     <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 方法地址列表，与 info 的一些标志位有关，如CLS_CLASS (0x1L)，则存储实例方法，如CLS_META (0x2L)，则存储类方法;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>                  <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 缓存最近使用的方法地址，用于提升效率；</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>      <span class="title">OBJC2_UNAVAILABLE</span>;</span> <span class="comment">// 存储该类声明遵守的协议的列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Use `Class` instead of `struct objc_class *` */</span></span><br></pre></td></tr></table></figure>
<p>由此可以看到，对象(id)就是一个isa指针，而类(class)中不仅有isa指针，还有其他成员变量。类也可以当做一个objc_object来对待，也就是说类和对象都是对象，分别称作类对象（class object）和实例对象（instance object也就是中的isa)，这样我们就可以区别对象和类了。</p>
<p>再仔细看其中成员变量的含义：</p>
<h3 id="1-isa："><a href="#1-isa：" class="headerlink" title="1. isa："></a>1. <strong>isa</strong>：</h3><p>id中的isa指针指向的类结构称为class（也就是该对象所属的类）其中存放着普通成员变量与动态方法（“-”开头的方法）。<br>而class中的isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法（“+”开头的方法）。</p>
<h4 id="2-super-class"><a href="#2-super-class" class="headerlink" title="2. super_class:"></a>2. super_class:</h4><p>指向该类的父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为nil。</p>
<p>类与对象的继承层次关系如图（图片源自网络）：</p>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/objective-runtime-1.png" alt> </p>
<p>所有的class中isa指针都是指向根metaclass，而根metaclass则指向自身。根metaclass是通过继承根类产生的，与根class结构体成员一致，不同的是根metaclass的isa指针指向自身。</p>
<h4 id="3-SEL"><a href="#3-SEL" class="headerlink" title="3. SEL:"></a>3. SEL:</h4><p><code>typedef struct objc_selector *SEL;</code>SEL是selector在Objective-C中的表示类型。selector可以理解为区别方法的ID。</p>
<h4 id="4-IMP"><a href="#4-IMP" class="headerlink" title="4. IMP:"></a>4. IMP:</h4><p>是“implementation”的缩写，它是由编译器生成的<strong>方法实现的一个函数指针</strong>。当你发起一个消息后（下文介绍），这个函数指针决定了最终执行哪段代码。(obj.h)<br>一个函数是由一个selector(SEL)，和一个implement(IML)组成的；Selector相当于门牌号，而Implement才是真正的住户（函数实现）。理解Selector和Implementation的关系蛮重要的！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="5-Method："><a href="#5-Method：" class="headerlink" title="5. Method："></a>5. Method：</h4><p>Method代表类中的某个方法的类型。(runtime.h中)</p>
<p><code>typedef struct objc_method *Method;</code><br>objc_method的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> &#123;</span></span><br><span class="line">    SEL method_name                   OBJC2_UNAVAILABLE; <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types                OBJC2_UNAVAILABLE; <span class="comment">// 方法类型</span></span><br><span class="line">    IMP method_imp                    OBJC2_UNAVAILABLE; <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-Ivar"><a href="#6-Ivar" class="headerlink" title="6. Ivar:"></a>6. Ivar:</h4><p>代表类中实例变量的类型<code>typedef struct objc_ivar *Ivar;</code><br>objc_ivar的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name                   OBJC2_UNAVAILABLE; <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_type                   OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="keyword">int</span> ivar_offset                   OBJC2_UNAVAILABLE; <span class="comment">// 基地址偏移字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space                         OBJC2_UNAVAILABLE; <span class="comment">// 占用空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-Category"><a href="#7-Category" class="headerlink" title="7. Category :"></a>7. Category :</h4><p>代表一个分类<code>typedef struct objc_category *Category;</code><br>objc_category的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_category</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *category_name                                      OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">char</span> *class_name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">instance_methods</span>                <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">class_methods</span>                   <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>                     <span class="title">OBJC2_UNAVAILABLE</span>;</span></span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>在运行时，类（包括class和metaclass）的objc_class结构体是固定的，不可能往这个结构体中添加数据，只能修改！譬如可以修改isa指针，让它指向一个中间类；在我的理解里，应该也可以修改ivars和methodLists，让它们指向一个新的区域；若可以这样，那么就可以在运行时随意添加/修改/删除成员变量和方法了。<br>但是，貌似Objective-C Runtime没有提供修改ivars和methodLists指针值的接口。<br>也因此，ivars在运行时指向的是一个固定区域，当然可以修改这个区域的值了，但这其实只是修改成员变量值而已；「在这个内存区域后面续上一段空余区域用于存放新的成员变量」？呵呵，想多了吧！因此，我们没办法在运行时为对象添加成员变量，这解释了为什么category中不能定义property（dynamic property不算）；<br>P.S: 那为什么protocol中可以添加变量，在我的理解里，protocol是在编译器处理的。所以objc_class中有一个变量叫protocols；<br>和ivars不同，methodLists是一个二维数组。虽然我们没办法扩展methodLists指向的内存区域，但是我们可以改变这个内存区域（这个内存区域存储的都是指针）的值。因此，我们可以在运行时动态添加（以及做其他的处理，譬如交换等）方法！</p>
<h4 id="8-objc-property-t"><a href="#8-objc-property-t" class="headerlink" title="8. objc_property_t:"></a>8. objc_property_t:</h4><p>objc_property_t是属性，它可以动态的为已存在的类添加新的方法。它的定义如下：</p>
<p><code>typedef struct objc_property *objc_property_t;</code><br>objc_property是内置的类型，与之关联的还有一个objc_property_attribute_t，它是属性的attribute，也就是其实是对属性的详细描述，包括属性名称、属性编码类型、原子类型/非原子类型等。它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *value;  <span class="comment">// 值（通常是空的）</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br></pre></td></tr></table></figure>
<h4 id="9-Cache"><a href="#9-Cache" class="headerlink" title="9. Cache"></a>9. Cache</h4><p>Catch的定义如下：</p>
<p>typedef struct objc_cache *Cache<br>objc_cache的定义如下：</p>
<p>struct objc_cache {<br>    unsigned int mask                   OBJC2_UNAVAILABLE;<br>    unsigned int occupied               OBJC2_UNAVAILABLE;<br>    Method buckets[1]                   OBJC2_UNAVAILABLE;<br>};<br>mask: 指定分配cache buckets的总数。在方法查找中，Runtime使用这个字段确定数组的索引位置。<br>occupied: 实际占用cache buckets的总数。<br>buckets: 指定Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。<br><strong>objc_msgSend（下文讲解）每调用一次方法后，就会把该方法缓存到cache列表中，下次的时候，就直接优先从cache列表中寻找，如果cache没有，才从methodLists中查找方法。</strong></p>
<h4 id="10-Module"><a href="#10-Module" class="headerlink" title="10.Module"></a>10.Module</h4><p>Module定义如下：<br><code>typedef struct objc_module *Module                           OBJC2_UNAVAILABLE;</code><br>objc_module定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_module</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> version                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    Symtab symtab                                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<h2 id="Objective-C的消息传递"><a href="#Objective-C的消息传递" class="headerlink" title="Objective-C的消息传递"></a>Objective-C的消息传递</h2><p>消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；</p>
<p>消息机制原理：对象根据方法编号SEL去映射表查找对应的方法实现</p>
<p>消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。</p>
<h3 id="objc-msgSend的作用"><a href="#objc-msgSend的作用" class="headerlink" title="objc_msgSend的作用"></a>objc_msgSend的作用</h3><p>在面向对象编程中，对象调用方法叫做发送消息。在编译时，程序的源代码就会从对象发送消息转换成Runtime的objc_msgSend函数调用。<br>例如某实例变量receiver实现某一个方法oneMethod</p>
<p><code>[receiver oneMethod];</code><br>Runtime会将其转成类似这样的代码</p>
<p><code>objc_msgSend(receiver, selector);</code><br>具体会转换成什么代码呢？</p>
<p>objc_msgSend:普通的消息都会通过该函数发送<br>objc_msgSend_stret:消息中有数据结构作为返回值（不是简单值）时，通过此函数发送和接收返回值<br>objc_msgSendSuper:和objc_msgSend类似，这里把消息发送给父类的实例<br>objc_msgSendSuper_stret:和objc_msgSend_stret类似，这里把消息发送给父类的实例并接收返回值。</p>
<p>objc_msgSend函数的调用过程：</p>
<ol>
<li>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain, release 这些函数了。</li>
<li>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 cache 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了，后面会提到。<br>PS:这里说的分发表其实就是Class中的方法列表，它将方法选择器和方法实现地址联系起来。</li>
</ol>
<p>举 objc_msgSend(obj, foo) 这个例子来说：</p>
<pre><code>首先，通过 obj 的 isa 指针找到它的 class ;
在 class 的 method list 找 foo ;
如果 class 中没到 foo，继续往它的 superclass 中找 ;
一旦找到 foo 这个函数，就去执行它的实现IMP .
</code></pre><p>每个消息都需要遍历一次 objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。这也就是 objc_class 中另一个重要成员 objc_cache 做的事情 - 再找到 foo 之后，把 foo 的 method_name 作为 key ，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list.</p>
<h4 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h4><p>消息有名称(name)或选择子(selector).可以接受参数，而且可能有返回值。方法在objc文件中的message.h。<br>OC的消息机制<br><code>[someObject messageName: parameter]</code><br><code>id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);</code> </p>
<p>objc_msgSend会根据接收者和选择子的类型来调用适当的方法, 流程如下</p>
<pre><code>查找接收者的所属类的cache列表, 如果没有则下一步
查找接收者所属类的&quot;方法列表&quot;
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 就沿着继承体系继续向上查找
如果能找到与选择子名称相符的方法, 就跳至其实现代码
找不到, 执行&quot;消息转发&quot;.
</code></pre><p>另一些函数：<br>objc_msgSend_stret:待发送的消息要返回结构体<br>objc_msgSend_fpret:消息返回的是浮点数<br>objc_msgSendSuper:要给超类发送消息</p>
<h3 id="动态方法解析和转发"><a href="#动态方法解析和转发" class="headerlink" title="动态方法解析和转发"></a>动态方法解析和转发</h3><p>动态解析流程图：</p>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-08%20%E4%B8%8A%E5%8D%889.16.01.png" alt></p>
<ol>
<li>对象在收到无法解读的消息后，首先将调用其所属类的下列方法：(NSObject.h中)</li>
</ol>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尚未实现的方法是类方法</span></span><br><span class="line">+ (<span class="keyword">BOOL</span>)resolveClassMethod:(SEL)sel </span><br><span class="line"><span class="comment">//尚未实现的方法是实例方法</span></span><br><span class="line">+ (<span class="keyword">BOOL</span>)resolveInstanceMethod:(SEL)sel</span><br></pre></td></tr></table></figure>
<p>方法决定是否动态添加方法。如果返回Yes则通过class_addMethod动态添加方法，消息得到处理，结束；如果返回No，则进入下一步；</p>
<ol start="2">
<li><p>这步会进入forwardingTargetForSelector:方法，<br><code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>用于指定备选对象响应这个selector，不能指定为self。如果返回某个对象则会调用对象的方法，结束。如果返回nil，则进入第三部；</p>
</li>
<li><p>这步我们要通过methodSignatureForSelector:方法签名，如果返回nil，则消息无法处理。如果返回methodSignature，则进入下一步；<br><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>
</li>
<li><p>这步调用forwardInvocation：方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等，如果方法调用成功，则结束。如果失败，则进入doesNotRecognizeSelector方法，若我们没有实现这个方法，那么就会crash。<br><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>
</li>
</ol>
<h4 id="第12条：消息转发机制"><a href="#第12条：消息转发机制" class="headerlink" title="第12条：消息转发机制"></a>第12条：消息转发机制</h4><p>消息转发分为两大阶段：第一阶段：征询接受者，动态方法解析。<br>第二阶段：完整的消息转发机制，请接收者看看有没有其他对象能处理这条消息，若有，则把消息转给那个对象。若没有，则启动完整的消息转发机制，会把消息有关的细节全都封装到NSInvocation中去。</p>
<ol>
<li>动态方法解析：对象收到无法解读的消息后，调用类方法：<br><code>+(BOOL)resolveInstanceMethod:(SEL)selector</code><br>要访问CoreData框架中的NSManagedObjects对象时，用resolveInstanceMethod来实现@dynamic属性。  </li>
<li>备援接收者：能不能把这条消息传给其他接收者来处理<br><code>-(id)forwardingTargetForSelector:(SEL)selctor;</code></li>
<li>完整的消息转发：首先，创建NSInvocation对象，把选择子，目标(target)及参数都封装于其中，在触发NSInvocation对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。<br><code>-(void)forwardInvocation:(NSInvocation *)invocation;</code></li>
<li>以完整的例子演示动态方法解析<br>由开发者来添加属性定义，并将其声明为@dynamic，而类则会自动处理相关属性值的存放于获取操作。</li>
</ol>
<h4 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h4><ol>
<li>Objective-c对象的本质：都是指向某块内存数据的指针，所以声明变量时，类型后面要加“<em>”字符。`NSString </em>point= @“string”；<code>id类型本身就是指针。可以改写为</code>id point= @“string”;`<br>描述objective-c对象所用的数据结构定义在runtime.h文件中，对于id，Class，还有is a 指针，涉及到runtime的机制.</li>
<li><p>在类继承体系中查询类型信息<br>“isMemberOfClass”:能够判断出对象是否为某个特定类的实例。<br>“isKindOfClass”:能够判断出对象是否为某类或某派生类的实例。<br>通过使用isa指针获取对象所属的类，然后通过super_class指针在继承体系中游走。</p>
<pre><code>每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。
如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。
尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。
</code></pre></li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="isa-swizzling-的应用"><a href="#isa-swizzling-的应用" class="headerlink" title="isa swizzling 的应用"></a>isa swizzling 的应用</h3><h4 id="KVO的实现"><a href="#KVO的实现" class="headerlink" title="KVO的实现"></a>KVO的实现</h4><p>利用runtime动态产生一个类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术，详见<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">官方文档</a></p>
<p>据此，我们可以手动实现一个KVO。<a href="http://tech.glowing.com/cn/implement-kvo/" target="_blank" rel="noopener">http://tech.glowing.com/cn/implement-kvo/</a></p>
<p>Objective-C中的KVC和KVO<a href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/</a></p>
<h3 id="Method-Swizzling-应用"><a href="#Method-Swizzling-应用" class="headerlink" title="Method Swizzling 应用"></a>Method Swizzling 应用</h3><p>Objective-C 提供了以下 API 来动态替换类方法或实例方法的实现：<br>class_replaceMethod 替换类方法的定义<br><strong>method_exchangeImplementations 交换 2 个方法的实现</strong><br>method_setImplementation 设置 1 个方法的实现</p>
<p>使用 method swizlling 来修改原有的方法时, 就是在分类 load 中实现的.不在 initialize 方法中改变方法实现的原因是 initialize 可能会被子类所继承并重新执行最终导致无限递归, 而 load 并不会被继承.</p>
<h4 id="第13条：用method-swizzling调试黑盒方法"><a href="#第13条：用method-swizzling调试黑盒方法" class="headerlink" title="第13条：用method swizzling调试黑盒方法"></a>第13条：用method swizzling调试黑盒方法</h4><p>method swizzling：与给定的选择子名称相对应得方法也可以在运行期改变。（不需要源码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能）可用在本类的所有实例中。<strong>使用另一份实现来替换原有的方法实现</strong><br>IMP指针：id(*IMP)(id,SEL,….)类的方法列表会吧选择子的名称映射到相关方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示。<br>互换两个方法的实现：  </p>
<ol>
<li>互换两个已经写好方法实现：(两个参数为待交换的两个方法实现)<br><code>void method_exchangeImplementations(Method m1,Method m2)</code></li>
<li>获得方法实现：<br><code>Method class_getInstanceMethod(Class aClass,SEL aselector)</code></li>
</ol>
<p>用途：</p>
<pre><code>- 来为既有的方法添加新功能，新方法添加在NSString的一个“分类”中，在方法中实现所需的附加功能，并调用原有的实现。
- 为完全不知道其具体实现的黑盒方法增加日志记录，有助于程序调试。不宜乱用
</code></pre><h3 id="给分类添加属性"><a href="#给分类添加属性" class="headerlink" title="给分类添加属性"></a>给分类添加属性</h3><p><strong>Category实现的原理，同样解释了Category不能添加属性的原因</strong><br>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。也就是说可以动态修改*methodLists的值来添加成员方法，</p>
<p>最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的深入理解Objective-C：Category<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">http://tech.meituan.com/DiveIntoCategory.html</a>。</p>
<p>PS：<strong>任性的话可以在Category中添加@dynamic的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）</strong></p>
<p>因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。<strong>所以无法在运行时动态给对象增加成员变量</strong>。<br>相对的，对象的方法定义都保存在类的可变区域中。Objective-C 2.0 并未在头文件中将实现暴露出来，但在 Objective-C 1.0 中，我们可以看到方法的定义列表是一个名为 methodLists的指针的指针。通过修改该指针指向的指针的值，就可以实现动态地为某一个类增加成员方法。这也是Category实现的原理。<strong>同时也说明了为什么Category只可为对象增加成员方法，却不能增加成员变量。</strong><br>iOS 关联引用为分类添加属性:<br> 主要代码：（runtime.h）</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)  </span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure>
<h3 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h3><p>要将JSON转换为Model啦！<br>利用runtime遍历模型对象的所有属性，根据属性名从字典中取出对应的值，设置到模型的属性上。</p>
<h3 id="利用runtime遍历模型对象的所有属性来归档和解档"><a href="#利用runtime遍历模型对象的所有属性来归档和解档" class="headerlink" title="利用runtime遍历模型对象的所有属性来归档和解档"></a>利用runtime遍历模型对象的所有属性来归档和解档</h3><p> <img src="http://7xr8q7.com1.z0.glb.clouddn.com/runtime.png" alt><br> <img src="http://7xr8q7.com1.z0.glb.clouddn.com/rumtime%E5%BD%92%E6%A1%A3.png" alt><br> <img src="http://7xr8q7.com1.z0.glb.clouddn.com/runtime%E8%A7%A3%E6%A1%A3.png" alt>    </p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol start="3">
<li><p>讲讲Runtime，以及消息转发过程；</p>
</li>
<li><p>讲讲runtime，以及hook，以及如何进行方法交换；</p>
</li>
<li><p>详解runtime，OC为什么是动态的语言，内部机制；<br>在OC中，如果向某对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全在runtime决定，甚至可以在程序运行时改变，这些特性使得Objective-C成为一门真正的动态语言。</p>
</li>
<li><p>runtime 的运行机制？</p>
</li>
<li><p>KVO如何实现，内部机制；<br><a href="http://zhangbuhuai.com/understanding-kvo/" target="_blank" rel="noopener">http://zhangbuhuai.com/understanding-kvo/</a></p>
</li>
<li><p>kvo的底层实现？</p>
</li>
<li><p>如何去手动触发KVO，如何让KVO去监听一个方法；</p>
</li>
</ol>
<ol>
<li><p>[※※]objc中向一个nil对象发送消息将会发生什么？<br>在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用。</p>
</li>
<li><p>[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？</p>
</li>
</ol>
<blockquote>
<p>objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
</blockquote>
<ol start="3">
<li>[※※※]什么时候会报unrecognized selector的异常？<br>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：<br>见上图。</li>
</ol>
<ol start="4">
<li>[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）  </li>
</ol>
<ul>
<li>所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.</li>
<li>每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的对象方法列表成员变量的列表,属性列表。它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。</li>
<li>根对象就是NSObject，它的superclass指针指向nil。</li>
<li>类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。</li>
</ul>
<ol start="5">
<li><p>[※※※※]一个objc对象的isa的指针指向什么？有什么作用？</p>
<pre><code>isa是对象中的隐藏指针,指向创建这个对象的类。
对象会顺着内部的isa指针找到存储于类中的方法并执行。
</code></pre></li>
<li>[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）<br>selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</li>
<li><p>[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</p>
<blockquote>
<p>无论在MRC下还是ARC下均不需要。</p>
</blockquote>
</li>
<li><p>[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？</p>
</li>
<li><p>[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？</p>
<blockquote>
<p>_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
</blockquote>
</li>
</ol>
<p>首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。<br>_objc_msgForward在进行消息转发的过程中会涉及以下这几个方法：</p>
<p>resolveInstanceMethod:方法 (或 resolveClassMethod:)。<br>forwardingTargetForSelector:方法<br>methodSignatureForSelector:方法<br>forwardInvocation:方法<br>doesNotRecognizeSelector: 方法</p>
<p>直接调用调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>
<p>如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend：“我没有在这个对象里找到这个方法的实现”</p>
<p>哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。举例说明：</p>
<ul>
<li>JSPatch （Github 链接）就是直接调用_objc_msgForward来实现其核心功能的：JSPatch 以小巧的体积做到了让JS调用/替换任意OC方法，让iOS APP具备热更新的能力。<br>作者的博文《JSPatch实现原理详解》详细记录了实现原理，有兴趣可以看下。</li>
<li>RAC(ReactiveCocoa) 源码中也用到了该方法。</li>
</ul>
<ol start="10">
<li><p>[※※※※※]runtime如何实现weak变量的自动置nil？</p>
<blockquote>
<p>runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
</li>
<li><p>[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p>
</li>
</ol>
<ul>
<li>不能向编译后得到的类中增加实例变量;</li>
<li>能向运行时创建的类中添加实例变量;</li>
</ul>
<ol>
<li>下面的代码分别输出什么？</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Son</span> : <span class="title">Father</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">super</span> <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>答案：都输出”Son”<br>解释：objc中super是编译器标示符，并不像self一样是一个对象，遇到向super发的方法时会转译成<strong>objc_msgSendSuper(…)</strong>，而参数中的对象还是self，于是从父类开始沿继承链寻找 - class这个方法，最后在NSObject中找到（若无override），此时，[self class]和[super class]已经等价了。</p>
<p>参考：<br>Objective-C 消息发送与转发机制原理<br><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/</a></p>
<p>Objective-C Runtime 1小时入门教程：<br><a href="https://www.ianisme.com/ios/2019.html" target="_blank" rel="noopener">https://www.ianisme.com/ios/2019.html</a></p>
<p>Objective-C对象模型及应用<a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="noopener">http://blog.devtang.com/2013/10/15/objective-c-object-model/</a></p>
<p>Method Swizzling 和 AOP 实践<a href="http://tech.glowing.com/cn/method-swizzling-aop/" target="_blank" rel="noopener">http://tech.glowing.com/cn/method-swizzling-aop/</a></p>
<p>Method Swizzling<br><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="noopener">http://nshipster.com/method-swizzling/</a></p>
<p>手Runtime（附MJExtension的底层实现）<br><a href="http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://www.devstore.cn/essay/essayInfo/3270.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
<p>iOS面试题sunny<a href="http://blog.sunnyxx.com/2015/07/04/ios-interview/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2015/07/04/ios-interview/</a><br><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="noopener">答案</a></p>
<p>补充：苹果开源了runtime的实现，在网站<br><a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/</a><br>中可以找到各个版本的runtime源码。<br>但提供的是一个个文件，不方便打包下载，网站<br><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a>中提供了压缩包的下载。</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/07/05/Runtime/">Runtime</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年07月05日 - 16时22分</p>
        <p><span>最后更新:</span>2019年02月01日 - 10时28分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/07/05/Runtime/" title="Runtime">http://peilinghui.com/2016/07/05/Runtime/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/07/05/Runtime/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target="_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/07/10/消息处理之performSelector/">
                    消息处理之performSelector
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/07/02/TableView的一些事/">
                    TableView的一些事
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Objective-C的元素"><span class="toc-number">1.</span> <span class="toc-text">Objective-C的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-isa："><span class="toc-number">1.1.</span> <span class="toc-text">1. isa：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-super-class"><span class="toc-number">1.1.1.</span> <span class="toc-text">2. super_class:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-SEL"><span class="toc-number">1.1.2.</span> <span class="toc-text">3. SEL:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-IMP"><span class="toc-number">1.1.3.</span> <span class="toc-text">4. IMP:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Method："><span class="toc-number">1.1.4.</span> <span class="toc-text">5. Method：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Ivar"><span class="toc-number">1.1.5.</span> <span class="toc-text">6. Ivar:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Category"><span class="toc-number">1.1.6.</span> <span class="toc-text">7. Category :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-objc-property-t"><span class="toc-number">1.1.7.</span> <span class="toc-text">8. objc_property_t:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-Cache"><span class="toc-number">1.1.8.</span> <span class="toc-text">9. Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-Module"><span class="toc-number">1.1.9.</span> <span class="toc-text">10.Module</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Objective-C的消息传递"><span class="toc-number">2.</span> <span class="toc-text">Objective-C的消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#objc-msgSend的作用"><span class="toc-number">2.1.</span> <span class="toc-text">objc_msgSend的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第11条：理解objc-msgSend的作用"><span class="toc-number">2.1.1.</span> <span class="toc-text">第11条：理解objc_msgSend的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态方法解析和转发"><span class="toc-number">2.2.</span> <span class="toc-text">动态方法解析和转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第12条：消息转发机制"><span class="toc-number">2.2.1.</span> <span class="toc-text">第12条：消息转发机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第14条：理解“类对象”的用意"><span class="toc-number">2.2.2.</span> <span class="toc-text">第14条：理解“类对象”的用意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用"><span class="toc-number">3.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#isa-swizzling-的应用"><span class="toc-number">3.1.</span> <span class="toc-text">isa swizzling 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KVO的实现"><span class="toc-number">3.1.1.</span> <span class="toc-text">KVO的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Swizzling-应用"><span class="toc-number">3.2.</span> <span class="toc-text">Method Swizzling 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#第13条：用method-swizzling调试黑盒方法"><span class="toc-number">3.2.1.</span> <span class="toc-text">第13条：用method swizzling调试黑盒方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给分类添加属性"><span class="toc-number">3.3.</span> <span class="toc-text">给分类添加属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典转模型"><span class="toc-number">3.4.</span> <span class="toc-text">字典转模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用runtime遍历模型对象的所有属性来归档和解档"><span class="toc-number">3.5.</span> <span class="toc-text">利用runtime遍历模型对象的所有属性来归档和解档</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面试题"><span class="toc-number">4.</span> <span class="toc-text">面试题</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/07/05/Runtime/" data-title="Runtime" data-url="http://peilinghui.com/2016/07/05/Runtime/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/07/10/消息处理之performSelector/" title="上一篇: 消息处理之performSelector">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/07/02/TableView的一些事/" title="下一篇: TableView的一些事">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/20/Axios源码分析/">Axios源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/JavaScript面试题/">JavaScript面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/React新特性Hooks/">React新特性Hooks</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/09/RN第三方组件/">RN第三方组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/Redux中间件与异步/">Redux中间件与异步</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/19/TypeScript/">TypeScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/学习Node.js/">Node.js</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/22/RN性能优化总结/">RN性能优化总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/11/学习Dva/">学习Dva</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/关于RN的热更新/">关于RN的热更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/02/Mac获取ipa方法/">Mac获取ipa方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/学习iOS逆向/">学习iOS逆向</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/03/升级Xcode10遇到的问题/">升级Xcode10遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/RN与iOS的混合开发/">RN与iOS的混合开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/在APP中IM使用融云/">在APP中IM使用融云</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/独立开发一个APP/">独立开发一个APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/iOS底层实现/">iOS底层实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/Effective-JavaScript/">Effective JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/22/React知识/">React技术栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/ReactNative中使用Redux/">ReactNative中使用Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/React-Native的APP/">React-Native的APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/ReactNative的常用组件/">ReactNative的常用组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/iOS应用APP架构/">iOS应用APP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/iOS网络层的封装/">iOS网络层的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/项目重构遇到的问题/">项目重构遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/iOS中的图表Charts/">iOS中的图表Charts</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/移动应用的设计模式/">移动应用的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Jenkins搭建来实现自动化打包/">Jenkins搭建来实现自动化打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/05/AFNetworking3.0/">AFNetworking3.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/搜索框的Demo/">搜索框的Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/使用Mac本地服务器/">如何使用Mac本地服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/iOS打包和发布流程/">iOS打包和发布流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/iOS中JS与OC相互调用的方式/">iOS中JS与OC相互调用的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/NSURLProtocol/">NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/UIView的Frame和bounds区别/">UIView的Frame和bounds区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/21/React-Native的与原生的交互/">React-Native的与原生的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/React-Native的API和组件/">React-Native的API和组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/React-Native入门/">React Native入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/自动化测试/">自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/YYModel/">YYModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/Quartz2D的使用/">Quartz2D的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/KVC和KVO/">深入学习KVC和KVO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/RunLoop/">RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/消息处理之performSelector/">消息处理之performSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/Runtime/">Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/ARC内存管理/">ARC内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/NSString的引用计数问题/">NSString的引用计数问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/Effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/Block/">Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/剑指offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/Linux系统的学习/">Linux系统的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/SDWebImage框架/">SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的第三方框架/">iOS中的第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/AFNetworking2.0/">AFNetworking2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/CocosPods/">CocosPods</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机网络基础知识与安全/">计算机网络基础知识与安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/经典排序算法总结与实现/">经典排序算法总结与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		<span id="busuanzi_container_site_pv">
   		 本站总访问量<span id="busuanzi_value_site_pv"></span>次
		</span>
                <span id="busuanzi_value_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span>
                        
                    
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>