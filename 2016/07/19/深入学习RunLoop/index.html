<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>深入学习RunLoop | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。源码：https://opensource.apple.com/tarballs/CF/API">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习RunLoop">
<meta property="og:url" content="http://peilinghui.com/2016/07/19/深入学习RunLoop/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。源码：https://opensource.apple.com/tarballs/CF/API">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.15.58.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.37.07.png">
<meta property="og:updated_time" content="2017-03-23T12:26:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入学习RunLoop">
<meta name="twitter:description" content="深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。源码：https://opensource.apple.com/tarballs/CF/API">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/RAC-学习笔记/" style="font-size: 10px;">RAC,学习笔记</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS面试/" style="font-size: 13.33px;">iOS面试</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习笔记/" style="font-size: 13.33px;">学习笔记</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/面试/" style="font-size: 16.67px;">面试</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-深入学习RunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/19/深入学习RunLoop/" class="article-date">
      <time datetime="2016-07-19T14:45:17.000Z" itemprop="datePublished">2016-07-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入学习RunLoop
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>深入学习RunLoop。看CFRunLoop.h和CFRunLoop.c。<br>源码：<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">https://opensource.apple.com/tarballs/CF/</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="external">API</a><br><a id="more"></a></p>
<h1 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h1><p>其实，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。  </p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br><strong>CFRunLoopRef</strong> 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是<strong>线程安全</strong>的。<br><strong>NSRunLoop</strong> 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API <strong>不是线程安全</strong>的。它的方法只应在当前线程的上下文中被调用。您不应该尝试调用NSRun​Loop在不同线程中运行的对象的方法，因为这样做可能会导致意外的结果。一个NSRun​Loop对象处理用于来源如从窗口系统鼠标和键盘事件，输入NSPort对象，和NSConnection对象。一个NSRun​Loop对象也处理NSTimer事件。  </p>
<p><strong>基本作用</strong></p>
<ul>
<li>保持程序的持续运行(比如主运行循环)</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件、Selector事件）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
<h1 id="RunLoop的工作模式"><a href="#RunLoop的工作模式" class="headerlink" title="RunLoop的工作模式"></a>RunLoop的工作模式</h1><p>Run loop接收输入事件来自两种不同的来源：输入源（input source）和定时源（timer source）。两种源都使用程序的某一特定的处理例程来处理到达的事件。<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.15.58.png" alt=""></p>
<h2 id="RunLoop-内部结构"><a href="#RunLoop-内部结构" class="headerlink" title="RunLoop 内部结构"></a>RunLoop 内部结构</h2><p>CFRunloop.h文件中</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CFRunloop.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CFStringRef</span> <span class="built_in">CFRunLoopMode</span> <span class="built_in">CF_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __<span class="built_in">CFRunLoop</span> * <span class="built_in">CFRunLoopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __<span class="built_in">CFRunLoopSource</span> * <span class="built_in">CFRunLoopSourceRef</span>;<span class="comment">//是事件产生的地方</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="keyword">id</span>) __<span class="built_in">CFRunLoopObserver</span> * <span class="built_in">CFRunLoopObserverRef</span>;<span class="comment">//观察者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CF_BRIDGED_MUTABLE_TYPE</span>(<span class="built_in">NSTimer</span>) __<span class="built_in">CFRunLoopTimer</span> * <span class="built_in">CFRunLoopTimerRef</span>;<span class="comment">//基于时间的触发器</span></span><br><span class="line"><span class="comment">//  CFRunLoop.c</span></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>RunLoop 与线程的关系</strong>  </p>
<ol>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>主线程的RunLoop已经自动启动的，子线程的RunLoop需要主动创建。</li>
<li>RunLoop在第一次获取时创建，在线程结束时销毁</li>
</ol>
<p>iOS的应用程序里面，程序启动后会有一个如下的main（）函数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  main（<span class="keyword">int</span> argc，<span class="keyword">char</span> * argv []）&#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">UIApplicationMain</span>（argc，argv，<span class="literal">nil</span>，<span class="built_in">NSStringFromClass</span>（[AppDelegate class ]））;</span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>重点是UIApplicationMain（）函数，这个方法会为主线程设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候还能立马响应。  </p>
<ol>
<li>在任何一个Cocoa程序的线程中，都可以通过以下代码来获取到当前线程的运行循环。</li>
</ol>
<p><code>NSRunLoop * runloop = [NSRunLoop  currentRunLoop];</code></p>
<p>关系；<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-18%20%E4%B8%8B%E5%8D%883.37.07.png" alt=""></p>
<ul>
<li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。</li>
<li>每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。</li>
<li>如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。</li>
<li>这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</li>
</ul>
<h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h3><p>系统默认注册了5个Mode:(前两个跟最后一个常用)</p>
<ul>
<li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode。<br>在CFRunLoop.h中暴露的是：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> k<span class="built_in">CFRunLoopDefaultMode</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">CFRunLoopMode</span> k<span class="built_in">CFRunLoopCommonModes</span>;</span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopRef"><a href="#CFRunLoopRef" class="headerlink" title="CFRunLoopRef"></a>CFRunLoopRef</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>);<span class="comment">//获取当前线程</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>);<span class="comment">//获取主线程</span></span><br></pre></td></tr></table></figure>
<h3 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h3><p>CFRunLoopSourceRef是事件源（输入源）</p>
<p><strong>按照官方文档的分类</strong></p>
<ul>
<li>Port-Based Sources，系统底层的 Port 事件，例如 CFSocketRef ，在应用层基本用不到</li>
<li>Custom Input Sources，用户手动创建的 Source</li>
<li>Cocoa Perform Selector Sources， Cocoa 提供的 performSelector 系列方法，也是一种事件源  </li>
</ul>
<p><strong>按照函数调用栈的分类</strong><br>源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。</p>
<ul>
<li>Source0：非基于Port的。 app 内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1：基于Port的。包含了一个 mach_port 和一个回调，被用于通过内核和其他线程相互发送消息,能主动唤醒 RunLoop 的线程。</li>
</ul>
<h3 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h3><p>CFRunLoopTimerRef是基于时间的触发器,在 iOS 用到的 NSTimer 或者 performSelector:afterDelay: 都是通过它来实现的。使用时先设置一个时间长度和一个回调，然后将其加入 RunLoop，这样 RunLoop 就会注册对应的时间点，当到了该时间点时就会唤醒 RunLoop 来执行那个回调。iOS7 之后，timer 还可有一个 tolerance，因为 timer 不太准确，如上面提到的，某个 mode 下的 timer 在 RunLoop 切换 mode 时可能就失效了，而 tolerance 则用来计算最后能执行那个回调的时间点。</p>
<p>基本上说的就是NSTimer(CADisplayLink也是加到RunLoop),它受RunLoop的Mode影响</p>
<p>GCD的定时器不受RunLoop的Mode影响</p>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><p>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</p>
<p>可以监听的时间点有以下几个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),		<span class="comment">//即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">//即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">//即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">//刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),       <span class="comment">//即将推出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以使用 CFRunLoopObserverCreateWithHandler() 来创建 observer，创建时设置要监听的状态变化和回调，再用 CFRunLoopAddObserver() 来给 RunLoop 添加 observer，当该 RunLoop 状态发生在监听类型内的变化时，observer 就会执行回调 ：</p>
<!--## 定时源
![](http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-10%20%E4%B8%8B%E5%8D%883.35.47.png)

RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。


-->
<h1 id="运行逻辑"><a href="#运行逻辑" class="headerlink" title="运行逻辑"></a>运行逻辑</h1><h2 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h2><p>苹果不允许我们创建 RunLoop，要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数，获取过程大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> __<span class="built_in">CFRunLoops</span> = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet0</span>(pthread_t t) &#123;</span><br><span class="line">    <span class="comment">// 第一次进入时，创建全局 dictionary</span></span><br><span class="line">    <span class="keyword">if</span> (!__<span class="built_in">CFRunLoops</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建可变字典</span></span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> dict = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="comment">// 先创建主线程的 RunLoop</span></span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = __<span class="built_in">CFRunLoopCreate</span>(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">// 主线程的 RunLoop 存进字典中</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(dict, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 传进来的线程 作 key，获取对应的 RunLoop</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(__<span class="built_in">CFRunLoops</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果获取不到，则新建一个，并存入字典</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __<span class="built_in">CFRunLoopCreate</span>(t);</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(__<span class="built_in">CFRunLoops</span>, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取主线程的 RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _<span class="built_in">CFRunLoopGet0</span>(pthread_main_thread_np());</span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前线程的 RunLoop</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet0</span>(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，线程和 RunLoop 是一一对应的，对应关系保存在一个全局的 dictionary 中。RunLoop 类似懒加载，只有在第一次获取的时候才会创建。当线程销毁时，也销毁对应的 RunLoop。</p>
<h2 id="RunLoop的运行"><a href="#RunLoop的运行" class="headerlink" title="RunLoop的运行"></a>RunLoop的运行</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 用 <span class="type">DefaultMode</span> 启动(<span class="keyword">do</span>-<span class="keyword">while</span>循环)</span><br><span class="line"><span class="type">void</span> <span class="type">CFRunLoopRun</span>(<span class="type">void</span>) &#123;	/* <span class="type">DOES</span> <span class="type">CALLOUT</span> */</span><br><span class="line">    int32_t <span class="literal">result</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="literal">result</span> = <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1</span>.<span class="number">0</span>e10, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != <span class="literal">result</span> &amp;&amp; kCFRunLoopRunFinished != <span class="literal">result</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用指定的 mode 启动</span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunInMode</span>(<span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     /* <span class="type">DOES</span> <span class="type">CALLOUT</span> */</span><br><span class="line">    <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// <span class="type">RunLoop</span> 的实现</span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;    </span><br><span class="line">    // 根据 modeName 找到对应的 mode</span><br><span class="line">    <span class="type">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    // 判断 mode 是否为空 (即 source/timer 皆空)，是的话则返回</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 通知 observers: 即将进入 loop</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    // 进入 loop</span><br><span class="line">    <span class="literal">result</span> = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    // 通知 observers： 即将退出</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入 RunLoop 后</span></span><br><span class="line"><span class="keyword">static</span> int32_t __<span class="built_in">CFRunLoopRun</span>() &#123;</span><br><span class="line">    <span class="comment">// 设置 timer</span></span><br><span class="line">    dispatch_source_t timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置过期时间</span></span><br><span class="line">    seconds = <span class="number">9999999999.0</span>;</span><br><span class="line"></span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始 loop</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉 observer：要处理 timer</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeTimers</span>);</span><br><span class="line">	   <span class="comment">// 告诉 observer：要处理 sources</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeSources</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行被加入的 block</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理 Sources0（非 port）</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __<span class="built_in">CFRunLoopDoSources0</span>(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!didDispatchPortLastTime) &#123;</span><br><span class="line">            <span class="comment">// 如果有 GCD 分发到 main queue 的 block</span></span><br><span class="line">            <span class="keyword">if</span> (__<span class="built_in">CFRunLoopServiceMachPort</span>(dispatchPort, &amp;msg)) &#123;</span><br><span class="line">                <span class="comment">// 跳过睡眠阶段，直接去处理消息</span></span><br><span class="line">                <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知 observers：即将进入睡眠</span></span><br><span class="line">        <span class="keyword">if</span> () __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopBeforeWaiting</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 mach_msg 等待接受 mach_port 的消息，线程将进入睡眠</span></span><br><span class="line">        __<span class="built_in">CFRunLoopServiceMachPort</span>(waitSet, &amp;msg, ...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 observers：刚被唤醒</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoObservers</span>(rl, rlm, k<span class="built_in">CFRunLoopAfterWaiting</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理消息的标记</span></span><br><span class="line">    handle_msg:;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过判断端口，找出要处理的事件</span></span><br><span class="line">        <span class="keyword">if</span> (MACH_PORT_NULL == livePort) &#123;</span><br><span class="line">            <span class="comment">// 纯粹是被手动唤醒的，无消息，则不做任何处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == rlm-&gt;_timerPort) &#123;</span><br><span class="line">		  <span class="comment">// 被 timer 唤醒,则触发这个 timer 的回调</span></span><br><span class="line">            __<span class="built_in">CFRunLoopDoTimers</span>(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">		  <span class="comment">// 被 GCD 唤醒,则执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">            __<span class="built_in">CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 如果被 source1（基于 port） 唤醒的，则处理这个事件</span></span><br><span class="line">           __<span class="built_in">CFRunLoopDoSource1</span>(rl, rlm, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">           <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">               mach_msg(reply, MACH_SEND_MSG);</span><br><span class="line">           &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行加入到 loop 的 block</span></span><br><span class="line">        __<span class="built_in">CFRunLoopDoBlocks</span>(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否应该退出 loop</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            <span class="comment">// 传入的参数是否说明应该在处理完事件就返回</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunHandledSource</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">// 是否过期</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunTimedOut</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopIsStopped</span>(rl)) &#123;</span><br><span class="line">            <span class="comment">// 是否被强制停止</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunStopped</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(rl, rlm)) &#123;</span><br><span class="line">            <span class="comment">// mode 是否为空，即 source、timer 为空</span></span><br><span class="line">            retVal = k<span class="built_in">CFRunLoopRunFinished</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 都不是，则继续 loop</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而判断 mode 的逻辑大致如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__CFRunLoopModeIsEmpty() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> != rlm<span class="subst">-&gt;</span>_sources0 <span class="subst">&amp;&amp;</span> <span class="number">0</span> &lt; CFSetGetCount(rlm<span class="subst">-&gt;</span>_sources0)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> != rlm<span class="subst">-&gt;</span>_sources1 <span class="subst">&amp;&amp;</span> <span class="number">0</span> &lt; CFSetGetCount(rlm<span class="subst">-&gt;</span>_sources1)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NULL</span> != rlm<span class="subst">-&gt;</span>_timers <span class="subst">&amp;&amp;</span> <span class="number">0</span> &lt; CFArrayGetCount(rlm<span class="subst">-&gt;</span>_timers)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="AutoreleasePool（自动释放池）"><a href="#AutoreleasePool（自动释放池）" class="headerlink" title="AutoreleasePool（自动释放池）"></a>AutoreleasePool（自动释放池）</h2><p>一般我们比较关心的是自动释放池什么时候会释放？<br>在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">CFRunLoopObserver</span>&gt;</span>&#123;activities = 0x1, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; </span><br><span class="line"><span class="tag">&lt;<span class="title">CFRunLoopObserver</span>&gt;</span>&#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br></pre></td></tr></table></figure>
<p>即 app 启动后，苹果会给 RunLoop 注册很多个 observers，其中有两个是跟自动释放池相关的，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code><br>第一个 observer 监听的是 activities = 0x1（kCFRunLoopEntry），也就是在即将进入 loop 时，其回调会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池；<br>第二个 observer 监听的是 <code>activities = 0xa0（kCFRunLoopBeforeWaiting | kCFRunLoopExit）</code>，即监听的是准备进入睡眠和即将退出 loop 两个事件。在准备进入睡眠之前，因为睡眠可能时间很长，所以为了不占用资源先调用 <code>_objc_autoreleasePoolPop()</code>释放旧的释放池，并调用 <code>_objc_autoreleasePoolPush()</code> 创建新建一个新的，用来装载被唤醒后要处理的事件对象；在最后即将退出 loop 时则会 <code>_objc_autoreleasePoolPop()</code> 释放池子。</p>
<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括<strong>识别 UIGesture/处理屏幕旋转/发送给 UIWindow</strong> 等。通常事件比如 <strong>UIButton 点击</strong>、<strong>touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的</strong>。</p>
<h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>NSTimer 其实就是 CFRunLoopTimerRef。<br>解决界面卡顿</p>
<h2 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h2><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h2 id="RunLoop-与-GCD"><a href="#RunLoop-与-GCD" class="headerlink" title="RunLoop 与 GCD"></a>RunLoop 与 GCD</h2><p>RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。 例如 dispatch_async()。<br>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h2 id="UIImageView-延迟加载图片"><a href="#UIImageView-延迟加载图片" class="headerlink" title="UIImageView 延迟加载图片"></a>UIImageView 延迟加载图片</h2><p>给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。</p>
<h2 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h2><p>子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。具体做法是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 返回一个线程 */</span></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        <span class="comment">// 创建一个线程，并在该线程上执行下一个方法</span></span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                                                        selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:)</span><br><span class="line">                                                          object:<span class="literal">nil</span>];</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在新开的线程中执行的第一个方法 */</span></span><br><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"AFNetworking"</span>];</span><br><span class="line">        <span class="comment">// 获取当前线程对应的 RunLoop</span></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">// 为 RunLoop 添加 source，模式为 DefaultMode</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 开始运行 RunLoop</span></span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，</p>
<h1 id="与-Runloop-相关的坑"><a href="#与-Runloop-相关的坑" class="headerlink" title="与 Runloop 相关的坑"></a>与 Runloop 相关的坑</h1><p>日常开发中，与 runLoop 接触得最近可能就是通过 NSTimer 了。一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行。</p>
<p>有如下两种解决方案：</p>
<p>第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。<br>第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。<br>在 AFNetworking 3.0 中，就有相关的代码，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startActivationDelayTimer &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.activationDelayTimer</span> = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span><span class="variable">.activationDelay</span> target:<span class="keyword">self</span></span><br><span class="line">       selector:<span class="keyword">@selector</span>(activationDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span><span class="variable">.activationDelayTimer</span> forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是添加了一个计时器，由于指定了 NSRunLoopCommonModes，所以不管 RunLoop 出于什么状态，都执行这个计时器任务。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol>
<li>[※※※]runloop和线程有什么关系？</li>
<li>[※※※]runloop的mode作用是什么？<br>model主要是用来指定事件在运行循环中的优先级的，分为：</li>
</ol>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态  </li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）：模式集合</li>
</ul>
<p>苹果公开提供的模式有两个：</p>
<ul>
<li>NSDefaultRunLoopMode（kCFRunLoopDefaultMode）</li>
<li>NSRunLoopCommonModes（kCFRunLoopCommonModes）</li>
</ul>
<ol>
<li>[※※※※]以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</li>
</ol>
<ol>
<li><p>[※※※※※]猜想runloop内部是如何实现的？</p>
</li>
<li><p>如何刷新View界面？</p>
</li>
<li><p>线程和RunLoop的关系</p>
</li>
<li><p>NSTimer有什么需注意的以及和RunLoop的关系？</p>
</li>
<li>主线程runloop(mainRunloop)主要执行事件：<br>负责创建Autoreleasepool和释放autoreleasepool,  周期大概是event loop(事件循环)；<br>事件响应—&gt;当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</li>
</ol>
<p>手势识别—&gt;当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>界面更新—&gt;当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<ol>
<li><p>NSTimer事件</p>
</li>
<li><p>PerformSelecter—&gt;performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去</p>
</li>
</ol>
<p>参考：<br>iOS RunLoop进阶:<a href="http://www.jianshu.com/p/2c067bdc7e47#" target="_blank" rel="external">http://www.jianshu.com/p/2c067bdc7e47#</a><br>解密-神秘的RunLoop：<a href="http://www.jianshu.com/p/cf4915508929" target="_blank" rel="external">http://www.jianshu.com/p/cf4915508929</a><br><a href="http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">http://sunshineyg888.github.io/2016/05/21/RunLoop-%E8%AF%A6%E8%A7%A3/</a><br>RunLoop源码观察:<a href="http://tutudev.com/2016/06/28/runloop/" target="_blank" rel="external">http://tutudev.com/2016/06/28/runloop/</a></p>
<p>深入理解RunLoop<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">http://blog.ibireme.com/2015/05/18/runloop/</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/07/19/深入学习RunLoop/">深入学习RunLoop</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年07月19日 - 22时45分</p>
        <p><span>最后更新:</span>2017年03月23日 - 20时26分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/07/19/深入学习RunLoop/" title="深入学习RunLoop">http://peilinghui.com/2016/07/19/深入学习RunLoop/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/07/19/深入学习RunLoop/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/08/20/深入学习KVC和KVO/">
                    深入学习KVC和KVO
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/07/10/消息处理之performSelector/">
                    消息处理之performSelector
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop-的概念"><span class="toc-number">1.</span> <span class="toc-text">RunLoop 的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RunLoop的工作模式"><span class="toc-number">2.</span> <span class="toc-text">RunLoop的工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-内部结构"><span class="toc-number">2.1.</span> <span class="toc-text">RunLoop 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopMode"><span class="toc-number">2.1.1.</span> <span class="toc-text">CFRunLoopMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopRef"><span class="toc-number">2.1.2.</span> <span class="toc-text">CFRunLoopRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopSourceRef"><span class="toc-number">2.1.3.</span> <span class="toc-text">CFRunLoopSourceRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopTimerRef"><span class="toc-number">2.1.4.</span> <span class="toc-text">CFRunLoopTimerRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFRunLoopObserverRef"><span class="toc-number">2.1.5.</span> <span class="toc-text">CFRunLoopObserverRef</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#运行逻辑"><span class="toc-number">3.</span> <span class="toc-text">运行逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取RunLoop"><span class="toc-number">3.1.</span> <span class="toc-text">获取RunLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop的运行"><span class="toc-number">3.2.</span> <span class="toc-text">RunLoop的运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#应用"><span class="toc-number">4.</span> <span class="toc-text">应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AutoreleasePool（自动释放池）"><span class="toc-number">4.1.</span> <span class="toc-text">AutoreleasePool（自动释放池）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事件响应"><span class="toc-number">4.2.</span> <span class="toc-text">事件响应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#手势识别"><span class="toc-number">4.3.</span> <span class="toc-text">手势识别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#界面更新"><span class="toc-number">4.4.</span> <span class="toc-text">界面更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时器"><span class="toc-number">4.5.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PerformSelecter"><span class="toc-number">4.6.</span> <span class="toc-text">PerformSelecter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RunLoop-与-GCD"><span class="toc-number">4.7.</span> <span class="toc-text">RunLoop 与 GCD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIImageView-延迟加载图片"><span class="toc-number">4.8.</span> <span class="toc-text">UIImageView 延迟加载图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AFNetworking"><span class="toc-number">4.9.</span> <span class="toc-text">AFNetworking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncDisplayKit"><span class="toc-number">4.10.</span> <span class="toc-text">AsyncDisplayKit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#与-Runloop-相关的坑"><span class="toc-number">5.</span> <span class="toc-text">与 Runloop 相关的坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题"><span class="toc-number">6.</span> <span class="toc-text">面试题</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/07/19/深入学习RunLoop/" data-title="深入学习RunLoop" data-url="http://peilinghui.com/2016/07/19/深入学习RunLoop/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/08/20/深入学习KVC和KVO/" title="上一篇: 深入学习KVC和KVO">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/07/10/消息处理之performSelector/" title="下一篇: 消息处理之performSelector">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/iOS应用APP架构/">iOS应用APP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/iOS网络层的封装/">iOS网络层的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/项目重构遇到的问题/">项目重构遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/iOS中的图表Charts/">iOS中的图表Charts</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/移动应用的设计模式/">移动应用的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Jenkins搭建来实现自动化打包/">Jenkins搭建来实现自动化打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/做一个搜索框的Demo/">做一个搜索框的Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/如何使用Mac本地服务器/">如何使用Mac本地服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/iOS打包和发布流程/">iOS打包和发布流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/学习iOS中JS与OC相互调用的方式/">学习iOS中JS与OC相互调用的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/深入学习NSURLProtocol/">深入学习NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/UIView的Frame和bounds区别/">UIView的Frame和bounds区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/学习React-Native的API和组件/">学习React-Native的API和组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/学习React-Native入门/">学习React Native入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/自动化测试/">自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/研究框架YYModel/">研究框架YYModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/深入学习GCD/">深入学习GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/深入学习KVC和KVO/">深入学习KVC和KVO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/深入学习RunLoop/">深入学习RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/消息处理之performSelector/">消息处理之performSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习Runtime/">深入学习Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转 </a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/深入学习内存管理/">深入学习内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/关于NSString的引用计数问题/">关于NSString的引用计数问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/深入学习Block/">深入学习Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/设计模式解析/">设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的第三方框架/">iOS中的第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/关于深拷贝和浅拷贝/">关于深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机网络基础知识与安全/">计算机网络基础知识与安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/经典排序算法总结与实现/">经典排序算法总结与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>