<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>计算机基础知识总结 | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础知识总结">
<meta property="og:url" content="http://peilinghui.com/2016/03/01/计算机基础知识/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-04%20%E4%B8%8B%E5%8D%883.00.16.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B7%A7%E4%BA%A4%E6%8D%A2.png">
<meta property="og:updated_time" content="2017-04-25T08:40:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机基础知识总结">
<meta name="twitter:description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/RAC-学习笔记/" style="font-size: 10px;">RAC,学习笔记</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS面试/" style="font-size: 13.33px;">iOS面试</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习笔记/" style="font-size: 13.33px;">学习笔记</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/面试/" style="font-size: 16.67px;">面试</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-计算机基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/计算机基础知识/" class="article-date">
      <time datetime="2016-03-01T08:57:25.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      计算机基础知识总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/面试/">面试</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>总结算法和数据结构，还有计算机网络，操作系统的知识。</p>
<a id="more"></a>
<h1 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h1><p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png" alt=""></p>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg" alt=""> </p>
<p>堆区：分配方式类似链表。C语言中由malloc分配，free释放，C++中由new分配，delete释放。<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>牛客网的编程题</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）"><a href="#每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）" class="headerlink" title="每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）"></a>每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）</h3><p>思想：首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。不断缩小范围，直到找到要查找的数字。否则不存在。</p>
<h3 id="递增排序数组的旋转数组求最小值（剑指offer第8题）"><a href="#递增排序数组的旋转数组求最小值（剑指offer第8题）" class="headerlink" title="递增排序数组的旋转数组求最小值（剑指offer第8题）"></a>递增排序数组的旋转数组求最小值（剑指offer第8题）</h3><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Description</a><br>思想：二分查找。<br>旋转后的数组实际上可以划分为两个排序数组，最小的元素是这俩个子数组的分界线。<br>两个指针，一个指向第一个元素，一个指向最后一个元素，找到中间元素。<br>如果中间元素比第一个大，则到后一段中找；<br>如果中间元素比最后一个小，则到前一段中找。不断缩小，直到两个指针相邻，第二个指针所指向的就是最小的值，循环结束。<br>特例：1）前面0个元素移到后面，即排序数组本身。（）<br>        2）{1，0，1，1，1}和数组{1，1，1，0，1}是递增数组{0，1，1，1，1}的旋转，只能采取顺序查找的方法。</p>
<h3 id="旋转数组求查找某个值是否存在"><a href="#旋转数组求查找某个值是否存在" class="headerlink" title="旋转数组求查找某个值是否存在"></a>旋转数组求查找某个值是否存在</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description</a><br>思想：同上：二分法</p>
<h3 id="数组中出现次数超过一半的数字（剑指offer第29题）"><a href="#数组中出现次数超过一半的数字（剑指offer第29题）" class="headerlink" title="数组中出现次数超过一半的数字（剑指offer第29题）"></a>数组中出现次数超过一半的数字（剑指offer第29题）</h3><p>解法一：快速排序。O(n)<br>解法二：这个数字出现的次数比其他所有数字出现的次数的和还要多。遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果不同，则次数减1。如果次数为0，则保存在一个数字，并把次数设为1，要找的数字肯定是最后一次把次数设为1的对应的数字。</p>
<h3 id="最小的k个数-最大的K个数"><a href="#最小的k个数-最大的K个数" class="headerlink" title="最小的k个数(最大的K个数)"></a>最小的k个数(最大的K个数)</h3><p>思想：解法一：快速排序，基于数组的第K个数字来调整，使得比第K个数字小的所有数字都位于数组的左边，比第K个数字大的所有数字都位于数组的右边。左边的K个数字为最小的K个数字。时间复杂度O(n).<br>此方法的限制：要一次性读入所有数，而且修改输入的数组。<br>解法二：堆排序。适合处理海量数据。<br>首先我们读入K个数创建一个大小为K的大根堆，然后我们依次读入剩余数据，如果当前数据比大根堆的堆顶小，则用这个数替换当前的堆顶，并调整堆使其保持大根堆的性质。如果当前数据比大根堆的堆顶大，则不可能是最小的K个整数之一。时间复杂度：O(nlogk)<br><strong>注意：当求最小的K个数的时候是建立大根堆，当求最大的K个数的时候是建立小根堆。</strong><br>或者：红黑树，STL中的set和multiset。</p>
<p>【扩展】<br>第 k 大的数<br><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/kth-largest-element-in-an-array/?tab=Description</a></p>
<h3 id="有序数组中某个数字出现的次数（二分查找）"><a href="#有序数组中某个数字出现的次数（二分查找）" class="headerlink" title="有序数组中某个数字出现的次数（二分查找）"></a>有序数组中某个数字出现的次数（二分查找）</h3><p>由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置。</p>
<ol>
<li>先二分找到第一个k下标first，再二分找到最后一个k下标last，</li>
<li>last-first+1即为所求。</li>
<li>复杂度，O(lgN) + O(lgN) = O(lgN)<br>复杂度：时间：O(lgN)；空间O(1)</li>
</ol>
<h3 id="求两个等长、有序数组的中位数（二分法）"><a href="#求两个等长、有序数组的中位数（二分法）" class="headerlink" title="求两个等长、有序数组的中位数（二分法）"></a>求两个等长、有序数组的中位数（二分法）</h3><p>就是比较两个区间的中位数，如果第一个区间的中位数比第二个大，那么就把第一个区间的范围缩小至它的前半段，把第二个区间缩小至它的后半段，然后重复上述过程。<br>算法复杂度(O(lgn))。</p>
<pre><code>设置a[0..n-1]的中位数是 m1，b[0..n-1]的中位数为 m2
如果 m1=m2，则 m1 则为 2n 个数的中位数
如果 m1&gt;m2，则 2n 个数的中位数一定在 a[0..2/n]和 b[n/2..n]，在求这两个子数组的中位数 
如果 m1&lt;m2，则 2n 个数的中位数一定在 a[n/2..n]和 b[0..2/n]，在求这两个子数组的中位数。
</code></pre><h3 id="求两个不等长、有序数组的中位数"><a href="#求两个不等长、有序数组的中位数" class="headerlink" title="求两个不等长、有序数组的中位数"></a>求两个不等长、有序数组的中位数</h3><p>解法：<a href="http://blog.csdn.net/ojshilu/article/details/15027309" target="_blank" rel="external">http://blog.csdn.net/ojshilu/article/details/15027309</a></p>
<h3 id="调整数组顺序是奇数位于偶数前面"><a href="#调整数组顺序是奇数位于偶数前面" class="headerlink" title="调整数组顺序是奇数位于偶数前面"></a>调整数组顺序是奇数位于偶数前面</h3><p>思路:解法一：扫描这个数组，如果发现有偶数出现在奇数的前面，我们可以交换它们的顺序。维护两个指针，第一个指针在数组的一个数字，向后移动，第二个指针在数组的最后一个数值，向前移动。<br>解法二：把整个函数解耦成两部分：一判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作。</p>
<h3 id="和为S的两个数字VS和为S的连续正数序列（41）"><a href="#和为S的两个数字VS和为S的连续正数序列（41）" class="headerlink" title="和为S的两个数字VS和为S的连续正数序列（41）"></a>和为S的两个数字VS和为S的连续正数序列（41）</h3><p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字，输出一对序列。<br>思路:定义两个指针，一个指向第一个元素，第二个指针指向最后一个元素，看这两个数字的和&gt;S，则大数–；如果和&lt;S，则小数++；</p>
<h3 id="判断数组中是否有重复值，空间复杂度O-n"><a href="#判断数组中是否有重复值，空间复杂度O-n" class="headerlink" title="判断数组中是否有重复值，空间复杂度O(n)"></a>判断数组中是否有重复值，空间复杂度O(n)</h3><p>没有空间复杂度的限制用哈希表<br>有的话先排序再判断，用非递归的堆排序。</p>
<h3 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h3><p>只包含0，1，2的整数数组进行排序，使用交换、原地排序。<br> 与快排的划分类似。时间O(N),空间O(1),<br> {} 1 1 0 0 2 1 1 0 {}</p>
<p>前面为0区，后面为2区，若是1，向后移指针，若是0与前交换，放入0区，若是2与后交换，放入2区。当前位置和2区重合的时候，停止。</p>
<h3 id="需要排序的最短子数组的长度"><a href="#需要排序的最短子数组的长度" class="headerlink" title="需要排序的最短子数组的长度"></a>需要排序的最短子数组的长度</h3><h3 id="排序后相邻两数的最大差值"><a href="#排序后相邻两数的最大差值" class="headerlink" title="排序后相邻两数的最大差值"></a>排序后相邻两数的最大差值</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串转换为数字（49）"><a href="#字符串转换为数字（49）" class="headerlink" title="字符串转换为数字（49）"></a>字符串转换为数字（49）</h3><p>思想：依次扫描字符串，每扫描到一个字符，我们把在之前得到的数字乘以10在加上当前字符表示的数字。<br>遇到“+”号向前走，遇到“-”号，表明这个数是负数。<br>考虑非法输入：需要判断这个指针是不是为空。<br>输入的字符串可能含有不是数字的字符，每当碰到非法的字符，转换停止。<br>溢出问题，若溢出，则返回0.</p>
<h3 id="翻转字符串-42"><a href="#翻转字符串-42" class="headerlink" title="翻转字符串(42)"></a>翻转字符串(42)</h3><p>思想：第一步翻转句子中所有的字符。第二步再翻转每个单词中字符的顺序。</p>
<p>【扩展】左旋转字符串<br>翻转字符串前面N个字符，再翻转字符串后面的部分，最后翻转整个字符串。</p>
<h3 id="替换空格-4"><a href="#替换空格-4" class="headerlink" title="替换空格(4)"></a>替换空格(4)</h3><p>思想：先遍历一次字符串，统计出空格的总数，计算出替换以后的字符串的总长度，每替换一个空格，长度增加2.<br>从字符串后面开始复制和替换。先准备两个指针P1和P2，P1指向原始字符串的末尾，P2指向替换之后的字符串的末尾，<br>向前移动P1，逐个把它指向的字符串复制到P2所指向的位置，直到碰到第一个空格的时候，把P1向前移动一个，P2向前移动3格并插入“%20”。继续往前走，直到P1和P2指向同一个位置。<br>时间复杂度：O(n)</p>
<h3 id="字符串包含（KMP算法）"><a href="#字符串包含（KMP算法）" class="headerlink" title="字符串包含（KMP算法）"></a>字符串包含（KMP算法）</h3><p>在给定字符串A中查找一个子字符串B。<br>KMP算法：利用不匹配字符的前面那一段字符的最长前后缀来尽可能地跳过最大的距离。</p>
<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p>输入一个字符串，打印出字符串的所有排列<br>输入：abc，输出：acb,bac,cab,cba.<br>思想：首先求所有可能出现在第一个位置的字符。把第一个字符和后面的所有字符交换。<br>第二步固定一个字符，求后面所有字符的排列。<br>输入：abc,输出：a,b,c,ab,ac,bc,abc.</p>
<p>【扩展】求字符的所有组合</p>
<h3 id="第一个只出现一个的字符（35）"><a href="#第一个只出现一个的字符（35）" class="headerlink" title="第一个只出现一个的字符（35）"></a>第一个只出现一个的字符（35）</h3><p>利用哈希表，哈希表的Key是字符，value是该字符出现的次数。<br>从头开始扫描字符串两次，第一次扫描字符串的时候，每扫描到一个字符串就在哈希表的对应项中把次数加1，第二次扫描的时候就能从哈希表中得到该字符串出现的次数。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>单链表</strong> </p>
<ol>
<li>定义</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"></span><span class="title">&#123;</span><br><span class="line">    int</span> data;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"></span><span class="title">* next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>头插法建立单链表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从表尾到表头逆向建立单链表，每次均在头结点之后插入元素</span></span><br><span class="line">    LNode *s;<span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next= <span class="literal">NULL</span>;<span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>) &#123;<span class="comment">//创建新结点</span></span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125; </span><br><span class="line">时间复杂度：O(n)</span><br></pre></td></tr></table></figure>
<ol>
<li>尾插法建立单链表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从表尾到表头逆向建立单链表，每次均在头结点之后插入元素</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>) &#123;<span class="comment">//创建新结点</span></span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;<span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NUll;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>按序号查找表结点值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span>)<span class="keyword">return</span> NUll;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;j&lt;i) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表的建立：头插法和尾插法。头插法常用在将一个已存在的链表逆序。<br>单链表的插入、删除：O(n),读取的时间复杂度也是O(n).<br>双链表的插入：<br>双链表的删除：    </p>
<h3 id="在O-1-时间删除链表节点（13）"><a href="#在O-1-时间删除链表节点（13）" class="headerlink" title="在O(1)时间删除链表节点（13）"></a>在O(1)时间删除链表节点（13）</h3><p>思想：把下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除，就相当于把当前需要删除的结点删除了,不是尾结点。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1)时间删除链表节点，从无头单链表中删除节点</span></span><br><span class="line"><span class="literal">void</span> deleteRandomNode(Node *cur)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cur != <span class="built_in">NULL</span>);</span><br><span class="line">    assert(cur<span class="subst">-&gt;</span>next != <span class="built_in">NULL</span>);    <span class="comment">//不能是尾节点</span></span><br><span class="line">    Node* pNext = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">    cur<span class="subst">-&gt;</span><span class="built_in">data</span> = pNext<span class="subst">-&gt;</span><span class="built_in">data</span>;</span><br><span class="line">    cur<span class="subst">-&gt;</span>next = pNext<span class="subst">-&gt;</span>next;</span><br><span class="line">    delete pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的逆转（16）"><a href="#单链表的逆转（16）" class="headerlink" title="单链表的逆转（16）"></a>单链表的逆转（16）</h3><p>输入一个单向链表，输出逆序反转后的链表的头结点。<br>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。<br>非递归:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="identifier"></span><span class="title">* reverseByLoop</span>(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>)</span><br><span class="line">&#123;	</span><br><span class="line">	if(head == NULL||head-&gt;<span class="variable">next=</span>=NULL) return head;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*pre</span> = NULL;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*next</span> = NULL;</span><br><span class="line">	while(head!=NULL)&#123;</span><br><span class="line">		next = head-&gt;next;</span><br><span class="line">		</span><br><span class="line">		head-&gt;next = pre;</span><br><span class="line">		pre = head;</span><br><span class="line">		head = next;</span><br><span class="line">	&#125;</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="identifier"></span><span class="title">* reverseByRecursion</span>(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>)</span><br><span class="line">&#123;</span><br><span class="line">	if(head == NULL || head-&gt;next == NULL) return head;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*newHead</span> = reverseByRecursion(head-&gt;next);</span><br><span class="line">	</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = NULL;</span><br><span class="line">	</span><br><span class="line">	return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）"><a href="#判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）" class="headerlink" title="判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）"></a>判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）</h3><p>题目描述：输入一个单向链表，判断链表是否有环？</p>
<p>分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到</span><br><span class="line">bool hasCircle(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>,<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*&amp;circleNode</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">*slow</span>,*fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    while(fast != NULL &amp;&amp; fast-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if(fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            circleNode = fast;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果链表存在环，如何找到环的入口点？</p>
<p>按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>
<p>为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>
<p>p1走的路径： a+b ＝ n；<br>p2走的路径： a+b+k<em>L = 2</em>n； p2 比 p1 多走了k圈环路，总路程是p1的2倍</p>
<p>根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>
<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到环的入口点</span></span><br><span class="line">Node* findLoopPort(Node *head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果head为空，或者为单结点，则不存在环</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">Node *slow,*fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先判断是否存在环</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">slow = slow-&gt;<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">if</span>(fast == slow)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fast != slow) <span class="keyword">return</span> <span class="keyword">NULL</span>; <span class="comment">//不存在环</span></span><br><span class="line"></span><br><span class="line">fast = head; <span class="comment">//快指针从头开始走，步长变为1</span></span><br><span class="line"><span class="keyword">while</span>(fast != slow) <span class="comment">//两者相遇即为入口点</span></span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;<span class="keyword">next</span>;</span><br><span class="line">slow = slow-&gt;<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个链表是否相交-两链表相交的第一个公共节点"><a href="#判断两个链表是否相交-两链表相交的第一个公共节点" class="headerlink" title="判断两个链表是否相交,两链表相交的第一个公共节点"></a>判断两个链表是否相交,两链表相交的第一个公共节点</h3><p>给出两个单向链表的头指针（如下图所示）<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-04%20%E4%B8%8B%E5%8D%883.00.16.png" alt=""><br>比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。</p>
<p>思想一：那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。<br>所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)</p>
<p>思想二：计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//求两链表相交的第一个公共节点</span><br><span class="line">Node* findIntersectNode(Node *h1,Node *h2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> len1 = listLength(h1)<span class="comment">; //求链表长度</span></span><br><span class="line"><span class="built_in">int</span> len2 = listLength(h2)<span class="comment">;</span></span><br><span class="line">//对齐两个链表</span><br><span class="line"><span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span><span class="comment">;i&lt;len1-len2;i++)</span></span><br><span class="line">h1=h1-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span><span class="comment">;i&lt;len2-len1;i++)</span></span><br><span class="line">h2=h2-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(h1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(h1 == h2)</span><br><span class="line"><span class="keyword">return</span> h1<span class="comment">;</span></span><br><span class="line">h1 = h1-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">h2 = h2-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第-k-个节点（15）"><a href="#链表中倒数第-k-个节点（15）" class="headerlink" title="链表中倒数第 k 个节点（15）"></a>链表中倒数第 k 个节点（15）</h3><p>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p1 向前走 k-1 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。当第一个指针到达链表的结尾的时候，第二个指针刚好是倒数第K个结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒数第k个节点</span></span><br><span class="line"><span class="function">Node* <span class="title">theKthNode</span><span class="params">(Node *head,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//异常判断</span></span><br><span class="line"></span><br><span class="line">    Node *slow,*fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;<span class="number">0</span> &amp;&amp; fast!=<span class="literal">NULL</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//考虑k大于链表长度的case</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个有序链表合并-17"><a href="#两个有序链表合并-17" class="headerlink" title="两个有序链表合并(17)"></a>两个有序链表合并(17)</h3><p>比较两个头结点的值，得到两个链表中值较小的头结点并把它链接到可以合并的链表之后，两个链表剩余的结点依然是排序的，递归。<br>当一个头结点是空，第一个链表是空链表，合并后返回的就是第二个链表。</p>
<h3 id="复杂链表的复制-26"><a href="#复杂链表的复制-26" class="headerlink" title="复杂链表的复制(26)"></a>复杂链表的复制(26)</h3><p>思想1：用空间换时间<br>第一步：复制原始链表上的每个结点N创建N‘，然后把这些创建出来的结点用m_pNext连接起来。同时我们把&lt;N,N’&gt;的配对信息放到一个哈希表中。<br>第二步：设置复制链表上每个结点的m_pSibling.如果在原始链表中结点N的m_pSibling指向结点S.那么在复制链表中，N’指向S’，有了哈希表，我们就可以在O(1)的时间根据S找到S‘。</p>
<p>思想2：复制原始链表上的每个结点N创建N‘，把N’链接在N的后面。<br>把这个长链表拆分成两个链表，奇数位置上的结点组成原始链表，偶数位置上的结点组成复制出来的链表。</p>
<h3 id="删除链表中重复节点-57"><a href="#删除链表中重复节点-57" class="headerlink" title="删除链表中重复节点(57)"></a>删除链表中重复节点(57)</h3><p>排序链表中，如何删除重复的结点？<br>思想：第一步;确定删除函数的参数，当然这个函数需要输入待删除链表的头结点。头结点可能与后面的结点重复，也就是说头结点也可能被删除，因此删除函数应该声明为<code>void deleteDuplication(ListNode **pHead)</code>而不是<code>void deleteDuplication(ListNode *pHead);</code><br>第二步;从头遍历整个链表，如果当前结点的值和下一个结点的值相同，那么它们就是重复结点，都可以被删除。为了保证不断开，我们要把当前结点的前一个结点和后面值比当前结点的值要大的结点相连。</p>
<h3 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h3><p>题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>
<p>分析：此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//求链表的中间节点</span><br><span class="line">Node* theMiddleNode(Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span><span class="comment">;</span></span><br><span class="line">    Node *slow,*fast<span class="comment">;</span></span><br><span class="line">    slow = fast = head<span class="comment">;</span></span><br><span class="line">    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件</span><br><span class="line">    //<span class="keyword">while</span>(fast &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">        slow = slow-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>顺序栈 </p>
<ol>
<li>初始化<br>void InitStack(&amp;S){<br> s.top=-1;//将栈顶指针置为空<br>}  </li>
<li>判断栈空<br>bool empty(S){<br> if (s.top==-1) return true;//栈空<br> else return false;<br>}  </li>
<li>进栈<br>bool push(x){<br> if (S.top==MaxSize-1) return false;//栈满，报错<br> S.data[++S.top]=x;//指针先加1，再入栈<br> return true;<br>}  </li>
<li>出栈<br>bool pop(x){<br> if (S.top==-1) return false;//栈空，报错<br> x=S.data[S.top–];//先出栈，指针再减1<br> return true;<br>}  </li>
<li>读栈顶元素<br>void GetTop(x){<br> if (S.top==-1)return false;//栈空，报错<br> x= S.data[S.top];//x记录栈顶元素<br> return false;<br>}</li>
</ol>
<h3 id="用两个栈实现队列-7"><a href="#用两个栈实现队列-7" class="headerlink" title="用两个栈实现队列(7)"></a>用两个栈实现队列(7)</h3><p>用两个栈，当进队列的时候向一个栈中push进去，当出队列的时候，把元素弹出到栈2，然后在pop，顺序一样。<br>【扩展】用两个队列实现栈</p>
<h3 id="实现一个栈，可以用常数级时间找出栈中的最小值"><a href="#实现一个栈，可以用常数级时间找出栈中的最小值" class="headerlink" title="实现一个栈，可以用常数级时间找出栈中的最小值"></a>实现一个栈，可以用常数级时间找出栈中的最小值</h3><h3 id="判断栈的压栈、弹栈序列是否合法（剑指offer-第-22-题）"><a href="#判断栈的压栈、弹栈序列是否合法（剑指offer-第-22-题）" class="headerlink" title="判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）"></a>判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）</h3><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><pre><code>【3】根据中序和后序遍历结果重建二叉树、
【3】根据中序和前序遍历结果重建二叉树
【2】翻转二叉树
【2】从上往下打印二叉树 (BFS 的思想)
【3】判断某个数组是不是二叉树的后序遍历结果 (剑指 offer 第 24 题)
【3】二叉树中和为某个值的路径
【3*】二叉树中某个节点的下一个节点 (强烈推荐准备一下，剑指 offer 第 58 题)
</code></pre><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="给一个十进制数字，求它的二进制表示中，有多少个-1-（10）"><a href="#给一个十进制数字，求它的二进制表示中，有多少个-1-（10）" class="headerlink" title="给一个十进制数字，求它的二进制表示中，有多少个 1 （10）"></a>给一个十进制数字，求它的二进制表示中，有多少个 1 （10）</h3><p>(n &amp;= n - 1)<br>把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0.那么一个整数的二进制中表示中有多少个1，就可以进行多少次这样的操作。</p>
<h3 id="给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"><a href="#给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数" class="headerlink" title="给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"></a>给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数</h3><p>从头到尾依次异或数组中的每一个数字，最终得到的结果就是这个数字。</p>
<h3 id="给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"><a href="#给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数" class="headerlink" title="给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"></a>给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数</h3><p>从头到尾依次异或数组中的每一个数字，最终得到的结果就是这两个数字异或的结果，，在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组。重复上面过程。<br>数组：{2，4，3，6，3，2，5，5}最终得到结果就是4和6的异或结果，0100^0110=0010,然后根据第二位是不是1分为2个数字，第一个子数组{2，3，6，3，2}中所有数字的倒数第二位都是1，而第二个子数组{4，5，5}中所有数字的倒数第二位都是0、分别异或，就得到了6和4.</p>
<h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><p>【补充】不用中间变量,用两种方法交换A和B的值<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B7%A7%E4%BA%A4%E6%8D%A2.png" alt=""><br>或者使用<strong>位运算符</strong>异或<br>A = A^B;<br>B = A^B;<br>A = A^B;</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>一种用来解决最优化问题的思想。动态规划将一个复杂的问题分解成若干个简单的子问题，通过综合子问题的求解结果来得到原问题的解。<br>本质:通过记录曾经计算过的内容，来避免重复计算。<br>1&gt;递归<br>斐波那契数列</p>
<p>2&gt;递推<br>数塔DP问题：将一些数字排成数塔形状，其中第一层有一个数字，第二层有两个数字。。。。。第N层有N个数字，形状要从第一层走到第N层，每次只能走向下一层连接的两个数字中的一个，问最后将路径上所以数字相加后得到的和最大是多少？</p>
<h3 id="最大连续子序列和-31"><a href="#最大连续子序列和-31" class="headerlink" title="最大连续子序列和(31)"></a>最大连续子序列和(31)</h3><p>题目：输入一个数字序列a1,a2,求i,j（1&lt;=i&lt;=j&lt;=n）,使得ai+…….aj最大，输出最大和。</p>
<p>思想：扫描数组，从左到右记录当前子序列的和 ThisSum，若返个和不断增加，那么最大子序列的和 MaxSum 也不断增加(不断更新 MaxSum)。如果往前扫描中遇到负数，那么当前子序列的和将会减小。此时 ThisSum 将会小于 MaxSum，当然 MaxSum 也就不断更新。如果 ThisSum 降到 0 时， 说明前面已经扫描的那一段就可以抛弃了，这时将 ThisSum 置为 0。然后，ThisSum 将从后面开始将这个子段进行分析，若有比当前 MaxSum 大的子段，继续更新 MaxSum。这样一趟扫描结果也就出来了。</p>
<p>【扩展】和最接近 0 的子序列：<br>【扩展】环形数组的最大子序列和:将环形数组首尾拼接成一个 2n 的线型数组(如环形数组 0 1 2， 可以 拼接成 0 1 2 0 1 2)，按1的方法可以找到最大连续子序列和</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>题目：有N件物品，每件物品的重量为W[i],价值为C[i],现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的价值最大，其中每种物品都只有一件。</p>
<h3 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h3><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>题目：给定两个字符串A和B，求一个字符串，使得这个字符串是A和B的最长公共部分</p>
<h3 id="最长回文字串"><a href="#最长回文字串" class="headerlink" title="最长回文字串"></a>最长回文字串</h3><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><h3 id="实现简单的正则表达式匹配"><a href="#实现简单的正则表达式匹配" class="headerlink" title="实现简单的正则表达式匹配"></a>实现简单的正则表达式匹配</h3><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>进程和线程的区别？</strong></p>
<ol>
<li><strong>调度</strong>：<strong>进程：拥有资源的基本单位。线程：独立调度的基本单位。</strong>在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，则会引起进程切换。线程可以共享其隶属进程的系统资源。</li>
<li>并发性：进程和线程都可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量</li>
<li>系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如：内存空间、I/O设备。线程只需要保存和设置少量寄存器内容，系统所付出的开销远大于创建或撤销线程的开销。</li>
<li><strong>地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源</strong>，某进程内的线程对于其他进程不可见。</li>
<li><strong>通信方面：进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段（如：全局变量）来进行通信。</strong></li>
</ol>
<p>Linux系统进程间的通信：管道(Pipe)、信号（signal）、消息队列（Message）、共享内存、信号量、套接口。<br>Linux线程间的通信：互斥体（互斥量）、信号量、条件变量。<br>Windows进程间通信：管道(Pipe)、消息队列（Message）、共享内存、信号量、套接口。<br>Windows线程间通信：临界区(Critical Section)、互斥量（Mutex）、信号量（信号灯）、事件（Event）</p>
<ol>
<li>操作系统中的进程的存储结构；<br>一个正在运行着的进程在内存空间中的内存结构有：代码区、静态数据区、未初始化数据区、堆区和栈区5个部分.</li>
</ol>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度的基本准则：CPU利用率、系统吞吐量（单位时间内CPU完成作业的数量）、周转时间（作业完成时间-作业到达时间）、等待时间、响应时间。<br>典型的调度算法：先来先服务（FCFS）、短作业优先（SJF）、优先级调度算法、高响应比优先、时间片轮转、多级反馈队列调度算法。（短作业优先的平均等待时间、平均周转时间最少）（高响应比优先既有利于短作业又兼顾长作业）。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生的原因：</strong></p>
<ol>
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
</ol>
<p><strong>死锁产生的必要条件：</strong><br>互斥条件、不剥夺条件、请求和保持条件、循环等待条件</p>
<p><strong>死锁的处理</strong><br>死锁的预防：破坏四个必要条件中的一个<br>避免死锁：银行家算法<br>死锁的检测：资源分配图<br>死锁的解除：资源剥夺法、撤销进程法、进程回退法。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配管理方式"><a href="#内存分配管理方式" class="headerlink" title="内存分配管理方式"></a>内存分配管理方式</h3><p>连续分配方式：单一连续分配、固定分区分配、动态分区分配</p>
<p>非连续分配方式：分页存储管理方式（基本分页存储和请求分页存储管理方式）、分段存储管理方式</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>虚拟存储器：并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户感觉是好像存在一个比实际物理内存大的多的存储器。<br>实现方式：</p>
<ol>
<li>请求分页</li>
<li>请求分段</li>
<li>请求段页式</li>
</ol>
<p><strong>请求分页管理方式</strong></p>
<p>常见的置换算法：最佳置换算法、先进先出页面置换算法、最近最久未使用置换算法（LRU）。</p>
<p>最佳置换算法： 所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面。</p>
<p>先进先出页面置换算法：淘汰最早进入内存的页面</p>
<p>最近最久未使用置换算法：淘汰最近最长时间未访问的页面</p>
<p>内存抖动：频繁的换页活动。</p>
<ol>
<li>文件结构是用哪种数据结构实现的，树还是图，<br>答案是B+树；</li>
</ol>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>发生函数调用的时候，主调函数把实参的值传送给被调函数的形参，从而实现主调函数向被调函数的数据传送。</p>
<p>C++中的三种传递方法：</p>
<ul>
<li>值传递</li>
<li>指针传递</li>
<li>引用传递</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ol>
<li><p>成员函数成为内联函数<br>类中成员函数全部默认为内联函数。<br>类外定义该成员函数加inline也可成为内联函数</p>
</li>
<li><p>普通函数成为内联函数<br>普通函数声明或定义前加inline使其成为内联函数。</p>
</li>
</ol>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>在同一作用域中，可以有一组具有相同函数名，不同参数列表的函数。这组函数被称为重载函数。</p>
<p>用来命名一组功能相似的函数。</p>
<p>进行函数重载时，要求同名函数在参数个数上不同，或者参数类型上不同。</p>
<h3 id="函数模板与泛型"><a href="#函数模板与泛型" class="headerlink" title="函数模板与泛型"></a>函数模板与泛型</h3><p>泛型编程：以独立于任何特定类型的方式编写代码。依赖于某种形式的多态性。标准库用独立于类型的方式定义每个容器、迭代器和算法是泛型编程的例子。</p>
<p>模板是泛型编程的基础。模板是创建类或函数的蓝图或公式。以template<typename t="">.</typename></p>
<p>【宏定义和内联函数的区别】宏定义是在预处理阶段进行代码替换，内联函数是在编译阶段进行代码替换。宏定义没有类型检查，内联函数有类型检查。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>成员函数：形参this初始化为调用函数的对象的地址</p>
<p>构造函数：是特殊的成员函数，与类同名，没有返回类型。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。</p>
<p>拷贝构造函数：只要单个形参，而且该形参是对本类类型对象的引用（常用const修饰）由编译器隐式调用。<br>可用于：</p>
<ul>
<li>根据另一个同类型的对象初始化一个对象</li>
<li>复制一个对象，将她作为实参传给一个函数或从函数返回时复制一个对象。</li>
<li>初始化顺序容器中的元素</li>
<li>根据元素初始化式列表初始化数组元素</li>
</ul>
<p>析构函数：当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数，可以用来释放对象构造时活在对象的生命期中所获取的资源。</p>
<p>构造函数不能被定义为虚函数，析构函数可以被定义为虚函数</p>
<h3 id="成员函数的重载、覆盖于隐藏"><a href="#成员函数的重载、覆盖于隐藏" class="headerlink" title="成员函数的重载、覆盖于隐藏"></a>成员函数的重载、覆盖于隐藏</h3><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="虚函数多态"><a href="#虚函数多态" class="headerlink" title="虚函数多态"></a>虚函数多态</h3><p>多态性：一个接口，多个方法。函数重载就是简单的多态，一个函数名(调用接口)对应着几个不同的函数原型(方法)</p>
<p>静态多态：函数重载和操作符重载</p>
<p>动态多态：虚函数</p>
<p><strong>虚函数：</strong>在成员函数原型前加virtual。如果基类的成员函数为虚函数，它在所有派生类中也保持虚函数。</p>
<p>哪些函数不能为虚函数：普通函数、静态成员函数、构造函数、友元函数。</p>
<p><strong>虚函数表指针(vptr):</strong></p>
<ul>
<li>每一个类产生出一堆指向virtual functions的指针，放在表格中，这个表成为虚函数表</li>
<li>每个对象被添加了一个指针，指向相关的virtual table。这个指针被称为虚函数表指针。</li>
</ul>
<p><strong>虚基类表指针(bptr)</strong><br>在虚拟继承基类的子类中，子类会增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，这个指针成为虚基类表指针。</p>
<p><strong>纯虚函数</strong></p>
<ul>
<li>是一种特殊的虚函数。<strong>凡是含有纯虚函数的类称为抽象类</strong>。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中的所有纯虚函数，否则，<strong>派生类也是抽象类，不能实例化对象</strong>。</li>
<li><strong>只定义了protected型构造函数的类也是抽象类</strong>，没有提供public构造函数，无论是在外部还是在派生类中都不能创建该类的对象，但可以由派生出新的类。</li>
</ul>
<h3 id="动态运行时类型标识与显式转换"><a href="#动态运行时类型标识与显式转换" class="headerlink" title="动态运行时类型标识与显式转换"></a>动态运行时类型标识与显式转换</h3><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="100亿个整数，如何找到中位数"><a href="#100亿个整数，如何找到中位数" class="headerlink" title="100亿个整数，如何找到中位数"></a>100亿个整数，如何找到中位数</h3><p>首先数没有这么多，内存能放下，用quickSort的思想，找第K大的数放在它的右边。<br>现在内存放不下，用什么？</p>
<ol>
<li>用二分法。整数的范围就是[-2^32,2^32-1]。有了范围后就对这个范围进行二分，然后找多少个数小于Mid，多少数大于Mid，然后递归。</li>
<li>分桶法。化大为小，把所有的数划分到各个小区间[-2^32,-2^16],[-2^16,0]……..。把每个数映射到对应的区间里，对每个区间中数的个数进行计数。数一遍各个区间，看看中位数落在那个区间。若够小，使用基于内存的算法，否则继续划分。</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年03月01日 - 16时57分</p>
        <p><span>最后更新:</span>2017年04月25日 - 16时40分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/03/01/计算机基础知识/" title="计算机基础知识总结">http://peilinghui.com/2016/03/01/计算机基础知识/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/03/01/计算机基础知识/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/03/01/计算机网络基础知识与安全/">
                    计算机网络基础知识与安全
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/03/01/经典排序算法总结与实现/">
                    经典排序算法总结与实现
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法和数据结构"><span class="toc-number">1.</span> <span class="toc-text">算法和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）"><span class="toc-number">1.1.1.</span> <span class="toc-text">每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递增排序数组的旋转数组求最小值（剑指offer第8题）"><span class="toc-number">1.1.2.</span> <span class="toc-text">递增排序数组的旋转数组求最小值（剑指offer第8题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转数组求查找某个值是否存在"><span class="toc-number">1.1.3.</span> <span class="toc-text">旋转数组求查找某个值是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组中出现次数超过一半的数字（剑指offer第29题）"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组中出现次数超过一半的数字（剑指offer第29题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小的k个数-最大的K个数"><span class="toc-number">1.1.5.</span> <span class="toc-text">最小的k个数(最大的K个数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序数组中某个数字出现的次数（二分查找）"><span class="toc-number">1.1.6.</span> <span class="toc-text">有序数组中某个数字出现的次数（二分查找）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求两个等长、有序数组的中位数（二分法）"><span class="toc-number">1.1.7.</span> <span class="toc-text">求两个等长、有序数组的中位数（二分法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求两个不等长、有序数组的中位数"><span class="toc-number">1.1.8.</span> <span class="toc-text">求两个不等长、有序数组的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整数组顺序是奇数位于偶数前面"><span class="toc-number">1.1.9.</span> <span class="toc-text">调整数组顺序是奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和为S的两个数字VS和为S的连续正数序列（41）"><span class="toc-number">1.1.10.</span> <span class="toc-text">和为S的两个数字VS和为S的连续正数序列（41）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断数组中是否有重复值，空间复杂度O-n"><span class="toc-number">1.1.11.</span> <span class="toc-text">判断数组中是否有重复值，空间复杂度O(n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#荷兰国旗问题"><span class="toc-number">1.1.12.</span> <span class="toc-text">荷兰国旗问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#需要排序的最短子数组的长度"><span class="toc-number">1.1.13.</span> <span class="toc-text">需要排序的最短子数组的长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序后相邻两数的最大差值"><span class="toc-number">1.1.14.</span> <span class="toc-text">排序后相邻两数的最大差值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串转换为数字（49）"><span class="toc-number">1.2.1.</span> <span class="toc-text">字符串转换为数字（49）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#翻转字符串-42"><span class="toc-number">1.2.2.</span> <span class="toc-text">翻转字符串(42)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换空格-4"><span class="toc-number">1.2.3.</span> <span class="toc-text">替换空格(4)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串包含（KMP算法）"><span class="toc-number">1.2.4.</span> <span class="toc-text">字符串包含（KMP算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的排列"><span class="toc-number">1.2.5.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一个只出现一个的字符（35）"><span class="toc-number">1.2.6.</span> <span class="toc-text">第一个只出现一个的字符（35）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">1.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在O-1-时间删除链表节点（13）"><span class="toc-number">1.3.1.</span> <span class="toc-text">在O(1)时间删除链表节点（13）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单链表的逆转（16）"><span class="toc-number">1.3.2.</span> <span class="toc-text">单链表的逆转（16）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）"><span class="toc-number">1.3.3.</span> <span class="toc-text">判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个链表是否相交-两链表相交的第一个公共节点"><span class="toc-number">1.3.4.</span> <span class="toc-text">判断两个链表是否相交,两链表相交的第一个公共节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中倒数第-k-个节点（15）"><span class="toc-number">1.3.5.</span> <span class="toc-text">链表中倒数第 k 个节点（15）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个有序链表合并-17"><span class="toc-number">1.3.6.</span> <span class="toc-text">两个有序链表合并(17)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂链表的复制-26"><span class="toc-number">1.3.7.</span> <span class="toc-text">复杂链表的复制(26)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除链表中重复节点-57"><span class="toc-number">1.3.8.</span> <span class="toc-text">删除链表中重复节点(57)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求链表的中间节点"><span class="toc-number">1.3.9.</span> <span class="toc-text">求链表的中间节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈与队列"><span class="toc-number">1.4.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用两个栈实现队列-7"><span class="toc-number">1.4.1.</span> <span class="toc-text">用两个栈实现队列(7)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现一个栈，可以用常数级时间找出栈中的最小值"><span class="toc-number">1.4.2.</span> <span class="toc-text">实现一个栈，可以用常数级时间找出栈中的最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断栈的压栈、弹栈序列是否合法（剑指offer-第-22-题）"><span class="toc-number">1.4.3.</span> <span class="toc-text">判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">1.5.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找"><span class="toc-number">1.6.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算"><span class="toc-number">1.7.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个十进制数字，求它的二进制表示中，有多少个-1-（10）"><span class="toc-number">1.7.1.</span> <span class="toc-text">给一个十进制数字，求它的二进制表示中，有多少个 1 （10）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"><span class="toc-number">1.7.2.</span> <span class="toc-text">给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"><span class="toc-number">1.7.3.</span> <span class="toc-text">给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不用加减乘除做加法"><span class="toc-number">1.7.4.</span> <span class="toc-text">不用加减乘除做加法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">1.8.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最大连续子序列和-31"><span class="toc-number">1.8.1.</span> <span class="toc-text">最大连续子序列和(31)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题"><span class="toc-number">1.8.2.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长不下降子序列"><span class="toc-number">1.8.3.</span> <span class="toc-text">最长不下降子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长公共子序列（LCS）"><span class="toc-number">1.8.4.</span> <span class="toc-text">最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长回文字串"><span class="toc-number">1.8.5.</span> <span class="toc-text">最长回文字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连续子数组的最大和"><span class="toc-number">1.8.6.</span> <span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现简单的正则表达式匹配"><span class="toc-number">1.8.7.</span> <span class="toc-text">实现简单的正则表达式匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">2.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-number">2.1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度算法"><span class="toc-number">2.1.1.</span> <span class="toc-text">调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">2.1.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">2.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配管理方式"><span class="toc-number">2.2.1.</span> <span class="toc-text">内存分配管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存管理"><span class="toc-number">2.2.2.</span> <span class="toc-text">虚拟内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C"><span class="toc-number">2.3.</span> <span class="toc-text">C++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">2.4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数传递"><span class="toc-number">2.4.1.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内联函数"><span class="toc-number">2.4.2.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数重载"><span class="toc-number">2.4.3.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数模板与泛型"><span class="toc-number">2.4.4.</span> <span class="toc-text">函数模板与泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-number">2.5.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类成员"><span class="toc-number">2.5.1.</span> <span class="toc-text">类成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员函数的重载、覆盖于隐藏"><span class="toc-number">2.5.2.</span> <span class="toc-text">成员函数的重载、覆盖于隐藏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象编程"><span class="toc-number">2.6.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">2.6.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚函数多态"><span class="toc-number">2.6.2.</span> <span class="toc-text">虚函数多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态运行时类型标识与显式转换"><span class="toc-number">2.6.3.</span> <span class="toc-text">动态运行时类型标识与显式转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大数据"><span class="toc-number">2.7.</span> <span class="toc-text">大数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#100亿个整数，如何找到中位数"><span class="toc-number">2.7.1.</span> <span class="toc-text">100亿个整数，如何找到中位数</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/01/计算机基础知识/" data-title="计算机基础知识总结" data-url="http://peilinghui.com/2016/03/01/计算机基础知识/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/03/01/计算机网络基础知识与安全/" title="上一篇: 计算机网络基础知识与安全">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/03/01/经典排序算法总结与实现/" title="下一篇: 经典排序算法总结与实现">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/30/11月总结/">11月总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/开发一个React-Native的APP/">开发一个React-Native的APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/ReactNative的常用组件/">ReactNative的常用组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/iOS应用APP架构/">iOS应用APP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/iOS网络层的封装/">iOS网络层的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/项目重构遇到的问题/">项目重构遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/iOS中的图表Charts/">iOS中的图表Charts</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/移动应用的设计模式/">移动应用的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Jenkins搭建来实现自动化打包/">Jenkins搭建来实现自动化打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/做一个搜索框的Demo/">做一个搜索框的Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/如何使用Mac本地服务器/">如何使用Mac本地服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/iOS打包和发布流程/">iOS打包和发布流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/学习iOS中JS与OC相互调用的方式/">学习iOS中JS与OC相互调用的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/深入学习NSURLProtocol/">深入学习NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/UIView的Frame和bounds区别/">UIView的Frame和bounds区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/21/学习React-Native的与原生的交互/">学习React-Native的与原生的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/学习React-Native的API和组件/">学习React-Native的API和组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/学习React-Native入门/">学习React Native入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/22/学习React知识/">学习React知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/自动化测试/">自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/研究框架YYModel/">研究框架YYModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/深入学习GCD/">深入学习GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/深入学习KVC和KVO/">深入学习KVC和KVO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/深入学习RunLoop/">深入学习RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/消息处理之performSelector/">消息处理之performSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习Runtime/">深入学习Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转 </a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/深入学习内存管理/">深入学习内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/关于NSString的引用计数问题/">关于NSString的引用计数问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/深入学习Block/">深入学习Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/设计模式解析/">设计模式解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的第三方框架/">iOS中的第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/关于深拷贝和浅拷贝/">关于深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机网络基础知识与安全/">计算机网络基础知识与安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/经典排序算法总结与实现/">经典排序算法总结与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>