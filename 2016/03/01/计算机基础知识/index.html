<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>计算机基础知识总结 | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础知识总结">
<meta property="og:url" content="http://peilinghui.com/2016/03/01/计算机基础知识/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-04%20%E4%B8%8B%E5%8D%883.00.16.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/Insertion-sort-example-300px.gif">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/Merge-sort-example-300px.gif">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/Quicksort-example.gif">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/Heapsort-example.gif">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F.jpg">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8A%E5%8D%889.50.55.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8B%E5%8D%8812.33.32.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8B%E5%8D%8812.53.34.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AF%94%E8%BE%83get%E5%92%8Cpost.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%85%B6%E4%BB%96%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png">
<meta property="og:updated_time" content="2017-03-08T06:42:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机基础知识总结">
<meta name="twitter:description" content="总结算法和数据结构，还有计算机网络，操作系统的知识。">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/RAC-学习笔记/" style="font-size: 10px;">RAC,学习笔记</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS面试/" style="font-size: 10px;">iOS面试</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-计算机基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/计算机基础知识/" class="article-date">
      <time datetime="2016-03-01T08:57:25.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      计算机基础知识总结
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/面试/">面试</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>总结算法和数据结构，还有计算机网络，操作系统的知识。<br><a id="more"></a></p>
<h1 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）"><a href="#每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）" class="headerlink" title="每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）"></a>每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）</h3><p>思想：首先选取数组中有上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。不断缩小范围，直到找到要查找的数字。否则不存在。</p>
<h3 id="递增排序数组的旋转数组求最小值（剑指offer第8题）"><a href="#递增排序数组的旋转数组求最小值（剑指offer第8题）" class="headerlink" title="递增排序数组的旋转数组求最小值（剑指offer第8题）"></a>递增排序数组的旋转数组求最小值（剑指offer第8题）</h3><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/?tab=Description</a><br>思想：二分查找。<br>旋转后的数组实际上可以划分为两个排序数组，最小的元素是这俩个子数组的分界线。<br>两个指针，一个指向第一个元素，一个指向最后一个元素，找到中间元素。<br>如果中间元素比第一个大，则到后一段中找；<br>如果中间元素比最后一个小，则到前一段中找。不断缩小，直到两个指针相邻，第二个指针所指向的就是最小的值，循环结束。<br>特例：1）前面0个元素移到后面，即排序数组本身。（）<br>        2）{1，0，1，1，1}和数组{1，1，1，0，1}是递增数组{0，1，1，1，1}的旋转，只能采取顺序查找的方法。</p>
<h3 id="旋转数组求查找某个值是否存在"><a href="#旋转数组求查找某个值是否存在" class="headerlink" title="旋转数组求查找某个值是否存在"></a>旋转数组求查找某个值是否存在</h3><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/search-in-rotated-sorted-array/?tab=Description</a><br>思想：同上：二分法</p>
<h3 id="数组中出现次数超过一半的数字（剑指offer第29题）"><a href="#数组中出现次数超过一半的数字（剑指offer第29题）" class="headerlink" title="数组中出现次数超过一半的数字（剑指offer第29题）"></a>数组中出现次数超过一半的数字（剑指offer第29题）</h3><p>解法一：快速排序。O(n)<br>解法二：这个数字出现的次数比其他所有数字出现的次数的和还要多。遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1，如果不同，则次数减1。如果次数</p>
<h3 id="最小的k个数-最大的K个数"><a href="#最小的k个数-最大的K个数" class="headerlink" title="最小的k个数(最大的K个数)"></a>最小的k个数(最大的K个数)</h3><p>思想：解法一：快速排序，基于数组的第K个数字来调整，使得比第K个数字小的所有数字都位于数组的左边，比第K个数字大的所有数字都位于数组的右边。左边的K个数字为最小的K个数字。时间复杂度O(n).<br>此方法的限制：要一次性读入所有数，而且修改输入的数组。<br>解法二：堆排序。适合处理海量数据。<br>首先我们读入K个数创建一个大小为K的大根堆，然后我们依次读入剩余数据，如果当前数据比大根堆的堆顶小，则用这个数替换当前的堆顶，并调整堆使其保持大根堆的性质。如果当前数据比大根堆的堆顶大，则不可能是最小的K个整数之一。时间复杂度：O(nlogk)<br><strong>注意：当求最小的K个数的时候是建立大根堆，当求最大的K个数的时候是建立小根堆。</strong><br>或者：红黑树，STL中的set和multiset。</p>
<p>【扩展】<br>第 k 大的数<br><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/?tab=Description" target="_blank" rel="external">https://leetcode.com/problems/kth-largest-element-in-an-array/?tab=Description</a></p>
<h3 id="有序数组中某个数字出现的次数（二分查找）"><a href="#有序数组中某个数字出现的次数（二分查找）" class="headerlink" title="有序数组中某个数字出现的次数（二分查找）"></a>有序数组中某个数字出现的次数（二分查找）</h3><p>由于数组有序，所以使用二分查找方法定位k的第一次出现位置和最后一次出现位置。</p>
<ol>
<li>先二分找到第一个k下标first，再二分找到最后一个k下标last，</li>
<li>last-first+1即为所求。</li>
<li>复杂度，O(lgN) + O(lgN) = O(lgN)<br>复杂度：时间：O(lgN)；空间O(1)</li>
</ol>
<h3 id="求两个等长、有序数组的中位数（二分法）"><a href="#求两个等长、有序数组的中位数（二分法）" class="headerlink" title="求两个等长、有序数组的中位数（二分法）"></a>求两个等长、有序数组的中位数（二分法）</h3><p>就是比较两个区间的中位数，如果第一个区间的中位数比第二个大，那么就把第一个区间的范围缩小至它的前半段，把第二个区间缩小至它的后半段，然后重复上述过程。</p>
<h3 id="求两个不等长、有序数组的中位数"><a href="#求两个不等长、有序数组的中位数" class="headerlink" title="求两个不等长、有序数组的中位数"></a>求两个不等长、有序数组的中位数</h3><p>解法：<a href="http://blog.csdn.net/ojshilu/article/details/15027309" target="_blank" rel="external">http://blog.csdn.net/ojshilu/article/details/15027309</a></p>
<h3 id="调整数组顺序是奇数位于偶数前面"><a href="#调整数组顺序是奇数位于偶数前面" class="headerlink" title="调整数组顺序是奇数位于偶数前面"></a>调整数组顺序是奇数位于偶数前面</h3><p>思路:解法一：扫描这个数组，如果发现有偶数出现在奇数的前面，我们可以交换它们的顺序。维护两个指针，第一个指针在数组的一个数字，向后移动，第二个指针在数组的最后一个数值，向前移动。<br>解法二：把整个函数解耦成两部分：一判断数字应该在数组前半部分还是后半部分的标准，二是拆分数组的操作。</p>
<h3 id="一组正整数数字，如何找出两个数加为100的组合；"><a href="#一组正整数数字，如何找出两个数加为100的组合；" class="headerlink" title="一组正整数数字，如何找出两个数加为100的组合；"></a>一组正整数数字，如何找出两个数加为100的组合；</h3><p>（首先要排序）然后two pointers.</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串转换为数字（49）"><a href="#字符串转换为数字（49）" class="headerlink" title="字符串转换为数字（49）"></a>字符串转换为数字（49）</h3><p>思想：依次扫描字符串，每扫描到一个字符，我们把在之前得到的数字乘以10在加上当前字符表示的数字。<br>遇到“+”号向前走，遇到“-”号，表明这个数是负数。<br>考虑非法输入：需要判断这个指针是不是为空。<br>输入的字符串可能含有不是数字的字符，每当碰到非法的字符，转换停止。<br>溢出问题，若溢出，则返回0.</p>
<h3 id="翻转字符串-42"><a href="#翻转字符串-42" class="headerlink" title="翻转字符串(42)"></a>翻转字符串(42)</h3><p>思想：第一步翻转句子中所有的字符。第二步再翻转每个单词中字符的顺序。</p>
<p>【扩展】左旋转字符串<br>翻转字符串前面N个字符，再翻转字符串后面的部分，最后翻转整个字符串。</p>
<h3 id="替换空格-4"><a href="#替换空格-4" class="headerlink" title="替换空格(4)"></a>替换空格(4)</h3><p>思想：先遍历一次字符串，统计出空格的总数，计算出替换以后的字符串的总长度，每替换一个空格，长度增加2.<br>从字符串后面开始复制和替换。先准备两个指针P1和P2，P1指向原始字符串的末尾，P2指向替换之后的字符串的末尾，<br>向前移动P1，逐个把它指向的字符串复制到P2所指向的位置，直到碰到第一个空格的时候，把P1向前移动一个，P2向前移动3格并插入“%20”。继续往前走，直到P1和P2指向同一个位置。<br>时间复杂度：O(n)</p>
<h3 id="字符串包含（KMP算法）"><a href="#字符串包含（KMP算法）" class="headerlink" title="字符串包含（KMP算法）"></a>字符串包含（KMP算法）</h3><p>在给定字符串A中查找一个子字符串B。<br>KMP算法：利用不匹配字符的前面那一段字符的最长前后缀来尽可能地跳过最大的距离。</p>
<h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p>输入一个字符串，打印出字符串的所有排列<br>输入：abc，输出：acb,bac,cab,cba.<br>思想：首先求所有可能出现在第一个位置的字符。把第一个字符和后面的所有字符交换。<br>第二步固定一个字符，求后面所有字符的排列。<br>输入：abc,输出：a,b,c,ab,ac,bc,abc.</p>
<p>【扩展】求字符的所有组合</p>
<h3 id="第一个只出现一个的字符（35）"><a href="#第一个只出现一个的字符（35）" class="headerlink" title="第一个只出现一个的字符（35）"></a>第一个只出现一个的字符（35）</h3><p>利用哈希表，哈希表的Key是字符，value是该字符出现的次数。<br>从头开始扫描字符串两次，第一次扫描字符串的时候，每扫描到一个字符串就在哈希表的对应项中把次数加1，第二次扫描的时候就能从哈希表中得到该字符串出现的次数。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>单链表</strong> </p>
<ol>
<li>定义</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"></span><span class="title">&#123;</span><br><span class="line">    int</span> data;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"></span><span class="title">* next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>头插法建立单链表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从表尾到表头逆向建立单链表，每次均在头结点之后插入元素</span></span><br><span class="line">    LNode *s;<span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    L-&gt;next= <span class="literal">NULL</span>;<span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>) &#123;<span class="comment">//创建新结点</span></span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next=L-&gt;next;</span><br><span class="line">        L-&gt;next=s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125; </span><br><span class="line">时间复杂度：O(n)</span><br></pre></td></tr></table></figure>
<ol>
<li>尾插法建立单链表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">CreateList2</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从表尾到表头逆向建立单链表，每次均在头结点之后插入元素</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点</span></span><br><span class="line">    LNode *s,*r=L;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,x);</span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>) &#123;<span class="comment">//创建新结点</span></span><br><span class="line">        s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;<span class="comment">//r指向新的表尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=NUll;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>按序号查找表结点值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LNode *<span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    LNode *p=L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)<span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span>)<span class="keyword">return</span> NUll;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;j&lt;i) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单链表的建立：头插法和尾插法。头插法常用在将一个已存在的链表逆序。<br>单链表的插入、删除：O(n),读取的时间复杂度也是O(n).<br>双链表的插入：<br>双链表的删除：    </p>
<h3 id="在O-1-时间删除链表节点（13）"><a href="#在O-1-时间删除链表节点（13）" class="headerlink" title="在O(1)时间删除链表节点（13）"></a>在O(1)时间删除链表节点（13）</h3><p>思想：把下一个结点的内容复制到需要删除的结点上覆盖原有的内容，再把下一个结点删除，就相当于把当前需要删除的结点删除了,不是尾结点。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1)时间删除链表节点，从无头单链表中删除节点</span></span><br><span class="line"><span class="literal">void</span> deleteRandomNode(Node *cur)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cur != <span class="built_in">NULL</span>);</span><br><span class="line">    assert(cur<span class="subst">-&gt;</span>next != <span class="built_in">NULL</span>);    <span class="comment">//不能是尾节点</span></span><br><span class="line">    Node* pNext = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">    cur<span class="subst">-&gt;</span><span class="built_in">data</span> = pNext<span class="subst">-&gt;</span><span class="built_in">data</span>;</span><br><span class="line">    cur<span class="subst">-&gt;</span>next = pNext<span class="subst">-&gt;</span>next;</span><br><span class="line">    delete pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的逆转（16）"><a href="#单链表的逆转（16）" class="headerlink" title="单链表的逆转（16）"></a>单链表的逆转（16）</h3><p>输入一个单向链表，输出逆序反转后的链表的头结点。<br>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。<br>非递归:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="identifier"></span><span class="title">* reverseByLoop</span>(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>)</span><br><span class="line">&#123;	</span><br><span class="line">	if(head == NULL||head-&gt;<span class="variable">next=</span>=NULL) return head;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*pre</span> = NULL;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*next</span> = NULL;</span><br><span class="line">	while(head!=NULL)&#123;</span><br><span class="line">		next = head-&gt;next;</span><br><span class="line">		</span><br><span class="line">		head-&gt;next = pre;</span><br><span class="line">		pre = head;</span><br><span class="line">		head = next;</span><br><span class="line">	&#125;</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Node</span><span class="identifier"></span><span class="title">* reverseByRecursion</span>(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>)</span><br><span class="line">&#123;</span><br><span class="line">	if(head == NULL || head-&gt;next == NULL) return head;</span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*newHead</span> = reverseByRecursion(head-&gt;next);</span><br><span class="line">	</span><br><span class="line">	head-&gt;next-&gt;next = head;</span><br><span class="line">	head-&gt;next = NULL;</span><br><span class="line">	</span><br><span class="line">	return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）"><a href="#判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）" class="headerlink" title="判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）"></a>判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）</h3><p>题目描述：输入一个单向链表，判断链表是否有环？</p>
<p>分析：通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到</span><br><span class="line">bool hasCircle(<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*head</span>,<span class="keyword">Node</span><span class="identifier"> </span><span class="title">*&amp;circleNode</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">Node</span><span class="identifier"> </span><span class="title">*slow</span>,*fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    while(fast != NULL &amp;&amp; fast-&gt;next != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        if(fast == slow)</span><br><span class="line">        &#123;</span><br><span class="line">            circleNode = fast;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果链表存在环，如何找到环的入口点？</p>
<p>按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>
<p>为什么？：假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>
<p>p1走的路径： a+b ＝ n；<br>p2走的路径： a+b+k<em>L = 2</em>n； p2 比 p1 多走了k圈环路，总路程是p1的2倍</p>
<p>根据上述公式可以得到 k*L=a+b=n显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>
<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到环的入口点</span></span><br><span class="line">Node* findLoopPort(Node *head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果head为空，或者为单结点，则不存在环</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">NULL</span> || head-&gt;<span class="keyword">next</span> == <span class="keyword">NULL</span>) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">Node *slow,*fast;</span><br><span class="line">slow = fast = head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先判断是否存在环</span></span><br><span class="line"><span class="keyword">while</span>(fast != <span class="keyword">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="keyword">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">slow = slow-&gt;<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">if</span>(fast == slow)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fast != slow) <span class="keyword">return</span> <span class="keyword">NULL</span>; <span class="comment">//不存在环</span></span><br><span class="line"></span><br><span class="line">fast = head; <span class="comment">//快指针从头开始走，步长变为1</span></span><br><span class="line"><span class="keyword">while</span>(fast != slow) <span class="comment">//两者相遇即为入口点</span></span><br><span class="line">&#123;</span><br><span class="line">fast = fast-&gt;<span class="keyword">next</span>;</span><br><span class="line">slow = slow-&gt;<span class="keyword">next</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个链表是否相交-两链表相交的第一个公共节点"><a href="#判断两个链表是否相交-两链表相交的第一个公共节点" class="headerlink" title="判断两个链表是否相交,两链表相交的第一个公共节点"></a>判断两个链表是否相交,两链表相交的第一个公共节点</h3><p>给出两个单向链表的头指针（如下图所示）<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-04%20%E4%B8%8B%E5%8D%883.00.16.png" alt=""><br>比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。</p>
<p>思想一：那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。<br>所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)</p>
<p>思想二：计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//求两链表相交的第一个公共节点</span><br><span class="line">Node* findIntersectNode(Node *h1,Node *h2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> len1 = listLength(h1)<span class="comment">; //求链表长度</span></span><br><span class="line"><span class="built_in">int</span> len2 = listLength(h2)<span class="comment">;</span></span><br><span class="line">//对齐两个链表</span><br><span class="line"><span class="keyword">if</span>(len1 &gt; len2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span><span class="comment">;i&lt;len1-len2;i++)</span></span><br><span class="line">h1=h1-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span><span class="comment">;i&lt;len2-len1;i++)</span></span><br><span class="line">h2=h2-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(h1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(h1 == h2)</span><br><span class="line"><span class="keyword">return</span> h1<span class="comment">;</span></span><br><span class="line">h1 = h1-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">h2 = h2-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表中倒数第-k-个节点（15）"><a href="#链表中倒数第-k-个节点（15）" class="headerlink" title="链表中倒数第 k 个节点（15）"></a>链表中倒数第 k 个节点（15）</h3><p>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p1 向前走 k-1 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。当第一个指针到达链表的结尾的时候，第二个指针刚好是倒数第K个结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//倒数第k个节点</span></span><br><span class="line"><span class="function">Node* <span class="title">theKthNode</span><span class="params">(Node *head,<span class="keyword">int</span> k)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//异常判断</span></span><br><span class="line"></span><br><span class="line">    Node *slow,*fast;</span><br><span class="line">    slow = fast = head;</span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;<span class="number">0</span> &amp;&amp; fast!=<span class="literal">NULL</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//考虑k大于链表长度的case</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个有序链表合并-17"><a href="#两个有序链表合并-17" class="headerlink" title="两个有序链表合并(17)"></a>两个有序链表合并(17)</h3><h3 id="复杂链表的复制-26"><a href="#复杂链表的复制-26" class="headerlink" title="复杂链表的复制(26)"></a>复杂链表的复制(26)</h3><h3 id="删除链表中重复节点-57"><a href="#删除链表中重复节点-57" class="headerlink" title="删除链表中重复节点(57)"></a>删除链表中重复节点(57)</h3><h3 id="求链表的中间节点"><a href="#求链表的中间节点" class="headerlink" title="求链表的中间节点"></a>求链表的中间节点</h3><p>题目描述：求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>
<p>分析：此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//求链表的中间节点</span><br><span class="line">Node* theMiddleNode(Node *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span><span class="comment">;</span></span><br><span class="line">    Node *slow,*fast<span class="comment">;</span></span><br><span class="line">    slow = fast = head<span class="comment">;</span></span><br><span class="line">    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件</span><br><span class="line">    //<span class="keyword">while</span>(fast &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;<span class="keyword">next</span> != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">        slow = slow-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p>顺序栈 </p>
<ol>
<li>初始化<br>void InitStack(&amp;S){<br> s.top=-1;//将栈顶指针置为空<br>}  </li>
<li>判断栈空<br>bool empty(S){<br> if (s.top==-1) return true;//栈空<br> else return false;<br>}  </li>
<li>进栈<br>bool push(x){<br> if (S.top==MaxSize-1) return false;//栈满，报错<br> S.data[++S.top]=x;//指针先加1，再入栈<br> return true;<br>}  </li>
<li>出栈<br>bool pop(x){<br> if (S.top==-1) return false;//栈空，报错<br> x=S.data[S.top–];//先出栈，指针再减1<br> return true;<br>}  </li>
<li><p>读栈顶元素<br>void GetTop(x){<br> if (S.top==-1)return false;//栈空，报错<br> x= S.data[S.top];//x记录栈顶元素<br> return false;<br>}</p>
<p> 【2】用两个栈实现队列、【2】用两个队列实现栈<br> 【2】实现一个栈，可以用常数级时间找出栈中的最小值<br> 【3】判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）</p>
</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><pre><code>【3】根据中序和后序遍历结果重建二叉树、【3】根据中序和前序遍历结果重建二叉树
【2】翻转二叉树
【2】从上往下打印二叉树 (BFS 的思想)
【3】判断某个数组是不是二叉树的后序遍历结果 (剑指 offer 第 24 题)
【3】二叉树中和为某个值的路径
【3*】二叉树中某个节点的下一个节点 (强烈推荐准备一下，剑指 offer 第 58 题)
</code></pre><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>了解以下排序的时间、空间复杂度，是否稳定，实现原理</p>
<pre><code>归并排序、拓展：求数组中的逆序对个数
快速排序 重点：partion 函数的实现
堆排序
数组元素值域已知时，考虑 基数排序 和 桶排序
</code></pre><h3 id="冒泡排序-BubbleSort"><a href="#冒泡排序-BubbleSort" class="headerlink" title="冒泡排序 BubbleSort"></a>冒泡排序 BubbleSort</h3><p>冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>步骤：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>空间效率：O（1）<br>时间效率：平均和最坏都是：O（N2） </li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]= &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">4</span>; i++) &#123;<span class="comment">//进行n-1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">5</span>-i; j++) &#123;<span class="comment">//第i趟时从a[0]到a[n-i]都与他们的下一个数比较</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;<span class="comment">//如果左边的数更大，则交换a[j]和a[j+1]</span></span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。<br>优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。</p>
<h3 id="选择排序-SelectionSort"><a href="#选择排序-SelectionSort" class="headerlink" title="选择排序 SelectionSort"></a>选择排序 SelectionSort</h3><p>选择排序无疑是最简单直观的排序。它的工作原理如下。</p>
<p>步骤：</p>
<ul>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>以此类推，直到所有元素均排序完毕。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> selectSort()&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;n; i++) &#123;<span class="comment">//进行n-1趟</span></span><br><span class="line">        <span class="built_in">min</span> = i;<span class="comment">//记录最小元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;=n; j++) <span class="comment">//从i...n中选择最小元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[j]&lt;A[<span class="built_in">min</span>]) <span class="built_in">min</span> = j;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];<span class="comment">//最小元素与A[i]交换</span></span><br><span class="line">    A[i] = A[<span class="built_in">min</span>];</span><br><span class="line">    A[<span class="built_in">min</span>] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>步骤：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果被扫描的元素（已排序）大于新元素，将该元素后移一位</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ul>
<p>排序演示：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/Insertion-sort-example-300px.gif" alt=""><br>空间效率：O（1）<br>时间效率：O（N2） </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=A[i];</span><br><span class="line">        <span class="keyword">for</span> (j=i-<span class="number">1</span>; temp&lt;A[j]; j--) &#123;<span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];<span class="comment">//向后移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[j+<span class="number">1</span>]=temp;<span class="comment">//复制到插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>思想：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。<br>时间复杂度：O(n^1.3)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = right -left +<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> d = len;</span><br><span class="line">	<span class="keyword">while</span>(d&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		d=(d+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =left;i&lt;right+<span class="number">1</span>-d;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(data[i+d]&lt;data[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = data[i+d];</span><br><span class="line">				data[i+d]=data[i];</span><br><span class="line">				data[i]=tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort2</span><span class="params">(<span class="keyword">int</span> *data,<span class="keyword">int</span> len)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d =len;</span><br><span class="line">	<span class="keyword">while</span>(d&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		d = (d+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-d;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(data[i+d]&lt;data[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = data[i+d];</span><br><span class="line">				data[i+d] = data[i];</span><br><span class="line">				data[i] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%5d"</span>,data[i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> n=<span class="number">9</span>,m =<span class="number">0</span>,i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"input 10 number:"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">list</span>[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	ShellSort2(<span class="built_in">list</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//ShellSort(list,0,9);</span></span><br><span class="line">	print(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%5d"</span>,<span class="built_in">list</span>[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>含义：将两个或俩个以上的有序表合并成为一个新的有序表。<br>先分解后合并。<br>时间复杂度：O(nlogn)稳定！</p>
<p>思想：<br>第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>重复步骤3直到某一指针超出序列尾</p>
<p>将另一序列剩下的所有元素直接复制到合并序列尾.<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/Merge-sort-example-300px.gif" alt=""><br>递归实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//将数组A的[L1,R1]与[L2,R2]区间合并为有序区间L2=R1+1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> L1,<span class="keyword">int</span> R1,<span class="keyword">int</span> L2,<span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1,j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn],index=<span class="number">0</span>;<span class="comment">//temp存放合并后的数组，index为其下标</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=R1&amp;&amp;j&lt;=R2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;=A[j]) &#123;</span><br><span class="line">            temp[index++]=A[i++];<span class="comment">//将A[i]加入序列temp</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[index++]=A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=R1)temp[index++]=A[i++];<span class="comment">//将区间[L1,R1]的剩余元素加入序列temp</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;=R2)temp[index++]=A[j++];<span class="comment">//将区间[L2,R2]的剩余元素加入序列temp</span></span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>; i&lt;index; i++) &#123;</span><br><span class="line">        A[L1+i]=temp[i]; <span class="comment">//将合并后的序列赋值回数组A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Array数组当前区间[left,right]进行归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);</span><br><span class="line">        mergeSort(A, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(A, left, mid, mid+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight"><figcaption><span>mergeSort(int A[])&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    //step&#20026;&#32452;&#20869;&#20803;&#32032;&#20010;&#25968;&#10;    for (int step= 2; step/2 &#60;= n; step*=2) &#123;&#10;        //&#27599;step&#20010;&#20803;&#32032;&#19968;&#32452;&#65292;&#32452;&#20869;&#36827;&#34892;&#25490;&#24207;&#10;        for (int i =1; i&#60;=n; i+=step) &#123;&#10;            int mid = i +step/2 -1;&#10;            if (mid +1&#60;=n) &#123;&#10;                merge(A,mid,mid+1,min(i+step-1,n));&#10;            &#125;&#10;        &#125;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//step为组内元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step= <span class="number">2</span>; step/<span class="number">2</span> &lt;= n; step*=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//每step个元素一组，组内进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;=n; i+=step) &#123;</span><br><span class="line">            sort(A+i,A+min(i+step,n+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>是所有排序算法中平均时间最好的一种算法，O(nlogn)思想是基于分治法。</p>
<ol>
<li>调整序列中的元素，使得当前序列最左短的元素在调整后满足左侧所以元素均不超过该元素、右侧所有元素均大于该元素。  </li>
<li>对该元素的左侧和右侧分别递归进行1的调整，直到当前调整区间的长度不超过1.<br>时间复杂度：O(n2)<br>空间复杂度：O(logn)<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/Quicksort-example.gif" alt=""><br>递归实现：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int <span class="type">Partition</span>(int <span class="type">A</span>[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">    int temp = <span class="type">A</span>[<span class="keyword">left</span>];<span class="comment">//将表中第一个元素设为枢轴值，</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">left</span>&lt;<span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">left</span>&lt;<span class="keyword">right</span>&amp;&amp;<span class="type">A</span>[<span class="keyword">right</span>]&gt;temp) <span class="keyword">right</span>--;</span><br><span class="line">        <span class="type">A</span>[<span class="keyword">left</span>]=<span class="type">A</span>[<span class="keyword">right</span>];<span class="comment">//将比枢轴值小的元素移动到左边</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">left</span>&lt;<span class="keyword">right</span>&amp;&amp;<span class="type">A</span>[<span class="keyword">left</span>]&lt;=temp) <span class="keyword">left</span>++;</span><br><span class="line">        <span class="type">A</span>[<span class="keyword">right</span>]=<span class="type">A</span>[<span class="keyword">left</span>];<span class="comment">//将比枢轴值大的元素移动到右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">A</span>[<span class="keyword">left</span>]=temp;<span class="comment">//枢轴放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">left</span>;<span class="comment">//返回下标</span></span><br><span class="line">&#125;</span><br><span class="line">void <span class="built_in">quickSort</span>(int <span class="type">A</span>[],int <span class="keyword">left</span>,int <span class="keyword">right</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">left</span>&lt;<span class="keyword">right</span>) &#123;</span><br><span class="line">        int pos = <span class="type">Partition</span>(<span class="type">A</span>,<span class="keyword">left</span>,<span class="keyword">right</span>);<span class="comment">//将[left,right]按A[left]一分为二</span></span><br><span class="line">        <span class="built_in">quickSort</span>(<span class="type">A</span>, <span class="keyword">left</span>, pos);<span class="comment">//对左子区间递归进行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(<span class="type">A</span>, pos+<span class="number">1</span>, <span class="keyword">right</span>);<span class="comment">//对右子区间递归进行快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>时间复杂度：O(nlogn)</p>
<p>建立堆的复杂度是O(n)，只建立一次<br>调整堆的时间复杂度是o(logn)，调用n-1次  所以是nlogn<br>不稳定<br> <img src="http://7xr8q7.com1.z0.glb.clouddn.com/Heapsort-example.gif" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//array是待调整的堆数组，i是待调整的数组元素的位置，nlength是数组的长度</span></span><br><span class="line"><span class="comment">//本函数功能是：根据数组array构建大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> i,<span class="keyword">int</span> nLength)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nChild;</span><br><span class="line">    <span class="keyword">int</span> nTemp;</span><br><span class="line">    <span class="keyword">for</span>(;<span class="number">2</span>*i+<span class="number">1</span>&lt;nLength;i=nChild)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子结点的位置=2*（父结点位置）+1</span></span><br><span class="line">        nChild=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//得到子结点中较大的结点</span></span><br><span class="line">        <span class="keyword">if</span>(nChild&lt;nLength-<span class="number">1</span>&amp;&amp;<span class="built_in">array</span>[nChild+<span class="number">1</span>]&gt;<span class="built_in">array</span>[nChild])++nChild;</span><br><span class="line">        <span class="comment">//如果较大的子结点大于父结点那么把较大的子结点往上移动，替换它的父结点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i]&lt;<span class="built_in">array</span>[nChild])</span><br><span class="line">        &#123;</span><br><span class="line">            nTemp=<span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i]=<span class="built_in">array</span>[nChild];</span><br><span class="line">            <span class="built_in">array</span>[nChild]=nTemp; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">//否则退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[],<span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//调整序列的前半部分元素，调整完之后第一个元素是序列的最大的元素</span></span><br><span class="line">    <span class="comment">//length/2-1是最后一个非叶节点，此处"/"为整除</span></span><br><span class="line">    <span class="keyword">for</span>(i=length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    HeapAdjust(<span class="built_in">array</span>,i,length);</span><br><span class="line">    <span class="comment">//从最后一个元素开始对序列进行调整，不断的缩小调整的范围直到第一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i=length-<span class="number">1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//把第一个元素和当前的最后一个元素交换，</span></span><br><span class="line">        <span class="comment">//保证当前的最后一个位置的元素都是在现在的这个序列之中最大的</span></span><br><span class="line">        交换arry[i] arry[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">//不断缩小调整heap的范围，每一次调整完毕保证第一个元素是当前序列的最大值</span></span><br><span class="line">        HeapAdjust(<span class="built_in">array</span>,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%8E%92%E5%BA%8F.jpg" alt=""></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="给一个十进制数字，求它的二进制表示中，有多少个-1-（10）"><a href="#给一个十进制数字，求它的二进制表示中，有多少个-1-（10）" class="headerlink" title="给一个十进制数字，求它的二进制表示中，有多少个 1 （10）"></a>给一个十进制数字，求它的二进制表示中，有多少个 1 （10）</h3><p>(n &amp;= n - 1)<br>把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0.那么一个整数的二进制中表示中有多少个1，就可以进行多少次这样的操作。</p>
<h3 id="给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"><a href="#给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数" class="headerlink" title="给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"></a>给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数</h3><p>从头到尾依次异或数组中的每一个数字，最终得到的结果就是这个数字。</p>
<h3 id="给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"><a href="#给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数" class="headerlink" title="给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"></a>给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数</h3><p>从头到尾依次异或数组中的每一个数字，最终得到的结果就是这两个数字异或的结果，，在结果数字中找到第一个为1的位的位置，记为第N位。现在我们以第N位是不是1为标准把原数组中的数字分成两个子数组。重复上面过程。<br>数组：{2，4，3，6，3，2，5，5}最终得到结果就是4和6的异或结果，0100^0110=0010,然后根据第二位是不是1分为2个数字，第一个子数组{2，3，6，3，2}中所有数字的倒数第二位都是1，而第二个子数组{4，5，5}中所有数字的倒数第二位都是0、分别异或，就得到了6和4.</p>
<h3 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a>不用加减乘除做加法</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>一种用来解决最优化问题的思想。动态规划将一个复杂的问题分解成若干个简单的子问题，通过综合子问题的求解结果来得到原问题的解。<br>本质:通过记录曾经计算过的内容，来避免重复计算。<br>1&gt;递归<br>斐波那契数列</p>
<p>2&gt;递推<br>数塔DP问题：将一些数字排成数塔形状，其中第一层有一个数字，第二层有两个数字。。。。。第N层有N个数字，形状要从第一层走到第N层，每次只能走向下一层连接的两个数字中的一个，问最后将路径上所以数字相加后得到的和最大是多少？</p>
<h3 id="最大练习子序列和"><a href="#最大练习子序列和" class="headerlink" title="最大练习子序列和"></a>最大练习子序列和</h3><p>题目：输入一个数字序列a1,a2,求i,j（1&lt;=i&lt;=j&lt;=n）,使得ai+…….aj最大，输出最大和。</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>题目：有N件物品，每件物品的重量为W[i],价值为C[i],现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的价值最大，其中每种物品都只有一件。</p>
<h3 id="最长不下降子序列"><a href="#最长不下降子序列" class="headerlink" title="最长不下降子序列"></a>最长不下降子序列</h3><h3 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h3><p>题目：给定两个字符串A和B，求一个字符串，使得这个字符串是A和B的最长公共部分</p>
<h3 id="最长回文字串"><a href="#最长回文字串" class="headerlink" title="最长回文字串"></a>最长回文字串</h3><h3 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h3><h3 id="实现简单的正则表达式匹配"><a href="#实现简单的正则表达式匹配" class="headerlink" title="实现简单的正则表达式匹配"></a>实现简单的正则表达式匹配</h3><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>OSI有七层，从下到上分别是：物理层、数据链路层、网络层、<strong>传输层</strong>、会话层、表示层、应用层。<br>数据链路层：负责分配Mac地址，一个网卡会有一个全球固定的MAC地址。</p>
<p>物理层设备：中继器和集线、网卡。数据链路层的设备：网桥或交换机。实现同一种数据链路下的包传递。</p>
<p><strong>网络层：</strong>对数据包进行路由选择和存储转发。协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF等；数据单位为分组或数据包。设备：路由器。实现跨越不同数据链路的包传递。</p>
<p><strong>传输层：</strong>第一个端到端，进程到进程的层次。有复用和分用的功能。协议：TCP、UDP、SCTP等。传输层数据的单位为报文或数据段。</p>
<p>应用层：为操作系统或者网络应用程序提供网络接口。协议：RIP、TELNET、FIP、HTTP、SNMP。</p>
<h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h2><p>从低到高：网络接口层，网际层、传输层和应用层。<br>由于得到广泛用于而成为事实上的国际标准。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a>IPV4地址</h3><p>连接在Internet中的每台主机（路由器）都分配一个32bit的全球唯一标识符，就是IP地址。<br>IP地址编码的三种：分类的IP地址、子网的划分、CIDR。<br>IP地址：分类的地址，分别为A类、B类、C类和D类、E类。都是由网络号和主机号两部分组成。网络号：主机所连接到的网络。主机号：该主机或路由器在网络中的地址。<br>分类的依据是IP地址的前四位：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8A%E5%8D%889.50.55.png" alt=""><br>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个。</p>
<p>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</p>
<p>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</p>
<p>D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。</p>
<p>特殊IP地址:</p>
<pre><code>主机号全为0表示网络本身。
主机号全为1表示本网络的广播地址。
127.0.0.1表示任意主机本身。
0.0.0.0表示整个TCP/IP网络
255.255.255.255表示整个TCP/IP网络的广播地址。
</code></pre><p>网络地址转化–NAT<br>通过将专用网络地址（企业内部网）转换为公用地址，从而对外隐藏了内部管理的IP地址。<br>私有IP地址：10.0.0.0~10.255.255.255、172.16.0.0~172.31.255.255、192.168.0.0~192.168.255.255.<br>私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球IP才能用于Internet。</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>各类地址默认的子网掩码：<br>A类：255.0.0.0<br>B类：255.255.0.0<br>C类：255.255.255.0<br>使用子网划分时的地址格式：<br>A类：8位+子网X位+主机24-X位。<br>B类：16位+子网X位+主机16-X位。<br>C类：24位+子网X位+主机8-X位。</p>
<h4 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h4><p>消除A类、B类、C类网络划分。可以大幅度提高IP地址空间的利用率，并减少路由表的大小，提高路由器的路由转发能力。<br>主要特点：<br>1&gt;IP地址分为网络前缀和主机号。斜线记法：IP地址/网络前缀所占比特数（对应于网络号部分）如：192.168.10.0/20。前20位为网络前缀。<br>2&gt;将网络前缀都相同的练习IP地址成为“CIDR地址块”，一个CIDR地址块库包括多个A、B、C类地址，这种地址的聚合称为路由聚合，或构成超网。有利于减少路由之间的路由选择信息的交换，从而提高网络性能。</p>
<h3 id="ICMP、ARP、RARP"><a href="#ICMP、ARP、RARP" class="headerlink" title="ICMP、ARP、RARP"></a>ICMP、ARP、RARP</h3><p>IP地址到MAC地址的映射，用到ARP(地址解析协议)<br>ARP(获取MAC地址)，每台主机上单独存放一个从IP地址到MAC地址的映射表，称为ARP表。主机和路由器使用地址解析ARP协议来动态维护ARP表。<br>RARP：物理地址转IP地址。<br>ICMP协议(数据发送异常通知)：ping命令。<br>ping www.taobao.com 所使用的协议有：ARP(IP到MAC的解析)、ICMP(ping所需)和DNS(域名到IP的解析)</p>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><p>由126bit构成，主要变化：<br>1&gt;更大的地址空间。IPV4是32bit。<br>2&gt;扩展的地址层次结构<br>3&gt;灵活的首部格式<br>4&gt;改进的选项，加快了分组处理的速度<br>5&gt;允许协议继续扩充。<br>6&gt;支持即插即用<br>7&gt;支持资源的预分配<br><strong>8&gt;增加了安全性，身份验证和保密验证</strong><br>9&gt;分片限制为由源点来完成，是端到端的，路由途中的路由器不允许进行分片。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>功能：使得发送端和目的端主机上的对等实体可以进行会话。<br>两种协议：<br>1&gt;TCP传输控制协议，它是面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>2&gt;UDP用户数据包协议，它是无连接的，数据传输的单位是用户数据包，不提用可靠的交付，只能提供“最大努力交付”。</p>
<h4 id="TCP连接的建立和终止"><a href="#TCP连接的建立和终止" class="headerlink" title="TCP连接的建立和终止"></a>TCP连接的建立和终止</h4><p><strong>TCP建立连接要进行“三次握手”：</strong>交换三个分节。<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8B%E5%8D%8812.33.32.png" alt=""><br>（客户端）：我要建立连接了。<br>（服务端）：我知道你要建立连接了，我这边没有问题。<br>（客户端）：我知道你知道我要建立连接了，接下来我们就正式开始通信。<br>大致流程：<br>1&gt;客户端向服务器发送一个SYN J；<br>2&gt;服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1。<br>3&gt;客户端再向服务器发一个确认ACK K+1;</p>
<p><strong>为何采用“三次握手”建立连接，采用二次握手可以吗？为什么？</strong></p>
<p>答：不可以。采用三次握手是为了防止失效的连接请求报文段突然又传送到了服务器，从而发生错误。<br>当客户端发出的连接请求报文段由于某些原因没有及时到达服务器，而客户端再等待一段时间后，又重新发送连接请求，且建立成功，那么第一次发送的那个就是失效的连接报文段。<br>若是因为网络延迟到达服务器，服务器以为是客户端又发起的新连接，于是服务器同意连接，并向客户端发回确认，但是此时客户端不理会，服务器就一直等待客户端发送数据，导致服务器资源浪费。</p>
<p><strong>TCP终止连接要进行“四次挥手”</strong><br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-28%20%E4%B8%8B%E5%8D%8812.53.34.png" alt=""></p>
<p>（客户端）：我要关闭连接了。<br>（服务端）：你那边的连接可以关闭了。<br>（服务端）：我这边也要关闭连接了。<br>（客户端）：你那边的连接可以关闭了。<br>由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。<br>大致流程：<br>1&gt;某个应用进程首先调用close，我们称这一端执行主动关闭，这一端的TCP于是发送一个FIN分节，表示数据发送完毕。<br>2&gt;另一端接收到FIN分节之后，执行被动关闭，对这个FIN进行确认。它的接受也作为文件结束符传递给接收端应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；<br>3&gt;一段时间后，接收到文件结束符的应用进程调用close关闭它的套接字。这导致它的TCP也发送一个FIN。<br>4&gt;接收到这个FIN的原发送端TCP(执行主动关闭的那一端)对它进行确认。<br>进程终止时，所以打开的TCP连接上都会发出一个FIN。</p>
<p><strong>为什么需要四次挥手释放连接？</strong><br>关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有数据都全部发送给对方了，所以你未必马上关闭socket，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方表示你没有数据发送给对方了，针对每个FIN报文，都需要一个ACK报文，故需要四次挥手。</p>
<p>只有主动关闭的一方才会进入TIME_WAIT状态。</p>
<h4 id="Socket的基本操作（TCP）"><a href="#Socket的基本操作（TCP）" class="headerlink" title="Socket的基本操作（TCP）"></a>Socket的基本操作（TCP）</h4><ol>
<li>socket()函数</li>
<li>bind()函数</li>
<li>listen()函数</li>
<li>connect()函数</li>
<li>accept()函数</li>
<li>close()函数</li>
<li>shutdown()函数<br><strong>描述一个面向连接的客户端socket程序的主要步骤：</strong></li>
<li>加载套接字库</li>
<li>创建套接字（socket()）</li>
<li>向服务器发送连接请求(connect())</li>
<li>和服务器端进行通信</li>
<li>关闭套接字(close())</li>
</ol>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>虚拟终端协议（Telnet）、文件传输协议（FTP）、电子邮件协议（SMTP）、超文本传输协议（HTTP）、域名解析服务（DNS）–通常基于UDP协议</p>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>通过浏览器访问网页就直接使用了 HTTP 协议。使用 HTTP 协议时，客户端首先与服务端的 80 端口建立一个 TCP 连接，然后在这个连接的基础上进行请求和应答，以及数据的交换。<br>HTTP 有两个常用版本，分别是 1.0 和 1.1。主要区别在于 HTTP 1.0 中每次请求和应答都会使用一个新的 TCP 连接，而从 HTTP 1.1 开始，运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。<br><strong>状态码:</strong></p>
<pre><code>1XX:代表请求已被接受，需要继续处理。100表示客户端应该继续发送请求。
2XX：代表请求已成功被接受、理解、并接受。200表示请求已成功。
3XX：重定向
4XX：客户端错误。
5XX：服务端错误。
</code></pre><p>HTTP 有八种请求（也称方法），其中最常见的是 <strong>GET 请求和 POST 请求。</strong></p>
<p>GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据.<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E6%AF%94%E8%BE%83get%E5%92%8Cpost.png" alt=""><br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%85%B6%E4%BB%96%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.png" alt=""></p>
<p>注意：</p>
<p>  POST 请求仅比 GET 请求略安全一点，它的数据不在 URL 中，但依然以明文的形式存放于 HTTP 的请求头中。</p>
<p><strong>Cookie 和 Session</strong></p>
<p>HTTP 是一种无状态的连接，客户端每次读取 web 页面时，服务器都会认为这是一次新的会话。但有时候我们又需要持久保持某些信息，比如登录时的用户名、密码，用户上一次连接时的信息等。这些信息就由 Cookie 和 Session 保存。</p>
<p>这两者的根本性区别在于，cookie 保存在客户端上，而 session 则保存在服务器中。由此我们还可以拓展出以下结论：</p>
<ol>
<li>cookie 相对来说不安全，浏览器可以分析本地的 cookie 进行 cookie 欺骗。</li>
<li>session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。</li>
<li>单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。</li>
<li>客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。</li>
</ol>
<p>当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。</p>
<p><strong>加密</strong></p>
<p>加密分为两种，对称加密和非对称加密。<br>所谓的对称，就是指加密秘钥和解密秘钥相同，而非对称自然就是指两者不同。</p>
<p>对称加密的优点在于速度快，但是假设秘钥由服务器保存，如何安全的让客户端得到秘钥是需要解决的问题。</p>
<p>常见的一个非对称加密算法是 RSA 算法，利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。<br>因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。<br>因此实际的网络传输中，通常使用对称加密与非对称加密结合的方式，服务端通过非对称加密将对称秘钥发给客户端。此后双方使用这个对称密钥进行通信。</p>
<p><strong>HTTPS</strong></p>
<p>HTTPS 协议是如何避免三大风险</p>
<p>窃听风险：第三方节点可以获知通信内容。<br>篡改风险：第三方节点可以修改通信内容。<br>冒充风险：第三方节点可以冒充他人身份参与通信。</p>
<p>先用非对称加密传输密码，然后用这个密码对称加密数据，使得第三方无法获得通信内容<br>发送方将数据的哈希结果写到数据中，接收方解密后对比数据的哈希结果，如果不一致则说明被修改。由于传输数据加密，第三方无法修改哈希结果。<br>由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信。</p>
<p><strong>输入URL按下回车后究竟发生了什么？</strong></p>
<ol>
<li>浏览器向DNS服务器查询URL对应的IP地址</li>
<li>DNS返回IP地址</li>
<li>浏览器打开TCP连接（默认端口为80），并向web服务器发送HTTP请求</li>
<li>若页面发生跳转，服务器则以一个重定向响应，然后跳转到5，否则到6</li>
<li>浏览器跟随重定向，再次发送http请求</li>
<li>服务器处理请求，并返回HTML响应</li>
<li>浏览器接受请求的页面源码</li>
<li>浏览器开始渲染HTML</li>
<li>浏览器发送嵌入到HTML中的对象请求</li>
<li>浏览器进一步发送异步（Ajax）请求</li>
<li><p>浏览器关闭TCP连接</p>
</li>
<li><p>http和https的区别；抓包的时候有什么区别；</p>
<ul>
<li>HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头     - HTTP 是不安全的，而 HTTPS 是安全的 </li>
<li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443</li>
<li>在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层 </li>
<li>HTTP 无法加密，而HTTPS 对传输的数据进行加密 </li>
<li>HTTP无需证书，而HTTPS需要CA机构wosign的颁发的SSL证书 </li>
<li>HTTP无安全锁，HTTPS有安全锁</li>
<li>HTTP不能防钓鱼网站，HTTPS可以预防钓鱼网站</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议,要比http协议安全</li>
</ul>
</li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><strong>进程和线程的区别？</strong></p>
<ol>
<li><strong>调度</strong>：进程：拥有资源的基本单位。线程：独立调度的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，则会引起进程切换。线程可以共享其隶属进程的系统资源。</li>
<li>并发性：进程和线程都可以并发执行，从而使操作系统具有更好的并发性，大大提高了系统吞吐量</li>
<li>系统开销：创建和撤销进程时，系统都要为之分配或回收资源，如：内存空间、I/O设备。线程只需要保存和设置少量寄存器内容，系统所付出的开销远大于创建或撤销线程的开销。</li>
<li>地址空间和其他资源：进程的地址空间之间相互独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。</li>
<li>通信方面：进程间通信需要借助操作系统，而线程间可以直接读/写进程数据段（如：全局变量）来进行通信。</li>
</ol>
<p>Linux系统进程间的通信：管道(Pipe)、信号（signal）、消息队列（Message）、共享内存、信号量、套接口。<br>Linux线程间的通信：互斥体（互斥量）、信号量、条件变量。<br>Windows进程间通信：管道(Pipe)、消息队列（Message）、共享内存、信号量、套接口。<br>Windows线程间通信：临界区(Critical Section)、互斥量（Mutex）、信号量（信号灯）、事件（Event）</p>
<ol>
<li>操作系统中的进程的存储结构；<br>一个正在运行着的进程在内存空间中的内存结构有：代码区、静态数据区、未初始化数据区、堆区和栈区5个部分.</li>
</ol>
<p><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.jpg" alt=""> </p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>调度的基本准则：CPU利用率、系统吞吐量（单位时间内CPU完成作业的数量）、周转时间（作业完成时间-作业到达时间）、等待时间、响应时间。<br>典型的调度算法：先来先服务（FCFS）、短作业优先（SJF）、优先级调度算法、高响应比优先、时间片轮转、多级反馈队列调度算法。（短作业优先的平均等待时间、平均周转时间最少）（高响应比优先既有利于短作业又兼顾长作业）。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生的原因：</strong></p>
<ol>
<li>系统资源的竞争</li>
<li>进程推进顺序非法</li>
</ol>
<p><strong>死锁产生的必要条件：</strong><br>互斥条件、不剥夺条件、请求和保持条件、循环等待条件</p>
<p><strong>死锁的处理</strong><br>死锁的预防：破坏四个必要条件中的一个<br>避免死锁：银行家算法<br>死锁的检测：资源分配图<br>死锁的解除：资源剥夺法、撤销进程法、进程回退法。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配管理方式"><a href="#内存分配管理方式" class="headerlink" title="内存分配管理方式"></a>内存分配管理方式</h3><p>连续分配方式：单一连续分配、固定分区分配、动态分区分配</p>
<p>非连续分配方式：分页存储管理方式（基本分页存储和请求分页存储管理方式）、分段存储管理方式</p>
<h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>虚拟存储器：并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户感觉是好像存在一个比实际物理内存大的多的存储器。<br>实现方式：</p>
<ol>
<li>请求分页</li>
<li>请求分段</li>
<li>请求段页式</li>
</ol>
<p><strong>请求分页管理方式</strong></p>
<p>常见的置换算法：最佳置换算法、先进先出页面置换算法、最近最久未使用置换算法（LRU）。</p>
<p>最佳置换算法： 所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面。</p>
<p>先进先出页面置换算法：淘汰最早进入内存的页面</p>
<p>最近最久未使用置换算法：淘汰最近最长时间未访问的页面</p>
<p>内存抖动：频繁的换页活动。<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%8C%BA%E5%88%AB.png" alt=""></p>
<ol>
<li>文件结构是用哪种数据结构实现的，树还是图，<br>答案是B+树；</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年03月01日 - 16时57分</p>
        <p><span>最后更新:</span>2017年03月08日 - 14时42分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/03/01/计算机基础知识/" title="计算机基础知识总结">http://peilinghui.com/2016/03/01/计算机基础知识/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/03/01/计算机基础知识/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/03/04/iOS中的多线程网络/">
                    iOS中的多线程网络
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/03/01/iOS面试题总结/">
                    iOS面试题总结
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法和数据结构"><span class="toc-number">1.</span> <span class="toc-text">算法和数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指-offer-第-3-题）"><span class="toc-number">1.1.1.</span> <span class="toc-text">每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递增排序数组的旋转数组求最小值（剑指offer第8题）"><span class="toc-number">1.1.2.</span> <span class="toc-text">递增排序数组的旋转数组求最小值（剑指offer第8题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转数组求查找某个值是否存在"><span class="toc-number">1.1.3.</span> <span class="toc-text">旋转数组求查找某个值是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组中出现次数超过一半的数字（剑指offer第29题）"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组中出现次数超过一半的数字（剑指offer第29题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小的k个数-最大的K个数"><span class="toc-number">1.1.5.</span> <span class="toc-text">最小的k个数(最大的K个数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有序数组中某个数字出现的次数（二分查找）"><span class="toc-number">1.1.6.</span> <span class="toc-text">有序数组中某个数字出现的次数（二分查找）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求两个等长、有序数组的中位数（二分法）"><span class="toc-number">1.1.7.</span> <span class="toc-text">求两个等长、有序数组的中位数（二分法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求两个不等长、有序数组的中位数"><span class="toc-number">1.1.8.</span> <span class="toc-text">求两个不等长、有序数组的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调整数组顺序是奇数位于偶数前面"><span class="toc-number">1.1.9.</span> <span class="toc-text">调整数组顺序是奇数位于偶数前面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一组正整数数字，如何找出两个数加为100的组合；"><span class="toc-number">1.1.10.</span> <span class="toc-text">一组正整数数字，如何找出两个数加为100的组合；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串转换为数字（49）"><span class="toc-number">1.2.1.</span> <span class="toc-text">字符串转换为数字（49）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#翻转字符串-42"><span class="toc-number">1.2.2.</span> <span class="toc-text">翻转字符串(42)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换空格-4"><span class="toc-number">1.2.3.</span> <span class="toc-text">替换空格(4)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串包含（KMP算法）"><span class="toc-number">1.2.4.</span> <span class="toc-text">字符串包含（KMP算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串的排列"><span class="toc-number">1.2.5.</span> <span class="toc-text">字符串的排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第一个只出现一个的字符（35）"><span class="toc-number">1.2.6.</span> <span class="toc-text">第一个只出现一个的字符（35）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">1.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在O-1-时间删除链表节点（13）"><span class="toc-number">1.3.1.</span> <span class="toc-text">在O(1)时间删除链表节点（13）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#单链表的逆转（16）"><span class="toc-number">1.3.2.</span> <span class="toc-text">单链表的逆转（16）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断链表是否有环（快慢指针），若有环-找出环的入口结点（剑指offer的第56）"><span class="toc-number">1.3.3.</span> <span class="toc-text">判断链表是否有环（快慢指针），若有环,找出环的入口结点（剑指offer的第56）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断两个链表是否相交-两链表相交的第一个公共节点"><span class="toc-number">1.3.4.</span> <span class="toc-text">判断两个链表是否相交,两链表相交的第一个公共节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表中倒数第-k-个节点（15）"><span class="toc-number">1.3.5.</span> <span class="toc-text">链表中倒数第 k 个节点（15）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两个有序链表合并-17"><span class="toc-number">1.3.6.</span> <span class="toc-text">两个有序链表合并(17)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂链表的复制-26"><span class="toc-number">1.3.7.</span> <span class="toc-text">复杂链表的复制(26)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除链表中重复节点-57"><span class="toc-number">1.3.8.</span> <span class="toc-text">删除链表中重复节点(57)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求链表的中间节点"><span class="toc-number">1.3.9.</span> <span class="toc-text">求链表的中间节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈与队列"><span class="toc-number">1.4.</span> <span class="toc-text">栈与队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">1.5.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-number">1.6.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序-BubbleSort"><span class="toc-number">1.6.1.</span> <span class="toc-text">冒泡排序 BubbleSort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#选择排序-SelectionSort"><span class="toc-number">1.6.2.</span> <span class="toc-text">选择排序 SelectionSort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#插入排序"><span class="toc-number">1.6.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">1.6.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并排序"><span class="toc-number">1.6.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">1.6.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">1.6.7.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找"><span class="toc-number">1.7.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算"><span class="toc-number">1.8.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个十进制数字，求它的二进制表示中，有多少个-1-（10）"><span class="toc-number">1.8.1.</span> <span class="toc-text">给一个十进制数字，求它的二进制表示中，有多少个 1 （10）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数"><span class="toc-number">1.8.2.</span> <span class="toc-text">给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数"><span class="toc-number">1.8.3.</span> <span class="toc-text">给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不用加减乘除做加法"><span class="toc-number">1.8.4.</span> <span class="toc-text">不用加减乘除做加法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-number">1.9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最大练习子序列和"><span class="toc-number">1.9.1.</span> <span class="toc-text">最大练习子序列和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题"><span class="toc-number">1.9.2.</span> <span class="toc-text">0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长不下降子序列"><span class="toc-number">1.9.3.</span> <span class="toc-text">最长不下降子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长公共子序列（LCS）"><span class="toc-number">1.9.4.</span> <span class="toc-text">最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最长回文字串"><span class="toc-number">1.9.5.</span> <span class="toc-text">最长回文字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连续子数组的最大和"><span class="toc-number">1.9.6.</span> <span class="toc-text">连续子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现简单的正则表达式匹配"><span class="toc-number">1.9.7.</span> <span class="toc-text">实现简单的正则表达式匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#计算机网络"><span class="toc-number">2.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI参考模型"><span class="toc-number">2.1.</span> <span class="toc-text">OSI参考模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP模型"><span class="toc-number">2.2.</span> <span class="toc-text">TCP/IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#网络层"><span class="toc-number">2.2.1.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV4地址"><span class="toc-number">2.2.2.</span> <span class="toc-text">IPV4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#子网掩码"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">子网掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CIDR无分类编址"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">CIDR无分类编址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP、ARP、RARP"><span class="toc-number">2.2.3.</span> <span class="toc-text">ICMP、ARP、RARP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV6"><span class="toc-number">2.2.4.</span> <span class="toc-text">IPV6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#传输层"><span class="toc-number">2.2.5.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP连接的建立和终止"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">TCP连接的建立和终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket的基本操作（TCP）"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">Socket的基本操作（TCP）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用层"><span class="toc-number">2.2.6.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP协议"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">HTTP协议</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">3.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程和线程"><span class="toc-number">3.1.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调度算法"><span class="toc-number">3.1.1.</span> <span class="toc-text">调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">3.1.2.</span> <span class="toc-text">死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理"><span class="toc-number">3.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配管理方式"><span class="toc-number">3.2.1.</span> <span class="toc-text">内存分配管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存管理"><span class="toc-number">3.2.2.</span> <span class="toc-text">虚拟内存管理</span></a></li></ol></li></ol></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/01/计算机基础知识/" data-title="计算机基础知识总结" data-url="http://peilinghui.com/2016/03/01/计算机基础知识/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/03/04/iOS中的多线程网络/" title="上一篇: iOS中的多线程网络">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/03/01/iOS面试题总结/" title="下一篇: iOS面试题总结">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/二维码/">二维码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习Runtime/">深入学习Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习GCD/">深入学习GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转 </a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/深入学习Block/">深入学习Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/深入理解内存管理/">深入理解内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/27/iOS面试题/">iOS面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/研究AFNetworking框架/">研究AFNetworking框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/iOS面试题总结/">iOS面试题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>