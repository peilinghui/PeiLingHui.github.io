<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>研究SDWebImage框架 | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
<meta property="og:type" content="article">
<meta property="og:title" content="研究SDWebImage框架">
<meta property="og:url" content="http://peilinghui.com/2016/03/06/研究SDWebImage框架/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/1.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-05%20%E4%B8%8B%E5%8D%884.00.43.png">
<meta property="og:updated_time" content="2017-03-07T02:50:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="研究SDWebImage框架">
<meta name="twitter:description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js" type="text/javascript"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/OC/" style="font-size: 10px;">OC</a> <a href="/tags/RAC-学习笔记/" style="font-size: 10px;">RAC,学习笔记</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/iOS面试/" style="font-size: 10px;">iOS面试</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/学习笔记/" style="font-size: 10px;">学习笔记</a> <a href="/tags/读书笔记/" style="font-size: 20px;">读书笔记</a> <a href="/tags/面试/" style="font-size: 20px;">面试</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-研究SDWebImage框架" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/06/研究SDWebImage框架/" class="article-date">
      <time datetime="2016-03-06T06:08:53.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      研究SDWebImage框架
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>研究SDWebImage框架.<a href="http://github.com/rs/SDWebImage" target="_blank" rel="external">http://github.com/rs/SDWebImage</a>是个支持异步下载与缓存的UIImageView扩展。<br>参考文档：<a href="http://cocoadocs.org/docsets/SDWebImage/4.0.0/" target="_blank" rel="external">http://cocoadocs.org/docsets/SDWebImage/4.0.0/</a></p>
<a id="more"></a>
<p>项目结构：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/1.png" alt=""></p>
<pre><code>SDWebImageDownloader负责管理图片的下载队列；
SDWebImageDownloaderOperation负责真正的单一的图片下载请求；
SDImageCache负责图片的缓存（内存缓存和磁盘缓存）；
SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;
SDWebImageDecoder负责图片的解压缩；
SDWebImagePrefetcher负责图片的预取；
UIImageView+WebCache和其他的扩展都是与用户直接打交道的。
</code></pre><p>项目整体架构：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-05%20%E4%B8%8B%E5%8D%884.00.43.png" alt=""></p>
<p>UIImageView+WebCache和UIButton+WebCache直接为表层的 UIKit框架提供接口, 而 SDWebImageManger负责处理和协调SDWebImageDownloader和SDWebImageCache, 并与 UIKit层进行交互。SDWebImageDownloaderOperation真正执行下载请求；最底层的两个类为高层抽象提供支持。</p>
<h2 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a>UIImageView+WebCache</h2><p>集成SDWebImage异步下载和使用的UIImageView远程图像缓存。<br>最常使用的方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder &#123;</span><br><span class="line">    [self <span class="string">sd_setImageWithURL:</span>url <span class="string">placeholderImage:</span>placeholder <span class="string">options:</span><span class="number">0</span> <span class="string">progress:</span>nil <span class="string">completed:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栗子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:MyIdentifier]</span><br><span class="line">                 autorelease];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [cell<span class="variable">.imageView</span> sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/image.jpg"</span>]</span><br><span class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>]];</span><br><span class="line"> </span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = <span class="string">@"My Text"</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的场景是已知图片的url地址，来下载图片并设置到UIImageView上。UIImageView+WebCache提供了一系列的接口:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options completed:<span class="params">(<span class="variable">SDWebImageCompletedBlock</span>)</span>completedBlock;</span></span><br></pre></td></tr></table></figure>
<p>这些接口最终会调用</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pp">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url placeholderImage:<span class="params">(<span class="variable">UIImage</span> *)</span>placeholder options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageCompletionBlock</span>)</span>completedBlock；</span></span><br></pre></td></tr></table></figure>
<p>方法的第一行代码[self sd_cancelCurrentImageLoad]是取消UIImageView上当前正在进行的异步下载，确保每个 UIImageView 对象中永远只存在一个 operation，当前只允许一个图片网络请求，该 operation 负责从缓存中获取 image 或者是重新下载 image。具体执行代码是：UIView+WebCacheOperation中<br><code>- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key</code>的方法,实际上，所有操作都是由一个operationDictionary字典维护的,<strong>执行新的操作之前，先cancel所有的operation</strong>。这里的cancel是SDWebImageOperation协议里面定义的。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            self.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是一种占位图策略，作为图片下载完成之前的替代图片。dispatch_main_async_safe是一个宏，保证在主线程安全执行.</p>
<p>然后判断url，url为空就直接调用完成回调，报告错误信息；<br>url不为空，用SDWebImageManager单例sharedManager的方法：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// <span class="variable">SDWebImageManager</span>是将<span class="variable">UIImageView</span>+<span class="variable">WebCache</span>同<span class="variable">SDImageCache</span>链接起来的</span><br><span class="line"><span class="pp">- <span class="params">(id &lt;<span class="variable">SDWebImageOperation</span>&gt;)</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url</span><br><span class="line">                                         options:<span class="params">(<span class="variable">SDWebImageOptions</span>)</span>options</span><br><span class="line">                                        progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock</span><br><span class="line">                                       completed:<span class="params">(<span class="variable">SDWebImageCompletionWithFinishedBlock</span>)</span>completedBlock</span><br><span class="line">```                                      </span><br><span class="line">方法下载图片</span>.下载完成后刷新<span class="variable">UIImageView</span>的图片</span><br></pre></td></tr></table></figure>
<p>//图像的绘制只能在主线程完成<br>dispatch_main_sync_safe(^{<br>        if (!wself) return;<br>        if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)<br>         {//延迟设置图片，手动处理<br>           completedBlock(image, error, cacheType, url);<br>            return;<br>         }<br>          else if (image) {<br>            //直接设置图片<br>         wself.image = image;<br>         [wself setNeedsLayout];<br>         } else {<br>         //image== nil,设置占位图<br>          if ((options &amp; SDWebImageDelayPlaceholder)) {<br>         wself.image = placeholder;<br>         [wself setNeedsLayout];<br>           }<br>       }<br>   if (completedBlock &amp;&amp; finished) {<br>    completedBlock(image, error, cacheType, url);<br>                }<br>            });<br>}];</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最后，把返回的<span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation添加到operationDictionary中，方便后续的cancel。(<span class="built_in">UIView</span>+WebCacheOperation方法中的)</span><br><span class="line">`[<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];`                                    </span><br><span class="line">                                     </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### UIView+WebCacheOperation</span></span><br><span class="line">方法：</span><br></pre></td></tr></table></figure>
<ul>
<li>(void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key;</li>
<li>(void)sd_cancelImageLoadOperationWithKey:(NSString *)key;</li>
<li>(void)sd_removeImageLoadOperationWithKey:(NSString *)key;<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">具体的实现是使用runtime的objc_associate方法给UIView绑定了一个属性，这个属性的<span class="variable">key</span>是<span class="keyword">static</span> <span class="built_in">char</span> loadOperationKey的地址,</span><br><span class="line">这个属性是NSMutableDictionary类型，value为操作，<span class="variable">key</span>是针对不同类型的视图和不同类型的操作设定的字符串。这个<span class="variable">key</span>值是用来存储和识别队列的。</span><br><span class="line"></span><br><span class="line">为什么要使用<span class="keyword">static</span> <span class="built_in">char</span> loadOperationKey的地址作为属性的<span class="variable">key</span>，实际上很多第三方框架在给类绑定属性的时候都会使用这种方案(如AFN)，这样做有以下几个好处：</span><br><span class="line"></span><br><span class="line">	<span class="number">1.</span>占用空间小，只有一个字节。</span><br><span class="line">	<span class="number">2.</span>静态变量，地址不会改变，使用地址作为<span class="variable">key</span>总是唯一的且不变的。</span><br><span class="line">	<span class="number">3.</span>避免和其他框架定义的<span class="variable">key</span>重复，或者其他<span class="variable">key</span>将其覆盖的情况。比如在其他文件(仍然是UIView的分类)中定义了同名同值的<span class="variable">key</span>，使用objc_setAssociatedObject进行设置绑定的属性的时候，可能会将在别的文件中设置的属性值覆盖。</span><br><span class="line"></span><br><span class="line">## SDWebImageManager</span><br><span class="line">SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.</span><br><span class="line">SDWebImageManager.h首先定义了一些枚举类型的SDWebImageOptions。参考&lt;http:<span class="comment">//www.jianshu.com/p/6ae6f99b6c4c#&gt;</span></span><br><span class="line"></span><br><span class="line">然后声明了三个Block：</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>//操作完成的回调，被上层的扩展调用。<br>typedef void(^SDWebImageCompletionBlock)(UIImage <em>image, NSError </em>error, SDImageCacheType cacheType, NSURL <em>imageURL);<br>//被SDWebImageManager调用。如果使用了SDWebImageProgressiveDownload标记，这个block可能会被重复调用，直到图片完全下载结束，finished=true,再最后调用一次这个block。<br>typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage </em>image, NSError <em>error, SDImageCacheType cacheType, BOOL finished, NSURL </em>imageURL);<br>//SDWebImageManager每次把URL转换为cache key的时候调用，可以删除一些image URL中的动态部分。<br>typedef NSString <em>(^SDWebImageCacheKeyFilterBlock)(NSURL </em>url);<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">定义了SDWebImageManagerDelegate协议：</span><br></pre></td></tr></table></figure></p>
<p>@protocol SDWebImageManagerDelegate <nsobject><br>@optional<br>/<em>
 </em>主要作用是当缓存里没有发现某张图片的缓存时,是否选择下载这张图片(默认是yes),可以选择no,那么sdwebimage在缓存中没有找到这张图片的时候不会选择下载<br> */</nsobject></p>
<ul>
<li>(BOOL)imageManager:(SDWebImageManager <em>)imageManager shouldDownloadImageForURL:(NSURL </em>)imageURL;<br>/<em>*
</em>在图片下载完成并且还没有加入磁盘缓存或者内存缓存的时候就transform这个图片.这个方法是在异步线程执行的,防治阻塞主线程.<br><em>至于为什么在异步执行很简单,对一张图片纠正方向(也就是transform)是很耗资源的,一张2M大小的图片纠正方向你可以用instrument测试一下耗时.很恐怖
</em>/</li>
<li>(UIImage <em>)imageManager:(SDWebImageManager </em>)imageManager transformDownloadedImage:(UIImage <em>)image withURL:(NSURL </em>)imageURL;</li>
</ul>
<p>@end<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SDWebImageManager是单例使用的，分别维护了一个SDImageCache实例和一个SDWebImageDownloader实例。</span><br></pre></td></tr></table></figure></p>
<p>@property (strong, nonatomic, readonly) SDImageCache <em>imageCache;<br>@property (strong, nonatomic, readonly) SDWebImageDownloader </em>imageDownloader;<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">再有一个<span class="keyword">Block</span></span><br><span class="line">`@property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter;`这个<span class="keyword">Block</span>的作用是需要把一个<span class="keyword">URL</span>转换成一个cache key,这个能被用来移除掉图片<span class="keyword">URL</span>的一部分。</span><br><span class="line"></span><br><span class="line">方法：</span><br></pre></td></tr></table></figure></p>
<p>//初始化SDWebImageManager单例</p>
<ul>
<li>(SDWebImageManager *)sharedManager;<br>//下载图片</li>
</ul>
<ul>
<li>(id <sdwebimageoperation>)downloadImageWithURL:(NSURL *)url<pre><code>  options:(SDWebImageOptions)options
 progress:(SDWebImageDownloaderProgressBlock)progressBlock
completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;
</code></pre>//缓存给定URL的图片</sdwebimageoperation></li>
<li>(void)saveImageToCache:(UIImage <em>)image forURL:(NSURL </em>)url;<br>//取消当前所有的操作</li>
<li>(void)cancelAll;<br>//监测当前是否有进行中的操作</li>
<li>(BOOL)isRunning;<br>//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</li>
<li>(BOOL)cachedImageExistsForURL:(NSURL *)url;<br>//监测图片是否缓存在disk里</li>
<li>(BOOL)diskImageExistsForURL:(NSURL *)url;<br>//监测图片是否在缓存中,监测结束后调用completionBlock,仍在主队列</li>
<li>(void)cachedImageExistsForURL:(NSURL *)url<pre><code>completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
</code></pre>//监测图片是否缓存在disk里,监测结束后调用completionBlock</li>
<li>(void)diskImageExistsForURL:(NSURL *)url<pre><code>completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;
</code></pre>//返回给定URL的cache key</li>
<li>(NSString <em>)cacheKeyForURL:(NSURL </em>)url;<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们主要研究第二个：下载图片</span><br><span class="line">首先，判断 url 的合法性。</span><br><span class="line">第一个判断条件是防止很多用户直接传递<span class="built_in">NSString</span>作为<span class="built_in">NSURL</span>导致的错误，第二个判断条件防止crash。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>if ([url isKindOfClass:NSString.class]) {<br>        url = [NSURL URLWithString:(NSString *)url];<br>    }<br>// Prevents app crashing on argument type error like sending NSNull instead of NSURL<br>if (![url isKindOfClass:NSURL.class]) {<br>        url = nil;<br>    }<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再新建了SDWebImageCombinedOperation</span><br></pre></td></tr></table></figure></p>
<p>if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) {<br>        dispatch_main_sync_safe(^{<br>            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];<br>            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);<br>        });<br>        return operation;<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">集合failedURLs保存之前失败的urls，如果url为空或者url之前失败过且不采用重试策略，直接调用completedBlock返回错误。</span><br></pre></td></tr></table></figure></p>
<p>@synchronized (self.runningOperations) {<br>        [self.runningOperations addObject:operation];<br>}<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runningOperations是一个可变数组，保存所有的operation，主要用来监测是否有operation在执行，即判断<span class="property">running</span> 状态。</span><br></pre></td></tr></table></figure></p>
<p>// 根据 URL 生成对应的 key，没有特殊处理为 [url absoluteString];<br>NSString <em>key = [self cacheKeyForURL:url];<br>// 去缓存中查找图片（参见 SDImageCache）先在memory以及disk的cache中查找是否下载过相同的照片<br>operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage </em>image, SDImageCacheType cacheType) {<br>    if (operation.isCancelled) {<br>            @synchronized (self.runningOperations) {<br>                [self.runningOperations removeObject:operation];<br>            }<br>    return;<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span><span class="keyword">*</span>如果在缓存中找到图片<span class="keyword">*</span><span class="keyword">*</span>，直接调用completedBlock，第一个参数是缓存的image。`completedBlock(image, nil, cacheType, YES, url);`</span><br><span class="line">下面方法：</span><br></pre></td></tr></table></figure></p>
<p>if (image) {<br>         // 在缓存中找到图片了，直接返回<br>       dispatch_main_sync_safe(^{<br>                <strong>strong </strong>typeof(weakOperation) strongOperation = weakOperation;<br>        if (strongOperation &amp;&amp; !strongOperation.isCancelled) {<br>         completedBlock(image, nil, cacheType, YES, url);<br>         }<br>     });<br>        @synchronized (self.runningOperations) {<br>             [self.runningOperations removeObject:operation];<br>            }<br>    }<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**如果没有在缓存中找到图片**，或者不管是否找到图片，只要operation有<span class="variable">SDWebImageRefreshCached</span>标记，那么若<span class="variable">SDWebImageManagerDelegate</span>的should<span class="variable">DownloadImageForURL</span>方法返回<span class="literal">true</span>，即允许下载时，都使用 image<span class="variable">Downloader</span> 的(<span class="variable">SDWebImageDownloader</span>)</span><br><span class="line"></span><br><span class="line">`</span><br><span class="line"><span class="pp">- <span class="params">(id &lt;<span class="variable">SDWebImageOperation</span>&gt;)</span>downloadImageWithURL:<span class="params">(<span class="variable">NSURL</span> *)</span>url options:<span class="params">(<span class="variable">SDWebImageDownloaderOptions</span>)</span>options progress:<span class="params">(<span class="variable">SDWebImageDownloaderProgressBlock</span>)</span>progressBlock completed:<span class="params">(<span class="variable">SDWebImageDownloaderCompletedBlock</span>)</span>completedBlock`</span><br><span class="line">方法下载。如果操作队列取消则什么都不做，若发生错误，则直接调用completedBlock返回错误，并且视情况将url添加到failedURLs里面；</span></span><br></pre></td></tr></table></figure></p>
<p> if (error) {<br>                    dispatch_main_sync_safe(^{<br>                        if (strongOperation &amp;&amp; !strongOperation.isCancelled) {<br>                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);<br>                        }<br>                    });</p>
<pre><code>    if (   error.code != NSURLErrorNotConnectedToInternet
        &amp;&amp; error.code != NSURLErrorCancelled
        &amp;&amp; error.code != NSURLErrorTimedOut
        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff
        &amp;&amp; error.code != NSURLErrorDataNotAllowed
        &amp;&amp; error.code != NSURLErrorCannotFindHost
        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) {
        @synchronized (self.failedURLs) {
            [self.failedURLs addObject:url];
        }
    }
}
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若下载成功：</span><br><span class="line"></span><br><span class="line">若支持失败重试，将url从failURLs里删除：</span><br></pre></td></tr></table></figure>
<p>if ((options &amp; SDWebImageRetryFailed)) {<br>    @synchronized (self.failedURLs) {<br>         [self.failedURLs removeObject:url];<br>    }<br>}<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果delegate实现了<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>的方法，图片在缓存之前，需要做转换（在全局队列中调用，不阻塞主线程）。转化成功切下载全部结束，图片存入缓存，调用completedBlock回调，第一个参数是转换后的image。</span><br></pre></td></tr></table></figure></p>
<p>if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) {<br>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{<br>     UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];<br>      if (transformedImage &amp;&amp; finished) {<br>            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];<br>            [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];<br>           }<br>    dispatch_main_sync_safe(^{<br>      if (strongOperation &amp;&amp; !strongOperation.isCancelled) {<br>              completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);<br>            }<br>          });<br>   });<br>}<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">否则：直接存入缓存<span class="comment">(SDImageCache中的</span><br><span class="line">`- (void)</span>storeImage:<span class="comment">(UIImage *)</span>image recalculateFromImage:<span class="comment">(BOOL)</span>recalculate imageData:<span class="comment">(NSData *)</span>imageData forKey:<span class="comment">(NSString *)</span>key toDisk:<span class="comment">(BOOL)</span>toDisk`方法)，调用completedBlock回调，第一个参数是下载的原始image。</span><br></pre></td></tr></table></figure></p>
<p>if (downloadedImage &amp;&amp; finished) {<br>    [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];<br>}</p>
<p>dispatch_main_sync_safe(^{<br>    if (strongOperation &amp;&amp; !strongOperation.isCancelled) {<br>        completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);<br>    }<br>});<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后一种情况是：图片不在缓存中也不允许下载，直接调用completedBlock，第一个参数为<span class="literal">nil</span>。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_main_sync_safe(^{<br>    <strong>strong </strong>typeof(weakOperation) strongOperation = weakOperation;<br>    if (strongOperation &amp;&amp; !weakOperation.isCancelled) {//为啥这里用weakOperation TODO<br>        completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);<br>    }<br>});</p>
<p>//最后都要将这个operation从runningOperations里删除。</p>
<p>@synchronized (self.runningOperations) {<br>    [self.runningOperations removeObject:operation];<br> }<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="objectivec"><span class="preprocessor">## Downloader</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### SDWebImageDownloader</span></span><br><span class="line"></span><br><span class="line">**Asynchronous downloader dedicated and optimized <span class="keyword">for</span> image loading.专用的并且优化的图片异步下载器.**</span><br><span class="line">这个类的核心功能就是下载图片.</span><br><span class="line">定义了枚举类型：SDWebImageDownloaderOptions下载的选项和SDWebImageDownloaderExecutionOrder执行顺序,  </span><br><span class="line"></span><br><span class="line">	 <span class="comment">//默认的下载顺序，先进先出</span></span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    <span class="comment">//后进先出</span></span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line"></span><br><span class="line">开始下载和结束下载的通知的<span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span>的全局变量定义。  </span><br><span class="line">三个Block：</span></span><br></pre></td></tr></table></figure></p>
<p>// 下载进度回调(返回已经接收的图片数据的大小,未接收的图片数据的大小)<br>typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);<br>// 下载完成回调，返回图片数据或错误<br>typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage <em>image, NSData </em>data, NSError <em>error, BOOL finished);<br>//过滤HTTP请求的Header<br>typedef NSDictionary </em>(^SDWebImageDownloaderHeadersFilterBlock)(NSURL <em>url, NSDictionary </em>headers);<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性：</span><br><span class="line">是否应该压缩图片，最大并发下载数，当前下载量，下载队列的时长(默认<span class="number">15</span>s)，下载队列执行顺序，对于请求队列设置默认的URL证书，设置用户名，设置密码，设置过滤HTTP请求的header。  </span><br><span class="line">类方法：</span><br></pre></td></tr></table></figure></p>
<p>//给每个HTTP下载请求头的指定field设置值。</p>
<ul>
<li>(void)setValue:(NSString <em>)value forHTTPHeaderField:(NSString </em>)field;<br>//返回HTTP特定field的值</li>
<li>(NSString <em>)valueForHTTPHeaderField:(NSString </em>)field;<br>//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</li>
<li>(void)setOperationClass:(Class)operationClass;<br>//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</li>
<li>(id <sdwebimageoperation>)downloadImageWithURL:(NSURL *)url<pre><code>  options:(SDWebImageDownloaderOptions)options
 progress:(SDWebImageDownloaderProgressBlock)progressBlock
completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
</code></pre>// 设置下载队列为挂起状态</sdwebimageoperation></li>
<li>(void)setSuspended:(BOOL)suspended;<br>//取消队列中的所有操作。</li>
<li><p>(void)cancelAllDownloads;</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="objectivec"></span><br><span class="line">SDWebImageDownloader 下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个 <span class="built_in">NSOperationQueue</span> 操作队列中来完成的，`<span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;`默认最大的并行操作个数是<span class="number">6</span>。队列中每一个SDWebImageDownloaderOperation实例才是真正的下载请求执行者。</span><br><span class="line">我们重点研究核心下载方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>(id <sdwebimageoperation>)downloadImageWithURL:(NSURL *)url</sdwebimageoperation></p>
<pre><code>  options:(SDWebImageDownloaderOptions)options
 progress:(SDWebImageDownloaderProgressBlock)progressBlock
completed:(SDWebImageDownloaderCompletedBlock)completedBlock;
</code></pre><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个方法实际上就是调用了另外一个关键方法：</span><br></pre></td></tr></table></figure>
</li>
<li><p>(void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock </p>
<pre><code>completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock 
         forURL:(NSURL *)url 
 createCallback:(SDWebImageNoParamsBlock)createCallback {
</code></pre><p>  // url作为URLCallbacks的key，如果为nil ,直接调用completedBlock。<br>  if (url == nil) {</p>
<pre><code>if (completedBlock != nil) {
    completedBlock(nil, nil, nil, NO);
}
return;
</code></pre><p>  }<br>  //将所有下载任务的网络响应处理放到barrierQueue队列中。<br>  //并设置栅栏来确保同一时间只有一个线程操作URLCallbacks属性<br>  dispatch_barrier_sync(self.barrierQueue, ^{</p>
<pre><code>BOOL first = NO;
if (!self.URLCallbacks[url]) {
    self.URLCallbacks[url] = [NSMutableArray new];
    first = YES;
}

// Handle single download of simultaneous download request for the same URL
//修改url对应的URLCallbacks
//URLCallbacks是一个字典: key是url, value是数组
//数组的元素是字典，key是callback类型字符串，value是callback的block
NSMutableArray *callbacksForURL = self.URLCallbacks[url];
NSMutableDictionary *callbacks = [NSMutableDictionary new];
if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];
if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];
[callbacksForURL addObject:callbacks];
self.URLCallbacks[url] = callbacksForURL;
//第一次请求这个url 才去真正做http请求
if (first) {
    createCallback();
}
</code></pre><p>  });<br>}</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该方法为下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作。图片下载的progressBlock和completedBlock回调由一个字典URLCallbacks管理。字典的<span class="built_in">key</span>是图片的url，<span class="built_in">value</span> 是一个数组，数组只包含一个元素,这个元素的类型是NSMutableDictionary类型,这个字典的<span class="built_in">key</span>为NSString类型代表着回调类型,<span class="built_in">value</span>为block,是对应的回调。由于允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证线程安全，将下载操作作为一个个任务放到barrierQueue队列中，并设置栅栏来确保同一时间只有一个线程操作URLCallbacks属性</span><br><span class="line">两个回调对应的<span class="built_in">key</span>分别是</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>static NSString <em>const kProgressCallbackKey = @”progress”;<br>static NSString </em>const kCompletedCallbackKey = @”completed”;<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了去阻止潜在的重复的缓存（NSURLCache和SDWebCache缓存），如果有一种缓存我们不能去请求缓存</span></span><br></pre></td></tr></table></figure></p>
<p>NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];<br>request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);<br>request.HTTPShouldUsePipelining = YES;<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果URLCallbacks没有url这个<span class="variable">key</span>，说明是第一次请求这个url，需要调用createCallback创建下载任务，即使用</span><br></pre></td></tr></table></figure></p>
<ul>
<li>(id)initWithRequest:(NSURLRequest *)request<pre><code>inSession:(NSURLSession *)session
  options:(SDWebImageDownloaderOptions)options
 progress:(SDWebImageDownloaderProgressBlock)progressBlock
completed:(SDWebImageDownloaderCompletedBlock)completedBlock
cancelled:(SDWebImageNoParamsBlock)cancelBlock
</code></pre></li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用这个方法后的progressBlock是：对已经接收到的大小和期待的大小调用<span class="keyword">callback</span>；</span><br></pre></td></tr></table></figure>
<p>SDWebImageDownloader <em>sself = wself;<br>if (!sself) return;<br>__block NSArray </em>callbacksForURL;<br>dispatch_sync(sself.barrierQueue, ^{<br>    callbacksForURL = [sself.URLCallbacks[url] copy];<br>});<br>for (NSDictionary *callbacks in callbacksForURL) {<br>    //异步提交， 当前线程直接返回<br>    //callbacks在main_queue中并行执行<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];<br>        if (callback)<br>            callback(receivedSize, expectedSize);<br>    });<br>}</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">completedBlock</span>是,对image和<span class="typedef"><span class="keyword">data</span>调用callback,在completed block中我们取出存储在<span class="type">URLCallbacks</span>中的completedBlock.</span></span><br></pre></td></tr></table></figure>
<p>SDWebImageDownloader <em>sself = wself;<br>if (!sself) return;<br>__block NSArray </em>callbacksForURL;<br>dispatch_barrier_sync(sself.barrierQueue, ^{<br>    callbacksForURL = [sself.URLCallbacks[url] copy];<br>    if (finished) {<br>        [sself.URLCallbacks removeObjectForKey:url];<br>    }<br> });<br>for (NSDictionary *callbacks in callbacksForURL) {<br>    SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];<br>    if (callback)<br>        callback(image, data, error, finished);<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cancelBlock是：我们移除存储在URLCallbacks的数组。</span><br></pre></td></tr></table></figure></p>
<p> SDWebImageDownloader *sself = wself;<br> if (!sself) return;<br> dispatch_barrier_async(sself.barrierQueue, ^{<br>             [sself.URLCallbacks removeObjectForKey:url];<br>    });<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来：</span><br></pre></td></tr></table></figure></p>
<p>//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO。<br>operation.shouldDecompressImages = wself.shouldDecompressImages;<br>//设置证书<br>if (wself.urlCredential) {<br>      operation.credential = wself.urlCredential;<br>    } else if (wself.username &amp;&amp; wself.password) {<br> operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];<br>        }<br>        //设置队列优先级<br>        if (options &amp; SDWebImageDownloaderHighPriority) {<br>            operation.queuePriority = NSOperationQueuePriorityHigh;<br>        } else if (options &amp; SDWebImageDownloaderLowPriority) {<br>            operation.queuePriority = NSOperationQueuePriorityLow;<br>        }<br>        //加入操作队列后， operation 真正开始执行start<br>        //所有的下载任务放在downloadQueue队列中.<br>        [wself.downloadQueue addOperation:operation];<br>        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) {</p>
<pre><code>        //若果是LIFO的下载执行顺序，还要加上任务的依赖，也就是说依赖的任务都完成后，才能执行当前任务
        [wself.lastAddedOperation addDependency:operation];
        wself.lastAddedOperation = operation;
    }
}];
</code></pre><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="livecodeserver"><span class="comment">### SDWebImageDownloaderOperation</span></span><br><span class="line">SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageOperation&gt;是NSOperation的子类，遵循SDWebImageDownloaderOperationInterface, SDWebImageOperation, NSURLSessionTaskDelegate, NSURLSessionDataDelegate协议，并重写了<span class="built_in">start</span>方法。在<span class="built_in">start</span>方法中真正处理HTTP请求和<span class="built_in">URL</span>链接。</span><br><span class="line">看一下<span class="built_in">start</span>方法：首先检测下载状态：</span></span><br></pre></td></tr></table></figure>
<p>//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES<br>if (self.isCancelled) {<br>    self.finished = YES;<br>    [self reset];<br>    return;<br>}<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是iOS4<span class="number">.0</span>以上的版本，还需要考虑是否在后台执行：</span><br></pre></td></tr></table></figure></p>
<p>Class UIApplicationClass = NSClassFromString(@”UIApplication”);<br>BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];<br>if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) {<br>    //如果设置了在后台执行，则进行后台执行<br>     <strong>weak </strong>typeof<strong> (self) wself = self;<br>    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];<br>    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^{<br>        // 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务
        </strong>strong __typeof (wself) sself = wself;<br>        if (sself) {<br>            [sself cancel];<br>            [app endBackgroundTask:sself.backgroundTaskId];<br>            sself.backgroundTaskId = UIBackgroundTaskInvalid;<br>        }<br>    }];<br>｝<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>Version3.8中，下载已经由原先的NSURLConnection切换到了NSURLSession了:<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">创建好任务后开始执行请求。 如果任务创建成功，可能需要调用progressBlock回调并发送下载开始的通知；如果创建失败，直接执行完成回调,并传递一个connection没有初始化的错误：</span><br></pre></td></tr></table></figure></p>
<p>NSURLSession <em>session = self.unownedSession;<br>if (!self.unownedSession) {<br>    NSURLSessionConfiguration </em>sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];<br>    sessionConfig.timeoutIntervalForRequest = 15;<br>    //为任务创建会话，我们给delegateQueue设置nil来创建一个顺序操作队列去执行所有的代理方法和完成回调。<br>    self.ownedSession = [NSURLSession sessionWithConfiguration:sessionConfig<br>                                                      delegate:self<br>                                                 delegateQueue:nil];<br>    session = self.ownedSession;<br>}<br>self.dataTask = [session dataTaskWithRequest:self.request];<br>self.executing = YES;<br>//开启任务<br>[self.dataTask resume];<br>if (self.dataTask) {<br>    if (self.progressBlock) {<br>        self.progressBlock(0, NSURLResponseUnknownLength);<br>    }<br>    dispatch_async(dispatch_get_main_queue(), ^{<br>        // 在主线程中发送开始下载的通知<br>        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];<br>     });<br>} else {<br>    //如果session创建失败,直接执行完成回调,并传递一个connection没有初始化的错误<br>    if (self.completedBlock) {<br>        self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@{NSLocalizedDescriptionKey : @”Connection can’t be initialized”}], YES);<br>    }<br>}<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">任务开始后，我们需要关注NSURLSessionDataDelegate的几个代理方法。另外还有NSURLSessionTaskDelegate的两个代理方法:</span><br><span class="line"></span><br><span class="line">`NSString <span class="keyword">*</span>key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];`</span><br><span class="line">把URL作为Key值，</span><br><span class="line"></span><br><span class="line"><span class="comment">## SDImageCache</span></span><br><span class="line">SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.</span><br><span class="line">SDImageCache维持了一个内存缓存memCache和一个可选的磁盘缓存。同时，磁盘缓存的写操作是异步的，所以它不会对 UI 造成不必要的影响。  </span><br><span class="line"></span><br><span class="line"> 内存缓存是用NSCache实现的，以Key-Value的形式存储图片，当内存不够的时候会清除所有缓存图片。  </span><br><span class="line"> 磁盘缓存则是缓存到沙盒中，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。默认情况下，会将缓存保存在应用沙盒的cache/com.hackemist.SDWebImageCache.default中.</span><br><span class="line"> </span><br><span class="line"> `static const NSInteger kDefaultCacheMaxCacheAge = 60 <span class="keyword">*</span> 60 <span class="keyword">*</span> 24 <span class="keyword">*</span> 7; // 1 week`</span><br><span class="line"> </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>枚举<span class="keyword">*</span><span class="keyword">*</span>：缓存主要有不缓存，磁盘缓存、内存缓存。  </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>三个BLock<span class="keyword">*</span><span class="keyword">*</span>：请求完成，检查缓存完成，计算大小。</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>属性<span class="keyword">*</span><span class="keyword">*</span>：是否压缩图片(遇到崩溃因过度的内存消耗将它设置为NO),关闭iCloud云备份[默认为YES]，使用内存缓存[默认为YES]，最大内存成本，最大内存数量限制，最大内存周期，最大内存大小。  </span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>方法<span class="keyword">*</span><span class="keyword">*</span>：实例化，内存存储的使用空间，创建磁盘缓存的目录，添加只读缓存路径，添加只读路径，用key来存储图片到内存或磁盘缓存，用key存储图片到内存或可选的磁盘，同步查询内存\磁盘缓存，同步从内存和磁盘中移除图片，异步从内存和磁盘中移除图片，清理所有内存缓存图片，清理所有磁盘缓存图片，移除所有过期的缓存图片，通过磁盘缓存获得使用大小，获得磁盘缓存中图片的数量，异步计算磁盘缓存的大小，如果图片已经存在磁盘缓存中同步检查，检查如果图片已经在磁盘内存中存在则不要下载，对于特定的key获得缓存路径，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>重要方法：<span class="keyword">*</span><span class="keyword">*</span></span><br></pre></td></tr></table></figure></p>
<p>//将key对应的image存储到内存缓存和磁盘缓存中</p>
<ul>
<li>(void)storeImage:(UIImage <em>)image forKey:(NSString </em>)key;<br>//将key对应的image存储到内存缓存，是否同时存入磁盘中由参数toDisk决定</li>
<li>(void)storeImage:(UIImage <em>)image forKey:(NSString </em>)key toDisk:(BOOL)toDisk;<br>//功能同上，参数recalculate指明imageData是否可用或者应该从UIImage重新构造；参数imageData是由服务器返回，可以用于磁盘存储，这样可以避免将image转换为一个可存储/压缩的图片以节省CPU。</li>
<li>(void)storeImage:(UIImage <em>)image recalculateFromImage:(BOOL)recalculate imageData:(NSData </em>)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk;<br>//真正将key对应的image存储到磁盘缓存中</li>
<li>(void)storeImageDataToDisk:(NSData <em>)imageData forKey:(NSString </em>)key;<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个方法和第二个方法最终都会调用第三个方法，</span><br><span class="line"></span><br><span class="line">如果需要存储到memory <span class="keyword">cache</span>中，首先存入memcache。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>if (self.shouldCacheImagesInMemory) {<br>    NSUInteger cost = SDCacheCostForImage(image);<br>    [self.memCache setObject:image forKey:key cost:cost];<br>}<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果需要存储到disk <span class="keyword">cache</span>，在子线程中串行存储到disk <span class="keyword">cache</span>中：</span><br></pre></td></tr></table></figure></p>
<p>if (toDisk) {<br>        dispatch_async(self.ioQueue, ^{<br>        //串行队列io队列<br>            NSData *data = imageData;</p>
<pre><code>        if (!data &amp;&amp; image) {
            SDImageFormat imageFormatFromData = [NSData sd_imageFormatForImageData:data];
            data = [image sd_imageDataAsFormat:imageFormatFromData];
        }

        [self storeImageDataToDisk:data forKey:key];
        if (completionBlock) {
            dispatch_async(dispatch_get_main_queue(), ^{
                completionBlock();
            });
        }
    });
} else {
    if (completionBlock) {
        completionBlock();
    }
}
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. disk <span class="operator"><span class="keyword">cache</span>的文件名是<span class="keyword">key</span>做<span class="keyword">MD5</span>后的字符串：</span></span><br></pre></td></tr></table></figure>
<p>#pragma mark SDImageCache (private)</p>
<ul>
<li><p>(NSString <em>)cachedFileNameForKey:(NSString </em>)key {<br>  const char *str = [key UTF8String];<br>  if (str == NULL) {</p>
<pre><code>str = &quot;&quot;;
</code></pre><p>  }<br>  unsigned char r[CC_MD5_DIGEST_LENGTH];<br>  CC_MD5(str, (CC_LONG)strlen(str), r);<br>  NSString *filename = [NSString stringWithFormat:@”%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@”,</p>
<pre><code>r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],
r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];
</code></pre><p>  return filename;<br>}<br>```    </p>
</li>
</ul>
<ol>
<li><p>内存处理：当app接收到内存警告时，SDWebImage做了什么？</p>
<ul>
<li>SDWebImage会监听系统的UIApplicationDidReceiveMemoryWarningNotification通知，一旦收到通知，就会清理内存</li>
<li>应用程序将要终止的通知,UIApplicationWillTerminateNotification, 清理磁盘</li>
<li>应用程序进入后台的通知，UIApplicationDidEnterBackgroundNotification，也会后台清理磁盘</li>
</ul>
</li>
</ol>
<h4 id="NSData-ImageContentType-h"><a href="#NSData-ImageContentType-h" class="headerlink" title="NSData+ImageContentType.h"></a>NSData+ImageContentType.h</h4><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol>
<li>过程<br>1&gt;UIImageView+WebCache:  setImageWithURL:placeholderImage:options: <strong>先显示 placeholderImage ，同时由SDWebImageManager 根据 URL 来在本地查找图片。</strong></li>
</ol>
<p>2&gt;SDWebImageManager: downloadWithURL:delegate:options:userInfo: SDWebImageManager是将UIImageView+WebCache同SDImageCache链接起来的类， SDImageCache： queryDiskCacheForKey:delegate:userInfo:<strong>用来从缓存根据CacheKey查找图片是否已经在缓存中</strong></p>
<p>3&gt;如果内存中已经有图片缓存， SDWebImageManager会回调SDImageCacheDelegate : imageCache:didFindImage:forKey:userInfo:</p>
<p>4&gt;而 UIImageView+WebCache 则回调SDWebImageManagerDelegate:  webImageManager:didFinishWithImage:来显示图片。</p>
<p>5&gt;如果内存中没有图片缓存，那么生成 NSInvocationOperation 添加到队列，从硬盘查找图片是否已被下载缓存。</p>
<p>6&gt;根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</p>
<p>7&gt;如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</p>
<p>8&gt;如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。</p>
<p>9&gt;共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</p>
<p>10&gt;图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>11&gt;connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br>12&gt;connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>13&gt;图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>14&gt;在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br>15&gt;imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>16&gt;通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>17&gt;将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。<br>18&gt;写文件到硬盘在单独 NSInvocationOperation 中完成，避免拖慢主线程。<br>19&gt;如果是在iOS上运行，SDImageCache 在初始化的时候会注册notification 到 UIApplicationDidReceiveMemoryWarningNotification 以及  UIApplicationWillTerminateNotification,在内存警告的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>20&gt;SDWebImagePrefetcher 可以预先下载图片，方便后续使用</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年03月06日 - 14时08分</p>
        <p><span>最后更新:</span>2017年03月07日 - 10时50分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/03/06/研究SDWebImage框架/" title="研究SDWebImage框架">http://peilinghui.com/2016/03/06/研究SDWebImage框架/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/03/06/研究SDWebImage框架/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/03/14/ViewController的生命周期/">
                    ViewController的生命周期
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/03/05/研究AFNetworking框架/">
                    研究AFNetworking框架
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#UIImageView-WebCache"><span class="toc-number">1.</span> <span class="toc-text">UIImageView+WebCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NSData-ImageContentType-h"><span class="toc-number">1.0.1.</span> <span class="toc-text">NSData+ImageContentType.h</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题"><span class="toc-number"></span> <span class="toc-text">面试题</span></a>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/06/研究SDWebImage框架/" data-title="研究SDWebImage框架" data-url="http://peilinghui.com/2016/03/06/研究SDWebImage框架/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/03/14/ViewController的生命周期/" title="上一篇: ViewController的生命周期">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/03/05/研究AFNetworking框架/" title="下一篇: 研究AFNetworking框架">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/二维码/">二维码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习Runtime/">深入学习Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/深入学习GCD/">深入学习GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转 </a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/Objective-C高级编程读书笔记/">Objective-C高级编程读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/27/iOS面试题/">iOS面试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/研究SDWebImage框架/">研究SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/研究AFNetworking框架/">研究AFNetworking框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/iOS面试题总结/">iOS面试题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>