<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>SDWebImage框架 | 向着阳光奔跑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
<meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage框架">
<meta property="og:url" content="http://peilinghui.com/2016/03/06/SDWebImage框架/index.html">
<meta property="og:site_name" content="向着阳光奔跑">
<meta property="og:description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/1.png">
<meta property="og:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-05%20%E4%B8%8B%E5%8D%884.00.43.png">
<meta property="og:updated_time" content="2018-07-18T01:41:00.215Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SDWebImage框架">
<meta name="twitter:description" content="研究SDWebImage框架.http://github.com/rs/SDWebImage是个支持异步下载与缓存的UIImageView扩展。参考文档：http://cocoadocs.org/docsets/SDWebImage/4.0.0/">
<meta name="twitter:image" content="http://7xr8q7.com1.z0.glb.clouddn.com/1.png">
  
    <link rel="alternative" href="/atom.xml" title="向着阳光奔跑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  
</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/images/avatar.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">向阳</a></h1>
        </hgroup>

        
        <p class="header-subtitle">没有到不了的远方</p>
        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://lysongzi.com/">小松子</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/CHENYUFENG1991/article/category/5655903/4">iOS大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://cspilgrimzww.github.io/">蔚蔚</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.changhuiyuan.com/">惠源</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hxdavid.com/">PAT大神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://wut0719.github.io/">桐神</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pangjiuzala.github.io/">兴爷</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://han.pm/">交换生</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://frankhu.me">frank</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://judyzhangxin.com/">UI设计师</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://sunus.me/">阿里学长</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://imhuchao.com/">胡超-凤凰网</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.xuanzhangjiong.xyz/">囧囧囧-网易安卓</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">没有到不了的远方，向往远方。。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">向阳</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/images/avatar.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">向阳</a></h1>
            </hgroup>
            
            <p class="header-subtitle">没有到不了的远方</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="/peilinghuibest@gmail.com" title="Email"></a></li>
                            
                                <li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/575544059" title="新浪微博"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/peilinghui" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap"><article id="post-SDWebImage框架" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/06/SDWebImage框架/" class="article-date">
      <time datetime="2016-03-06T06:08:53.000Z" itemprop="datePublished">2016-03-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SDWebImage框架
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>研究SDWebImage框架.<a href="http://github.com/rs/SDWebImage" target="_blank" rel="noopener">http://github.com/rs/SDWebImage</a>是个支持异步下载与缓存的UIImageView扩展。<br>参考文档：<a href="http://cocoadocs.org/docsets/SDWebImage/4.0.0/" target="_blank" rel="noopener">http://cocoadocs.org/docsets/SDWebImage/4.0.0/</a></p>
<a id="more"></a>
<p>项目结构：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/1.png" alt></p>
<pre><code>SDWebImageDownloader负责管理图片的下载队列；
SDWebImageDownloaderOperation负责真正的单一的图片下载请求；
SDImageCache负责图片的缓存（内存缓存和磁盘缓存）；
SDWebImageManager是总的管理类，维护了一个SDWebImageDownloader实例和一个SDImageCache实例，是下载与缓存的桥梁;
SDWebImageDecoder负责图片的解压缩；
SDWebImagePrefetcher负责图片的预取；
UIImageView+WebCache和其他的扩展都是与用户直接打交道的。
</code></pre><p>项目整体架构：<br><img src="http://7xr8q7.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-05%20%E4%B8%8B%E5%8D%884.00.43.png" alt></p>
<p>UIImageView+WebCache和UIButton+WebCache直接为表层的 UIKit框架提供接口, 而 SDWebImageManger负责处理和协调SDWebImageDownloader和SDWebImageCache, 并与 UIKit层进行交互。SDWebImageDownloaderOperation真正执行下载请求；最底层的两个类为高层抽象提供支持。</p>
<h2 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a>UIImageView+WebCache</h2><p>集成SDWebImage异步下载和使用的UIImageView远程图像缓存。<br>最常使用的方法：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">sd_setImageWithURL:</span>(NSURL *)url <span class="string">placeholderImage:</span>(UIImage *)placeholder &#123;</span><br><span class="line">    [self <span class="string">sd_setImageWithURL:</span>url <span class="string">placeholderImage:</span>placeholder <span class="string">options:</span><span class="number">0</span> <span class="string">progress:</span>nil <span class="string">completed:</span>nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用栗子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:MyIdentifier]</span><br><span class="line">                 autorelease];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [cell.imageView sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/image.jpg"</span>]</span><br><span class="line">                      placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>]];</span><br><span class="line"> </span><br><span class="line">    cell.textLabel.text = <span class="string">@"My Text"</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的场景是已知图片的url地址，来下载图片并设置到UIImageView上。UIImageView+WebCache提供了一系列的接口:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder options:<span class="params">(SDWebImageOptions)</span>options;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url completed:<span class="params">(SDWebImageCompletedBlock)</span>completedBlock;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder completed:<span class="params">(SDWebImageCompletedBlock)</span>completedBlock;</span><br><span class="line">- <span class="params">(void)</span>setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder options:<span class="params">(SDWebImageOptions)</span>options completed:<span class="params">(SDWebImageCompletedBlock)</span>completedBlock;</span><br></pre></td></tr></table></figure>
<p>这些接口最终会调用</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sd_setImageWithURL:<span class="params">(NSURL *)</span>url placeholderImage:<span class="params">(UIImage *)</span>placeholder options:<span class="params">(SDWebImageOptions)</span>options progress:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock completed:<span class="params">(SDWebImageCompletionBlock)</span>completedBlock；</span><br></pre></td></tr></table></figure>
<p>方法的第一行代码[self sd_cancelCurrentImageLoad]是取消UIImageView上当前正在进行的异步下载，确保每个 UIImageView 对象中永远只存在一个 operation，当前只允许一个图片网络请求，该 operation 负责从缓存中获取 image 或者是重新下载 image。具体执行代码是：UIView+WebCacheOperation中<br><code>- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key</code>的方法,实际上，所有操作都是由一个operationDictionary字典维护的,<strong>执行新的操作之前，先cancel所有的operation</strong>。这里的cancel是SDWebImageOperation协议里面定义的。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        <span class="keyword">dispatch_main_async_safe(^&#123;</span></span><br><span class="line"><span class="keyword"> </span>           self.image = placeholder<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>是一种占位图策略，作为图片下载完成之前的替代图片。dispatch_main_async_safe是一个宏，保证在主线程安全执行.</p>
<p>然后判断url，url为空就直接调用完成回调，报告错误信息；<br>url不为空，用SDWebImageManager单例sharedManager的方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDWebImageManager是将UIImageView+WebCache同SDImageCache链接起来的</span></span><br><span class="line"><span class="selector-tag">-</span> (id &lt;SDWebImageOperation&gt;)<span class="selector-tag">downloadImageWithURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">url</span></span><br><span class="line">                                         <span class="selector-tag">options</span><span class="selector-pseudo">:(SDWebImageOptions)options</span></span><br><span class="line">                                        <span class="selector-tag">progress</span><span class="selector-pseudo">:(SDWebImageDownloaderProgressBlock)progressBlock</span></span><br><span class="line">                                       <span class="selector-tag">completed</span><span class="selector-pseudo">:(SDWebImageCompletionWithFinishedBlock)completedBlock</span></span><br></pre></td></tr></table></figure>
<p>上面方法下载图片.下载完成后刷新UIImageView的图片.</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图像的绘制只能在主线程完成</span></span><br><span class="line"> id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:nil completed:^(UIImage *<span class="keyword">image</span>, NSError *<span class="keyword">error</span>, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            __strong UIButton *sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">image</span> &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">            &#123;</span><br><span class="line">                completedBlock(<span class="keyword">image</span>, <span class="keyword">error</span>, cacheType, url);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">image</span>) &#123;</span><br><span class="line">                [sself setImage:<span class="keyword">image</span> forState:state];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                completedBlock(<span class="keyword">image</span>, <span class="keyword">error</span>, cacheType, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>最后，把返回的id <sdwebimageoperation> operation添加到operationDictionary中，方便后续的cancel。(UIView+WebCacheOperation方法中的)<br>[self sd_setImageLoadOperation:operation forKey:@”UIImageViewImageLoad”];                                  </sdwebimageoperation></p>
<h2 id="UIView-WebCacheOperation"><a href="#UIView-WebCacheOperation" class="headerlink" title="UIView+WebCacheOperation"></a>UIView+WebCacheOperation</h2><p>方法：<br><code>- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key;</code><br><code>- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key;</code><br><code>- (void)sd_removeImageLoadOperationWithKey:(NSString *)key;</code><br>具体的实现是使用runtime的objc_associate方法给UIView绑定了一个属性，这个属性的key是static char loadOperationKey的地址,<br>这个属性是NSMutableDictionary类型，value为操作，key是针对不同类型的视图和不同类型的操作设定的字符串。这个key值是用来存储和识别队列的。</p>
<p>为什么要使用static char loadOperationKey的地址作为属性的key，实际上很多第三方框架在给类绑定属性的时候都会使用这种方案(如AFN)，这样做有以下几个好处：</p>
<pre><code>1.占用空间小，只有一个字节。
2.静态变量，地址不会改变，使用地址作为key总是唯一的且不变的。
3.避免和其他框架定义的key重复，或者其他key将其覆盖的情况。比如在其他文件(仍然是UIView的分类)中定义了同名同值的key，使用objc_setAssociatedObject进行设置绑定的属性的时候，可能会将在别的文件中设置的属性值覆盖。
</code></pre><h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><p>SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.<br>SDWebImageManager.h首先定义了一些枚举类型的SDWebImageOptions。参考<a href="http://www.jianshu.com/p/6ae6f99b6c4c#" target="_blank" rel="noopener">http://www.jianshu.com/p/6ae6f99b6c4c#</a></p>
<p>然后声明了三个Block：<br><code>//操作完成的回调，被上层的扩展调用。
typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL);</code><br><code>//被SDWebImageManager调用。如果使用了SDWebImageProgressiveDownload标记，这个block可能会被重复调用，直到图片完全下载结束，finished=true,再最后调用一次这个block。
typedef void(^SDWebImageCompletionWithFinishedBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL);</code><br><code>//SDWebImageManager每次把URL转换为cache key的时候调用，可以删除一些image URL中的动态部分。
typedef NSString *(^SDWebImageCacheKeyFilterBlock)(NSURL *url);</code></p>
<p>定义了SDWebImageManagerDelegate协议：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *主要作用是当缓存里没有发现某张图片的缓存时,是否选择下载这张图片(默认是yes),可以选择no,那么sdwebimage在缓存中没有找到这张图片的时候不会选择下载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)<span class="attribute">imageManager</span>:(SDWebImageManager *)imageManager <span class="attribute">shouldDownloadImageForURL</span>:(NSURL *)imageURL;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在图片下载完成并且还没有加入磁盘缓存或者内存缓存的时候就transform这个图片.这个方法是在异步线程执行的,防治阻塞主线程.</span></span><br><span class="line"><span class="comment"> *至于为什么在异步执行很简单,对一张图片纠正方向(也就是transform)是很耗资源的,一张2M大小的图片纠正方向你可以用instrument测试一下耗时.很恐怖</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">-</span> (UIImage *)<span class="selector-tag">imageManager</span><span class="selector-pseudo">:(SDWebImageManager</span> *)<span class="selector-tag">imageManager</span> <span class="selector-tag">transformDownloadedImage</span><span class="selector-pseudo">:(UIImage</span> *)<span class="selector-tag">image</span> <span class="selector-tag">withURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">imageURL</span>;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure>
<p>SDWebImageManager是单例使用的，分别维护了一个SDImageCache实例和一个SDWebImageDownloader实例。</p>
<p><code>@property (strong, nonatomic, readonly) SDImageCache *imageCache;</code><br><code>@property (strong, nonatomic, readonly) SDWebImageDownloader *imageDownloader;</code></p>
<p>再有一个Block<br><code>@property (nonatomic, copy) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</code>这个Block的作用是需要把一个URL转换成一个cache key,这个能被用来移除掉图片URL的一部分。</p>
<p>方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化SDWebImageManager单例</span></span><br><span class="line">+ (SDWebImageManager *)sharedManager;</span><br><span class="line"><span class="comment">//下载图片</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock;</span><br><span class="line"><span class="comment">//缓存给定URL的图片</span></span><br><span class="line">- (<span class="keyword">void</span>)saveImageToCache:(<span class="built_in">UIImage</span> *)image forURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line"><span class="comment">//取消当前所有的操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAll;</span><br><span class="line"><span class="comment">//监测当前是否有进行中的操作</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRunning;</span><br><span class="line"><span class="comment">//监测图片是否在缓存中， 先在memory cache里面找  再到disk cache里面找</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line"><span class="comment">//监测图片是否缓存在disk里</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line"><span class="comment">//监测图片是否在缓存中,监测结束后调用completionBlock,仍在主队列</span></span><br><span class="line">- (<span class="keyword">void</span>)cachedImageExistsForURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                     completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"><span class="comment">//监测图片是否缓存在disk里,监测结束后调用completionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)diskImageExistsForURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                   completion:(SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"><span class="comment">//返回给定URL的cache key</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheKeyForURL:(<span class="built_in">NSURL</span> *)url;</span><br></pre></td></tr></table></figure>
<p>我们主要研究第二个：下载图片<br>首先，判断 url 的合法性。<br>第一个判断条件是防止很多用户直接传递NSString作为NSURL导致的错误，第二个判断条件防止crash。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([url <span class="string">isKindOfClass:</span>NSString.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = [NSURL <span class="string">URLWithString:</span>(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></span><br><span class="line"><span class="keyword">if</span> (![url <span class="string">isKindOfClass:</span>NSURL.<span class="keyword">class</span>]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再新建了SDWebImageCombinedOperation</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>集合failedURLs保存之前失败的urls，如果url为空或者url之前失败过且不采用重试策略，直接调用completedBlock返回错误。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">synchronized</span> (self.runningOperations) &#123;</span><br><span class="line">        <span class="selector-attr">[self.runningOperations addObject:operation]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runningOperations是一个可变数组，保存所有的operation，主要用来监测是否有operation在执行，即判断running 状态。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 URL 生成对应的 key，没有特殊处理为 [url absoluteString];</span></span><br><span class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</span><br><span class="line"><span class="comment">// 去缓存中查找图片（参见 SDImageCache）先在memory以及disk的cache中查找是否下载过相同的照片</span></span><br><span class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">    <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果在缓存中找到图片</strong>，直接调用completedBlock，第一个参数是缓存的image。<code>completedBlock(image, nil, cacheType, YES, url);</code><br>下面方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (image) &#123;</span><br><span class="line">         <span class="comment">// 在缓存中找到图片了，直接返回</span></span><br><span class="line">       dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">        <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">         completedBlock(image, <span class="literal">nil</span>, cacheType, <span class="literal">YES</span>, url);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">             [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果没有在缓存中找到图片</strong>，或者不管是否找到图片，只要operation有SDWebImageRefreshCached标记，那么若SDWebImageManagerDelegate的shouldDownloadImageForURL方法返回true，即允许下载时，都使用 imageDownloader 的(SDWebImageDownloader)</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id &lt;SDWebImageOperation&gt;)</span>downloadImageWithURL:<span class="params">(NSURL *)</span>url options:<span class="params">(SDWebImageDownloaderOptions)</span>options progress:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock completed:<span class="params">(SDWebImageDownloaderCompletedBlock)</span>completedBlock</span><br></pre></td></tr></table></figure>
<p>方法下载。如果操作队列取消则什么都不做，若发生错误，则直接调用completedBlock返回错误，并且视情况将url添加到failedURLs里面；</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">if</span> (error) &#123;</span><br><span class="line">     dispatch_main_sync_safe(^&#123;</span><br><span class="line">         <span class="meta">if</span> (<span class="keyword">strongOperation </span>&amp;&amp; !<span class="keyword">strongOperation.isCancelled) </span>&#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, finished, url)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">if</span> (   error<span class="meta">.code</span> != NSURLErrorNotConnectedToInternet</span><br><span class="line">          &amp;&amp; error<span class="meta">.code</span> != NSURLErrorCanc</span><br><span class="line">          &amp;&amp; error<span class="meta">.code</span> != NSURLErrorInternationalRoamingOff</span><br><span class="line">          &amp;&amp; error<span class="meta">.code</span> != NSURLErrorDataNotAllowed</span><br><span class="line">          &amp;&amp; error<span class="meta">.code</span> != NSURLErrorCannotFindHost</span><br><span class="line">          &amp;&amp; error<span class="meta">.code</span> != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">          <span class="comment">@synchronized (self.failedURLs) &#123;</span></span><br><span class="line">          [<span class="keyword">self.failedURLs </span><span class="keyword">addObject:url];</span></span><br><span class="line"><span class="keyword"> </span>       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若下载成功：</p>
<p>若支持失败重试，将url从failURLs里删除：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    <span class="variable">@synchronized</span> (self.failedURLs) &#123;</span><br><span class="line">         <span class="selector-attr">[self.failedURLs removeObject:url]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果delegate实现了imageManager:transformDownloadedImage:withURL:的方法，图片在缓存之前，需要做转换（在全局队列中调用，不阻塞主线程）。转化成功切下载全部结束，图片存入缓存，调用completedBlock回调，第一个参数是转换后的image。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate <span class="string">respondsToSelector:</span><span class="meta">@selector</span>(<span class="string">imageManager:</span><span class="string">transformDownloadedImage:</span><span class="string">withURL:</span>)]) &#123;                        </span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</span><br><span class="line">     UIImage *transformedImage = [self.delegate <span class="string">imageManager:</span>self <span class="string">transformDownloadedImage:</span>downloadedImage <span class="string">withURL:</span>url];</span><br><span class="line">	  <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage <span class="string">isEqual:</span>downloadedImage];</span><br><span class="line">            [self.imageCache <span class="string">storeImage:</span>transformedImage <span class="string">recalculateFromImage:</span>imageWasTransformed <span class="string">imageData:</span>(imageWasTransformed ? nil : data) <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];</span><br><span class="line">           &#125;</span><br><span class="line">	dispatch_main_sync_safe(^&#123;</span><br><span class="line">      <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;       </span><br><span class="line">      		completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">            &#125;</span><br><span class="line">  		&#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>否则：直接存入缓存(SDImageCache中的<br><code>- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk</code>方法)，调用completedBlock回调，第一个参数是下载的原始image。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">    [self.imageCache <span class="string">storeImage:</span>downloadedImage <span class="string">recalculateFromImage:</span>NO <span class="string">imageData:</span>data <span class="string">forKey:</span>key <span class="string">toDisk:</span>cacheOnDisk];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">    <span class="keyword">if</span> (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">        completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后一种情况是：图片不在缓存中也不允许下载，直接调用completedBlock，第一个参数为nil。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_sync_safe(^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">    <span class="keyword">if</span> (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;<span class="comment">//为啥这里用weakOperation TODO</span></span><br><span class="line">        completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后都要将这个operation从runningOperations里删除。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h2><h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><p><strong>Asynchronous downloader dedicated and optimized for image loading.专用的并且优化的图片异步下载器.</strong><br>这个类的核心功能就是下载图片.<br>定义了枚举类型：SDWebImageDownloaderOptions下载的选项和SDWebImageDownloaderExecutionOrder执行顺序,  </p>
<pre><code> //默认的下载顺序，先进先出
SDWebImageDownloaderFIFOExecutionOrder,
//后进先出
SDWebImageDownloaderLIFOExecutionOrder
</code></pre><p>开始下载和结束下载的通知的extern NSString *const的全局变量定义。<br>三个Block：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载进度回调(返回已经接收的图片数据的大小,未接收的图片数据的大小)</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderProgressBlock</span>)(<span class="type">NSInteger</span> receivedSize, <span class="type">NSInteger</span> expectedSize);</span><br><span class="line">// 下载完成回调，返回图片数据或错误</span><br><span class="line">typedef void(^<span class="type">SDWebImageDownloaderCompletedBlock</span>)(<span class="type">UIImage</span> *image, <span class="type">NSData</span> *data, <span class="type">NSError</span> *error, <span class="type">BOOL</span> finished);</span><br><span class="line">//过滤<span class="type">HTTP</span>请求的<span class="type">Header</span></span><br><span class="line">typedef <span class="type">NSDictionary</span> *(^<span class="type">SDWebImageDownloaderHeadersFilterBlock</span>)(<span class="type">NSURL</span> *url, <span class="type">NSDictionary</span> *headers);</span><br></pre></td></tr></table></figure>
<p>属性：<br>是否应该压缩图片，最大并发下载数，当前下载量，下载队列的时长(默认15s)，下载队列执行顺序，对于请求队列设置默认的URL证书，设置用户名，设置密码，设置过滤HTTP请求的header。<br>类方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给每个HTTP下载请求头的指定field设置值。</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">value</span> <span class="selector-tag">forHTTPHeaderField</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">field</span>;</span><br><span class="line"><span class="comment">//返回HTTP特定field的值</span></span><br><span class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">valueForHTTPHeaderField</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">field</span>;</span><br><span class="line"><span class="comment">//设置一个SDWebImageDownloaderOperation的子类作为下载请求的默认NSOperation</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setOperationClass</span><span class="selector-pseudo">:(Class)operationClass</span>;</span><br><span class="line"><span class="comment">//创建一个SDWebImageDownloader异步下载实例，图片下载完成或错误时，通知delegate回调。方法返回一个 SDWebImageOperation</span></span><br><span class="line"><span class="selector-tag">-</span> (id &lt;SDWebImageOperation&gt;)<span class="selector-tag">downloadImageWithURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">url</span></span><br><span class="line">                                         <span class="selector-tag">options</span><span class="selector-pseudo">:(SDWebImageDownloaderOptions)options</span></span><br><span class="line">                                        <span class="selector-tag">progress</span><span class="selector-pseudo">:(SDWebImageDownloaderProgressBlock)progressBlock</span></span><br><span class="line">                                       <span class="selector-tag">completed</span><span class="selector-pseudo">:(SDWebImageDownloaderCompletedBlock)completedBlock</span>;</span><br><span class="line"><span class="comment">// 设置下载队列为挂起状态</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setSuspended</span><span class="selector-pseudo">:(BOOL)suspended</span>;</span><br><span class="line"><span class="comment">//取消队列中的所有操作。</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">cancelAllDownloads</span>;</span><br></pre></td></tr></table></figure>
<p>SDWebImageDownloader 下载管理器是一个单例类，它主要负责图片的下载操作的管理。图片的下载是放在一个 NSOperationQueue 操作队列中来完成的，<code>@property (strong, nonatomic) NSOperationQueue *downloadQueue;</code>默认最大的并行操作个数是6。队列中每一个SDWebImageDownloaderOperation实例才是真正的下载请求执行者。<br>我们重点研究核心下载方法</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id &lt;SDWebImageOperation&gt;)</span>downloadImageWithURL:<span class="params">(NSURL *)</span>url</span><br><span class="line">                                         options:<span class="params">(SDWebImageDownloaderOptions)</span>options</span><br><span class="line">                                        progress:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">                                       completed:<span class="params">(SDWebImageDownloaderCompletedBlock)</span>completedBlock;</span><br></pre></td></tr></table></figure>
<p>这个方法实际上就是调用了另外一个关键方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">             completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock </span><br><span class="line">                      forURL:(<span class="built_in">NSURL</span> *)url </span><br><span class="line">              createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    <span class="comment">// url作为URLCallbacks的key，如果为nil ,直接调用completedBlock。</span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将所有下载任务的网络响应处理放到barrierQueue队列中。</span></span><br><span class="line">    <span class="comment">//并设置栅栏来确保同一时间只有一个线程操作URLCallbacks属性</span></span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">        <span class="built_in">BOOL</span> first = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.URLCallbacks[url]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.URLCallbacks[url] = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">            first = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle single download of simultaneous download request for the same URL</span></span><br><span class="line">        <span class="comment">//修改url对应的URLCallbacks</span></span><br><span class="line">        <span class="comment">//URLCallbacks是一个字典: key是url, value是数组</span></span><br><span class="line">        <span class="comment">//数组的元素是字典，key是callback类型字符串，value是callback的block</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *callbacksForURL = <span class="keyword">self</span>.URLCallbacks[url];</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        <span class="keyword">self</span>.URLCallbacks[url] = callbacksForURL;</span><br><span class="line">        <span class="comment">//第一次请求这个url 才去真正做http请求</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法为下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作。图片下载的progressBlock和completedBlock回调由一个字典URLCallbacks管理。字典的key是图片的url，value 是一个数组，数组只包含一个元素,这个元素的类型是NSMutableDictionary类型,这个字典的key为NSString类型代表着回调类型,value为block,是对应的回调。由于允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证线程安全，将下载操作作为一个个任务放到barrierQueue队列中，并设置栅栏来确保同一时间只有一个线程操作URLCallbacks属性<br>两个回调对应的key分别是</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kProgressCallbackKey = <span class="string">@"progress"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> kCompletedCallbackKey = <span class="string">@"completed"</span>;</span><br></pre></td></tr></table></figure>
<p> //为了去阻止潜在的重复的缓存（NSURLCache和SDWebCache缓存），如果有一种缓存我们不能去请求缓存</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">NSMutableURLRequest</span> <span class="meta">*request</span> <span class="string">=</span> <span class="string">[[NSMutableURLRequest</span> <span class="string">alloc]</span> <span class="attr">initWithURL:url</span> <span class="attr">cachePolicy:(options</span> <span class="string">&amp;</span> <span class="string">SDWebImageDownloaderUseNSURLCache</span> <span class="string">?</span> <span class="string">NSURLRequestUseProtocolCachePolicy</span> <span class="string">:</span> <span class="string">NSURLRequestReloadIgnoringLocalCacheData)</span> <span class="attr">timeoutInterval:timeoutInterval];</span></span><br><span class="line"><span class="string">request.HTTPShouldHandleCookies</span> <span class="string">=</span> <span class="string">(options</span> <span class="string">&amp;</span> <span class="string">SDWebImageDownloaderHandleCookies);</span></span><br><span class="line"><span class="string">request.HTTPShouldUsePipelining</span> <span class="string">=</span> <span class="literal">YES</span><span class="string">;</span></span><br></pre></td></tr></table></figure>
<p>如果URLCallbacks没有url这个key，说明是第一次请求这个url，需要调用createCallback创建下载任务，即使用</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(id)</span>initWithRequest:<span class="params">(NSURLRequest *)</span>request</span><br><span class="line">            inSession:<span class="params">(NSURLSession *)</span>session</span><br><span class="line">              options:<span class="params">(SDWebImageDownloaderOptions)</span>options</span><br><span class="line">             progress:<span class="params">(SDWebImageDownloaderProgressBlock)</span>progressBlock</span><br><span class="line">            completed:<span class="params">(SDWebImageDownloaderCompletedBlock)</span>completedBlock</span><br><span class="line">            cancelled:<span class="params">(SDWebImageNoParamsBlock)</span>cancelBlock</span><br></pre></td></tr></table></figure>
<p>调用这个方法后的progressBlock是：对已经接收到的大小和期待的大小调用callback；</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloader *sself = wself;</span><br><span class="line"><span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">__block <span class="built_in">NSArray</span> *callbacksForURL;</span><br><span class="line"><span class="built_in">dispatch_sync</span>(sself.barrierQueue, ^&#123;</span><br><span class="line">    callbacksForURL = [sself.URLCallbacks[url] <span class="keyword">copy</span>];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *callbacks <span class="keyword">in</span> callbacksForURL) &#123;</span><br><span class="line">    <span class="comment">//异步提交， 当前线程直接返回</span></span><br><span class="line">    <span class="comment">//callbacks在main_queue中并行执行</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">        <span class="keyword">if</span> (callback) </span><br><span class="line">            callback(receivedSize, expectedSize);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>completedBlock是,对image和data调用callback,在completed block中我们取出存储在URLCallbacks中的completedBlock.</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloader *sself = wself;</span><br><span class="line"><span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</span><br><span class="line">__block NSArray *callbacksForURL;</span><br><span class="line"><span class="built_in">dispatch_barrier_sync</span>(sself.barrierQueue, ^&#123;</span><br><span class="line">    callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="keyword">for</span> (NSDictionary *callbacks in callbacksForURL) &#123;                             </span><br><span class="line">    SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">    <span class="keyword">if</span> (callback) </span><br><span class="line">        <span class="built_in">callback</span>(image, data, <span class="built_in">error</span>, finished);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cancelBlock是：我们移除存储在URLCallbacks的数组。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageDownloader *sself = wself<span class="comment">;</span></span><br><span class="line">if (!sself) return<span class="comment">;</span></span><br><span class="line"><span class="keyword">dispatch_barrier_async(sself.barrierQueue, </span>^&#123;</span><br><span class="line">			[sself.URLCallbacks removeObjectForKey:url]<span class="comment">;</span></span><br><span class="line">   &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>接下来：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否解压下载的图片，默认是YES,但是会消耗掉很多内存，如果遇到内存不足的crash时，将值设为NO。</span></span><br><span class="line">operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line"><span class="comment">//设置证书</span></span><br><span class="line"><span class="keyword">if</span> (wself.urlCredential) &#123;</span><br><span class="line">      operation.credential = wself.urlCredential;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line"> operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置队列优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入操作队列后， operation 真正开始执行start</span></span><br><span class="line">        <span class="comment">//所有的下载任务放在downloadQueue队列中.</span></span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        <span class="keyword">if</span> (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若果是LIFO的下载执行顺序，还要加上任务的依赖，也就是说依赖的任务都完成后，才能执行当前任务</span></span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h3><p>SDWebImageDownloaderOperation : NSOperation <sdwebimageoperation>是NSOperation的子类，遵循SDWebImageDownloaderOperationInterface, SDWebImageOperation, NSURLSessionTaskDelegate, NSURLSessionDataDelegate协议，并重写了start方法。在start方法中真正处理HTTP请求和URL链接。<br>看一下start方法：首先检测下载状态：</sdwebimageoperation></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">    <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> reset];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是iOS4.0以上的版本，还需要考虑是否在后台执行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</span><br><span class="line"><span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line"><span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    <span class="comment">//如果设置了在后台执行，则进行后台执行</span></span><br><span class="line">     __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</span><br><span class="line">    <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        <span class="comment">// 如果在系统规定时间内任务还没有完成（一般是10分钟），结束后台任务</span></span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">        <span class="keyword">if</span> (sself) &#123;</span><br><span class="line">            [sself cancel];</span><br><span class="line">            [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">            sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p><strong>Version3.8中，下载已经由原先的NSURLConnection切换到了NSURLSession了:</strong><br>创建好任务后开始执行请求。 如果任务创建成功，可能需要调用progressBlock回调并发送下载开始的通知；如果创建失败，直接执行完成回调,并传递一个connection没有初始化的错误：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.unownedSession) &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">//为任务创建会话，我们给delegateQueue设置nil来创建一个顺序操作队列去执行所有的代理方法和完成回调。</span></span><br><span class="line">    <span class="keyword">self</span>.ownedSession = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                      delegate:<span class="keyword">self</span></span><br><span class="line">                                                 delegateQueue:<span class="literal">nil</span>];</span><br><span class="line">    session = <span class="keyword">self</span>.ownedSession;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</span><br><span class="line"><span class="keyword">self</span>.executing = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//开启任务</span></span><br><span class="line">[<span class="keyword">self</span>.dataTask resume];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 在主线程中发送开始下载的通知</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果session创建失败,直接执行完成回调,并传递一个connection没有初始化的错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.completedBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Connection can't be initialized"</span>&#125;], <span class="literal">YES</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>任务开始后，我们需要关注NSURLSessionDataDelegate的几个代理方法。另外还有NSURLSessionTaskDelegate的两个代理方法:</p>
<p><code>NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</code><br>把URL作为Key值，</p>
<h2 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h2><p>SDImageCache maintains a memory cache and an optional disk cache. Disk cache write operations are performed asynchronous so it doesn’t add unnecessary latency to the UI.<br>SDImageCache维持了一个内存缓存memCache和一个可选的磁盘缓存。同时，磁盘缓存的写操作是异步的，所以它不会对 UI 造成不必要的影响。  </p>
<p> 内存缓存是用NSCache实现的，以Key-Value的形式存储图片，当内存不够的时候会清除所有缓存图片。<br> 磁盘缓存则是缓存到沙盒中，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。默认情况下，会将缓存保存在应用沙盒的cache/com.hackemist.SDWebImageCache.default中.</p>
<p> <code>static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</code></p>
<p><strong>枚举</strong>：缓存主要有不缓存，磁盘缓存、内存缓存。<br><strong>三个BLock</strong>：请求完成，检查缓存完成，计算大小。<br><strong>属性</strong>：是否压缩图片(遇到崩溃因过度的内存消耗将它设置为NO),关闭iCloud云备份[默认为YES]，使用内存缓存[默认为YES]，最大内存成本，最大内存数量限制，最大内存周期，最大内存大小。<br><strong>方法</strong>：实例化，内存存储的使用空间，创建磁盘缓存的目录，添加只读缓存路径，添加只读路径，用key来存储图片到内存或磁盘缓存，用key存储图片到内存或可选的磁盘，同步查询内存\磁盘缓存，同步从内存和磁盘中移除图片，异步从内存和磁盘中移除图片，清理所有内存缓存图片，清理所有磁盘缓存图片，移除所有过期的缓存图片，通过磁盘缓存获得使用大小，获得磁盘缓存中图片的数量，异步计算磁盘缓存的大小，如果图片已经存在磁盘缓存中同步检查，检查如果图片已经在磁盘内存中存在则不要下载，对于特定的key获得缓存路径，</p>
<p><strong>重要方法：</strong></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key对应的image存储到内存缓存和磁盘缓存中</span></span><br><span class="line">- <span class="comment">(void)</span>storeImage:<span class="comment">(UIImage *)</span>image forKey:<span class="comment">(NSString *)</span>key;</span><br><span class="line"><span class="comment">//将key对应的image存储到内存缓存，是否同时存入磁盘中由参数toDisk决定</span></span><br><span class="line">- <span class="comment">(void)</span>storeImage:<span class="comment">(UIImage *)</span>image forKey:<span class="comment">(NSString *)</span>key toDisk:<span class="comment">(BOOL)</span>toDisk;</span><br><span class="line"><span class="comment">//功能同上，参数recalculate指明imageData是否可用或者应该从UIImage重新构造；参数imageData是由服务器返回，可以用于磁盘存储，这样可以避免将image转换为一个可存储/压缩的图片以节省CPU。</span></span><br><span class="line">- <span class="comment">(void)</span>storeImage:<span class="comment">(UIImage *)</span>image recalculateFromImage:<span class="comment">(BOOL)</span>recalculate imageData:<span class="comment">(NSData *)</span>imageData forKey:<span class="comment">(NSString *)</span>key toDisk:<span class="comment">(BOOL)</span>toDisk;</span><br><span class="line"><span class="comment">//真正将key对应的image存储到磁盘缓存中</span></span><br><span class="line">- <span class="comment">(void)</span>storeImageDataToDisk:<span class="comment">(NSData *)</span>imageData forKey:<span class="comment">(NSString *)</span>key;</span><br></pre></td></tr></table></figure>
<p>第一个方法和第二个方法最终都会调用第三个方法，</p>
<p>如果需要存储到memory cache中，首先存入memcache。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">    NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">    [self.memCache <span class="string">setObject:</span>image <span class="string">forKey:</span>key <span class="string">cost:</span>cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要存储到disk cache，在子线程中串行存储到disk cache中：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">if</span> (toDisk) &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //串行队列io队列</span><br><span class="line">            <span class="type">NSData</span> *<span class="class"><span class="keyword">data</span> = imageData;</span></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span> (!<span class="class"><span class="keyword">data</span> &amp;&amp; image) &#123;</span></span><br><span class="line"><span class="class">                <span class="type">SDImageFormat</span> <span class="title">imageFormatFromData</span> = [<span class="type">NSData</span> <span class="title">sd_imageFormatForImageData</span>:<span class="title">data</span>];</span></span><br><span class="line"><span class="class">                <span class="title">data</span> = [<span class="title">image</span> <span class="title">sd_imageDataAsFormat</span>:<span class="title">imageFormatFromData</span>];</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line">            </span><br><span class="line">            [self storeImageDataToDisk:<span class="class"><span class="keyword">data</span> forKey:key];</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>disk cache的文件名是key做MD5后的字符串：</li>
</ol>
<pre><code>#pragma mark SDImageCache (private)

- (NSString *)cachedFileNameForKey:(NSString *)key {
    const char *str = [key UTF8String];
    if (str == NULL) {
        str = &quot;&quot;;
    }
    unsigned char r[CC_MD5_DIGEST_LENGTH];
    CC_MD5(str, (CC_LONG)strlen(str), r);
    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,
                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],
                          r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];

    return filename;
}
</code></pre><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><ol start="7">
<li>过程<br>1&gt;UIImageView+WebCache:  setImageWithURL:placeholderImage:options: <strong>先显示 placeholderImage ，同时由SDWebImageManager 根据 URL 来在本地查找图片。</strong></li>
</ol>
<p>2&gt;SDWebImageManager: downloadWithURL:delegate:options:userInfo: SDWebImageManager是将UIImageView+WebCache同SDImageCache链接起来的类， SDImageCache： queryDiskCacheForKey:delegate:userInfo:<strong>用来从缓存根据CacheKey查找图片是否已经在缓存中</strong></p>
<p>3&gt;如果内存中已经有图片缓存， SDWebImageManager会回调SDImageCacheDelegate : imageCache:didFindImage:forKey:userInfo:</p>
<p>4&gt;而 UIImageView+WebCache 则回调SDWebImageManagerDelegate:  webImageManager:didFinishWithImage:来显示图片。</p>
<p>5&gt;如果内存中没有图片缓存，那么生成 NSInvocationOperation 添加到队列，从硬盘查找图片是否已被下载缓存。</p>
<p>6&gt;根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</p>
<p>7&gt;如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。</p>
<p>8&gt;如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。</p>
<p>9&gt;共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</p>
<p>10&gt;图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。<br>11&gt;connection:didReceiveData: 中利用 ImageIO 做了按图片下载进度加载效果。<br>12&gt;connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder 做图片解码处理。<br>13&gt;图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。<br>14&gt;在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。<br>15&gt;imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。<br>16&gt;通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。<br>17&gt;将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。<br>18&gt;写文件到硬盘在单独 NSInvocationOperation 中完成，避免拖慢主线程。<br>19&gt;如果是在iOS上运行，SDImageCache 在初始化的时候会注册notification 到 UIApplicationDidReceiveMemoryWarningNotification 以及  UIApplicationWillTerminateNotification,在内存警告的时候清理内存图片缓存，应用结束的时候清理过期图片。<br>20&gt;SDWebImagePrefetcher 可以预先下载图片，方便后续使用</p>
<ol>
<li>SDWebImage的缓存策略，是如何从缓存中hit一张图片的；使用了几级缓存；缓存如何满了如何处理，是否要设置过期时间；</li>
<li><ol start="12">
<li>设计一个网络图片缓存器(SDWebImage实现原理必需要了解)</li>
</ol>
</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2016/03/06/SDWebImage框架/">SDWebImage框架</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 向阳 的个人博客">向阳</a></p>
        <p><span>发布时间:</span>2016年03月06日 - 14时08分</p>
        <p><span>最后更新:</span>2018年07月18日 - 09时41分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2016/03/06/SDWebImage框架/" title="SDWebImage框架">http://peilinghui.com/2016/03/06/SDWebImage框架/</a>
            <span class="copy-path" data-clipboard-text="原文: http://peilinghui.com/2016/03/06/SDWebImage框架/　　作者: 向阳" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target="_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/03/14/ViewController的生命周期/">
                    ViewController的生命周期
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/03/05/iOS中的第三方框架/">
                    iOS中的第三方库
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#UIImageView-WebCache"><span class="toc-number">1.</span> <span class="toc-text">UIImageView+WebCache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIView-WebCacheOperation"><span class="toc-number">2.</span> <span class="toc-text">UIView+WebCacheOperation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDWebImageManager"><span class="toc-number">3.</span> <span class="toc-text">SDWebImageManager</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Downloader"><span class="toc-number">4.</span> <span class="toc-text">Downloader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDWebImageDownloader"><span class="toc-number">4.1.</span> <span class="toc-text">SDWebImageDownloader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SDWebImageDownloaderOperation"><span class="toc-number">4.2.</span> <span class="toc-text">SDWebImageDownloaderOperation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDImageCache"><span class="toc-number">5.</span> <span class="toc-text">SDImageCache</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题"><span class="toc-number"></span> <span class="toc-text">面试题</span></a>
</li></div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>

<input type="button" id="tocButton" value="隐藏目录" title="点击按钮隐藏或者显示文章目录">
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }

    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })

    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




    <div class="share">
    <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
    <a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
    <a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
    </div>
    <script>
        window._bd_share_config={
            "common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
    </script>
</div>



    
      <div class="duoshuo" id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="2016/03/06/SDWebImage框架/" data-title="SDWebImage框架" data-url="http://peilinghui.com/2016/03/06/SDWebImage框架/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:"peilinghui"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
    <!-- 多说公共JS代码 end -->
</div>

    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/03/14/ViewController的生命周期/" title="上一篇: ViewController的生命周期">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/03/05/iOS中的第三方框架/" title="下一篇: iOS中的第三方库">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/07/关于RN的热更新/">关于RN的热更新</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/02/Mac获取ipa方法/">Mac获取ipa方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/学习iOS逆向/">学习iOS逆向</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/03/升级Xcode10遇到的问题/">升级Xcode10遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/29/RN与iOS的混合开发/">RN与iOS的混合开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/21/在APP中IM使用融云/">在APP中IM使用融云</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/独立开发一个APP/">独立开发一个APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/25/iOS底层实现/">iOS底层实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/Effective-JavaScript/">Effective JavaScript</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/22/React知识/">React技术栈</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/12/ReactNative中使用Redux/">ReactNative中使用Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/24/React-Native的APP/">React-Native的APP</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/ReactNative的常用组件/">ReactNative的常用组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/iOS应用APP架构/">iOS应用APP架构</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/10/iOS网络层的封装/">iOS网络层的封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/05/项目重构遇到的问题/">项目重构遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/30/iOS中的图表Charts/">iOS中的图表Charts</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/26/移动应用的设计模式/">移动应用的设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/14/Jenkins搭建来实现自动化打包/">Jenkins搭建来实现自动化打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/05/AFNetworking3.0/">AFNetworking3.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/搜索框的Demo/">搜索框的Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/27/使用Mac本地服务器/">如何使用Mac本地服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/10/iOS打包和发布流程/">iOS打包和发布流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/iOS中JS与OC相互调用的方式/">iOS中JS与OC相互调用的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/NSURLProtocol/">NSURLProtocol</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/21/UIView的Frame和bounds区别/">UIView的Frame和bounds区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/21/React-Native的与原生的交互/">React-Native的与原生的交互</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/10/React-Native的API和组件/">React-Native的API和组件</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/02/React-Native入门/">React Native入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/16/自动化测试/">自动化测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/13/JavaScript高级程序设计读书笔记/">JavaScript高级程序设计读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/YYModel/">YYModel</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/Quartz2D的使用/">Quartz2D的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/02/iOS中的加密实现/">iOS中的加密实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/05/GCD/">GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/20/KVC和KVO/">深入学习KVC和KVO</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/RunLoop/">RunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/10/消息处理之performSelector/">消息处理之performSelector</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/05/Runtime/">Runtime</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/TableView的一些事/">TableView的一些事</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/02/iOS中页面传值和页面跳转/">iOS中页面传值和页面跳转</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/01/ARC内存管理/">ARC内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/29/ReactiveCocoa学习笔记/">ReactiveCocoa学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/14/iOS调试技巧/">iOS调试技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/14/iOS网络编程/">iOS网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/10/NSString的引用计数问题/">NSString的引用计数问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/03/effective objective-c 2.0读书笔记/">effective objective-c 2.0读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/Block/">Block</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/01/设计模式/">设计模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/25/剑指offer/">剑指offer</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/21/Linux系统的学习/">Linux系统的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/14/ViewController的生命周期/">ViewController的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/06/SDWebImage框架/">SDWebImage框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的第三方框架/">iOS中的第三方库</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/AFNetworking2.0/">AFNetworking2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/05/iOS中的数据存储/">iOS中的数据存储</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/iOS中的多线程网络/">iOS中的多线程网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/04/CocosPods/">CocosPods</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/深拷贝和浅拷贝/">深拷贝和浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机网络基础知识与安全/">计算机网络基础知识与安全</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/计算机基础知识/">计算机基础知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/经典排序算法总结与实现/">经典排序算法总结与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/25/git学习/">git学习笔记</a></li></ul>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 向阳
            </div>
            <div class="footer-right">
	     欢迎光临小站
            </div>
        </div>
        
            <div class="visit">
                
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
		<span id="busuanzi_container_site_pv">
   		 本站总访问量<span id="busuanzi_value_site_pv"></span>次
		</span>
                <span id="busuanzi_value_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span>
                        
                    
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style="display:none">
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>